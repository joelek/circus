// This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.

import * as autoguard from "@joelek/ts-autoguard/dist/lib-server";
import * as shared from "./index";

export type Server = autoguard.api.RequestListener;

export const makeServer = (routes: autoguard.api.Server<shared.Autoguard.Requests, shared.Autoguard.Responses>, serverOptions?: autoguard.api.ServerOptions): Server => {
	let endpoints = new Array<autoguard.api.Endpoint>();
	endpoints.push((raw, auxillary) => {
		let method = "POST";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("auth")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["x-circus-username"] = autoguard.api.decodeHeaderValue(raw.headers, "x-circus-username", true);
				headers["x-circus-password"] = autoguard.api.decodeHeaderValue(raw.headers, "x-circus-password", true);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["POST:/auth/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["POST:/auth/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["POST:/auth/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("x-circus-token", [response.headers?.["x-circus-token"]], true));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "POST";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["POST:/users/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["POST:/users/"](new autoguard.api.ClientRequest(request, false, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["POST:/users/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[0].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options["cues"] = autoguard.api.decodeParameterValue(raw.parameters, "cues", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/actors/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["actor_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<actor_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/actors/<actor_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<actor_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["actor_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<actor_id>/movies/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/actors/<actor_id>/movies/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<actor_id>/movies/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["actor_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<actor_id>/shows/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/actors/<actor_id>/shows/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<actor_id>/shows/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/albums/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/albums/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/albums/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("new")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getNewAlbums"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getNewAlbums"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getNewAlbums"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["album_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/albums/<album_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/albums/<album_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/albums/<album_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("discs")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["album_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getAlbumDiscs"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getAlbumDiscs"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getAlbumDiscs"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("context")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["album_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getAlbumContext"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getAlbumContext"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getAlbumContext"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("artists")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/artists/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/artists/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/artists/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("artists")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["artist_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/artists/<artist_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/artists/<artist_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/artists/<artist_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("artists")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["artist_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getArtistAlbums"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getArtistAlbums"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getArtistAlbums"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("artists")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("context")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["artist_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getArtistContext"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getArtistContext"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getArtistContext"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("discs")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/discs/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/discs/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/discs/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("discs")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["disc_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/discs/<disc_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/discs/<disc_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/discs/<disc_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("discs")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("tracks")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["disc_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getDiscTracks"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getDiscTracks"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getDiscTracks"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("discs")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("context")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["disc_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getDiscContext"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getDiscContext"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getDiscContext"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("episodes")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/episodes/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/episodes/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/episodes/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("episodes")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["episode_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/episodes/<episode_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/episodes/<episode_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/episodes/<episode_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("episodes")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("context")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["episode_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getEpisodeContext"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getEpisodeContext"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getEpisodeContext"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/genres/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["genre_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<genre_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/genres/<genre_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<genre_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["genre_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<genre_id>/movies/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/genres/<genre_id>/movies/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<genre_id>/movies/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["genre_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<genre_id>/shows/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/genres/<genre_id>/shows/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<genre_id>/shows/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/movies/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/movies/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/movies/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("new")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getNewMovies"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getNewMovies"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getNewMovies"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["movie_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/movies/<movie_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/movies/<movie_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/movies/<movie_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("suggestions")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["movie_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/movies/<movie_id>/suggestions/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/movies/<movie_id>/suggestions/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/movies/<movie_id>/suggestions/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("context")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["movie_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getMovieContext"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getMovieContext"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getMovieContext"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/playlists/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/playlists/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/playlists/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["playlist_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/playlists/<playlist_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/playlists/<playlist_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/playlists/<playlist_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("items")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["playlist_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getPlaylistItems"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getPlaylistItems"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getPlaylistItems"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("context")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["playlist_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getPlaylistContext"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getPlaylistContext"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getPlaylistContext"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("seasons")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/seasons/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/seasons/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/seasons/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("seasons")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["season_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/seasons/<season_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/seasons/<season_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/seasons/<season_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("seasons")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("episodes")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["season_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getSeasonEpisodes"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getSeasonEpisodes"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getSeasonEpisodes"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("seasons")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("context")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["season_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getSeasonContext"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getSeasonContext"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getSeasonContext"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/shows/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/shows/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/shows/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["show_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/shows/<show_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/shows/<show_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/shows/<show_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("seasons")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["show_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getShowSeasons"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getShowSeasons"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getShowSeasons"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("context")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["show_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getShowContext"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getShowContext"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getShowContext"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("tracks")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/tracks/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/tracks/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/tracks/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("tracks")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["track_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/tracks/<track_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/tracks/<track_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/tracks/<track_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("tracks")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["track_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/tracks/<track_id>/playlists/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/tracks/<track_id>/playlists/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/tracks/<track_id>/playlists/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("tracks")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("context")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["track_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getTrackContext"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["getTrackContext"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getTrackContext"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/users/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["user_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/users/<user_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["user_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/albums/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/users/<user_id>/albums/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/albums/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["user_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/playlists/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/users/<user_id>/playlists/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/playlists/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["user_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/shows/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/users/<user_id>/shows/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/shows/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["query"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<query>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/years/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<query>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["year_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<year_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/years/<year_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<year_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["year_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<year_id>/albums/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/years/<year_id>/albums/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<year_id>/albums/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["year_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
				options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<year_id>/movies/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/years/<year_id>/movies/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<year_id>/movies/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("files")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["file_id"] = matchers[1].getValue();
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/files/<file_id>/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/files/<file_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/files/<file_id>/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("statistics")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/statistics/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/statistics/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/statistics/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	return (request, response) => autoguard.api.route(endpoints, request, response, serverOptions);
};
