var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
define("build/languages", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pref = exports.db = void 0;
    const db = {
        eng: {
            title: "English",
            iso639_1: "en",
            iso3166_1: "US"
        },
        swe: {
            title: "Swedish",
            iso639_1: "sv",
            iso3166_1: "SE"
        },
        jpn: {
            title: "Japanese",
            iso639_1: "ja",
            iso3166_1: "JP"
        }
    };
    exports.db = db;
    const pref = [
        "swe",
        "eng",
        "jpn"
    ];
    exports.pref = pref;
});
define("build/client/browserMediaSession", ["require", "exports"], function (require, exports) {
    "use strict";
    // @ts-nocheck
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setHandlers = exports.setMetadata = void 0;
    function setMetadata(metadata) {
        if (navigator.mediaSession) {
            navigator.mediaSession.metadata = new globalThis.MediaMetadata(metadata);
        }
    }
    exports.setMetadata = setMetadata;
    function setHandlers(handlers) {
        if (navigator.mediaSession) {
            for (let type in handlers) {
                navigator.mediaSession.setActionHandler(type, handlers[type]);
            }
        }
    }
    exports.setHandlers = setHandlers;
});
define("build/observers/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayObservable = exports.computed = exports.ObservableClass = void 0;
    class ObservableClass {
        state;
        observers;
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer, alwaysNotify) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push({
                observer: (state) => {
                    observable.updateState(observer(state));
                },
                alwaysNotify
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return this.state;
        }
        updateState(state) {
            let didChange = state !== this.state;
            this.state = state;
            for (let observer of this.observers) {
                if (didChange || observer.alwaysNotify) {
                    observer.observer(this.state);
                }
            }
        }
    }
    exports.ObservableClass = ObservableClass;
    function computed(computer, ...observables) {
        let observable = new ObservableClass(computer(...observables.map((observable) => observable.getState())));
        let updater = () => {
            observable.updateState(computer(...observables.map((observable) => observable.getState())));
        };
        for (let observable of observables) {
            observable.addObserver(updater);
        }
        return observable;
    }
    exports.computed = computed;
    class ArrayObservable {
        state;
        observers;
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer) {
            this.observers.push(observer);
            for (let value of this.state) {
                observer.onappend?.(value);
            }
        }
        compute(observer) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push({
                onappend: (state) => {
                    observable.updateState(observer(this.state));
                },
                onsplice: (state, index) => {
                    observable.updateState(observer(this.state));
                }
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return this.state;
        }
        append(state) {
            this.state.push(state);
            for (let observer of this.observers) {
                observer.onappend?.(state);
            }
        }
        splice(index) {
            if (index < 0 || index >= this.state.length) {
                throw `Expected an index of at most ${this.state.length}, got ${index}!`;
            }
            let state = this.state[index];
            this.state.splice(index, 1);
            for (let observer of this.observers) {
                observer.onsplice?.(state, index);
            }
        }
        update(state) {
            for (let i = this.state.length - 1; i >= 0; i--) {
                this.splice(i);
            }
            for (let v of state) {
                this.append(v);
            }
        }
    }
    exports.ArrayObservable = ArrayObservable;
});
define("build/is", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.present = exports.absent = void 0;
    function absent(subject) {
        return subject == null;
    }
    exports.absent = absent;
    ;
    function present(subject) {
        return subject != null;
    }
    exports.present = present;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageSerializer = exports.MessageGuardError = void 0;
    class MessageGuardError {
        constructor(guard, subject, path) {
            this.guard = guard;
            this.subject = subject;
            this.path = path;
        }
        getSubjectType() {
            if (this.subject === null) {
                return "null";
            }
            if (this.subject instanceof Array) {
                return "array";
            }
            return typeof this.subject;
        }
        toString() {
            return `The type ${this.getSubjectType()} at ${this.path} is type-incompatible with the expected type: ${this.guard.ts()}`;
        }
    }
    exports.MessageGuardError = MessageGuardError;
    ;
    class MessageSerializer {
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let json = JSON.parse(string);
            if ((json != null) && (json.constructor === Object)) {
                if ((json.type != null) && (json.type.constructor === String)) {
                    let type = json.type;
                    let data = json.data;
                    let guard = this.guards[type];
                    if (guard === undefined) {
                        throw "Unknown message type \"" + type + "\"!";
                    }
                    cb(type, guard.as(data));
                    return;
                }
            }
            throw "Invalid message envelope!";
        }
        serialize(type, data) {
            return JSON.stringify({
                type,
                data
            });
        }
    }
    exports.MessageSerializer = MessageSerializer;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/guards", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization"], function (require, exports, serialization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Union = exports.Undefined = exports.Tuple = exports.StringLiteral = exports.String = exports.Reference = exports.Record = exports.Object = exports.NumberLiteral = exports.Number = exports.Null = exports.Intersection = exports.Group = exports.BooleanLiteral = exports.Boolean = exports.Array = exports.Any = void 0;
    exports.Any = {
        as(subject, path = "") {
            return subject;
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `any`;
        }
    };
    exports.Array = {
        of(guard) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Array)) {
                        for (let i = 0; i < subject.length; i++) {
                            guard.as(subject[i], path + "[" + i + "]");
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `array<${guard.ts(eol)}>`;
                }
            };
        }
    };
    exports.Boolean = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Boolean)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `boolean`;
        }
    };
    exports.BooleanLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `${value}`;
                }
            };
        }
    };
    exports.Group = {
        of(guard, name) {
            return {
                as(subject, path = "") {
                    return guard.as(subject, path);
                },
                is(subject) {
                    return guard.is(subject);
                },
                ts(eol = "\n") {
                    return name !== null && name !== void 0 ? name : guard.ts(eol);
                }
            };
        }
    };
    exports.Intersection = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    for (let guard of guards) {
                        guard.as(subject, path);
                    }
                    return subject;
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let guard of guards) {
                        lines.push("\t" + guard.ts(eol + "\t"));
                    }
                    return "intersection<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
    exports.Null = {
        as(subject, path = "") {
            if (subject === null) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `null`;
        }
    };
    exports.Number = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Number)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `number`;
        }
    };
    exports.NumberLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `${value}`;
                }
            };
        }
    };
    exports.Object = {
        of(guards) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Object)) {
                        for (let key in guards) {
                            guards[key].as(subject[key], path + (/^([a-z][a-z0-9_]*)$/isu.test(key) ? "." + key : "[\"" + key + "\"]"));
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let [key, value] of globalThis.Object.entries(guards)) {
                        lines.push(`\t"${key}": ${value.ts(eol + "\t")}`);
                    }
                    return "object<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
    exports.Record = {
        of(guard) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Object)) {
                        let wrapped = exports.Union.of(exports.Undefined, guard);
                        for (let key of globalThis.Object.keys(subject)) {
                            wrapped.as(subject[key], path + "[\"" + key + "\"]");
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `record<${guard.ts(eol)}>`;
                }
            };
        }
    };
    exports.Reference = {
        of(guard) {
            return {
                as(subject, path = "") {
                    return guard().as(subject, path);
                },
                is(subject) {
                    return guard().is(subject);
                },
                ts(eol = "\n") {
                    return guard().ts(eol);
                }
            };
        }
    };
    exports.String = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.String)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return "string";
        }
    };
    exports.StringLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `"${value}"`;
                }
            };
        }
    };
    exports.Tuple = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Array)) {
                        for (let i = 0; i < guards.length; i++) {
                            guards[i].as(subject[i], path + "[" + i + "]");
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let guard of guards) {
                        lines.push(`\t${guard.ts(eol + "\t")}`);
                    }
                    return "tuple<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
    exports.Undefined = {
        as(subject, path = "") {
            if (subject === undefined) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return "undefined";
        }
    };
    exports.Union = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    for (let guard of guards) {
                        try {
                            return guard.as(subject, path);
                        }
                        catch (error) { }
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let guard of guards) {
                        lines.push("\t" + guard.ts(eol + "\t"));
                    }
                    return "union<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/api", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards"], function (require, exports, guards) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __asyncValues = (this && this.__asyncValues) || function (o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializePayload = exports.deserializeStringPayload = exports.compareArrays = exports.serializePayload = exports.serializeStringPayload = exports.collectPayload = exports.deserializeValue = exports.serializeValue = exports.Headers = exports.Options = exports.JSON = exports.Primitive = exports.Binary = exports.SyncBinary = exports.AsyncBinary = exports.decodeUndeclaredHeaders = exports.decodeHeaderValue = exports.decodeHeaderValues = exports.decodeUndeclaredParameters = exports.decodeParameterValue = exports.decodeParameterValues = exports.encodeUndeclaredParameterPairs = exports.encodeParameterPairs = exports.escapeParameterValue = exports.escapeParameterKey = exports.encodeComponents = exports.escapeComponent = exports.encodeUndeclaredHeaderPairs = exports.encodeHeaderPairs = exports.escapeHeaderValue = exports.escapeHeaderKey = exports.splitHeaders = exports.combineParameters = exports.splitParameters = exports.combineComponents = exports.splitComponents = exports.decodeURIComponent = void 0;
    function decodeURIComponent(string) {
        try {
            return globalThis.decodeURIComponent(string);
        }
        catch (error) { }
    }
    exports.decodeURIComponent = decodeURIComponent;
    ;
    function splitComponents(url) {
        let components = new Array();
        for (let part of url.split("?")[0].split("/").slice(1)) {
            components.push(part);
        }
        return components;
    }
    exports.splitComponents = splitComponents;
    ;
    function combineComponents(components) {
        return "/" + components.join("/");
    }
    exports.combineComponents = combineComponents;
    ;
    function splitParameters(url) {
        let parameters = new Array();
        let query = url.split("?").slice(1).join("?");
        if (query !== "") {
            for (let part of query.split("&")) {
                let parts = part.split("=");
                if (parts.length === 1) {
                    let key = parts[0];
                    let value = "";
                    parameters.push([key, value]);
                }
                else {
                    let key = parts[0];
                    let value = parts.slice(1).join("=");
                    parameters.push([key, value]);
                }
            }
        }
        return parameters;
    }
    exports.splitParameters = splitParameters;
    ;
    function combineParameters(parameters) {
        let parts = parameters.map((parameters) => {
            let key = parameters[0];
            let value = parameters[1];
            return `${key}=${value}`;
        });
        if (parts.length === 0) {
            return "";
        }
        return `?${parts.join("&")}`;
    }
    exports.combineParameters = combineParameters;
    ;
    function splitHeaders(lines) {
        return lines.map((part) => {
            let parts = part.split(":");
            if (parts.length === 1) {
                let key = parts[0].toLowerCase();
                let value = "";
                return [key, value];
            }
            else {
                let key = parts[0].toLowerCase();
                let value = parts.slice(1).join(":").trim();
                return [key, value];
            }
        });
    }
    exports.splitHeaders = splitHeaders;
    ;
    const RFC7320_DELIMITERS = "\"(),/:;<=>?@[\\]{}";
    const RFC7320_WHITESPACE = "\t ";
    // The specification (rfc7320) allows octets 33-126 and forbids delimiters. Octets 128-255 have been deprecated since rfc2616.
    function escapeHeaderKey(string, alwaysEncode = "") {
        return escapeHeaderValue(string, RFC7320_DELIMITERS + RFC7320_WHITESPACE + alwaysEncode);
    }
    exports.escapeHeaderKey = escapeHeaderKey;
    ;
    // The specification (rfc7320) allows octets 33-126 and whitespace. Octets 128-255 have been deprecated since rfc2616.
    function escapeHeaderValue(string, alwaysEncode = "") {
        return [...string]
            .map((codePointString) => {
            var _a;
            if (!alwaysEncode.includes(codePointString) && codePointString !== "%") {
                let codePoint = (_a = codePointString.codePointAt(0)) !== null && _a !== void 0 ? _a : 0;
                if (codePoint >= 33 && codePoint <= 126) {
                    return codePointString;
                }
                if (RFC7320_WHITESPACE.includes(codePointString)) {
                    return codePointString;
                }
            }
            return encodeURIComponent(codePointString);
        })
            .join("");
    }
    exports.escapeHeaderValue = escapeHeaderValue;
    ;
    function encodeHeaderPairs(key, values, plain) {
        let pairs = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                if (plain) {
                    pairs.push([
                        escapeHeaderKey(key),
                        escapeHeaderValue(serialized)
                    ]);
                }
                else {
                    pairs.push([
                        escapeHeaderKey(key),
                        escapeHeaderKey(serialized)
                    ]);
                }
            }
        }
        return pairs;
    }
    exports.encodeHeaderPairs = encodeHeaderPairs;
    ;
    function encodeUndeclaredHeaderPairs(record, exclude) {
        let pairs = new Array();
        for (let [key, value] of Object.entries(record)) {
            if (!exclude.includes(key) && value !== undefined) {
                if (guards.String.is(value)) {
                    pairs.push(...encodeHeaderPairs(key, [value], true));
                }
                else if (guards.Array.of(guards.String).is(value)) {
                    pairs.push(...encodeHeaderPairs(key, value, true));
                }
                else {
                    throw `Expected type of undeclared header "${key}" to be string or string[]!`;
                }
            }
        }
        return pairs;
    }
    exports.encodeUndeclaredHeaderPairs = encodeUndeclaredHeaderPairs;
    ;
    function escapeComponent(string) {
        return encodeURIComponent(string);
    }
    exports.escapeComponent = escapeComponent;
    ;
    function encodeComponents(values, plain) {
        let array = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                array.push(escapeComponent(serialized));
            }
        }
        return array;
    }
    exports.encodeComponents = encodeComponents;
    ;
    function escapeParameterKey(string) {
        return encodeURIComponent(string);
    }
    exports.escapeParameterKey = escapeParameterKey;
    ;
    function escapeParameterValue(string) {
        return encodeURIComponent(string);
    }
    exports.escapeParameterValue = escapeParameterValue;
    ;
    function encodeParameterPairs(key, values, plain) {
        let pairs = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                pairs.push([
                    escapeParameterKey(key),
                    escapeParameterValue(serialized)
                ]);
            }
        }
        return pairs;
    }
    exports.encodeParameterPairs = encodeParameterPairs;
    ;
    function encodeUndeclaredParameterPairs(record, exclude) {
        let pairs = new Array();
        for (let [key, value] of Object.entries(record)) {
            if (!exclude.includes(key) && value !== undefined) {
                if (guards.String.is(value)) {
                    pairs.push(...encodeParameterPairs(key, [value], true));
                }
                else if (guards.Array.of(guards.String).is(value)) {
                    pairs.push(...encodeParameterPairs(key, value, true));
                }
                else {
                    throw `Expected type of undeclared parameter "${key}" to be string or string[]!`;
                }
            }
        }
        return pairs;
    }
    exports.encodeUndeclaredParameterPairs = encodeUndeclaredParameterPairs;
    ;
    function decodeParameterValues(pairs, key, plain) {
        let values = new Array();
        for (let pair of pairs) {
            if (key === decodeURIComponent(pair[0])) {
                let parts = pair[1].split(",");
                for (let part of parts) {
                    let value = deserializeValue(decodeURIComponent(part), plain);
                    if (value === undefined) {
                        throw `Expected parameter "${key}" to be properly encoded!`;
                    }
                    values.push(value);
                }
            }
        }
        return values;
    }
    exports.decodeParameterValues = decodeParameterValues;
    ;
    function decodeParameterValue(pairs, key, plain) {
        let values = decodeParameterValues(pairs, key, plain);
        if (values.length > 1) {
            throw `Expected no more than one "${key}" parameter!`;
        }
        return values[0];
    }
    exports.decodeParameterValue = decodeParameterValue;
    ;
    function decodeUndeclaredParameters(pairs, exclude) {
        let map = {};
        for (let pair of pairs) {
            let key = decodeURIComponent(pair[0]);
            let value = decodeURIComponent(pair[1]);
            if (key === undefined || value === undefined) {
                throw `Expected undeclared parameter "${key}" to be properly encoded!`;
            }
            if (!exclude.includes(key)) {
                let values = map[key];
                if (values === undefined) {
                    values = new Array();
                    map[key] = values;
                }
                values.push(value);
            }
        }
        let record = {};
        for (let [key, value] of Object.entries(map)) {
            if (value.length === 1) {
                record[key] = value[0];
            }
            else {
                record[key] = value;
            }
        }
        return record;
    }
    exports.decodeUndeclaredParameters = decodeUndeclaredParameters;
    ;
    function decodeHeaderValues(pairs, key, plain) {
        let values = new Array();
        for (let pair of pairs) {
            if (key === decodeURIComponent(pair[0])) {
                let parts = pair[1].split(",");
                for (let part of parts) {
                    let value = deserializeValue(decodeURIComponent(part.trim()), plain);
                    if (value === undefined) {
                        throw `Expected header "${key}" to be properly encoded!`;
                    }
                    values.push(value);
                }
            }
        }
        return values;
    }
    exports.decodeHeaderValues = decodeHeaderValues;
    ;
    function decodeHeaderValue(pairs, key, plain) {
        let values = decodeHeaderValues(pairs, key, plain);
        if (values.length > 1) {
            throw `Expected no more than one "${key}" header!`;
        }
        return values[0];
    }
    exports.decodeHeaderValue = decodeHeaderValue;
    ;
    function decodeUndeclaredHeaders(pairs, exclude) {
        let map = {};
        for (let pair of pairs) {
            let key = decodeURIComponent(pair[0]);
            let value = decodeURIComponent(pair[1]);
            if (key === undefined || value === undefined) {
                throw `Expected undeclared header "${key}" to be properly encoded!`;
            }
            if (!exclude.includes(key)) {
                let values = map[key];
                if (values === undefined) {
                    values = new Array();
                    map[key] = values;
                }
                values.push(value);
            }
        }
        let record = {};
        for (let [key, value] of Object.entries(map)) {
            if (value.length === 1) {
                record[key] = value[0];
            }
            else {
                record[key] = value;
            }
        }
        return record;
    }
    exports.decodeUndeclaredHeaders = decodeUndeclaredHeaders;
    ;
    exports.AsyncBinary = {
        as(subject, path = "") {
            if (subject != null) {
                let member = subject[Symbol.asyncIterator];
                if (member != null && member.constructor === globalThis.Function) {
                    return subject;
                }
            }
            throw "Expected AsyncBinary at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `AsyncBinary`;
        }
    };
    exports.SyncBinary = {
        as(subject, path = "") {
            if (subject != null) {
                let member = subject[Symbol.iterator];
                if (member != null && member.constructor === globalThis.Function) {
                    return subject;
                }
            }
            throw "Expected SyncBinary at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `SyncBinary`;
        }
    };
    exports.Binary = guards.Union.of(exports.AsyncBinary, exports.SyncBinary);
    exports.Primitive = guards.Union.of(guards.Boolean, guards.Number, guards.String, guards.Undefined);
    exports.JSON = guards.Group.of(guards.Union.of(guards.Boolean, guards.Null, guards.Number, guards.String, guards.Array.of(guards.Reference.of(() => exports.JSON)), guards.Record.of(guards.Reference.of(() => exports.JSON)), guards.Undefined), "JSON");
    exports.Options = guards.Record.of(exports.JSON);
    exports.Headers = guards.Record.of(exports.JSON);
    function serializeValue(value, plain) {
        if (value === undefined) {
            return;
        }
        return plain ? String(value) : globalThis.JSON.stringify(value);
    }
    exports.serializeValue = serializeValue;
    ;
    function deserializeValue(value, plain) {
        if (value === undefined || plain) {
            return value;
        }
        try {
            return globalThis.JSON.parse(value);
        }
        catch (error) { }
    }
    exports.deserializeValue = deserializeValue;
    ;
    function collectPayload(binary) {
        var binary_1, binary_1_1;
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            let chunks = new Array();
            let length = 0;
            try {
                for (binary_1 = __asyncValues(binary); binary_1_1 = yield binary_1.next(), !binary_1_1.done;) {
                    let chunk = binary_1_1.value;
                    chunks.push(chunk);
                    length += chunk.length;
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (binary_1_1 && !binary_1_1.done && (_a = binary_1.return))
                        yield _a.call(binary_1);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            let payload = new Uint8Array(length);
            let offset = 0;
            for (let chunk of chunks) {
                payload.set(chunk, offset);
                offset += chunk.length;
            }
            return payload;
        });
    }
    exports.collectPayload = collectPayload;
    ;
    function serializeStringPayload(string) {
        // @ts-ignore
        let encoder = new TextEncoder();
        let array = encoder.encode(string);
        return [array];
    }
    exports.serializeStringPayload = serializeStringPayload;
    ;
    function serializePayload(payload) {
        let serialized = serializeValue(payload, false);
        if (serialized === undefined) {
            return [];
        }
        return serializeStringPayload(serialized);
    }
    exports.serializePayload = serializePayload;
    ;
    function compareArrays(one, two) {
        if (one.length !== two.length) {
            return false;
        }
        for (let i = 0; i < one.length; i++) {
            if (one[i] !== two[i]) {
                return false;
            }
        }
        return true;
    }
    exports.compareArrays = compareArrays;
    ;
    function deserializeStringPayload(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            let buffer = yield collectPayload(binary);
            // @ts-ignore
            let decoder = new TextDecoder();
            let string = decoder.decode(buffer);
            // @ts-ignore
            let encoder = new TextEncoder();
            let encoded = encoder.encode(string);
            if (!compareArrays(buffer, encoded)) {
                throw `Expected payload to be UTF-8 encoded!`;
            }
            return string;
        });
    }
    exports.deserializeStringPayload = deserializeStringPayload;
    ;
    function deserializePayload(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            let string = yield deserializeStringPayload(binary);
            if (string === "") {
                return;
            }
            let value = deserializeValue(string, false);
            if (value === undefined) {
                throw `Expected payload to be JSON encoded!`;
            }
            return value;
        });
    }
    exports.deserializePayload = deserializePayload;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/api", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards", "node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization"], function (require, exports, api, guards, serialization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialization = exports.guards = exports.api = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialization = exports.guards = exports.api = void 0;
    exports.api = api;
    exports.guards = guards;
    exports.serialization = serialization;
});
define("build/database/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Year = exports.PlaylistItem = exports.Playlist = exports.Stream = exports.Token = exports.Key = exports.User = exports.Cue = exports.Subtitle = exports.ShowGenre = exports.MovieGenre = exports.Genre = exports.ShowActor = exports.MovieActor = exports.Actor = exports.MovieFile = exports.Movie = exports.EpisodeFile = exports.Episode = exports.Season = exports.ShowFile = exports.Show = exports.TrackArtist = exports.AlbumArtist = exports.TrackFile = exports.Track = exports.Disc = exports.AlbumFile = exports.Album = exports.Artist = exports.VideoSubtitle = exports.VideoFile = exports.SubtitleFile = exports.MetadataFile = exports.ImageFile = exports.AudioFile = exports.File = exports.Directory = void 0;
    exports.Directory = autoguard.guards.Object.of({
        "directory_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "parent_directory_id": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.File = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "parent_directory_id": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "index_timestamp": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "size": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    });
    exports.AudioFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("audio/mp4"), autoguard.guards.StringLiteral.of("audio/mp3")),
        "duration_ms": autoguard.guards.Number
    });
    exports.ImageFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.StringLiteral.of("image/jpeg"),
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    });
    exports.MetadataFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.StringLiteral.of("application/json")
    });
    exports.SubtitleFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.StringLiteral.of("text/vtt"),
        "duration_ms": autoguard.guards.Number,
        "language": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.VideoFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.StringLiteral.of("video/mp4"),
        "duration_ms": autoguard.guards.Number,
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    });
    exports.VideoSubtitle = autoguard.guards.Object.of({
        "video_file_id": autoguard.guards.String,
        "subtitle_file_id": autoguard.guards.String
    });
    exports.Artist = autoguard.guards.Object.of({
        "artist_id": autoguard.guards.String,
        "name": autoguard.guards.String
    });
    exports.Album = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    });
    exports.AlbumFile = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.Disc = autoguard.guards.Object.of({
        "disc_id": autoguard.guards.String,
        "album_id": autoguard.guards.String,
        "number": autoguard.guards.Number
    });
    exports.Track = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "disc_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.TrackFile = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.AlbumArtist = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "artist_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.TrackArtist = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "artist_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.Show = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.ShowFile = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.Season = autoguard.guards.Object.of({
        "season_id": autoguard.guards.String,
        "show_id": autoguard.guards.String,
        "number": autoguard.guards.Number
    });
    exports.Episode = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "season_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.EpisodeFile = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.Movie = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.MovieFile = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.Actor = autoguard.guards.Object.of({
        "actor_id": autoguard.guards.String,
        "name": autoguard.guards.String
    });
    exports.MovieActor = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "actor_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.ShowActor = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "actor_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.Genre = autoguard.guards.Object.of({
        "genre_id": autoguard.guards.String,
        "name": autoguard.guards.String
    });
    exports.MovieGenre = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "genre_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.ShowGenre = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "genre_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.Subtitle = autoguard.guards.Object.of({
        "subtitle_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.Cue = autoguard.guards.Object.of({
        "cue_id": autoguard.guards.String,
        "subtitle_id": autoguard.guards.String,
        "start_ms": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number,
        "lines": autoguard.guards.String
    });
    exports.User = autoguard.guards.Object.of({
        "user_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "username": autoguard.guards.String,
        "password": autoguard.guards.String
    });
    exports.Key = autoguard.guards.Object.of({
        "key_id": autoguard.guards.String,
        "user_id": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.Token = autoguard.guards.Object.of({
        "token_id": autoguard.guards.String,
        "user_id": autoguard.guards.String,
        "hash": autoguard.guards.String,
        "expires_ms": autoguard.guards.Number
    });
    exports.Stream = autoguard.guards.Object.of({
        "stream_id": autoguard.guards.String,
        "user_id": autoguard.guards.String,
        "file_id": autoguard.guards.String,
        "timestamp_ms": autoguard.guards.Number
    });
    exports.Playlist = autoguard.guards.Object.of({
        "playlist_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "description": autoguard.guards.String,
        "user_id": autoguard.guards.String
    });
    exports.PlaylistItem = autoguard.guards.Object.of({
        "playlist_item_id": autoguard.guards.String,
        "playlist_id": autoguard.guards.String,
        "track_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "added_ms": autoguard.guards.Number
    });
    exports.Year = autoguard.guards.Object.of({
        "year_id": autoguard.guards.String,
        "year": autoguard.guards.Number
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Directory": autoguard.guards.Reference.of(() => exports.Directory),
            "File": autoguard.guards.Reference.of(() => exports.File),
            "AudioFile": autoguard.guards.Reference.of(() => exports.AudioFile),
            "ImageFile": autoguard.guards.Reference.of(() => exports.ImageFile),
            "MetadataFile": autoguard.guards.Reference.of(() => exports.MetadataFile),
            "SubtitleFile": autoguard.guards.Reference.of(() => exports.SubtitleFile),
            "VideoFile": autoguard.guards.Reference.of(() => exports.VideoFile),
            "VideoSubtitle": autoguard.guards.Reference.of(() => exports.VideoSubtitle),
            "Artist": autoguard.guards.Reference.of(() => exports.Artist),
            "Album": autoguard.guards.Reference.of(() => exports.Album),
            "AlbumFile": autoguard.guards.Reference.of(() => exports.AlbumFile),
            "Disc": autoguard.guards.Reference.of(() => exports.Disc),
            "Track": autoguard.guards.Reference.of(() => exports.Track),
            "TrackFile": autoguard.guards.Reference.of(() => exports.TrackFile),
            "AlbumArtist": autoguard.guards.Reference.of(() => exports.AlbumArtist),
            "TrackArtist": autoguard.guards.Reference.of(() => exports.TrackArtist),
            "Show": autoguard.guards.Reference.of(() => exports.Show),
            "ShowFile": autoguard.guards.Reference.of(() => exports.ShowFile),
            "Season": autoguard.guards.Reference.of(() => exports.Season),
            "Episode": autoguard.guards.Reference.of(() => exports.Episode),
            "EpisodeFile": autoguard.guards.Reference.of(() => exports.EpisodeFile),
            "Movie": autoguard.guards.Reference.of(() => exports.Movie),
            "MovieFile": autoguard.guards.Reference.of(() => exports.MovieFile),
            "Actor": autoguard.guards.Reference.of(() => exports.Actor),
            "MovieActor": autoguard.guards.Reference.of(() => exports.MovieActor),
            "ShowActor": autoguard.guards.Reference.of(() => exports.ShowActor),
            "Genre": autoguard.guards.Reference.of(() => exports.Genre),
            "MovieGenre": autoguard.guards.Reference.of(() => exports.MovieGenre),
            "ShowGenre": autoguard.guards.Reference.of(() => exports.ShowGenre),
            "Subtitle": autoguard.guards.Reference.of(() => exports.Subtitle),
            "Cue": autoguard.guards.Reference.of(() => exports.Cue),
            "User": autoguard.guards.Reference.of(() => exports.User),
            "Key": autoguard.guards.Reference.of(() => exports.Key),
            "Token": autoguard.guards.Reference.of(() => exports.Token),
            "Stream": autoguard.guards.Reference.of(() => exports.Stream),
            "Playlist": autoguard.guards.Reference.of(() => exports.Playlist),
            "PlaylistItem": autoguard.guards.Reference.of(() => exports.PlaylistItem),
            "Year": autoguard.guards.Reference.of(() => exports.Year)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/objects/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/database/schema/index", "build/database/schema/index", "build/database/schema/index", "build/database/schema/index"], function (require, exports, autoguard, schema_1, schema_2, schema_3, schema_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Entity = exports.EntityBase = exports.Year = exports.YearBase = exports.Cue = exports.CueBase = exports.Subtitle = exports.SubtitleBase = exports.Episode = exports.EpisodeBase = exports.Season = exports.SeasonBase = exports.Show = exports.ShowBase = exports.Movie = exports.MovieBase = exports.Genre = exports.GenreBase = exports.PlaylistItem = exports.PlaylistItemBase = exports.Playlist = exports.PlaylistBase = exports.User = exports.UserBase = exports.Track = exports.TrackBase = exports.Disc = exports.DiscBase = exports.Album = exports.AlbumBase = exports.Artist = exports.ArtistBase = exports.Actor = exports.ActorBase = void 0;
    exports.ActorBase = autoguard.guards.Object.of({
        "actor_id": autoguard.guards.String,
        "name": autoguard.guards.String
    });
    exports.Actor = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ActorBase), autoguard.guards.Object.of({}));
    exports.ArtistBase = autoguard.guards.Object.of({
        "artist_id": autoguard.guards.String,
        "title": autoguard.guards.String
    });
    exports.Artist = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ArtistBase), autoguard.guards.Object.of({
        "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Album))
    }));
    exports.AlbumBase = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Album = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.AlbumBase), autoguard.guards.Object.of({
        "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ArtistBase)),
        "discs": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Disc)),
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    }));
    exports.DiscBase = autoguard.guards.Object.of({
        "disc_id": autoguard.guards.String,
        "album": autoguard.guards.Reference.of(() => exports.AlbumBase),
        "number": autoguard.guards.Number
    });
    exports.Disc = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.DiscBase), autoguard.guards.Object.of({
        "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Track))
    }));
    exports.TrackBase = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "disc": autoguard.guards.Reference.of(() => exports.DiscBase),
        "number": autoguard.guards.Number
    });
    exports.Track = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.TrackBase), autoguard.guards.Object.of({
        "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ArtistBase)),
        "last_stream_date": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "media": autoguard.guards.Reference.of(() => schema_1.AudioFile),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    }));
    exports.UserBase = autoguard.guards.Object.of({
        "user_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "username": autoguard.guards.String
    });
    exports.User = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.UserBase), autoguard.guards.Object.of({}));
    exports.PlaylistBase = autoguard.guards.Object.of({
        "playlist_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "description": autoguard.guards.String,
        "user": autoguard.guards.Reference.of(() => exports.UserBase)
    });
    exports.Playlist = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.PlaylistBase), autoguard.guards.Object.of({
        "items": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.PlaylistItem))
    }));
    exports.PlaylistItemBase = autoguard.guards.Object.of({
        "playlist_item_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "playlist": autoguard.guards.Reference.of(() => exports.PlaylistBase),
        "track": autoguard.guards.Reference.of(() => exports.Track)
    });
    exports.PlaylistItem = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.PlaylistItemBase), autoguard.guards.Object.of({}));
    exports.GenreBase = autoguard.guards.Object.of({
        "genre_id": autoguard.guards.String,
        "title": autoguard.guards.String
    });
    exports.Genre = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.GenreBase), autoguard.guards.Object.of({}));
    exports.MovieBase = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Movie = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.MovieBase), autoguard.guards.Object.of({
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "genres": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Genre)),
        "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Actor)),
        "last_stream_date": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "media": autoguard.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_3.SubtitleFile)),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    }));
    exports.ShowBase = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Show = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ShowBase), autoguard.guards.Object.of({
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "genres": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Genre)),
        "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Actor)),
        "seasons": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Season))
    }));
    exports.SeasonBase = autoguard.guards.Object.of({
        "season_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "show": autoguard.guards.Reference.of(() => exports.ShowBase)
    });
    exports.Season = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.SeasonBase), autoguard.guards.Object.of({
        "episodes": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Episode))
    }));
    exports.EpisodeBase = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "season": autoguard.guards.Reference.of(() => exports.SeasonBase)
    });
    exports.Episode = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.EpisodeBase), autoguard.guards.Object.of({
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "last_stream_date": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "media": autoguard.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_3.SubtitleFile)),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    }));
    exports.SubtitleBase = autoguard.guards.Object.of({
        "subtitle_id": autoguard.guards.String,
        "subtitle": autoguard.guards.Reference.of(() => schema_3.SubtitleFile)
    });
    exports.Subtitle = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.SubtitleBase), autoguard.guards.Object.of({
        "cues": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Cue))
    }));
    exports.CueBase = autoguard.guards.Object.of({
        "cue_id": autoguard.guards.String,
        "subtitle": autoguard.guards.Reference.of(() => exports.SubtitleBase),
        "start_ms": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number,
        "lines": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.Cue = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.CueBase), autoguard.guards.Object.of({
        "media": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Episode), autoguard.guards.Reference.of(() => exports.Movie))
    }));
    exports.YearBase = autoguard.guards.Object.of({
        "year_id": autoguard.guards.String,
        "year": autoguard.guards.Number
    });
    exports.Year = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.YearBase), autoguard.guards.Object.of({}));
    exports.EntityBase = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ActorBase), autoguard.guards.Reference.of(() => exports.AlbumBase), autoguard.guards.Reference.of(() => exports.ArtistBase), autoguard.guards.Reference.of(() => exports.CueBase), autoguard.guards.Reference.of(() => exports.DiscBase), autoguard.guards.Reference.of(() => exports.EpisodeBase), autoguard.guards.Reference.of(() => exports.GenreBase), autoguard.guards.Reference.of(() => exports.MovieBase), autoguard.guards.Reference.of(() => exports.PlaylistBase), autoguard.guards.Reference.of(() => exports.SeasonBase), autoguard.guards.Reference.of(() => exports.ShowBase), autoguard.guards.Reference.of(() => exports.TrackBase), autoguard.guards.Reference.of(() => exports.UserBase), autoguard.guards.Reference.of(() => exports.YearBase));
    exports.Entity = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Actor), autoguard.guards.Reference.of(() => exports.Album), autoguard.guards.Reference.of(() => exports.Artist), autoguard.guards.Reference.of(() => exports.Cue), autoguard.guards.Reference.of(() => exports.Disc), autoguard.guards.Reference.of(() => exports.Episode), autoguard.guards.Reference.of(() => exports.Genre), autoguard.guards.Reference.of(() => exports.Movie), autoguard.guards.Reference.of(() => exports.Playlist), autoguard.guards.Reference.of(() => exports.Season), autoguard.guards.Reference.of(() => exports.Show), autoguard.guards.Reference.of(() => exports.Track), autoguard.guards.Reference.of(() => exports.User), autoguard.guards.Reference.of(() => exports.Year));
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ActorBase": autoguard.guards.Reference.of(() => exports.ActorBase),
            "Actor": autoguard.guards.Reference.of(() => exports.Actor),
            "ArtistBase": autoguard.guards.Reference.of(() => exports.ArtistBase),
            "Artist": autoguard.guards.Reference.of(() => exports.Artist),
            "AlbumBase": autoguard.guards.Reference.of(() => exports.AlbumBase),
            "Album": autoguard.guards.Reference.of(() => exports.Album),
            "DiscBase": autoguard.guards.Reference.of(() => exports.DiscBase),
            "Disc": autoguard.guards.Reference.of(() => exports.Disc),
            "TrackBase": autoguard.guards.Reference.of(() => exports.TrackBase),
            "Track": autoguard.guards.Reference.of(() => exports.Track),
            "UserBase": autoguard.guards.Reference.of(() => exports.UserBase),
            "User": autoguard.guards.Reference.of(() => exports.User),
            "PlaylistBase": autoguard.guards.Reference.of(() => exports.PlaylistBase),
            "Playlist": autoguard.guards.Reference.of(() => exports.Playlist),
            "PlaylistItemBase": autoguard.guards.Reference.of(() => exports.PlaylistItemBase),
            "PlaylistItem": autoguard.guards.Reference.of(() => exports.PlaylistItem),
            "GenreBase": autoguard.guards.Reference.of(() => exports.GenreBase),
            "Genre": autoguard.guards.Reference.of(() => exports.Genre),
            "MovieBase": autoguard.guards.Reference.of(() => exports.MovieBase),
            "Movie": autoguard.guards.Reference.of(() => exports.Movie),
            "ShowBase": autoguard.guards.Reference.of(() => exports.ShowBase),
            "Show": autoguard.guards.Reference.of(() => exports.Show),
            "SeasonBase": autoguard.guards.Reference.of(() => exports.SeasonBase),
            "Season": autoguard.guards.Reference.of(() => exports.Season),
            "EpisodeBase": autoguard.guards.Reference.of(() => exports.EpisodeBase),
            "Episode": autoguard.guards.Reference.of(() => exports.Episode),
            "SubtitleBase": autoguard.guards.Reference.of(() => exports.SubtitleBase),
            "Subtitle": autoguard.guards.Reference.of(() => exports.Subtitle),
            "CueBase": autoguard.guards.Reference.of(() => exports.CueBase),
            "Cue": autoguard.guards.Reference.of(() => exports.Cue),
            "YearBase": autoguard.guards.Reference.of(() => exports.YearBase),
            "Year": autoguard.guards.Reference.of(() => exports.Year),
            "EntityBase": autoguard.guards.Reference.of(() => exports.EntityBase),
            "Entity": autoguard.guards.Reference.of(() => exports.Entity)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/player/schema/objects/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2, objects_3, objects_4, objects_5, objects_6, objects_7, objects_8, objects_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Session = exports.Device = exports.ContextItem = exports.Context = exports.ContextEpisode = exports.ContextSeason = exports.ContextShow = exports.ContextMovie = exports.ContextPlaylist = exports.ContextTrack = exports.ContextDisc = exports.ContextArtist = exports.ContextAlbum = void 0;
    exports.ContextAlbum = autoguard.guards.Reference.of(() => objects_1.Album);
    exports.ContextArtist = autoguard.guards.Reference.of(() => objects_2.Artist);
    exports.ContextDisc = autoguard.guards.Reference.of(() => objects_3.Disc);
    exports.ContextTrack = autoguard.guards.Reference.of(() => objects_9.Track);
    exports.ContextPlaylist = autoguard.guards.Reference.of(() => objects_6.Playlist);
    exports.ContextMovie = autoguard.guards.Reference.of(() => objects_5.Movie);
    exports.ContextShow = autoguard.guards.Reference.of(() => objects_8.Show);
    exports.ContextSeason = autoguard.guards.Reference.of(() => objects_7.Season);
    exports.ContextEpisode = autoguard.guards.Reference.of(() => objects_4.Episode);
    exports.Context = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ContextAlbum), autoguard.guards.Reference.of(() => exports.ContextArtist), autoguard.guards.Reference.of(() => exports.ContextDisc), autoguard.guards.Reference.of(() => exports.ContextTrack), autoguard.guards.Reference.of(() => exports.ContextPlaylist), autoguard.guards.Reference.of(() => exports.ContextMovie), autoguard.guards.Reference.of(() => exports.ContextShow), autoguard.guards.Reference.of(() => exports.ContextSeason), autoguard.guards.Reference.of(() => exports.ContextEpisode));
    exports.ContextItem = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ContextTrack), autoguard.guards.Reference.of(() => exports.ContextMovie), autoguard.guards.Reference.of(() => exports.ContextEpisode));
    exports.Device = autoguard.guards.Object.of({
        "id": autoguard.guards.String,
        "protocol": autoguard.guards.String,
        "name": autoguard.guards.String,
        "type": autoguard.guards.String
    });
    exports.Session = autoguard.guards.Object.of({
        "context": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Context), autoguard.guards.Undefined),
        "device": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Device), autoguard.guards.Undefined),
        "index": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "playback": autoguard.guards.Boolean,
        "progress": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ContextAlbum": autoguard.guards.Reference.of(() => exports.ContextAlbum),
            "ContextArtist": autoguard.guards.Reference.of(() => exports.ContextArtist),
            "ContextDisc": autoguard.guards.Reference.of(() => exports.ContextDisc),
            "ContextTrack": autoguard.guards.Reference.of(() => exports.ContextTrack),
            "ContextPlaylist": autoguard.guards.Reference.of(() => exports.ContextPlaylist),
            "ContextMovie": autoguard.guards.Reference.of(() => exports.ContextMovie),
            "ContextShow": autoguard.guards.Reference.of(() => exports.ContextShow),
            "ContextSeason": autoguard.guards.Reference.of(() => exports.ContextSeason),
            "ContextEpisode": autoguard.guards.Reference.of(() => exports.ContextEpisode),
            "Context": autoguard.guards.Reference.of(() => exports.Context),
            "ContextItem": autoguard.guards.Reference.of(() => exports.ContextItem),
            "Device": autoguard.guards.Reference.of(() => exports.Device),
            "Session": autoguard.guards.Reference.of(() => exports.Session)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/player/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/player/schema/objects/index", "build/player/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.SetToken = exports.SetProgress = exports.SetPlayback = exports.SetLocalDevice = exports.SetIndex = exports.SetDevices = exports.SetDevice = exports.SetContext = void 0;
    exports.SetContext = autoguard.guards.Object.of({
        "context": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_1.Context), autoguard.guards.Undefined)
    });
    exports.SetDevice = autoguard.guards.Object.of({
        "device": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_2.Device), autoguard.guards.Undefined)
    });
    exports.SetDevices = autoguard.guards.Object.of({
        "devices": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Device))
    });
    exports.SetIndex = autoguard.guards.Object.of({
        "index": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    });
    exports.SetLocalDevice = autoguard.guards.Object.of({
        "device": autoguard.guards.Reference.of(() => objects_2.Device)
    });
    exports.SetPlayback = autoguard.guards.Object.of({
        "playback": autoguard.guards.Boolean
    });
    exports.SetProgress = autoguard.guards.Object.of({
        "progress": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    });
    exports.SetToken = autoguard.guards.Object.of({
        "token": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "SetContext": autoguard.guards.Reference.of(() => exports.SetContext),
            "SetDevice": autoguard.guards.Reference.of(() => exports.SetDevice),
            "SetDevices": autoguard.guards.Reference.of(() => exports.SetDevices),
            "SetIndex": autoguard.guards.Reference.of(() => exports.SetIndex),
            "SetLocalDevice": autoguard.guards.Reference.of(() => exports.SetLocalDevice),
            "SetPlayback": autoguard.guards.Reference.of(() => exports.SetPlayback),
            "SetProgress": autoguard.guards.Reference.of(() => exports.SetProgress),
            "SetToken": autoguard.guards.Reference.of(() => exports.SetToken)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/player/schema/index", ["require", "exports", "build/player/schema/messages/index", "build/player/schema/objects/index"], function (require, exports, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    exports.messages = messages;
    exports.objects = objects;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/routing/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamespacedMessageRouter = exports.MessageRouter = void 0;
    class MessageRouter {
        constructor() {
            this.observers = Object.create(null);
        }
        addObserver(type, observer) {
            let observers = this.observers[type];
            if (observers === undefined) {
                observers = new Set();
                this.observers[type] = observers;
            }
            observers.add(observer);
        }
        removeObserver(type, observer) {
            let observers = this.observers[type];
            if (observers !== undefined) {
                observers.delete(observer);
                if (observers.size === 0) {
                    delete this.observers[type];
                }
            }
        }
        route(type, message) {
            let observers = this.observers[type];
            if (observers !== undefined) {
                for (let observer of observers) {
                    observer(message);
                }
            }
        }
        size() {
            return Object.keys(this.observers).length;
        }
    }
    exports.MessageRouter = MessageRouter;
    ;
    class NamespacedMessageRouter {
        constructor() {
            this.routers = Object.create(null);
        }
        addObserver(namespace, type, observer) {
            let router = this.routers[namespace];
            if (router === undefined) {
                router = new MessageRouter();
                this.routers[namespace] = router;
            }
            router.addObserver(type, observer);
        }
        removeObserver(namespace, type, observer) {
            let router = this.routers[namespace];
            if (router !== undefined) {
                router.removeObserver(type, observer);
                if (router.size() === 0) {
                    delete this.routers[namespace];
                }
            }
        }
        route(namespace, type, message) {
            let router = this.routers[namespace];
            if (router !== undefined) {
                router.route(type, message);
            }
        }
    }
    exports.NamespacedMessageRouter = NamespacedMessageRouter;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/index", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/routing/index"], function (require, exports, routing) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = void 0;
    exports.routing = routing;
});
define("node_modules/@joelek/ts-sockets/dist/lib/shared", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusCode = exports.ReadyState = void 0;
    var ReadyState;
    (function (ReadyState) {
        ReadyState[ReadyState["CONNECTING"] = 0] = "CONNECTING";
        ReadyState[ReadyState["OPEN"] = 1] = "OPEN";
        ReadyState[ReadyState["CLOSING"] = 2] = "CLOSING";
        ReadyState[ReadyState["CLOSED"] = 3] = "CLOSED";
    })(ReadyState = exports.ReadyState || (exports.ReadyState = {}));
    ;
    var StatusCode;
    (function (StatusCode) {
        StatusCode[StatusCode["NORMAL"] = 1000] = "NORMAL";
        StatusCode[StatusCode["GOING_AWAY"] = 1001] = "GOING_AWAY";
        StatusCode[StatusCode["PROTOCOL_ERROR"] = 1002] = "PROTOCOL_ERROR";
        StatusCode[StatusCode["DATA_TYPE_NOT_ACCEPTED"] = 1003] = "DATA_TYPE_NOT_ACCEPTED";
        StatusCode[StatusCode["RESERVED_1004"] = 1004] = "RESERVED_1004";
        StatusCode[StatusCode["RESERVED_1005"] = 1005] = "RESERVED_1005";
        StatusCode[StatusCode["RESERVED_1006"] = 1006] = "RESERVED_1006";
        StatusCode[StatusCode["BAD_DATA_TYPE"] = 1007] = "BAD_DATA_TYPE";
        StatusCode[StatusCode["POLICY_VIOLATION"] = 1008] = "POLICY_VIOLATION";
        StatusCode[StatusCode["MESSAGE_TOO_BIG"] = 1009] = "MESSAGE_TOO_BIG";
        StatusCode[StatusCode["CLIENT_EXPECTED_EXTENSION"] = 1010] = "CLIENT_EXPECTED_EXTENSION";
        StatusCode[StatusCode["SERVER_UNEXPECTED_CONDITION"] = 1011] = "SERVER_UNEXPECTED_CONDITION";
        StatusCode[StatusCode["RESERVED_1015"] = 1015] = "RESERVED_1015";
    })(StatusCode = exports.StatusCode || (exports.StatusCode = {}));
    ;
    ;
});
define("build/typesockets/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Envelope = void 0;
    exports.Envelope = autoguard.guards.Object.of({
        "type": autoguard.guards.String,
        "data": autoguard.guards.Any,
        "id": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Envelope": autoguard.guards.Reference.of(() => exports.Envelope)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/typesockets/shared", ["require", "exports", "build/typesockets/schema/index", "build/is"], function (require, exports, schema, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Serializer = void 0;
    class Serializer {
        guards;
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let envelope = schema.Envelope.as(JSON.parse(string));
            let id = envelope.id;
            let type = envelope.type;
            let data = envelope.data;
            let guard = this.guards[type];
            if (is.absent(guard)) {
                throw `Unknown message type "${type}"!`;
            }
            cb(type, guard.as(data), id);
        }
        serialize(type, data, id) {
            return JSON.stringify({
                type,
                data,
                id
            });
        }
    }
    exports.Serializer = Serializer;
    ;
});
define("build/typesockets/client", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/index", "node_modules/@joelek/ts-sockets/dist/lib/shared", "build/typesockets/shared", "build/is"], function (require, exports, stdlib, sockets, shared, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketClient = void 0;
    class TypeSocketClient {
        nextConnectionAttemptDelayFactor;
        nextConnectionAttemptDelay;
        router;
        serializer;
        url;
        factory;
        socket;
        requests;
        makeId() {
            let string = "";
            for (let i = 0; i < 32; i++) {
                let number = Math.floor(Math.random() * 16);
                string += number.toString(16);
            }
            return string;
        }
        makeSocket() {
            let socket = this.factory(this.url);
            socket.addEventListener("close", this.onClose.bind(this));
            socket.addEventListener("error", this.onError.bind(this));
            socket.addEventListener("message", this.onMessage.bind(this));
            socket.addEventListener("open", this.onOpen.bind(this));
            return socket;
        }
        onClose(event) {
            this.router.route("sys", "disconnect", {});
        }
        onError(event) {
            setTimeout(() => {
                this.socket = this.makeSocket();
            }, this.nextConnectionAttemptDelay);
            this.nextConnectionAttemptDelay = Math.round(this.nextConnectionAttemptDelay * this.nextConnectionAttemptDelayFactor);
        }
        onMessage(event) {
            try {
                this.serializer.deserialize(event.data, (type, data, id) => {
                    this.router.route("sys", "message", {
                        type,
                        data
                    });
                    if (is.present(id)) {
                        let callback = this.requests.get(id);
                        if (is.present(callback)) {
                            this.requests.delete(id);
                            callback(type, data);
                        }
                    }
                    this.router.route("app", type, data);
                });
            }
            catch (error) {
                this.socket.close();
            }
        }
        onOpen(event) {
            this.nextConnectionAttemptDelay = 2000;
            this.router.route("sys", "connect", {});
        }
        queue(payload) {
            if (this.socket.readyState === sockets.ReadyState.OPEN) {
                this.socket.send(payload);
            }
            else {
                let onopen = () => {
                    this.socket.removeEventListener("open", onopen);
                    this.socket.send(payload);
                };
                this.socket.addEventListener("open", onopen);
            }
        }
        constructor(url, factory, guards) {
            this.nextConnectionAttemptDelayFactor = 2.0 + Math.random();
            this.nextConnectionAttemptDelay = 2000;
            this.router = new stdlib.routing.NamespacedMessageRouter();
            this.serializer = new shared.Serializer(guards);
            this.url = url;
            this.factory = factory;
            this.socket = this.makeSocket();
            this.requests = new Map();
        }
        addEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        close() {
            this.socket.close();
        }
        reconnect() {
            if (this.socket.readyState === sockets.ReadyState.CLOSED) {
                this.socket = this.makeSocket();
            }
        }
        removeEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        request(type, response_type, data) {
            return new Promise((resolve, reject) => {
                let id = this.makeId();
                let payload = this.serializer.serialize(type, data, id);
                this.requests.set(id, (type, data) => {
                    if (type !== response_type) {
                        reject(`Received response with type "${type}" when expecting "${response_type}"!`);
                    }
                    else {
                        resolve(data);
                    }
                });
                this.queue(payload);
            });
        }
        send(type, data) {
            let payload = this.serializer.serialize(type, data);
            this.queue(payload);
        }
    }
    exports.TypeSocketClient = TypeSocketClient;
    ;
});
define("build/player/client", ["require", "exports", "build/is", "build/observers/index", "build/player/schema/index", "build/typesockets/client"], function (require, exports, is, observers, schema, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextClient = void 0;
    class ContextClient {
        tsc;
        estimatedProgress = new observers.ObservableClass(undefined);
        estimatedProgressTimestamp = new observers.ObservableClass(undefined);
        token = new observers.ObservableClass(undefined);
        localDevice = new observers.ObservableClass(undefined);
        devices = new observers.ArrayObservable(new Array());
        device = new observers.ObservableClass(undefined);
        isDeviceLocal = new observers.ObservableClass(false);
        isDeviceRemote = new observers.ObservableClass(false);
        context = new observers.ObservableClass(undefined);
        contextPath = new observers.ObservableClass(undefined);
        flattenedContext = new observers.ObservableClass(undefined);
        lastIndex = new observers.ObservableClass(undefined);
        lastEntry = new observers.ObservableClass(undefined);
        lastLocalEntry = new observers.ObservableClass(undefined);
        currentIndex = new observers.ObservableClass(undefined);
        currentEntry = new observers.ObservableClass(undefined);
        currentLocalEntry = new observers.ObservableClass(undefined);
        nextIndex = new observers.ObservableClass(undefined);
        nextEntry = new observers.ObservableClass(undefined);
        nextLocalEntry = new observers.ObservableClass(undefined);
        playback = new observers.ObservableClass(false);
        progress = new observers.ObservableClass(undefined);
        localPlayback = new observers.ObservableClass(false);
        canPlayLast = new observers.ObservableClass(false);
        canPlayCurrent = new observers.ObservableClass(false);
        canPlayNext = new observers.ObservableClass(false);
        isCurrentEntryVideo = new observers.ObservableClass(false);
        isOnline = new observers.ObservableClass(false);
        sendPlay(context, index) {
            this.isCurrentEntryVideo.updateState(false);
            this.tsc.send("SetContext", {
                context
            });
            this.tsc.send("SetIndex", {
                index
            });
            this.tsc.send("SetPlayback", {
                playback: true
            });
        }
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.tsc = new typesockets.TypeSocketClient(url, factory, schema.messages.Autoguard.Guards);
            this.tsc.addEventListener("sys", "connect", () => {
                this.isOnline.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.isOnline.updateState(false);
            });
            this.context.addObserver((context) => {
                if (is.present(context)) {
                    if (schema.objects.ContextAlbum.is(context)) {
                        let files = [];
                        let album = context;
                        for (let disc of album.discs) {
                            files.push(...disc.tracks);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextArtist.is(context)) {
                        let files = [];
                        let artist = context;
                        for (let album of artist.albums) {
                            for (let disc of album.discs) {
                                files.push(...disc.tracks);
                            }
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextEpisode.is(context)) {
                        let files = [];
                        let episode = context;
                        files.push(episode);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextMovie.is(context)) {
                        let files = [];
                        let movie = context;
                        files.push(movie);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextPlaylist.is(context)) {
                        let files = [];
                        let playlist = context;
                        for (let item of playlist.items) {
                            files.push(item.track);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextSeason.is(context)) {
                        let files = [];
                        let season = context;
                        files.push(...season.episodes);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextShow.is(context)) {
                        let files = [];
                        let show = context;
                        for (let season of show.seasons) {
                            files.push(...season.episodes);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextTrack.is(context)) {
                        let files = [];
                        let track = context;
                        files.push(track);
                        this.flattenedContext.updateState(files);
                    }
                    else {
                        throw `Expected code to be unreachable!`;
                    }
                }
            });
            {
                let computer = () => {
                    let context = this.context.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(context) && is.present(currentIndex)) {
                        if (schema.objects.ContextAlbum.is(context)) {
                            let discIndex = 0;
                            let trackIndex = currentIndex;
                            let album = context;
                            let discs = album.discs;
                            for (let d = 0; d < discs.length; d++) {
                                let length = discs[d].tracks.length;
                                if (trackIndex >= length) {
                                    discIndex += 1;
                                    trackIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.album_id,
                                context.discs[discIndex]?.disc_id,
                                context.discs[discIndex]?.tracks[trackIndex]?.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextArtist.is(context)) {
                            let albumIndex = 0;
                            let discIndex = 0;
                            let trackIndex = currentIndex;
                            let artist = context;
                            let albums = artist.albums;
                            outer: for (let a = 0; a < albums.length; a++) {
                                let discs = albums[a].discs;
                                for (let d = 0; d < discs.length; d++) {
                                    let length = discs[d].tracks.length;
                                    if (trackIndex >= length) {
                                        discIndex += 1;
                                        trackIndex -= length;
                                    }
                                    else {
                                        break outer;
                                    }
                                }
                                albumIndex += 1;
                                discIndex = 0;
                            }
                            return this.contextPath.updateState([
                                context.artist_id,
                                context.albums[albumIndex]?.album_id,
                                context.albums[albumIndex]?.discs[discIndex]?.disc_id,
                                context.albums[albumIndex]?.discs[discIndex]?.tracks[trackIndex]?.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextEpisode.is(context)) {
                            return this.contextPath.updateState([
                                context.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextMovie.is(context)) {
                            return this.contextPath.updateState([
                                context.movie_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextPlaylist.is(context)) {
                            let itemIndex = currentIndex;
                            return this.contextPath.updateState([
                                context.playlist_id,
                                context.items[itemIndex]?.track.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextShow.is(context)) {
                            let seasonIndex = 0;
                            let episodeIndex = currentIndex;
                            let show = context;
                            let seasons = show.seasons;
                            for (let d = 0; d < seasons.length; d++) {
                                let length = seasons[d].episodes.length;
                                if (episodeIndex >= length) {
                                    seasonIndex += 1;
                                    episodeIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.show_id,
                                context.seasons[seasonIndex]?.season_id,
                                context.seasons[seasonIndex]?.episodes[episodeIndex]?.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextSeason.is(context)) {
                            let episodeIndex = currentIndex;
                            return this.contextPath.updateState([
                                context.season_id,
                                context.episodes[episodeIndex]?.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextTrack.is(context)) {
                            return this.contextPath.updateState([
                                context.track_id
                            ].filter(is.present));
                        }
                        else {
                            throw `Expected code to be unreachable!`;
                        }
                    }
                    this.contextPath.updateState(undefined);
                };
                this.context.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            this.lastEntry.addObserver((lastEntry) => {
                this.canPlayLast.updateState(is.present(lastEntry));
            });
            this.currentEntry.addObserver((currentEntry) => {
                this.canPlayCurrent.updateState(is.present(currentEntry));
            });
            this.nextEntry.addObserver((nextEntry) => {
                this.canPlayNext.updateState(is.present(nextEntry));
            });
            this.progress.addObserver((progress) => {
                this.estimatedProgress.updateState(progress);
                this.estimatedProgressTimestamp.updateState(Date.now());
            }, true);
            this.playback.addObserver((playback) => {
                let estimatedProgress = this.estimatedProgress.getState();
                let estimatedProgressTimestamp = this.estimatedProgressTimestamp.getState();
                let now = Date.now();
                if (!playback) {
                    if (is.present(estimatedProgress) && is.present(estimatedProgressTimestamp)) {
                        this.estimatedProgress.updateState(estimatedProgress + (now - estimatedProgressTimestamp) / 1000);
                    }
                }
                this.estimatedProgressTimestamp.updateState(now);
            });
            this.progress.addObserver((progress) => {
                console.log(`Progress: ${progress}`);
            });
            this.estimatedProgress.addObserver((estimatedProgress) => {
                console.log(`Estimated progress: ${estimatedProgress}`);
            });
            {
                let computer = () => {
                    let playback = this.playback.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.localPlayback.updateState(isDeviceLocal && playback);
                };
                this.playback.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let lastEntry = this.lastEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.lastLocalEntry.updateState(isDeviceLocal ? lastEntry : undefined);
                };
                this.lastEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let currentEntry = this.currentEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.currentLocalEntry.updateState(isDeviceLocal ? currentEntry : undefined);
                };
                this.currentEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let nextEntry = this.nextEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.nextLocalEntry.updateState(isDeviceLocal ? nextEntry : undefined);
                };
                this.nextEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id === device.id) {
                            return this.isDeviceLocal.updateState(true);
                        }
                    }
                    return this.isDeviceLocal.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id !== device.id) {
                            return this.isDeviceRemote.updateState(true);
                        }
                    }
                    return this.isDeviceRemote.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(currentIndex)) {
                        let index = currentIndex - 1;
                        if (index >= 0 && index < flattenedContext.length) {
                            return this.lastIndex.updateState(index);
                        }
                    }
                    return this.lastIndex.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(currentIndex)) {
                        let index = currentIndex + 1;
                        if (index >= 0 && index < flattenedContext.length) {
                            return this.nextIndex.updateState(index);
                        }
                    }
                    return this.nextIndex.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let lastIndex = this.lastIndex.getState();
                    if (is.present(flattenedContext) && is.present(lastIndex)) {
                        return this.lastEntry.updateState(flattenedContext[lastIndex]);
                    }
                    return this.lastEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.lastIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let contextIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(contextIndex)) {
                        if (contextIndex >= 0 && contextIndex + 0 < flattenedContext.length) {
                            return this.currentEntry.updateState(flattenedContext[contextIndex + 0]);
                        }
                    }
                    return this.currentEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let nextIndex = this.nextIndex.getState();
                    if (is.present(flattenedContext) && is.present(nextIndex)) {
                        return this.nextEntry.updateState(flattenedContext[nextIndex]);
                    }
                    return this.nextEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.nextIndex.addObserver(computer);
            }
            this.tsc.addEventListener("app", "SetLocalDevice", (message) => {
                this.localDevice.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetDevices", (message) => {
                this.devices.update(message.devices);
            });
            this.tsc.addEventListener("app", "SetContext", (message) => {
                this.context.updateState(message.context);
            });
            this.tsc.addEventListener("app", "SetDevice", (message) => {
                this.device.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetIndex", (message) => {
                this.currentIndex.updateState(message.index);
            });
            this.tsc.addEventListener("app", "SetPlayback", (message) => {
                this.playback.updateState(message.playback);
            });
            this.tsc.addEventListener("app", "SetProgress", (message) => {
                this.progress.updateState(message.progress);
            });
            this.tsc.addEventListener("app", "SetToken", (message) => {
                this.token.updateState(message.token);
            });
            this.isOnline.addObserver((isOnline) => {
                if (!isOnline) {
                    this.context.updateState(undefined);
                    this.currentIndex.updateState(undefined);
                    this.playback.updateState(false);
                    this.progress.updateState(undefined);
                }
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.isOnline, this.token);
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        close() {
            this.tsc.close();
        }
        last() {
            let lastIndex = this.lastIndex.getState();
            if (is.present(lastIndex)) {
                this.currentIndex.updateState(lastIndex);
                this.tsc.send("SetIndex", {
                    index: lastIndex
                });
            }
            else {
                this.pause();
            }
        }
        next() {
            let nextIndex = this.nextIndex.getState();
            if (is.present(nextIndex)) {
                this.currentIndex.updateState(nextIndex);
                this.tsc.send("SetIndex", {
                    index: nextIndex
                });
            }
            else {
                this.pause();
            }
        }
        pause() {
            this.playback.updateState(false);
            this.tsc.send("SetPlayback", {
                playback: false
            });
        }
        play() {
            this.resume();
        }
        playAlbum(album, discIndex, trackIndex) {
            let index = 0;
            if (is.present(discIndex)) {
                let discs = album.discs;
                if (discIndex < 0 || discIndex >= discs.length) {
                    throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                }
                index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                if (is.present(trackIndex)) {
                    let tracks = discs[discIndex].tracks;
                    if (trackIndex < 0 || trackIndex >= tracks.length) {
                        throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                    }
                    index += trackIndex;
                }
            }
            return this.sendPlay(album, index);
        }
        playArtist(artist, albumIndex, discIndex, trackIndex) {
            let index = 0;
            if (is.present(albumIndex)) {
                let albums = artist.albums;
                if (albumIndex < 0 || albumIndex >= albums.length) {
                    throw `Expected ${albumIndex} to be a number between 0 and ${albums.length}!`;
                }
                index += albums.slice(0, albumIndex).reduce((sum, album) => sum + album.discs.reduce((sum, disc) => sum + disc.tracks.length, 0), 0);
                if (is.present(discIndex)) {
                    let discs = albums[albumIndex].discs;
                    if (discIndex < 0 || discIndex >= discs.length) {
                        throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                    }
                    index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                    if (is.present(trackIndex)) {
                        let tracks = discs[discIndex].tracks;
                        if (trackIndex < 0 || trackIndex >= tracks.length) {
                            throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                        }
                        index += trackIndex;
                    }
                }
            }
            return this.sendPlay(artist, index);
        }
        playDisc(disc, trackIndex) {
            let index = 0;
            if (is.present(trackIndex)) {
                let tracks = disc.tracks;
                if (trackIndex < 0 || trackIndex >= tracks.length) {
                    throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                }
                index += trackIndex;
            }
            return this.sendPlay(disc, index);
        }
        playEpisode(episode) {
            this.sendPlay(episode, 0);
        }
        playMovie(movie) {
            this.sendPlay(movie, 0);
        }
        playPlaylist(playlist, itemIndex) {
            let index = 0;
            if (is.present(itemIndex)) {
                let items = playlist.items;
                if (itemIndex < 0 || itemIndex >= items.length) {
                    throw `Expected ${itemIndex} to be a number between 0 and ${items.length}!`;
                }
                index += itemIndex;
            }
            return this.sendPlay(playlist, index);
        }
        playSeason(season, episodeIndex) {
            let index = 0;
            if (is.present(episodeIndex)) {
                let episodes = season.episodes;
                if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                    throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                }
                index += episodeIndex;
            }
            return this.sendPlay(season, index);
        }
        playShow(show, seasonIndex, episodeIndex) {
            let index = 0;
            if (is.present(seasonIndex)) {
                let seasons = show.seasons;
                if (seasonIndex < 0 || seasonIndex >= seasons.length) {
                    throw `Expected ${seasonIndex} to be a number between 0 and ${seasons.length}!`;
                }
                index += seasons.slice(0, seasonIndex).reduce((sum, season) => sum + season.episodes.length, 0);
                if (is.present(episodeIndex)) {
                    let episodes = seasons[seasonIndex].episodes;
                    if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                        throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                    }
                    index += episodeIndex;
                }
            }
            return this.sendPlay(show, index);
        }
        playTrack(track) {
            this.sendPlay(track, 0);
        }
        reconnect() {
            this.tsc.reconnect();
        }
        resume() {
            if (this.canPlayCurrent.getState()) {
                this.playback.updateState(true);
                this.tsc.send("SetPlayback", {
                    playback: true
                });
            }
        }
        seek(progress) {
            this.progress.updateState(progress);
            this.tsc.send("SetProgress", {
                progress: progress
            });
        }
        toggle() {
            if (this.playback.getState()) {
                this.pause();
            }
            else {
                this.resume();
            }
        }
        transfer(device) {
            this.tsc.send("SetDevice", {
                device: device
            });
        }
    }
    exports.ContextClient = ContextClient;
});
define("build/xnode/index", ["require", "exports", "build/is", "build/observers/index"], function (require, exports, is, observers_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinarray = exports.text = exports.element = exports.XElement = exports.XText = void 0;
    class XText {
        content;
        constructor(content) {
            this.content = content;
        }
        render() {
            let node = document.createTextNode("");
            if (this.content instanceof observers_1.ObservableClass) {
                this.content.addObserver((content) => {
                    node.textContent = content;
                });
            }
            else {
                node.textContent = this.content;
            }
            return node;
        }
    }
    exports.XText = XText;
    class XElement {
        tag;
        attributes;
        children;
        bound;
        bound2;
        listeners;
        resolve;
        element;
        array;
        renderer;
        constructor(selector) {
            let parts = selector.split(".");
            this.tag = parts[0];
            this.attributes = new Map();
            this.children = new Array();
            this.bound = new Map();
            this.bound2 = new Map();
            this.listeners = new Map();
            this.resolve = () => { };
            this.element = new Promise((resolve, reject) => {
                this.resolve = resolve;
            });
            let classes = parts.slice(1).join(" ");
            if (classes !== "") {
                this.attributes.set("class", classes);
            }
        }
        add(...nodes) {
            // TODO: Detach node from current parent.
            for (let node of nodes) {
                if (node != null) {
                    this.children.push(node);
                }
            }
            return this;
        }
        bind(key, observable) {
            this.bound.set(key, observable);
            return this;
        }
        bind2(key, observable) {
            this.bound2.set(key, observable);
            return this;
        }
        on(kind, listener, override = true) {
            let listeners = this.listeners.get(kind);
            if (listeners == null) {
                listeners = new Array();
                this.listeners.set(kind, listeners);
            }
            listeners.push((event) => {
                if (override) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                listener(event);
            });
            return this;
        }
        ref() {
            if (is.absent(this.element)) {
                throw `Expected element to be rendered!`;
            }
            return this.element;
        }
        render() {
            let ns = ["svg", "path", "circle"].indexOf(this.tag) >= 0 ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml";
            let element = document.createElementNS(ns, this.tag);
            element.setAttribute = (() => {
                let setAttribute = element.setAttribute.bind(element);
                return (key, value) => {
                    if (key === "src") {
                        let observer = new IntersectionObserver((entries) => {
                            for (let entry of entries) {
                                if (entry.target === element && entry.isIntersecting) {
                                    observer.unobserve(element);
                                    setAttribute(key, value);
                                }
                            }
                        }, { root: document.body });
                        observer.observe(element);
                    }
                    else {
                        setAttribute(key, value);
                    }
                };
            })();
            for (let [kind, listeners] of this.listeners) {
                for (let listener of listeners) {
                    element.addEventListener(kind, listener);
                }
            }
            for (let [key, value] of this.attributes) {
                element.setAttribute(key, value);
            }
            for (let [key, observable] of this.bound) {
                observable((value) => {
                    element.setAttribute(key, `${value}`);
                });
            }
            for (let [key, observable] of this.bound2) {
                observable.addObserver((value) => {
                    element.setAttribute(key, `${value}`);
                });
                if (this.tag === "input" && key === "value") {
                    element.addEventListener("input", () => {
                        observable.updateState(element.value);
                    });
                }
            }
            for (let child of this.children) {
                element.appendChild(child.render());
            }
            if (this.array) {
                this.array.addObserver({
                    onappend: (state) => {
                        if (this.renderer) {
                            let child = this.renderer(state);
                            element.appendChild(child.render());
                        }
                    },
                    onsplice: (state, index) => {
                        let child = element.children[index];
                        if (is.present(child)) {
                            element.removeChild(child);
                        }
                    }
                });
            }
            this.resolve(element);
            return element;
        }
        repeat(array, renderer) {
            this.array = array;
            this.renderer = renderer;
            return this;
        }
        set(key, value = "") {
            this.attributes.set(key, value);
            return this;
        }
    }
    exports.XElement = XElement;
    function element(selector) {
        return new XElement(selector);
    }
    exports.element = element;
    function text(content) {
        return new XText(content);
    }
    exports.text = text;
    function joinarray(nodes, joiner = " \u00b7 ") {
        let array = [];
        for (let node of nodes) {
            array.push(node);
            array.push(text(joiner));
        }
        array.pop();
        return array;
    }
    exports.joinarray = joinarray;
});
define("build/ui/metadata/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatDuration = exports.computeDuration = exports.formatSize = void 0;
    function formatSize(b, options) {
        let format = options?.format ?? new Intl.NumberFormat();
        let kb = b / 1024 ** 1;
        let mb = b / 1024 ** 2;
        let gb = b / 1024 ** 3;
        let tb = b / 1024 ** 4;
        if (tb > 1) {
            return `${tb.toFixed(2)}TB`;
        }
        else if (gb > 1) {
            return `${gb.toFixed(2)}GB`;
        }
        else if (mb > 1) {
            return `${mb.toFixed(2)}MB`;
        }
        else if (kb > 1) {
            return `${kb.toFixed(2)}kB`;
        }
        else {
            return `${format.format(b)}B`;
        }
    }
    exports.formatSize = formatSize;
    ;
    function computeDuration(ms) {
        let s = Math.floor(ms / 1000);
        ms -= s * 1000;
        let m = Math.floor(s / 60);
        s -= m * 60;
        let h = Math.floor(m / 60);
        m -= h * 60;
        let d = Math.floor(h / 24);
        h -= d * 24;
        return {
            ms,
            s,
            m,
            h,
            d
        };
    }
    exports.computeDuration = computeDuration;
    ;
    function formatDuration(ms) {
        let duration = computeDuration(ms);
        if (duration.d >= 10) {
            return `${duration.d}d`;
        }
        else if (duration.d >= 1) {
            return `${duration.d}d ${duration.h}h`;
        }
        else if (duration.h >= 10) {
            return `${duration.h}h`;
        }
        else if (duration.h >= 1) {
            return `${duration.h}h ${duration.m}m`;
        }
        else if (duration.m >= 10) {
            return `${duration.m}m`;
        }
        else if (duration.m >= 1) {
            return `${duration.m}m ${duration.s}s`;
        }
        else {
            return `${duration.s}s`;
        }
    }
    exports.formatDuration = formatDuration;
    ;
});
define("build/api/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.RegisterResponse = exports.RegisterRequest = exports.ErrorMessage = void 0;
    exports.ErrorMessage = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.RegisterRequest = autoguard.guards.Object.of({
        "username": autoguard.guards.String,
        "password": autoguard.guards.String,
        "name": autoguard.guards.String,
        "key_id": autoguard.guards.String
    });
    exports.RegisterResponse = autoguard.guards.Object.of({
        "token": autoguard.guards.String
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ErrorMessage": autoguard.guards.Reference.of(() => exports.ErrorMessage),
            "RegisterRequest": autoguard.guards.Reference.of(() => exports.RegisterRequest),
            "RegisterResponse": autoguard.guards.Reference.of(() => exports.RegisterResponse)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/api/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/messages/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/messages/index", "build/api/schema/messages/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2, objects_3, objects_4, objects_5, objects_6, messages_1, objects_7, objects_8, objects_9, messages_2, messages_3, objects_10, objects_11, objects_12, objects_13, objects_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = void 0;
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {};
        Autoguard.Requests = {
            "POST:/auth/": autoguard.guards.Object.of({
                "options": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Options), autoguard.guards.Undefined),
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "x-circus-username": autoguard.guards.String,
                    "x-circus-password": autoguard.guards.String
                }), autoguard.api.Headers),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "POST:/users/": autoguard.guards.Object.of({
                "options": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Options), autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Reference.of(() => messages_2.RegisterRequest)
            }),
            "GET:/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "cues": autoguard.guards.Union.of(autoguard.guards.Boolean, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/actors/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/actors/<actor_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/actors/<actor_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/actors/<actor_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/albums/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "getNewAlbums": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/albums/<album_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "album_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/artists/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/artists/<artist_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "artist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/discs/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/discs/<disc_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "disc_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/episodes/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/episodes/<episode_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "episode_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/genres/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/genres/<genre_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/genres/<genre_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/genres/<genre_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/movies/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "getNewMovies": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/movies/<movie_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "movie_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/movies/<movie_id>/suggestions/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "movie_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/playlists/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/playlists/<playlist_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "playlist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/seasons/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/seasons/<season_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "season_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/shows/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/shows/<show_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "show_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/tracks/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/tracks/<track_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "track_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/tracks/<track_id>/playlists/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "track_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/users/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/users/<user_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/users/<user_id>/albums/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/users/<user_id>/playlists/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/users/<user_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/years/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/years/<year_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/years/<year_id>/albums/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/years/<year_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/files/<file_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "file_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/statistics/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            })
        };
        Autoguard.Responses = {
            "POST:/auth/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "x-circus-token": autoguard.guards.String
                }), autoguard.api.Headers),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "POST:/users/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => messages_3.RegisterResponse), autoguard.guards.Reference.of(() => messages_1.ErrorMessage))
            }),
            "GET:/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "entities": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_5.Entity))
                })
            }),
            "GET:/actors/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_1.Actor))
                })
            }),
            "GET:/actors/<actor_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "actor": autoguard.guards.Reference.of(() => objects_1.Actor)
                })
            }),
            "GET:/actors/<actor_id>/movies/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "GET:/actors/<actor_id>/shows/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                })
            }),
            "GET:/albums/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                })
            }),
            "getNewAlbums": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                })
            }),
            "GET:/albums/<album_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "album": autoguard.guards.Reference.of(() => objects_2.Album)
                })
            }),
            "GET:/artists/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_3.Artist))
                })
            }),
            "GET:/artists/<artist_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "artist": autoguard.guards.Reference.of(() => objects_3.Artist),
                    "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_12.Track)),
                    "appearances": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                })
            }),
            "GET:/discs/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "discs": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_4.Disc))
                })
            }),
            "GET:/discs/<disc_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "disc": autoguard.guards.Reference.of(() => objects_4.Disc),
                    "last": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_4.Disc), autoguard.guards.Undefined),
                    "next": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_4.Disc), autoguard.guards.Undefined)
                })
            }),
            "GET:/episodes/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "episodes": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_6.Episode))
                })
            }),
            "GET:/episodes/<episode_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "episode": autoguard.guards.Reference.of(() => objects_6.Episode),
                    "last": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_6.Episode), autoguard.guards.Undefined),
                    "next": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_6.Episode), autoguard.guards.Undefined)
                })
            }),
            "GET:/genres/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "genres": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_7.Genre))
                })
            }),
            "GET:/genres/<genre_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "genre": autoguard.guards.Reference.of(() => objects_7.Genre)
                })
            }),
            "GET:/genres/<genre_id>/movies/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "GET:/genres/<genre_id>/shows/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                })
            }),
            "GET:/movies/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "getNewMovies": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "GET:/movies/<movie_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movie": autoguard.guards.Reference.of(() => objects_8.Movie)
                })
            }),
            "GET:/movies/<movie_id>/suggestions/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "GET:/playlists/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "playlists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_9.Playlist))
                })
            }),
            "GET:/playlists/<playlist_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "playlist": autoguard.guards.Reference.of(() => objects_9.Playlist)
                })
            }),
            "GET:/seasons/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "seasons": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_10.Season))
                })
            }),
            "GET:/seasons/<season_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "season": autoguard.guards.Reference.of(() => objects_10.Season),
                    "last": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_10.Season), autoguard.guards.Undefined),
                    "next": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_10.Season), autoguard.guards.Undefined)
                })
            }),
            "GET:/shows/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                })
            }),
            "GET:/shows/<show_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "show": autoguard.guards.Reference.of(() => objects_11.Show)
                })
            }),
            "GET:/tracks/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_12.Track))
                })
            }),
            "GET:/tracks/<track_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "track": autoguard.guards.Reference.of(() => objects_12.Track),
                    "last": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_12.Track), autoguard.guards.Undefined),
                    "next": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_12.Track), autoguard.guards.Undefined)
                })
            }),
            "GET:/tracks/<track_id>/playlists/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "playlists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_9.Playlist))
                })
            }),
            "GET:/users/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "users": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_13.User))
                })
            }),
            "GET:/users/<user_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "user": autoguard.guards.Reference.of(() => objects_13.User)
                })
            }),
            "GET:/users/<user_id>/albums/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                })
            }),
            "GET:/users/<user_id>/playlists/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "playlists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_9.Playlist))
                })
            }),
            "GET:/users/<user_id>/shows/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                })
            }),
            "GET:/years/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "years": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_14.Year))
                })
            }),
            "GET:/years/<year_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "year": autoguard.guards.Reference.of(() => objects_14.Year)
                })
            }),
            "GET:/years/<year_id>/albums/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                })
            }),
            "GET:/years/<year_id>/movies/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "GET:/files/<file_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/statistics/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "statistics": autoguard.guards.Array.of(autoguard.guards.Object.of({
                        "title": autoguard.guards.String,
                        "value": autoguard.guards.Number,
                        "unit": autoguard.guards.Union.of(autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("BYTES"), autoguard.guards.StringLiteral.of("MILLISECONDS")), autoguard.guards.Undefined)
                    }))
                })
            })
        };
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/index", ["require", "exports", "build/api/schema/api/index", "build/api/schema/messages/index", "build/api/schema/objects/index"], function (require, exports, api, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = exports.api = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = exports.api = void 0;
    exports.api = api;
    exports.messages = messages;
    exports.objects = objects;
});
define("build/ui/EntityTitleFactory", ["require", "exports", "build/api/schema/objects/index", "build/xnode/index"], function (require, exports, api, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityTitleFactory = void 0;
    const CSS = ``;
    class EntityTitleFactory {
        entityLinkFactory;
        make(link, title) {
            return link.add(xnode.text(title));
        }
        constructor(entityLinkFactory) {
            this.entityLinkFactory = entityLinkFactory;
        }
        forEntity(entity) {
            if (api.Actor.is(entity)) {
                return this.forActor(entity);
            }
            if (api.Album.is(entity)) {
                return this.forAlbum(entity);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity);
            }
            if (api.Genre.is(entity)) {
                return this.forGenre(entity);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity);
            }
            if (api.User.is(entity)) {
                return this.forUser(entity);
            }
            throw `Expected code to be unreachable!`;
        }
        forActor(actor) {
            return this.make(this.entityLinkFactory.forActor(actor), actor.name);
        }
        forAlbum(album) {
            return this.make(this.entityLinkFactory.forAlbum(album), album.title);
        }
        forArtist(artist) {
            return this.make(this.entityLinkFactory.forArtist(artist), artist.title);
        }
        forDisc(disc) {
            return this.make(this.entityLinkFactory.forDisc(disc), `Disc ${disc.number}`);
        }
        forEpisode(episode) {
            return this.make(this.entityLinkFactory.forEpisode(episode), episode.title);
        }
        forGenre(genre) {
            return this.make(this.entityLinkFactory.forGenre(genre), genre.title);
        }
        forMovie(movie) {
            return this.make(this.entityLinkFactory.forMovie(movie), movie.title);
        }
        forPlaylist(playlist) {
            return this.make(this.entityLinkFactory.forPlaylist(playlist), playlist.title);
        }
        forSeason(season) {
            return this.make(this.entityLinkFactory.forSeason(season), `Season ${season.number}`);
        }
        forShow(show) {
            return this.make(this.entityLinkFactory.forShow(show), show.title);
        }
        forTrack(track) {
            return this.make(this.entityLinkFactory.forTrack(track), track.title);
        }
        forUser(user, options) {
            return this.make(this.entityLinkFactory.forUser(user), options?.title ?? user.name);
        }
        forYear(year) {
            return this.make(this.entityLinkFactory.forYear(year), year.year.toString());
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityTitleFactory = EntityTitleFactory;
    ;
});
define("build/ui/Grid", ["require", "exports", "build/xnode/index"], function (require, exports, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridFactory = void 0;
    const CSS = `
	.grid {
		align-items: start;
		display: grid;
		gap: 24px;
		grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
	}

	.grid--mini {
		grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
	}
`;
    class GridFactory {
        constructor() {
        }
        make(options) {
            let mini = options?.mini ?? false;
            return xnode.element(`div.grid${mini ? ".grid--mini" : ""}`);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.GridFactory = GridFactory;
    ;
});
define("build/ui/CarouselFactory", ["require", "exports", "build/observers/index", "build/xnode/index"], function (require, exports, observers, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CarouselFactory = void 0;
    const CSS = `
	.carousel {
		display: grid;
		gap: 24px;
	}

	.carousel__content {
		align-items: start;
		display: grid;
		gap: 24px;
		grid-auto-flow: column;
		grid-auto-columns: 100%;
		overflow: scroll hidden;
		scroll-behavior: smooth;
		scroll-snap-type: x mandatory;
	}

	@media (hover: hover) and (pointer: fine) {
		.carousel__content {
			overflow: hidden;
		}
	}

	.carousel__content > * {
		scroll-snap-align: start;
	}

	.carousel__controls {
		display: grid;
		gap: 16px;
		grid-auto-flow: column;
		justify-content: center;
	}

	.carousel__control {
		display: grid;
		gap: 8px;
		justify-items: center;
	}

	.carousel__control-title {
		color: rgb(159, 159, 159);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
    class CarouselFactory {
        iconFactory;
        constructor(iconFactory) {
            this.iconFactory = iconFactory;
        }
        make(children) {
            let childLength = new observers.ObservableClass(children.getState().length);
            children.compute((children) => {
                childLength.updateState(children.length);
            });
            let activeIndex = new observers.ObservableClass(0);
            let canScrollLast = observers.computed((activeIndex) => {
                return activeIndex > 0;
            }, activeIndex);
            let canScrollNext = observers.computed((activeIndex, childLength) => {
                return activeIndex < childLength - 1;
            }, activeIndex, childLength);
            let contentElement = xnode.element("div.carousel__content");
            contentElement.ref().then(async (contentElement) => {
                let observer = new IntersectionObserver(async (entries) => {
                    for (let entry of entries) {
                        for (let [index, child] of children.getState().entries()) {
                            let ref = await child.ref();
                            if (entry.target === ref && entry.isIntersecting) {
                                activeIndex.updateState(index);
                                return;
                            }
                        }
                    }
                }, {
                    root: contentElement
                });
                children.addObserver({
                    async onappend(state) {
                        observer.observe(await state.ref());
                    },
                    async onsplice(state, index) {
                        observer.unobserve(await state.ref());
                    }
                });
            });
            return xnode.element("div.carousel")
                .add(contentElement
                .repeat(children, (child) => child))
                .add(xnode.element("div.carousel__controls")
                .add(xnode.element("div.carousel__control")
                .on("click", async () => {
                if (canScrollLast.getState()) {
                    let content = await contentElement.ref();
                    let child = children.getState()[activeIndex.getState() - 1];
                    let ref = await child.ref();
                    content.scrollTo({ left: ref.offsetLeft - content.offsetLeft, behavior: "smooth" });
                }
            })
                .add(xnode.element("div.icon-button")
                .bind("data-enabled", canScrollLast.addObserver((canScrollLast) => `${canScrollLast}`))
                .add(this.iconFactory.makeChevron({ direction: "left" })))
                .add(xnode.element("div.carousel__control-title")
                .add(xnode.text("Last item"))))
                .add(xnode.element("div.carousel__control")
                .on("click", async () => {
                if (canScrollNext.getState()) {
                    let content = await contentElement.ref();
                    let child = children.getState()[activeIndex.getState() + 1];
                    let ref = await child.ref();
                    content.scrollTo({ left: ref.offsetLeft - content.offsetLeft, behavior: "smooth" });
                }
            })
                .add(xnode.element("div.icon-button")
                .bind("data-enabled", canScrollNext.addObserver((canScrollNext) => `${canScrollNext}`))
                .add(this.iconFactory.makeChevron()))
                .add(xnode.element("div.carousel__control-title")
                .add(xnode.text("Next item")))));
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.CarouselFactory = CarouselFactory;
    ;
});
define("build/ui/Icon", ["require", "exports", "build/xnode/index"], function (require, exports, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IconFactory = void 0;
    const CSS = `
	.icon--right {
		transform: rotate(0deg);
	}

	.icon--down {
		transform: rotate(90deg);
	}

	.icon--left {
		transform: rotate(180deg);
	}

	.icon--up {
		transform: rotate(270deg);
	}
`;
    function getClass(direction) {
        if (direction === "right") {
            return "icon--right";
        }
        if (direction === "down") {
            return "icon--down";
        }
        if (direction === "left") {
            return "icon--left";
        }
        if (direction === "up") {
            return "icon--up";
        }
        return "";
    }
    class IconFactory {
        constructor() {
        }
        makeBroadcast(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M2,16c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2,0.9,2,2c0,1.1,0.9,2,2,2s2-0.9,2-2C8,18.7,5.3,16,2,16z"))
                .add(xnode.element("path")
                .set("d", "M2,8c-1.1,0-2,0.9-2,2s0.9,2,2,2c5.5,0,10,4.5,10,10c0,1.1,0.9,2,2,2s2-0.9,2-2C16,14.3,9.7,8,2,8z"))
                .add(xnode.element("path")
                .set("d", "M2,0C0.9,0,0,0.9,0,2s0.9,2,2,2c9.9,0,18,8.1,18,18c0,1.1,0.9,2,2,2s2-0.9,2-2C24,9.9,14.1,0,2,0z"));
        }
        makeBulletList(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M7,4h16c0.6,0,1-0.4,1-1s-0.4-1-1-1H7C6.4,2,6,2.4,6,3S6.4,4,7,4z"))
                .add(xnode.element("path")
                .set("d", "M23,8H7C6.4,8,6,8.4,6,9s0.4,1,1,1h16c0.6,0,1-0.4,1-1S23.6,8,23,8z"))
                .add(xnode.element("path")
                .set("d", "M23,20H7c-0.6,0-1,0.4-1,1s0.4,1,1,1h16c0.6,0,1-0.4,1-1S23.6,20,23,20z"))
                .add(xnode.element("path")
                .set("d", "M23,14H7c-0.6,0-1,0.4-1,1s0.4,1,1,1h16c0.6,0,1-0.4,1-1S23.6,14,23,14z"))
                .add(xnode.element("path")
                .set("d", "M2,1C0.9,1,0,1.9,0,3s0.9,2,2,2s2-0.9,2-2S3.1,1,2,1z"))
                .add(xnode.element("path")
                .set("d", "M2,7C0.9,7,0,7.9,0,9c0,1.1,0.9,2,2,2s2-0.9,2-2C4,7.9,3.1,7,2,7z"))
                .add(xnode.element("path")
                .set("d", "M2,13c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S3.1,13,2,13z"))
                .add(xnode.element("path")
                .set("d", "M2,19c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S3.1,19,2,19z"));
        }
        makeCalendar(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M21,2h-3V1c0-0.6-0.4-1-1-1s-1,0.4-1,1v1H8V1c0-0.6-0.4-1-1-1S6,0.4,6,1v1H3C1.3,2,0,3.3,0,5v4c0,0,0,0,0,0s0,0,0,0v12c0,1.7,1.3,3,3,3h18c1.7,0,3-1.3,3-3V5C24,3.3,22.7,2,21,2z M3,4h3v1c0,0.6,0.4,1,1,1s1-0.4,1-1V4h8v1c0,0.6,0.4,1,1,1s1-0.4,1-1V4h3c0.6,0,1,0.4,1,1v3H2V5C2,4.4,2.4,4,3,4z M21,22H3c-0.6,0-1-0.4-1-1V10h20v11C22,21.6,21.6,22,21,22z"));
        }
        makeChevron(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19.4,10.6l-10-10c-0.8-0.8-2-0.8-2.8,0c-0.8,0.8-0.8,2,0,2.8l8.6,8.6l-8.6,8.6c-0.8,0.8-0.8,2,0,2.8C7,23.8,7.5,24,8,24s1-0.2,1.4-0.6l10-10C20.2,12.6,20.2,11.4,19.4,10.6z"));
        }
        makeCross(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M14.8,12l6.6-6.6c0.8-0.8,0.8-2,0-2.8c-0.8-0.8-2-0.8-2.8,0L12,9.2L5.4,2.6c-0.8-0.8-2-0.8-2.8,0c-0.8,0.8-0.8,2,0,2.8L9.2,12l-6.6,6.6c-0.8,0.8-0.8,2,0,2.8C3,21.8,3.5,22,4,22s1-0.2,1.4-0.6l6.6-6.6l6.6,6.6C19,21.8,19.5,22,20,22s1-0.2,1.4-0.6c0.8-0.8,0.8-2,0-2.8L14.8,12z"));
        }
        makeDisc(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M12,0C5.4,0,0,5.4,0,12c0,6.6,5.4,12,12,12c6.6,0,12-5.4,12-12C24,5.4,18.6,0,12,0z M12,22C6.5,22,2,17.5,2,12C2,6.5,6.5,2,12,2c5.5,0,10,4.5,10,10C22,17.5,17.5,22,12,22z"))
                .add(xnode.element("path")
                .set("d", "M12,10c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S13.1,10,12,10z"));
        }
        makeMagnifyingGlass(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M23.7,22.3l-6-6c1.4-1.7,2.3-3.9,2.3-6.3c0-5.5-4.5-10-10-10C4.5,0,0,4.5,0,10c0,5.5,4.5,10,10,10c2.4,0,4.6-0.8,6.3-2.3l6,6c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3C24.1,23.3,24.1,22.7,23.7,22.3z M10,18c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S14.4,18,10,18z"));
        }
        makeMinus(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M22,10H2c-1.1,0-2,0.9-2,2s0.9,2,2,2h20c1.1,0,2-0.9,2-2S23.1,10,22,10z"));
        }
        makeMonitor(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M21,2H3C1.3,2,0,3.3,0,5v12c0,1.7,1.3,3,3,3h18c1.7,0,3-1.3,3-3V5C24,3.3,22.7,2,21,2z M22,17c0,0.6-0.4,1-1,1H3c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h18c0.6,0,1,0.4,1,1V17z"))
                .add(xnode.element("path")
                .set("d", "M17,22H7c-0.6,0-1,0.4-1,1s0.4,1,1,1h10c0.6,0,1-0.4,1-1S17.6,22,17,22z"));
        }
        makeNote(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M16.6,5.2C15.1,4.2,14,3.5,14,1c0-0.6-0.4-1-1-1s-1,0.4-1,1v14c-0.8-0.6-1.9-1-3-1c-2.8,0-5,2.2-5,5s2.2,5,5,5s5-2.2,5-5V5.8c0.5,0.4,1,0.8,1.4,1.1c1.4,1,2.6,1.7,2.6,4.2c0,0.6,0.4,1,1,1s1-0.4,1-1C20,7.5,18.1,6.2,16.6,5.2z M9,22c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3S10.7,22,9,22z"));
        }
        makePadlock(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19,10h-1V6c0-3.3-2.7-6-6-6C8.7,0,6,2.7,6,6v4H5c-0.6,0-1,0.4-1,1v12c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1V11C20,10.4,19.6,10,19,10z M8,6c0-2.2,1.8-4,4-4c2.2,0,4,1.8,4,4v4H8V6z M18,22H6V12h12V22z"));
        }
        makePause(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M6,0C4.9,0,4,0.9,4,2v20c0,1.1,0.9,2,2,2s2-0.9,2-2V2C8,0.9,7.1,0,6,0z"))
                .add(xnode.element("path")
                .set("d", "M18,0c-1.1,0-2,0.9-2,2v20c0,1.1,0.9,2,2,2s2-0.9,2-2V2C20,0.9,19.1,0,18,0z"));
        }
        makePerson(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M18.9,16.2C17,15.5,16,15,16,13c0-0.5,0.2-0.7,0.5-1.3c0.6-1,1.5-2.4,1.5-5.7c0-3.5-2.5-6-6-6C8.5,0,6,2.5,6,6c0,3.4,0.9,4.7,1.5,5.7C7.8,12.3,8,12.5,8,13c0,2-1,2.5-2.9,3.2C2.9,17,0,18.1,0,23c0,0.6,0.4,1,1,1h22c0.6,0,1-0.4,1-1C24,18.1,21.1,17,18.9,16.2z M2.1,22c0.3-2.7,1.8-3.2,3.7-3.9S10,16.5,10,13c0-1.1-0.4-1.7-0.8-2.4C8.6,9.8,8,8.8,8,6c0-2.4,1.6-4,4-4s4,1.6,4,4c0,2.8-0.6,3.8-1.2,4.6C14.4,11.3,14,11.9,14,13c0,3.5,2.3,4.4,4.2,5.1c1.9,0.7,3.4,1.3,3.7,3.9H2.1z"));
        }
        makePieChart(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M17,14h-7V7c0-0.6-0.4-1-1-1c-5,0-9,4-9,9s4,9,9,9c5,0,9-4,9-9C18,14.4,17.6,14,17,14z M9,22c-3.9,0-7-3.1-7-7c0-3.5,2.6-6.4,6-6.9V15c0,0.6,0.4,1,1,1h6.9C15.4,19.4,12.5,22,9,22z"))
                .add(xnode.element("path")
                .set("d", "M13,0c-0.6,0-1,0.4-1,1v10c0,0.6,0.4,1,1,1h10c0.6,0,1-0.4,1-1C24,4.9,19.1,0,13,0z M14,10V2.1c4.2,0.5,7.5,3.8,7.9,7.9H14z"));
        }
        makePlay(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M23.1,11L5.7,1C4.8,0.5,4,0.9,4,2v20c0,1.1,0.8,1.5,1.7,1l17.3-10C24,12.5,24,11.5,23.1,11z"));
        }
        makePlus(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M22,10h-8V2c0-1.1-0.9-2-2-2s-2,0.9-2,2v8H2c-1.1,0-2,0.9-2,2s0.9,2,2,2h8v8c0,1.1,0.9,2,2,2s2-0.9,2-2v-8h8c1.1,0,2-0.9,2-2S23.1,10,22,10z"));
        }
        makeQuotationMark(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M8,4H2C0.9,4,0,4.9,0,6v4c0,1.1,0.9,2,2,2h3.7c-1,2.9-4.1,4.1-4.3,4.1c-1,0.3-1.6,1.5-1.3,2.5C0.4,19.5,1.2,20,2,20c0.2,0,0.4,0,0.6-0.1C2.9,19.8,10,17.4,10,10V6C10,4.9,9.1,4,8,4z")).add(xnode.element("path")
                .set("d", "M22,4h-6c-1.1,0-2,0.9-2,2v4c0,1.1,0.9,2,2,2h3.7c-1,2.9-4.1,4.1-4.3,4.1c-1,0.3-1.6,1.5-1.3,2.5c0.3,0.8,1.1,1.4,1.9,1.4c0.2,0,0.4,0,0.6-0.1c0.3-0.1,7.4-2.5,7.4-9.9V6C24,4.9,23.1,4,22,4z"));
        }
        makeReload(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M20.5,3.5c-4.7-4.7-12.3-4.7-17,0L2.8,2.8C2,2,1.2,2.3,1.1,3.4L0.3,7.9C0.1,9,0.9,9.7,2,9.5l4.5-0.8c1.1-0.2,1.3-1,0.6-1.7L6.3,6.3c3.1-3.1,8.2-3.1,11.3,0c3.1,3.1,3.1,8.2,0,11.3c-3.1,3.1-8.2,3.1-11.3,0c-0.8-0.8-2-0.8-2.8,0c-0.8,0.8-0.8,2,0,2.8c4.7,4.7,12.3,4.7,17,0C25.2,15.8,25.2,8.2,20.5,3.5z"));
        }
        makeSettings(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M22,10h-1.2c-0.2-1-0.6-1.9-1.2-2.8l0.9-0.9c0.8-0.8,0.8-2.1,0-2.8c-0.8-0.8-2.1-0.8-2.8,0l-0.9,0.9C15.9,3.9,15,3.5,14,3.2V2c0-1.1-0.9-2-2-2c-1.1,0-2,0.9-2,2v1.2C9,3.5,8.1,3.9,7.2,4.4L6.3,3.5c-0.8-0.8-2.1-0.8-2.8,0c-0.8,0.8-0.8,2.1,0,2.8l0.9,0.9C3.9,8.1,3.5,9,3.2,10H2c-1.1,0-2,0.9-2,2c0,1.1,0.9,2,2,2h1.2c0.2,1,0.6,1.9,1.2,2.8l-0.9,0.9c-0.8,0.8-0.8,2,0,2.8c0.8,0.8,2.1,0.8,2.8,0l0.9-0.9c0.8,0.5,1.8,0.9,2.8,1.2V22c0,1.1,0.9,2,2,2c1.1,0,2-0.9,2-2v-1.2c1-0.2,1.9-0.6,2.8-1.2l0.9,0.9c0.8,0.8,2,0.8,2.8,0c0.8-0.8,0.8-2.1,0-2.8l-0.9-0.9c0.5-0.8,0.9-1.8,1.2-2.8H22c1.1,0,2-0.9,2-2S23.1,10,22,10z M12,17c-2.8,0-5-2.2-5-5s2.2-5,5-5s5,2.2,5,5S14.8,17,12,17z"));
        }
        makeSkip(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19.1,11L1.7,1C0.8,0.5,0,0.9,0,2v20c0,1.1,0.8,1.5,1.7,1l17.3-10C20,12.5,20,11.5,19.1,11z"))
                .add(xnode.element("path")
                .set("d", "M22,0c-1.1,0-2,0.9-2,2v20c0,1.1,0.9,2,2,2s2-0.9,2-2V2C24,0.9,23.1,0,22,0z"));
        }
        makeSpeaker(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19,0H5C3.3,0,2,1.3,2,3v18c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V3C22,1.3,20.7,0,19,0z M20,21c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V3c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V21z"))
                .add(xnode.element("path")
                .set("d", "M12,10c-2.8,0-5,2.2-5,5s2.2,5,5,5s5-2.2,5-5S14.8,10,12,10z M12,18c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3S13.7,18,12,18z"))
                .add(xnode.element("path")
                .set("d", "M12,8c1.1,0,2-0.9,2-2s-0.9-2-2-2s-2,0.9-2,2S10.9,8,12,8z"));
        }
        makeStar(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M23.8,9.4c-0.2-0.7-0.9-1.2-1.6-1.4l-5.8-0.8L13.8,2c-0.3-0.7-1-1.1-1.8-1.1S10.5,1.3,10.2,2L7.6,7.2L1.9,8C1.1,8.1,0.5,8.7,0.2,9.4c-0.2,0.7,0,1.5,0.5,2l4.2,4.1l-1,5.7c-0.1,0.8,0.2,1.5,0.8,2c0.6,0.4,1.4,0.5,2.1,0.2l5.2-2.7l5.2,2.7c0.3,0.2,0.6,0.2,0.9,0.2c0.4,0,0.8-0.1,1.2-0.4c0.6-0.5,0.9-1.2,0.8-2l-1-5.7l4.2-4.1C23.8,10.9,24,10.1,23.8,9.4z M17.3,14.4C17.1,14.7,17,15,17,15.3l1.1,6.3c0,0,0,0,0,0l-5.6-3c-0.3-0.2-0.6-0.2-0.9,0l-5.6,3L7,15.3C7,15,6.9,14.7,6.7,14.4L2.1,10l6.3-0.9C8.8,9,9,8.8,9.2,8.5L12,2.8l2.8,5.7C15,8.8,15.2,9,15.6,9.1l6.3,0.9L17.3,14.4z"));
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.IconFactory = IconFactory;
    ;
});
define("build/ui/theme/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TEXT_ACCENT = exports.TEXT_2 = exports.TEXT_1 = exports.TEXT_0 = exports.BACKGROUND_ACCENT = exports.BACKGROUND_4 = exports.BACKGROUND_3 = exports.BACKGROUND_2 = exports.BACKGROUND_1 = exports.BACKGROUND_0 = void 0;
    exports.BACKGROUND_0 = "rgb(0, 0, 0)";
    exports.BACKGROUND_1 = "rgb(15, 15, 15)";
    exports.BACKGROUND_2 = "rgb(31, 31, 31)";
    exports.BACKGROUND_3 = "rgb(47, 47, 47)";
    exports.BACKGROUND_4 = "rgb(63, 63, 63)";
    exports.BACKGROUND_ACCENT = "rgb(223, 79, 127)";
    exports.TEXT_0 = "rgb(255, 255, 255)";
    exports.TEXT_1 = "rgb(159, 159, 159)";
    exports.TEXT_2 = "rgb(95, 95, 95)";
    exports.TEXT_ACCENT = "rgb(255, 255, 255)";
});
define("build/ui/ImageBox", ["require", "exports", "build/observers/index", "build/xnode/index", "build/ui/theme/index", "build/is"], function (require, exports, observables, xnode, theme, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageBoxFactory = void 0;
    const CSS = `
	.image-box {
		background-color: ${theme.BACKGROUND_3};
		border-radius: 4px;
		overflow: hidden;
		position: relative;
		will-change: opacity;
	}

	.image-box--poster {
		padding-bottom: ${3 / 2 * 100}%;
	}

	.image-box--square {
		padding-bottom: ${1 / 1 * 100}%;
	}

	.image-box--video {
		padding-bottom: ${9 / 16 * 100}%;
	}

	.image-box__image {
		height: 100%;
		object-fit: contain;
		position: absolute;
		width: 100%;
	}

	[data-opaque] {
		opacity: 0;
		transition: opacity 1.000s;
	}

	[data-opaque="true"] {
		opacity: 1;
		//filter: blur(32px);
	}
`;
    class ImageBoxFactory {
        token;
        constructor(token) {
            this.token = token;
        }
        for(url, format = "square") {
            let isLoaded = new observables.ObservableClass(false);
            return xnode.element(`div.image-box.image-box--${format}`)
                .add(is.absent(url) ? undefined : xnode.element("img.image-box__image")
                .bind("data-opaque", isLoaded.addObserver((isLoaded) => isLoaded))
                .bind("src", this.token.addObserver((token) => {
                if (is.present(token) && is.present(url)) {
                    return `${url}?token=${token}`;
                }
            }))
                .on("load", () => {
                isLoaded.updateState(true);
            }));
        }
        forPoster(url) {
            return this.for(url, "poster");
        }
        forSquare(url) {
            return this.for(url, "square");
        }
        forVideo(url) {
            return this.for(url, "video");
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.ImageBoxFactory = ImageBoxFactory;
    ;
});
define("build/ui/EntityLink", ["require", "exports", "build/api/schema/objects/index", "build/xnode/index"], function (require, exports, api, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityLinkFactory = void 0;
    const CSS = ``;
    class EntityLinkFactory {
        navigator;
        contextMenuEntity;
        make(url, entity) {
            let onclick = () => {
                this.navigator(url);
            };
            let oncontextmenu = () => {
                this.contextMenuEntity.updateState(undefined);
                this.contextMenuEntity.updateState(entity);
            };
            let timer;
            return xnode.element("a")
                .set("href", url)
                .on("click", onclick)
                .on("contextmenu", oncontextmenu)
                .on("touchstart", () => {
                timer = window.setTimeout(() => {
                    window.clearTimeout(timer);
                    timer = undefined;
                    oncontextmenu();
                }, 500);
            }, false)
                .on("touchcancel", () => {
                window.clearTimeout(timer);
                timer = undefined;
            }, false)
                .on("touchmove", () => {
                window.clearTimeout(timer);
                timer = undefined;
            }, false)
                .on("touchend", () => {
                window.clearTimeout(timer);
                timer = undefined;
            }, false);
        }
        constructor(navigator, contextMenuEntity) {
            this.navigator = navigator;
            this.contextMenuEntity = contextMenuEntity;
        }
        forActor(actor) {
            return this.make(`actors/${actor.actor_id}/`, actor);
        }
        forActors() {
            return this.make(`actors/`);
        }
        forAlbum(album) {
            return this.make(`audio/albums/${album.album_id}/`, album);
        }
        forAlbums() {
            return this.make(`audio/albums/`);
        }
        forArtist(artist) {
            return this.make(`audio/artists/${artist.artist_id}/`, artist);
        }
        forArtists() {
            return this.make(`audio/artists/`);
        }
        forCue(cue) {
            return this.make(`video/cues/${cue.cue_id}/`, cue);
        }
        forDisc(disc) {
            return this.make(`audio/discs/${disc.disc_id}/`, disc);
        }
        forDiscs() {
            return this.make(`audio/discs/`);
        }
        forEpisode(episode) {
            return this.make(`video/episodes/${episode.episode_id}/`, episode);
        }
        forEpisodes() {
            return this.make(`video/episodes/`);
        }
        forGenre(genre) {
            return this.make(`video/genres/${genre.genre_id}/`, genre);
        }
        forGenres() {
            return this.make(`video/genres/`);
        }
        forMovie(movie) {
            return this.make(`video/movies/${movie.movie_id}/`, movie);
        }
        forMovies() {
            return this.make(`video/movies/`);
        }
        forPlaylist(playlist) {
            return this.make(`audio/playlists/${playlist.playlist_id}/`, playlist);
        }
        forPlaylists() {
            return this.make(`audio/playlists/`);
        }
        forSeason(season) {
            return this.make(`video/seasons/${season.season_id}/`, season);
        }
        forSeasons() {
            return this.make(`video/seasons/`);
        }
        forShow(show) {
            return this.make(`video/shows/${show.show_id}/`, show);
        }
        forShows() {
            return this.make(`video/shows/`);
        }
        forTrack(track) {
            return this.make(`audio/tracks/${track.track_id}/`, track);
        }
        forTracks() {
            return this.make(`audio/tracks/`);
        }
        forUser(user) {
            return this.make(`users/${user.user_id}/`, user);
        }
        forUsers() {
            return this.make(`users/`);
        }
        forYear(year) {
            return this.make(`years/${year.year_id}/`, year);
        }
        forYears() {
            return this.make(`years/`);
        }
        forEntity(entity) {
            if (api.ActorBase.is(entity)) {
                return this.forActor(entity);
            }
            if (api.AlbumBase.is(entity)) {
                return this.forAlbum(entity);
            }
            if (api.ArtistBase.is(entity)) {
                return this.forArtist(entity);
            }
            if (api.CueBase.is(entity)) {
                return this.forCue(entity);
            }
            if (api.DiscBase.is(entity)) {
                return this.forDisc(entity);
            }
            if (api.EpisodeBase.is(entity)) {
                return this.forEpisode(entity);
            }
            if (api.GenreBase.is(entity)) {
                return this.forGenre(entity);
            }
            if (api.PlaylistBase.is(entity)) {
                return this.forPlaylist(entity);
            }
            if (api.MovieBase.is(entity)) {
                return this.forMovie(entity);
            }
            if (api.SeasonBase.is(entity)) {
                return this.forSeason(entity);
            }
            if (api.ShowBase.is(entity)) {
                return this.forShow(entity);
            }
            if (api.TrackBase.is(entity)) {
                return this.forTrack(entity);
            }
            if (api.UserBase.is(entity)) {
                return this.forUser(entity);
            }
            if (api.YearBase.is(entity)) {
                return this.forYear(entity);
            }
            throw `Expected code to be unreachable!`;
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityLinkFactory = EntityLinkFactory;
    ;
});
define("build/ui/EntityCard", ["require", "exports", "build/api/schema/objects/index", "build/xnode/index", "build/ui/theme/index", "build/ui/metadata/index", "build/is"], function (require, exports, api, xnode, theme, metadata, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityCardFactory = void 0;
    const CSS = `
	.entity-card {
		align-items: start;
		display: grid;
		gap: 24px;
		grid-auto-rows: min-content;
		grid-template-columns: repeat(auto-fit, minmax(240px, auto));
	}

	.entity-card__artwork {
		position: relative;
	}

	.entity-card__playback {
		position: absolute;
			bottom: 16px;
			right: 16px;
	}

	.entity-card__content {

	}

	.entity-card__pusher {
		width: 100vw;
	}

	.entity-card__metadata {
		display: grid;
		gap: 16px;
	}

	.entity-card__titles {
		display: grid;
		gap: 8px;
	}

	.entity-card__title {
		color: ${theme.TEXT_0};
		font-size: 20px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-card__subtitle {
		color: ${theme.TEXT_1};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-card__tags {
		display: grid;
		gap: 8px;
		grid-auto-columns: minmax(auto, max-content);
		grid-auto-flow: column;
	}

	.entity-card__tag {
		background-color: ${theme.BACKGROUND_3};
		border-radius: 2px;
		color: ${theme.TEXT_1};
		font-size: 12px;
		padding: 4px 8px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-card__tag--accent {
		background-color: ${theme.BACKGROUND_ACCENT};
		color: ${theme.TEXT_ACCENT};
	}

	.entity-card__description {
		color: ${theme.TEXT_1};
		font-size: 16px;
		line-height: 1.25;
		word-break: break-word;
	}

	.entity-card__description--compact {
		display: -webkit-box;
			-webkit-box-orient: vertical;
			-webkit-line-clamp: 3;
		max-height: 60px;
		overflow: hidden;
	}

	.entity-card__footer {
		color: ${theme.TEXT_2};
		font-size: 12px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
    function isHighDefinition(width, height) {
        let is_ultrawide = width * 9 > 16 * height;
        if (is_ultrawide) {
            return width >= 1280;
        }
        else {
            return height >= 720;
        }
    }
    class EntityCardFactory {
        entityTitleFactory;
        entityLinkFactory;
        ImageBox;
        PlaybackButton;
        make(link, image, titles, subtitles, tags, description, footer, options = {}) {
            return link.add(xnode.element("div.entity-card")
                .add(xnode.element("div.entity-card__artwork")
                .add(options.image ?? image)
                .add(xnode.element("div.entity-card__playback")
                .add(options.playbackButton)))
                .add(xnode.element("div.entity-card__content")
                .add(xnode.element("div.entity-card__pusher"))
                .add(xnode.element("div.entity-card__metadata")
                .add(xnode.element("div.entity-card__titles")
                .add(titles.length === 0 ? undefined : xnode.element("div.entity-card__title")
                .add(...xnode.joinarray(titles)))
                .add(subtitles.length === 0 ? undefined : xnode.element("div.entity-card__subtitle")
                .add(...xnode.joinarray(subtitles))))
                .add(tags.length === 0 ? undefined : xnode.element("div.entity-card__tags")
                .add(...tags))
                .add(is.absent(description) ? undefined : xnode.element(options.compactDescription === false ? "div.entity-card__description" : "div.entity-card__description.entity-card__description--compact")
                .add(xnode.text(description)))
                .add(is.absent(footer) ? undefined : xnode.element("div.entity-card__footer")
                .add(xnode.text(footer))))));
        }
        constructor(entityTitleFactory, entityLinkFactory, ImageBox, PlaybackButton) {
            this.entityTitleFactory = entityTitleFactory;
            this.entityLinkFactory = entityLinkFactory;
            this.ImageBox = ImageBox;
            this.PlaybackButton = PlaybackButton;
        }
        forEntity(entity, options = {}) {
            if (api.Actor.is(entity)) {
                return this.forActor(entity, options);
            }
            if (api.Album.is(entity)) {
                return this.forAlbum(entity, options);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity, options);
            }
            if (api.Cue.is(entity)) {
                return this.forCue(entity, options);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity, options);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity, options);
            }
            if (api.Genre.is(entity)) {
                return this.forGenre(entity, options);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity, options);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity, options);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity, options);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity, options);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity, options);
            }
            if (api.User.is(entity)) {
                return this.forUser(entity, options);
            }
            if (api.Year.is(entity)) {
                return this.forYear(entity, options);
            }
            throw `Expected code to be unreachable!`;
        }
        forActor(actor, options = {}) {
            let link = this.entityLinkFactory.forActor(actor);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forActor(actor)
            ];
            let subtitles = [];
            let tags = [
                "Actor"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forAlbum(album, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forAlbum(album);
            let duration_ms = 0;
            for (let disc of album.discs) {
                for (let track of disc.tracks) {
                    duration_ms += track.media.duration_ms;
                }
            }
            let link = this.entityLinkFactory.forAlbum(album);
            let image = this.ImageBox.forSquare(album.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forAlbum(album)
            ];
            let subtitles = album.artists.map((artist) => this.entityTitleFactory.forArtist(artist));
            let tags = [
                "Album",
                is.present(album.year) ? `${album.year}` : undefined,
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            let copyrights = new Array();
            for (let disc of album.discs) {
                for (let track of disc.tracks) {
                    let copyright = track.copyright;
                    if (is.present(copyright)) {
                        copyrights.push(copyright);
                    }
                }
            }
            copyrights = Array.from(new Set(copyrights));
            let footer = copyrights.length > 1 ? "See individual tracks for copyright information." : copyrights.length === 1 ? copyrights[0] : undefined;
            return this.make(link, image, titles, subtitles, tags, undefined, footer, options);
        }
        forArtist(artist, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forArtist(artist);
            let duration_ms = 0;
            for (let album of artist.albums) {
                for (let disc of album.discs) {
                    for (let track of disc.tracks) {
                        duration_ms += track.media.duration_ms;
                    }
                }
            }
            let link = this.entityLinkFactory.forArtist(artist);
            let image = this.ImageBox.forSquare(artist.albums[0]?.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forArtist(artist)
            ];
            let subtitles = new Array();
            let tags = [
                "Artist",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forCue(cue, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forCue(cue);
            options.image = this.ImageBox.forVideo(`/media/gifs/${cue.cue_id}/`);
            if (false) {
            }
            else if (api.Episode.is(cue.media)) {
                return this.forEpisode(cue.media, options);
            }
            else if (api.Movie.is(cue.media)) {
                return this.forMovie(cue.media, options);
            }
            else {
                throw `Expected code to be unreachable!`;
            }
        }
        forDisc(disc, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forDisc(disc);
            let duration_ms = 0;
            for (let track of disc.tracks) {
                duration_ms += track.media.duration_ms;
            }
            let link = this.entityLinkFactory.forDisc(disc);
            let image = this.ImageBox.forSquare(disc.album.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forDisc(disc)
            ];
            let subtitles = [
                this.entityTitleFactory.forAlbum(disc.album)
            ];
            let tags = [
                "Disc",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forEpisode(episode, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forEpisode(episode);
            let duration_ms = 0;
            duration_ms += episode.media.duration_ms;
            let link = this.entityLinkFactory.forEpisode(episode);
            let image = this.ImageBox.forVideo(`/media/stills/${episode.media.file_id}/`);
            let titles = [
                this.entityTitleFactory.forEpisode(episode)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(episode.season.show),
                this.entityTitleFactory.forSeason(episode.season)
            ];
            let tags = [
                "Episode",
                is.present(episode.year) ? `${episode.year}` : undefined,
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            if (isHighDefinition(episode.media.width, episode.media.height)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("HD")));
            }
            if (is.present(episode.last_stream_date)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("\u2713")));
            }
            return this.make(link, image, titles, subtitles, tags, episode.summary, episode.copyright, options);
        }
        forGenre(genre, options = {}) {
            let link = this.entityLinkFactory.forGenre(genre);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forGenre(genre)
            ];
            let subtitles = [];
            let tags = [
                "Genre"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forMovie(movie, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forMovie(movie);
            let duration_ms = 0;
            duration_ms += movie.media.duration_ms;
            let link = this.entityLinkFactory.forMovie(movie);
            let image = this.ImageBox.forPoster(movie.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forMovie(movie)
            ];
            let subtitles = movie.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            let tags = [
                "Movie",
                is.present(movie.year) ? `${movie.year}` : undefined,
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            if (isHighDefinition(movie.media.width, movie.media.height)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("HD")));
            }
            if (is.present(movie.last_stream_date)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("\u2713")));
            }
            return this.make(link, image, titles, subtitles, tags, movie.summary, movie.copyright, options);
        }
        forPlaylist(playlist, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forPlaylist(playlist);
            let duration_ms = 0;
            for (let item of playlist.items) {
                duration_ms += item.track.media.duration_ms;
            }
            let link = this.entityLinkFactory.forPlaylist(playlist);
            let image = this.ImageBox.forSquare(playlist.items[0]?.track.disc.album.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forPlaylist(playlist)
            ];
            let subtitles = [
                this.entityTitleFactory.forUser(playlist.user)
            ];
            let tags = [
                "Playlist",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, playlist.description, undefined, options);
        }
        forSeason(season, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forSeason(season);
            let duration_ms = 0;
            for (let episode of season.episodes) {
                duration_ms += episode.media.duration_ms;
            }
            let link = this.entityLinkFactory.forSeason(season);
            let image = this.ImageBox.forPoster(season.show.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forSeason(season)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(season.show)
            ];
            let tags = [
                "Season",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forShow(show, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forShow(show);
            let duration_ms = 0;
            for (let season of show.seasons) {
                for (let episode of season.episodes) {
                    duration_ms += episode.media.duration_ms;
                }
            }
            let link = this.entityLinkFactory.forShow(show);
            let image = this.ImageBox.forPoster(show.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forShow(show)
            ];
            let subtitles = show.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            let tags = [
                "Show",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, show.summary, undefined, options);
        }
        forTrack(track, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forTrack(track);
            let duration_ms = 0;
            duration_ms += track.media.duration_ms;
            let link = this.entityLinkFactory.forTrack(track);
            let image = this.ImageBox.forSquare(track.disc.album.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forTrack(track)
            ];
            let subtitles = [
                ...track.artists.map((artist) => this.entityTitleFactory.forArtist(artist)),
                this.entityTitleFactory.forAlbum(track.disc.album)
            ];
            let tags = [
                "Track",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, track.copyright, options);
        }
        forUser(user, options = {}) {
            let link = this.entityLinkFactory.forUser(user);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forUser(user)
            ];
            let subtitles = [
                this.entityTitleFactory.forUser(user, {
                    title: user.username
                })
            ];
            let tags = [
                "User"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forYear(year, options = {}) {
            let link = this.entityLinkFactory.forYear(year);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forYear(year)
            ];
            let subtitles = [];
            let tags = [
                "Year"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityCardFactory = EntityCardFactory;
    ;
});
define("build/ui/EntityRow", ["require", "exports", "build/api/schema/objects/index", "build/xnode/index", "build/ui/theme/index"], function (require, exports, api, xnode, theme) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityRowFactory = void 0;
    const CSS = `
	.entity-row {
		align-items: center;
		display: grid;
		gap: 16px;
		grid-template-columns: 60px 1fr;
	}

	.entity-row__artwork {
		position: relative;
	}

	.entity-row__playback {
		position: absolute;
			top: 50%; left: 50%;
		transform: translate(-50%, -50%);
	}

	.entity-row__content {

	}

	.entity-row__metadata {
		display: grid;
		gap: 16px;
	}

	.entity-row__titles {
		display: grid;
		gap: 8px;
	}

	.entity-row__title {
		color: ${theme.TEXT_0};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-row__subtitle {
		color: ${theme.TEXT_1};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
    class EntityRowFactory {
        entityTitleFactory;
        entityLinkFactory;
        ImageBox;
        PlaybackButton;
        make(link, image, playbackButton, titles, subtitles) {
            return link.add(xnode.element("div.entity-row")
                .add(xnode.element("div.entity-row__artwork")
                .add(image)
                .add(xnode.element("div.entity-row__playback")
                .add(playbackButton)))
                .add(xnode.element("div.entity-row__content")
                .add(xnode.element("div.entity-row__metadata")
                .add(xnode.element("div.entity-row__titles")
                .add(titles.length === 0 ? undefined : xnode.element("div.entity-row__title")
                .add(...xnode.joinarray(titles)))
                .add(subtitles.length === 0 ? undefined : xnode.element("div.entity-row__subtitle")
                .add(...xnode.joinarray(subtitles)))))));
        }
        constructor(entityTitleFactory, entityLinkFactory, ImageBox, PlaybackButton) {
            this.entityTitleFactory = entityTitleFactory;
            this.entityLinkFactory = entityLinkFactory;
            this.ImageBox = ImageBox;
            this.PlaybackButton = PlaybackButton;
        }
        forEntity(entity) {
            if (api.Actor.is(entity)) {
                return this.forActor(entity);
            }
            if (api.Album.is(entity)) {
                return this.forAlbum(entity);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity);
            }
            if (api.Cue.is(entity)) {
                return this.forCue(entity);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity);
            }
            if (api.Genre.is(entity)) {
                return this.forGenre(entity);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity);
            }
            if (api.User.is(entity)) {
                return this.forUser(entity);
            }
            if (api.Year.is(entity)) {
                return this.forYear(entity);
            }
            throw `Expected code to be unreachable!`;
        }
        forActor(actor) {
            let link = this.entityLinkFactory.forActor(actor);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forActor(actor)
            ];
            let subtitles = [];
            return this.make(link, image, undefined, titles, subtitles);
        }
        forAlbum(album, playbackButton = this.PlaybackButton.forAlbum(album)) {
            let link = this.entityLinkFactory.forAlbum(album);
            let image = this.ImageBox.forSquare(album.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forAlbum(album)
            ];
            let subtitles = album.artists.map((artist) => this.entityTitleFactory.forArtist(artist));
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forArtist(artist, playbackButton = this.PlaybackButton.forArtist(artist)) {
            let link = this.entityLinkFactory.forArtist(artist);
            let image = this.ImageBox.forSquare(artist.albums[0]?.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forArtist(artist)
            ];
            let subtitles = new Array();
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forCue(cue, playbackButton = this.PlaybackButton.forCue(cue)) {
            if (false) {
            }
            else if (api.Episode.is(cue.media)) {
                return this.forEpisode(cue.media, playbackButton);
            }
            else if (api.Movie.is(cue.media)) {
                return this.forMovie(cue.media, playbackButton);
            }
            else {
                throw `Expected code to be unreachable!`;
            }
        }
        forDisc(disc, playbackButton = this.PlaybackButton.forDisc(disc)) {
            let link = this.entityLinkFactory.forDisc(disc);
            let image = this.ImageBox.forSquare(disc.album.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forDisc(disc)
            ];
            let subtitles = [
                this.entityTitleFactory.forAlbum(disc.album)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forEpisode(episode, playbackButton = this.PlaybackButton.forEpisode(episode)) {
            let link = this.entityLinkFactory.forEpisode(episode);
            let image = this.ImageBox.forSquare(`/media/stills/${episode.media.file_id}/`);
            let titles = [
                this.entityTitleFactory.forEpisode(episode)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(episode.season.show),
                this.entityTitleFactory.forSeason(episode.season)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forGenre(genre) {
            let link = this.entityLinkFactory.forGenre(genre);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forGenre(genre)
            ];
            let subtitles = [];
            return this.make(link, image, undefined, titles, subtitles);
        }
        forMovie(movie, playbackButton = this.PlaybackButton.forMovie(movie)) {
            let link = this.entityLinkFactory.forMovie(movie);
            let image = this.ImageBox.forSquare(movie.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forMovie(movie)
            ];
            let subtitles = movie.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forPlaylist(playlist, playbackButton = this.PlaybackButton.forPlaylist(playlist)) {
            let link = this.entityLinkFactory.forPlaylist(playlist);
            let image = this.ImageBox.forSquare(playlist.items[0]?.track.disc.album.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forPlaylist(playlist)
            ];
            let subtitles = [
                this.entityTitleFactory.forUser(playlist.user)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forSeason(season, playbackButton = this.PlaybackButton.forSeason(season)) {
            let link = this.entityLinkFactory.forSeason(season);
            let image = this.ImageBox.forSquare(season.show.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forSeason(season)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(season.show)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forShow(show, playbackButton = this.PlaybackButton.forShow(show)) {
            let link = this.entityLinkFactory.forShow(show);
            let image = this.ImageBox.forSquare(show.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forShow(show)
            ];
            let subtitles = show.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forTrack(track, playbackButton = this.PlaybackButton.forTrack(track)) {
            let link = this.entityLinkFactory.forTrack(track);
            let image = this.ImageBox.forSquare(track.disc.album.artwork.map((image) => `/api/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forTrack(track)
            ];
            let subtitles = [
                ...track.artists.map((artist) => this.entityTitleFactory.forArtist(artist)),
                this.entityTitleFactory.forAlbum(track.disc.album)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forUser(user) {
            let link = this.entityLinkFactory.forUser(user);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forUser(user)
            ];
            let subtitles = [
                this.entityTitleFactory.forUser(user, {
                    title: user.username
                })
            ];
            return this.make(link, image, undefined, titles, subtitles);
        }
        forYear(year) {
            let link = this.entityLinkFactory.forYear(year);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forYear(year)
            ];
            let subtitles = [];
            return this.make(link, image, undefined, titles, subtitles);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityRowFactory = EntityRowFactory;
    ;
});
define("build/utils", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNextEpisode = exports.formatTimestamp = exports.join = void 0;
    function join(...parameters) {
        return parameters.map((parameter) => {
            return String(parameter);
        }).join("");
    }
    exports.join = join;
    function formatTimestamp(ms) {
        let s = Math.floor(ms / 1000);
        ms -= (s * 1000);
        let m = Math.floor(s / 60);
        s -= (m * 60);
        let h = Math.floor(m / 60);
        m -= (h * 60);
        let fh = join("00", h).slice(-2);
        let fm = join("00", m).slice(-2);
        let fs = join("00", s).slice(-2);
        let fms = join("000", ms).slice(-3);
        return join(fh, ":", fm, ":", fs, ".", fms);
    }
    exports.formatTimestamp = formatTimestamp;
    function getNextEpisode(show) {
        let indices;
        show.seasons.forEach((season, seasonIndex) => {
            season.episodes.forEach((episode, episodeIndex) => {
                if (is.present(episode.last_stream_date)) {
                    if (is.present(indices)) {
                        if (episode.last_stream_date < (show.seasons[indices.seasonIndex].episodes[indices.episodeIndex].last_stream_date ?? 0)) {
                            return;
                        }
                    }
                    indices = {
                        seasonIndex,
                        episodeIndex
                    };
                }
            });
        });
        if (is.present(indices)) {
            indices.episodeIndex += 1;
            if (indices.episodeIndex === show.seasons[indices.seasonIndex].episodes.length) {
                indices.episodeIndex = 0;
                indices.seasonIndex += 1;
                if (indices.seasonIndex === show.seasons.length) {
                    indices.seasonIndex = 0;
                }
            }
        }
        else {
            if (show.seasons.length > 0 && show.seasons[0].episodes.length > 0) {
                indices = {
                    seasonIndex: 0,
                    episodeIndex: 0
                };
            }
        }
        return indices;
    }
    exports.getNextEpisode = getNextEpisode;
});
define("build/ui/PlaybackButton", ["require", "exports", "build/api/schema/objects/index", "build/observers/index", "build/xnode/index", "build/ui/theme/index", "build/is", "build/utils"], function (require, exports, api, observables, xnode, theme, is, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaybackButtonFactory = void 0;
    const CSS = `
	.playback-button {
		background-color: ${theme.TEXT_0};
		border-radius: 50%;
		box-shadow: 0px 0px 8px 4px rgba(0, 0, 0, 0.25);
		cursor: pointer;
		fill: ${theme.BACKGROUND_2};
		padding: 8px;
		transition: transform 0.125s;
	}

	@media (hover: hover) and (pointer: fine) {
		.playback-button:not([data-enabled="false"]):hover {
			transform: scale(1.50);
		}

		.playback-button:active {
			transform: none;
		}
	}
`;
    class PlaybackButtonFactory {
        player;
        iconFactory;
        make(isContext, controller) {
            let isPlaying = observables.computed((isContext, playback) => {
                return isContext && playback;
            }, isContext, this.player.playback);
            return xnode.element("div.playback-button")
                .add(this.iconFactory.makePlay()
                .bind("data-hide", isPlaying.addObserver((isPlaying) => isPlaying)))
                .add(this.iconFactory.makePause()
                .bind("data-hide", isPlaying.addObserver((isPlaying) => !isPlaying)))
                .on("click", () => {
                let pause = controller.pause ?? (() => this.player.pause());
                let play = controller.play ?? (() => this.player.play());
                let resume = controller.resume ?? (() => this.player.resume());
                if (isPlaying.getState()) {
                    pause();
                }
                else {
                    if (isContext.getState()) {
                        resume();
                    }
                    else {
                        play();
                    }
                }
            });
        }
        constructor(player, iconFactory) {
            this.player = player;
            this.iconFactory = iconFactory;
        }
        forEntity(entity) {
            if (api.Album.is(entity)) {
                return this.forAlbum(entity);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity);
            }
            if (api.Cue.is(entity)) {
                return this.forCue(entity);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity);
            }
            throw `Expected code to be unreachable!`;
        }
        forAlbum(album, discIndex, trackIndex) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(discIndex)) {
                    let disc = album.discs[discIndex];
                    if (contextPath[contextPath.length - 2] !== disc.disc_id) {
                        return false;
                    }
                    if (is.present(trackIndex)) {
                        let track = disc.tracks[trackIndex];
                        if (contextPath[contextPath.length - 1] !== track.track_id) {
                            return false;
                        }
                    }
                }
                else {
                    if (contextPath[contextPath.length - 3] !== album.album_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, {
                play: () => this.player.playAlbum(album, discIndex, trackIndex)
            });
        }
        forArtist(artist, albumIndex, discIndex, trackIndex) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(albumIndex)) {
                    let album = artist.albums[albumIndex];
                    if (contextPath[contextPath.length - 3] !== album.album_id) {
                        return false;
                    }
                    if (is.present(discIndex)) {
                        let disc = album.discs[discIndex];
                        if (contextPath[contextPath.length - 2] !== disc.disc_id) {
                            return false;
                        }
                        if (is.present(trackIndex)) {
                            let track = disc.tracks[trackIndex];
                            if (contextPath[contextPath.length - 1] !== track.track_id) {
                                return false;
                            }
                        }
                    }
                }
                else {
                    if (contextPath[contextPath.length - 4] !== artist.artist_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, {
                play: () => this.player.playArtist(artist, albumIndex, discIndex, trackIndex)
            });
        }
        forCue(cue) {
            let start_s = Math.max(0, cue.start_ms / 1000 - 0.25);
            if (false) {
            }
            else if (api.Episode.is(cue.media)) {
                let episode = cue.media;
                let isContext = observables.computed((contextPath) => {
                    if (!is.present(contextPath)) {
                        return false;
                    }
                    if (contextPath[contextPath.length - 1] !== episode.episode_id) {
                        return false;
                    }
                    return true;
                }, this.player.contextPath);
                return this.make(isContext, {
                    play: () => {
                        this.player.playEpisode(episode);
                        this.player.seek(start_s);
                    },
                    resume: () => {
                        this.player.seek(0);
                        this.player.seek(start_s);
                        this.player.resume();
                    }
                });
            }
            else if (api.Movie.is(cue.media)) {
                let movie = cue.media;
                let isContext = observables.computed((contextPath) => {
                    if (!is.present(contextPath)) {
                        return false;
                    }
                    if (contextPath[contextPath.length - 1] !== movie.movie_id) {
                        return false;
                    }
                    return true;
                }, this.player.contextPath);
                return this.make(isContext, {
                    play: () => {
                        this.player.playMovie(movie);
                        this.player.seek(start_s);
                    },
                    resume: () => {
                        this.player.seek(0);
                        this.player.seek(start_s);
                        this.player.resume();
                    }
                });
            }
            throw `Expected code to be unreachable!`;
        }
        forDisc(disc, trackIndex) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(trackIndex)) {
                    let track = disc.tracks[trackIndex];
                    if (contextPath[contextPath.length - 1] !== track.track_id) {
                        return false;
                    }
                }
                else {
                    if (contextPath[contextPath.length - 2] !== disc.disc_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, {
                play: () => this.player.playDisc(disc, trackIndex)
            });
        }
        forEpisode(episode) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (contextPath[contextPath.length - 1] !== episode.episode_id) {
                    return false;
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, {
                play: () => this.player.playEpisode(episode)
            });
        }
        forMovie(movie) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (contextPath[contextPath.length - 1] !== movie.movie_id) {
                    return false;
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, {
                play: () => this.player.playMovie(movie)
            });
        }
        forPlaylist(playlist, trackIndex) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(trackIndex)) {
                    let track = playlist.items[trackIndex].track;
                    if (contextPath[contextPath.length - 1] !== track.track_id) {
                        return false;
                    }
                }
                else {
                    if (contextPath[contextPath.length - 2] !== playlist.playlist_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, {
                play: () => this.player.playPlaylist(playlist, trackIndex)
            });
        }
        forSeason(season, episodeIndex) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(episodeIndex)) {
                    let episode = season.episodes[episodeIndex];
                    if (contextPath[contextPath.length - 1] !== episode.episode_id) {
                        return false;
                    }
                }
                else {
                    if (contextPath[contextPath.length - 2] !== season.season_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, {
                play: () => this.player.playSeason(season, episodeIndex)
            });
        }
        forShow(show, seasonIndex, episodeIndex) {
            if (is.absent(seasonIndex)) {
                let indices = utils.getNextEpisode(show);
                seasonIndex = indices?.seasonIndex;
                episodeIndex = indices?.episodeIndex;
            }
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(seasonIndex)) {
                    let season = show.seasons[seasonIndex];
                    if (contextPath[contextPath.length - 2] !== season.season_id) {
                        return false;
                    }
                    if (is.present(episodeIndex)) {
                        let episode = season.episodes[episodeIndex];
                        if (contextPath[contextPath.length - 1] !== episode.episode_id) {
                            return false;
                        }
                    }
                }
                else {
                    if (contextPath[contextPath.length - 3] !== show.show_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, {
                play: () => this.player.playShow(show, seasonIndex, episodeIndex)
            });
        }
        forTrack(track) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (contextPath[contextPath.length - 1] !== track.track_id) {
                    return false;
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, {
                play: () => this.player.playTrack(track)
            });
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.PlaybackButtonFactory = PlaybackButtonFactory;
    ;
});
define("build/ui/EntityNavLinkFactory", ["require", "exports", "build/is", "build/ui/theme/index", "build/xnode/index"], function (require, exports, is, theme, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityNavLinkFactory = void 0;
    const CSS = `
	.entity-nav-link {
		display: grid;
		gap: 16px;
		grid-auto-flow: column;
		justify-content: center;
	}

	.entity-nav-link__last,
	.entity-nav-link__next {
		display: grid;
		gap: 8px;
		justify-items: center;
	}

	.entity-nav-link__title {
		color: ${theme.TEXT_1};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
    class EntityNavLinkFactory {
        iconFactory;
        entityLinkFactory;
        make(type, last, next) {
            let lastLink = is.absent(last) ? xnode.element("span") : this.entityLinkFactory.forEntity(last);
            let nextLink = is.absent(next) ? xnode.element("span") : this.entityLinkFactory.forEntity(next);
            return xnode.element("div.entity-nav-link")
                .add(lastLink.add(xnode.element("div.entity-nav-link__last")
                .add(xnode.element("div.icon-button")
                .set("data-enabled", `${is.present(last)}`)
                .add(this.iconFactory.makeChevron({ direction: "left" })))
                .add(xnode.element("div.entity-nav-link__title")
                .add(xnode.text(`Last ${type}`)))))
                .add(nextLink.add(xnode.element("div.entity-nav-link__next")
                .add(xnode.element("div.icon-button")
                .set("data-enabled", `${is.present(next)}`)
                .add(this.iconFactory.makeChevron()))
                .add(xnode.element("div.entity-nav-link__title")
                .add(xnode.text(`Next ${type}`)))));
        }
        constructor(iconFactory, entityLinkFactory) {
            this.iconFactory = iconFactory;
            this.entityLinkFactory = entityLinkFactory;
        }
        forEntity(last, next) {
            return this.make("item", last, next);
        }
        forActor(last, next) {
            return this.make("actor", last, next);
        }
        forAlbum(last, next) {
            return this.make("album", last, next);
        }
        forArtist(last, next) {
            return this.make("artist", last, next);
        }
        forCue(last, next) {
            return this.make("cue", last, next);
        }
        forDisc(last, next) {
            return this.make("disc", last, next);
        }
        forEpisode(last, next) {
            return this.make("episode", last, next);
        }
        forGenre(last, next) {
            return this.make("genre", last, next);
        }
        forMovie(last, next) {
            return this.make("movie", last, next);
        }
        forPlaylist(last, next) {
            return this.make("playlist", last, next);
        }
        forSeason(last, next) {
            return this.make("season", last, next);
        }
        forShow(last, next) {
            return this.make("show", last, next);
        }
        forTrack(last, next) {
            return this.make("track", last, next);
        }
        forUser(last, next) {
            return this.make("user", last, next);
        }
        forYear(last, next) {
            return this.make("year", last, next);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityNavLinkFactory = EntityNavLinkFactory;
    ;
});
define("build/jsondb/sorters", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = void 0;
    exports.CombinedSort = {
        of(...rankers) {
            return (one, two) => {
                for (let ranker of rankers) {
                    let rank = ranker(one, two);
                    if (rank !== 0) {
                        return rank;
                    }
                }
                return 0;
            };
        }
    };
    exports.CustomSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return (t ? 1 : 0) - (o ? 1 : 0);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return (o ? 1 : 0) - (t ? 1 : 0);
            };
        }
    };
    exports.LexicalSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t.localeCompare(o);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o.localeCompare(t);
            };
        }
    };
    exports.NumericSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t - o;
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o - t;
            };
        }
    };
});
define("build/jsondb/indices", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/is", "build/jsondb/sorters"], function (require, exports, stdlib, is, sorters) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SearchIndex = exports.getTokens = exports.RecordIndex = exports.CollectionIndex = void 0;
    class CollectionIndex {
        getPrimaryKeysFromIndexedValue;
        lookupRecord;
        getPrimaryKey;
        getIndexedValue;
        constructor(lookupRecord, getPrimaryKey, getIndexedValue) {
            this.getPrimaryKeysFromIndexedValue = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValue = getIndexedValue;
        }
        insert(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.absent(primaryKeys)) {
                primaryKeys = new Set();
                this.getPrimaryKeysFromIndexedValue.set(indexedValue, primaryKeys);
            }
            let primaryKey = this.getPrimaryKey(record);
            primaryKeys.add(primaryKey);
        }
        lookup(key) {
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(key);
            if (is.present(primaryKeys)) {
                return Array.from(primaryKeys).map(this.lookupRecord);
            }
            return new Array();
        }
        remove(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.present(primaryKeys)) {
                let primaryKey = this.getPrimaryKey(record);
                primaryKeys.delete(primaryKey);
                if (primaryKeys.size === 0) {
                    this.getPrimaryKeysFromIndexedValue.delete(indexedValue);
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
        static fromTable(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
    }
    exports.CollectionIndex = CollectionIndex;
    ;
    class RecordIndex {
        getRecordFromKey;
        getKey;
        router;
        insertOrUpdate(next, action = "replace") {
            let key = this.getKey(next);
            let last = this.getRecordFromKey.get(key);
            if (is.present(last)) {
                if (action === "combine") {
                    for (let key in last) {
                        let lastValue = last[key];
                        let nextValue = next[key];
                        if (is.present(lastValue) && is.absent(nextValue)) {
                            next[key] = last[key];
                        }
                    }
                }
                this.getRecordFromKey.set(key, next);
                this.router.route("update", { last, next });
                this.router.route("*", {});
            }
            else {
                this.getRecordFromKey.set(key, next);
                this.router.route("insert", { next });
                this.router.route("*", {});
            }
        }
        constructor(getKey) {
            this.getRecordFromKey = new Map();
            this.getKey = getKey;
            this.router = new stdlib.routing.MessageRouter();
        }
        [Symbol.iterator]() {
            return this.getRecordFromKey.values();
        }
        insert(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        keyof(record) {
            return this.getKey(record);
        }
        length() {
            return this.getRecordFromKey.size;
        }
        lookup(key) {
            let record = this.getRecordFromKey.get(key);
            if (is.absent(record)) {
                throw `Expected "${key}" to match a record!`;
            }
            return record;
        }
        on(type, listener) {
            this.router.addObserver(type, listener);
            if (type === "insert") {
                for (let record of this.getRecordFromKey.values()) {
                    listener({ next: record });
                }
            }
        }
        off(type, listener) {
            this.router.addObserver(type, listener);
        }
        remove(record) {
            let key = this.getKey(record);
            if (this.getRecordFromKey.has(key)) {
                this.getRecordFromKey.delete(key);
                this.router.route("remove", { last: record });
                this.router.route("*", {});
            }
        }
        update(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        static from(records, getKey) {
            let index = new RecordIndex(getKey);
            for (let record of records) {
                index.insert(record);
            }
            return index;
        }
    }
    exports.RecordIndex = RecordIndex;
    ;
    function getTokens(query) {
        let normalized = query;
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFKD");
        normalized = normalized.replace(/[\p{M}]/gu, "");
        return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
    }
    exports.getTokens = getTokens;
    ;
    class SearchIndex {
        getPrimaryKeysFromToken;
        lookupRecord;
        getPrimaryKey;
        getIndexedValues;
        minTokenLength;
        constructor(lookupRecord, getPrimaryKey, getIndexedValues, minTokenLength) {
            this.getPrimaryKeysFromToken = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValues = getIndexedValues;
            this.minTokenLength = minTokenLength;
        }
        insert(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value).filter((token) => token.length >= this.minTokenLength);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.absent(primaryKeys)) {
                        primaryKeys = new Set();
                        this.getPrimaryKeysFromToken.set(token, primaryKeys);
                    }
                    let primaryKey = this.getPrimaryKey(record);
                    primaryKeys.add(primaryKey);
                }
            }
        }
        lookup(query) {
            let tokens = getTokens(query).filter((token) => token.length >= this.minTokenLength);
            let primaryKeySets = tokens.map((token) => {
                return this.getPrimaryKeysFromToken.get(token);
            }).filter(is.present);
            let map = new Map();
            for (let primaryKeys of primaryKeySets) {
                for (let primaryKey of primaryKeys) {
                    let rank = map.get(primaryKey) ?? (0 - tokens.length);
                    map.set(primaryKey, rank + 2);
                }
            }
            return Array.from(map.entries())
                .filter((entry) => entry[1] >= 0)
                .sort(sorters.NumericSort.decreasing((entry) => entry[1]))
                .map((entry) => ({
                id: entry[0],
                rank: entry[1]
            }));
        }
        remove(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.present(primaryKeys)) {
                        let primaryKey = this.getPrimaryKey(record);
                        primaryKeys.delete(primaryKey);
                        if (primaryKeys.size === 0) {
                            this.getPrimaryKeysFromToken.delete(token);
                        }
                    }
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
        static fromTable(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            for (let record of records) {
                index.insert(record);
            }
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
    }
    exports.SearchIndex = SearchIndex;
    ;
});
define("build/jsondb/index", ["require", "exports", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters"], function (require, exports, indices, sorters, indices_1, indices_2, indices_3, sorters_1, sorters_2, sorters_3, sorters_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sorters = exports.indices = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = exports.SearchIndex = exports.RecordIndex = exports.CollectionIndex = exports.sorters = exports.indices = void 0;
    exports.indices = indices;
    exports.sorters = sorters;
    Object.defineProperty(exports, "CollectionIndex", { enumerable: true, get: function () { return indices_1.CollectionIndex; } });
    Object.defineProperty(exports, "RecordIndex", { enumerable: true, get: function () { return indices_2.RecordIndex; } });
    Object.defineProperty(exports, "SearchIndex", { enumerable: true, get: function () { return indices_3.SearchIndex; } });
    Object.defineProperty(exports, "CombinedSort", { enumerable: true, get: function () { return sorters_1.CombinedSort; } });
    Object.defineProperty(exports, "CustomSort", { enumerable: true, get: function () { return sorters_2.CustomSort; } });
    Object.defineProperty(exports, "LexicalSort", { enumerable: true, get: function () { return sorters_3.LexicalSort; } });
    Object.defineProperty(exports, "NumericSort", { enumerable: true, get: function () { return sorters_4.NumericSort; } });
});
define("build/playlists/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.UpdatePlaylistItem = exports.UpdatePlaylistItemResponse = exports.UpdatePlaylistItemRequest = exports.DeletePlaylistItem = exports.DeletePlaylistItemResponse = exports.DeletePlaylistItemRequest = exports.CreatePlaylistItem = exports.CreatePlaylistItemResponse = exports.CreatePlaylistItemRequest = exports.UpdatePlaylist = exports.UpdatePlaylistResponse = exports.UpdatePlaylistRequest = exports.DeletePlaylist = exports.DeletePlaylistResponse = exports.DeletePlaylistRequest = exports.CreatePlaylist = exports.CreatePlaylistResponse = exports.CreatePlaylistRequest = exports.PermissionsResponse = exports.PermissionsRequest = exports.SetToken = void 0;
    exports.SetToken = autoguard.guards.Object.of({
        "token": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.PermissionsRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String
        })
    });
    exports.PermissionsResponse = autoguard.guards.Object.of({
        "permissions": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("read"), autoguard.guards.StringLiteral.of("write"))
    });
    exports.CreatePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "title": autoguard.guards.String,
            "description": autoguard.guards.String
        })
    });
    exports.CreatePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String),
        "playlist_id": autoguard.guards.String
    });
    exports.CreatePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    });
    exports.DeletePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String
        })
    });
    exports.DeletePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.DeletePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    });
    exports.UpdatePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String,
            "title": autoguard.guards.String,
            "description": autoguard.guards.String
        })
    });
    exports.UpdatePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.UpdatePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    });
    exports.CreatePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String,
            "track_id": autoguard.guards.String
        })
    });
    exports.CreatePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String),
        "playlist_item_id": autoguard.guards.String
    });
    exports.CreatePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    });
    exports.DeletePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_item_id": autoguard.guards.String
        })
    });
    exports.DeletePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.DeletePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    });
    exports.UpdatePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_item_id": autoguard.guards.String,
            "number": autoguard.guards.Number
        })
    });
    exports.UpdatePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.UpdatePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "SetToken": autoguard.guards.Reference.of(() => exports.SetToken),
            "PermissionsRequest": autoguard.guards.Reference.of(() => exports.PermissionsRequest),
            "PermissionsResponse": autoguard.guards.Reference.of(() => exports.PermissionsResponse),
            "CreatePlaylistRequest": autoguard.guards.Reference.of(() => exports.CreatePlaylistRequest),
            "CreatePlaylistResponse": autoguard.guards.Reference.of(() => exports.CreatePlaylistResponse),
            "CreatePlaylist": autoguard.guards.Reference.of(() => exports.CreatePlaylist),
            "DeletePlaylistRequest": autoguard.guards.Reference.of(() => exports.DeletePlaylistRequest),
            "DeletePlaylistResponse": autoguard.guards.Reference.of(() => exports.DeletePlaylistResponse),
            "DeletePlaylist": autoguard.guards.Reference.of(() => exports.DeletePlaylist),
            "UpdatePlaylistRequest": autoguard.guards.Reference.of(() => exports.UpdatePlaylistRequest),
            "UpdatePlaylistResponse": autoguard.guards.Reference.of(() => exports.UpdatePlaylistResponse),
            "UpdatePlaylist": autoguard.guards.Reference.of(() => exports.UpdatePlaylist),
            "CreatePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.CreatePlaylistItemRequest),
            "CreatePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.CreatePlaylistItemResponse),
            "CreatePlaylistItem": autoguard.guards.Reference.of(() => exports.CreatePlaylistItem),
            "DeletePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.DeletePlaylistItemRequest),
            "DeletePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.DeletePlaylistItemResponse),
            "DeletePlaylistItem": autoguard.guards.Reference.of(() => exports.DeletePlaylistItem),
            "UpdatePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItemRequest),
            "UpdatePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItemResponse),
            "UpdatePlaylistItem": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItem)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/playlists/client", ["require", "exports", "build/observers/index", "build/jsondb/index", "build/playlists/schema/messages/index", "build/typesockets/client"], function (require, exports, observers, jsondb, messages, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaylistsClient = void 0;
    class PlaylistsClient {
        tsc;
        token = new observers.ObservableClass(undefined);
        online = new observers.ObservableClass(false);
        playlists = new observers.ArrayObservable(new Array());
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.tsc = new typesockets.TypeSocketClient(url, factory, messages.Autoguard.Guards);
            this.tsc.addEventListener("sys", "connect", () => {
                this.online.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.online.updateState(false);
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.online, this.token);
            this.tsc.addEventListener("app", "CreatePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
                let playlist = {
                    ...message.playlist,
                    items: new Array()
                };
                this.playlists.append(new observers.ObservableClass(playlist));
            });
            this.tsc.addEventListener("app", "DeletePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylist", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        playlist.updateState({
                            ...state,
                            ...message.playlist
                        });
                    }
                }
            });
            this.tsc.addEventListener("app", "CreatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        items.push(message.playlist_item);
                        let additions = 1;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "DeletePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        let additions = 0;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let old_index = state.items.findIndex((item) => item.playlist_item_id === message.playlist_item.playlist_item_id);
                        if (old_index >= 0) {
                            let new_index = message.playlist_item.number - 1;
                            if (new_index > old_index) {
                                for (let i = old_index + 1; i < new_index; i++) {
                                    state.items[i].number -= 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            else if (new_index < old_index) {
                                for (let i = new_index; i < old_index; i++) {
                                    state.items[i].number += 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            state.items[new_index] = {
                                ...state.items[new_index],
                                ...message.playlist_item
                            };
                            playlist.updateState({
                                ...state
                            });
                        }
                    }
                }
            });
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        isOnline() {
            return this.online.getState();
        }
        getPermissions(request) {
            return this.tsc.request("PermissionsRequest", "PermissionsResponse", request);
        }
        createPlaylist(request) {
            return this.tsc.request("CreatePlaylistRequest", "CreatePlaylistResponse", request);
        }
        deletePlaylist(request) {
            return this.tsc.request("DeletePlaylistRequest", "DeletePlaylistResponse", request);
        }
        updatePlaylist(request) {
            return this.tsc.request("UpdatePlaylistRequest", "UpdatePlaylistResponse", request);
        }
        createPlaylistItem(request) {
            return this.tsc.request("CreatePlaylistItemRequest", "CreatePlaylistItemResponse", request);
        }
        deletePlaylistItem(request) {
            return this.tsc.request("DeletePlaylistItemRequest", "DeletePlaylistItemResponse", request);
        }
        updatePlaylistItem(request) {
            return this.tsc.request("UpdatePlaylistItemRequest", "UpdatePlaylistItemResponse", request);
        }
        close() {
            this.tsc.close();
        }
        reconnect() {
            this.tsc.reconnect();
        }
    }
    exports.PlaylistsClient = PlaylistsClient;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-client/api", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-autoguard/dist/lib-shared/api"], function (require, exports, shared, api_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (this && this.__exportStar) || function (m, exports) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
                __createBinding(exports, m, p);
    };
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.finalizeRequest = exports.xhr = exports.ServerResponse = void 0;
    __exportStar(api_1, exports);
    class ServerResponse {
        constructor(response, collect) {
            this.response = response;
            this.collect = collect;
        }
        status() {
            let status = this.response.status;
            return status !== null && status !== void 0 ? status : 200;
        }
        headers() {
            let headers = this.response.headers;
            return Object.assign({}, headers);
        }
        payload() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.collectedPayload !== undefined) {
                    return this.collectedPayload;
                }
                let payload = this.response.payload;
                let collectedPayload = (this.collect ? yield shared.api.collectPayload(payload) : payload);
                this.collectedPayload = collectedPayload;
                return collectedPayload;
            });
        }
    }
    exports.ServerResponse = ServerResponse;
    ;
    function xhr(raw, urlPrefix) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            let xhr = new XMLHttpRequest();
            xhr.onerror = reject;
            xhr.onabort = reject;
            xhr.onload = () => {
                let status = xhr.status;
                // Header values for the same header name are joined by he XHR implementation.
                let headers = shared.api.splitHeaders(xhr.getAllResponseHeaders().split("\r\n").slice(0, -1));
                let payload = [new Uint8Array(xhr.response)];
                resolve({
                    status,
                    headers,
                    payload
                });
            };
            let url = urlPrefix !== null && urlPrefix !== void 0 ? urlPrefix : "";
            url += shared.api.combineComponents(raw.components);
            url += shared.api.combineParameters(raw.parameters);
            xhr.open(raw.method, url, true);
            xhr.responseType = "arraybuffer";
            for (let header of raw.headers) {
                // Header values for the same header name are joined by he XHR implementation.
                xhr.setRequestHeader(header[0], header[1]);
            }
            xhr.send(yield shared.api.collectPayload(raw.payload));
        }));
    }
    exports.xhr = xhr;
    ;
    function finalizeRequest(raw, defaultHeaders) {
        let headersToAppend = defaultHeaders.filter((defaultHeader) => {
            let found = raw.headers.find((header) => header[0].toLowerCase() === defaultHeader[0].toLowerCase());
            return found === undefined;
        });
        return Object.assign(Object.assign({}, raw), { headers: [
                ...raw.headers,
                ...headersToAppend
            ] });
    }
    exports.finalizeRequest = finalizeRequest;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-client/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-autoguard/dist/lib-client/api"], function (require, exports, lib_shared_1, api) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.api = void 0;
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (this && this.__exportStar) || function (m, exports) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
                __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.api = void 0;
    __exportStar(lib_shared_1, exports);
    exports.api = api;
});
define("build/api/schema/api/client", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-client/index", "build/api/schema/api/index"], function (require, exports, autoguard, shared) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeClient = void 0;
    const makeClient = (clientOptions) => ({
        "POST:/auth/": async (request) => {
            let guard = shared.Autoguard.Requests["POST:/auth/"];
            guard.as(request, "request");
            let method = "POST";
            let components = new Array();
            components.push("auth");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...[], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeHeaderPairs("x-circus-username", [request.headers?.["x-circus-username"]], true));
            headers.push(...autoguard.api.encodeHeaderPairs("x-circus-password", [request.headers?.["x-circus-password"]], true));
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/octet-stream"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers["x-circus-token"] = autoguard.api.decodeHeaderValue(raw.headers, "x-circus-token", true);
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = raw.payload;
                let guard = shared.Autoguard.Responses["POST:/auth/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, true);
            }
        },
        "POST:/users/": async (request) => {
            let guard = shared.Autoguard.Requests["POST:/users/"];
            guard.as(request, "request");
            let method = "POST";
            let components = new Array();
            components.push("users");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...[], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = autoguard.api.serializePayload(request.payload);
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["POST:/users/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("cues", [request.options?.["cues"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/actors/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/actors/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("actors");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/actors/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/actors/<actor_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/actors/<actor_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("actors");
            components.push(...autoguard.api.encodeComponents([request.options?.["actor_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["actor_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/actors/<actor_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/actors/<actor_id>/movies/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/actors/<actor_id>/movies/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("actors");
            components.push(...autoguard.api.encodeComponents([request.options?.["actor_id"]], true));
            components.push("movies");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["actor_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/actors/<actor_id>/movies/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/actors/<actor_id>/shows/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/actors/<actor_id>/shows/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("actors");
            components.push(...autoguard.api.encodeComponents([request.options?.["actor_id"]], true));
            components.push("shows");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["actor_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/actors/<actor_id>/shows/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/albums/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/albums/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("albums");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/albums/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getNewAlbums": async (request) => {
            let guard = shared.Autoguard.Requests["getNewAlbums"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("albums");
            components.push("new");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...[], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["getNewAlbums"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/albums/<album_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/albums/<album_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("albums");
            components.push(...autoguard.api.encodeComponents([request.options?.["album_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["album_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/albums/<album_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/artists/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/artists/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("artists");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/artists/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/artists/<artist_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/artists/<artist_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("artists");
            components.push(...autoguard.api.encodeComponents([request.options?.["artist_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["artist_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/artists/<artist_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/discs/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/discs/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("discs");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/discs/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/discs/<disc_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/discs/<disc_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("discs");
            components.push(...autoguard.api.encodeComponents([request.options?.["disc_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["disc_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/discs/<disc_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/episodes/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/episodes/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("episodes");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/episodes/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/episodes/<episode_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/episodes/<episode_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("episodes");
            components.push(...autoguard.api.encodeComponents([request.options?.["episode_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["episode_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/episodes/<episode_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/genres/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/genres/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("genres");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/genres/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/genres/<genre_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/genres/<genre_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("genres");
            components.push(...autoguard.api.encodeComponents([request.options?.["genre_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["genre_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/genres/<genre_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/genres/<genre_id>/movies/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/genres/<genre_id>/movies/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("genres");
            components.push(...autoguard.api.encodeComponents([request.options?.["genre_id"]], true));
            components.push("movies");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["genre_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/genres/<genre_id>/movies/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/genres/<genre_id>/shows/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/genres/<genre_id>/shows/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("genres");
            components.push(...autoguard.api.encodeComponents([request.options?.["genre_id"]], true));
            components.push("shows");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["genre_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/genres/<genre_id>/shows/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/movies/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/movies/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("movies");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/movies/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getNewMovies": async (request) => {
            let guard = shared.Autoguard.Requests["getNewMovies"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("movies");
            components.push("new");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...[], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["getNewMovies"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/movies/<movie_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/movies/<movie_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("movies");
            components.push(...autoguard.api.encodeComponents([request.options?.["movie_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["movie_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/movies/<movie_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/movies/<movie_id>/suggestions/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/movies/<movie_id>/suggestions/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("movies");
            components.push(...autoguard.api.encodeComponents([request.options?.["movie_id"]], true));
            components.push("suggestions");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["movie_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/movies/<movie_id>/suggestions/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/playlists/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/playlists/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("playlists");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/playlists/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/playlists/<playlist_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/playlists/<playlist_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("playlists");
            components.push(...autoguard.api.encodeComponents([request.options?.["playlist_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["playlist_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/playlists/<playlist_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/seasons/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/seasons/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("seasons");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/seasons/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/seasons/<season_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/seasons/<season_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("seasons");
            components.push(...autoguard.api.encodeComponents([request.options?.["season_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["season_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/seasons/<season_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/shows/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/shows/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("shows");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/shows/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/shows/<show_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/shows/<show_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("shows");
            components.push(...autoguard.api.encodeComponents([request.options?.["show_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["show_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/shows/<show_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/tracks/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/tracks/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("tracks");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/tracks/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/tracks/<track_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/tracks/<track_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("tracks");
            components.push(...autoguard.api.encodeComponents([request.options?.["track_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["track_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/tracks/<track_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/tracks/<track_id>/playlists/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/tracks/<track_id>/playlists/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("tracks");
            components.push(...autoguard.api.encodeComponents([request.options?.["track_id"]], true));
            components.push("playlists");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["track_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/tracks/<track_id>/playlists/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/users/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/users/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("users");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/users/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/users/<user_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/users/<user_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("users");
            components.push(...autoguard.api.encodeComponents([request.options?.["user_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["user_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/users/<user_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/users/<user_id>/albums/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/users/<user_id>/albums/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("users");
            components.push(...autoguard.api.encodeComponents([request.options?.["user_id"]], true));
            components.push("albums");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["user_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/users/<user_id>/albums/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/users/<user_id>/playlists/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/users/<user_id>/playlists/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("users");
            components.push(...autoguard.api.encodeComponents([request.options?.["user_id"]], true));
            components.push("playlists");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["user_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/users/<user_id>/playlists/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/users/<user_id>/shows/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/users/<user_id>/shows/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("users");
            components.push(...autoguard.api.encodeComponents([request.options?.["user_id"]], true));
            components.push("shows");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["user_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/users/<user_id>/shows/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/years/<query>": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/years/<query>"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("years");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/years/<query>"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/years/<year_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/years/<year_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("years");
            components.push(...autoguard.api.encodeComponents([request.options?.["year_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["year_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/years/<year_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/years/<year_id>/albums/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/years/<year_id>/albums/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("years");
            components.push(...autoguard.api.encodeComponents([request.options?.["year_id"]], true));
            components.push("albums");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["year_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/years/<year_id>/albums/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/years/<year_id>/movies/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/years/<year_id>/movies/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("years");
            components.push(...autoguard.api.encodeComponents([request.options?.["year_id"]], true));
            components.push("movies");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["year_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/years/<year_id>/movies/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/files/<file_id>/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/files/<file_id>/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("files");
            components.push(...autoguard.api.encodeComponents([request.options?.["file_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["file_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/octet-stream"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = raw.payload;
                let guard = shared.Autoguard.Responses["GET:/files/<file_id>/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, true);
            }
        },
        "GET:/statistics/": async (request) => {
            let guard = shared.Autoguard.Requests["GET:/statistics/"];
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("statistics");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...[], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions?.urlPrefix);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = shared.Autoguard.Responses["GET:/statistics/"];
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
    });
    exports.makeClient = makeClient;
});
define("build/client/client", ["require", "exports", "build/languages", "build/client/browserMediaSession", "build/observers/index", "build/player/client", "build/is", "build/api/schema/objects/index", "build/xnode/index", "build/ui/metadata/index", "build/api/schema/index", "build/ui/EntityTitleFactory", "build/ui/Grid", "build/ui/CarouselFactory", "build/ui/Icon", "build/ui/ImageBox", "build/ui/EntityLink", "build/ui/EntityCard", "build/ui/EntityRow", "build/ui/PlaybackButton", "build/ui/EntityNavLinkFactory", "build/playlists/client", "build/api/schema/api/client", "build/utils"], function (require, exports, languages, session, observers_1, client, is, objects_1, xml, metadata_1, apischema, EntityTitleFactory_1, Grid_1, CarouselFactory_1, Icon_1, ImageBox_1, EntityLink_1, EntityCard_1, EntityRow_1, PlaybackButton_1, EntityNavLinkFactory_1, client_1, apiv2, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    const apiclient = apiv2.makeClient({ urlPrefix: "/api" });
    function makeUrl(tail) {
        let path = `/sockets/${tail}`;
        let protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        let host = window.location.host;
        return `${protocol}//${host}${path}`;
    }
    let player = new client.ContextClient(makeUrl(`context/?type=browser&name=Client`));
    let playlists = new client_1.PlaylistsClient(makeUrl(`playlists/`));
    window.addEventListener("focus", () => {
        if (!player.isOnline.getState()) {
            player.reconnect();
        }
        if (!playlists.isOnline()) {
            playlists.reconnect();
        }
        //req<{}, {}>("/discover", {}, () => {});
    });
    function hideModalMenu() {
        showDevices.updateState(false);
        showContextMenu.updateState(false);
        showPage.updateState(false);
        modalPageElements.update([]);
        showModal.updateState(undefined);
    }
    window.addEventListener("keydown", (event) => {
        if (event.code === "Space") {
            if (event.target instanceof HTMLInputElement) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            player.toggle();
        }
        else if (event.code === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            hideModalMenu();
        }
    });
    let lastVideo = document.createElement("video");
    let currentVideo = document.createElement("video");
    let nextVideo = document.createElement("video");
    currentVideo.addEventListener("ended", () => {
        player.next();
    });
    let isLoading = new observers_1.ObservableClass(true);
    currentVideo.addEventListener("loadeddata", () => {
        isLoading.updateState(false);
    });
    currentVideo.addEventListener("playing", () => {
        player.isCurrentEntryVideo.updateState(currentVideo.videoWidth > 0 && currentVideo.videoHeight > 0);
    });
    {
        let computer = async () => {
            if (!isLoading.getState()) {
                currentVideo.currentTime = player.progress.getState() ?? 0;
            }
        };
        player.progress.addObserver(computer);
        isLoading.addObserver(computer);
    }
    {
        let computer = async () => {
            if (!isLoading.getState()) {
                if (player.playback.getState()) {
                    try {
                        await currentVideo.play();
                    }
                    catch (error) { }
                }
                else {
                    currentVideo.pause();
                }
            }
        };
        player.playback.addObserver(computer);
        isLoading.addObserver(computer);
    }
    {
        let computer = () => {
            let canPlayLast = player.canPlayLast.getState();
            let canPlayCurrent = player.canPlayCurrent.getState();
            let canPlayNext = player.canPlayNext.getState();
            session.setHandlers({
                play: canPlayCurrent ? player.resume.bind(player) : undefined,
                pause: canPlayCurrent ? player.pause.bind(player) : undefined,
                previoustrack: canPlayLast ? player.last.bind(player) : undefined,
                nexttrack: canPlayNext ? player.next.bind(player) : undefined
            });
        };
        player.canPlayLast.addObserver(computer);
        player.canPlayCurrent.addObserver(computer);
        player.canPlayNext.addObserver(computer);
    }
    let mediaPlayerTitle = new observers_1.ObservableClass("");
    let mediaPlayerSubtitle = new observers_1.ObservableClass("");
    player.currentEntry.addObserver((currentEntry) => {
        if (is.present(currentEntry)) {
            if (objects_1.Episode.is(currentEntry)) {
                let episode = currentEntry;
                let season = episode.season;
                let show = season.show;
                mediaPlayerTitle.updateState(episode.title);
                mediaPlayerSubtitle.updateState([show.title, `Season ${episode.season.number}`].join(" \u00b7 "));
                session.setMetadata({
                    title: episode.title
                });
            }
            else if (objects_1.Movie.is(currentEntry)) {
                let movie = currentEntry;
                mediaPlayerTitle.updateState(movie.title);
                mediaPlayerSubtitle.updateState(movie.genres.map((genre) => genre.title).join(" \u00b7 "));
                session.setMetadata({
                    title: movie.title,
                    artwork: movie.artwork.map((image) => ({
                        src: `/api/files/${image.file_id}/?token=${token}`,
                        sizes: `${image.width}x${image.height}`,
                        type: image.mime
                    }))
                });
            }
            else if (objects_1.Track.is(currentEntry)) {
                let track = currentEntry;
                let disc = track.disc;
                let album = disc.album;
                mediaPlayerTitle.updateState(track.title);
                mediaPlayerSubtitle.updateState([...track.artists.map((artist) => artist.title), track.disc.album.title].join(" \u00b7 "));
                session.setMetadata({
                    title: track.title,
                    artist: track.artists.map((artist) => artist.title).join(" \u00b7 "),
                    album: album.title,
                    artwork: album.artwork.map((image) => ({
                        src: `/api/files/${image.file_id}/?token=${token}`,
                        sizes: `${image.width}x${image.height}`,
                        type: image.mime
                    }))
                });
            }
            else {
                throw `Expected code to be unreachable!`;
            }
        }
        else {
            mediaPlayerTitle.updateState("");
            mediaPlayerSubtitle.updateState("");
            session.setMetadata({});
        }
    });
    {
        let computer = () => {
            let lastLocalEntry = player.lastLocalEntry.getState();
            let token = player.token.getState();
            if (is.absent(lastLocalEntry) || is.absent(token)) {
                lastVideo.src = ``;
                return;
            }
            else {
                lastVideo.src = `/api/files/${lastLocalEntry.media.file_id}/?token=${token}`;
            }
        };
        player.lastLocalEntry.addObserver(computer);
        player.token.addObserver(computer);
    }
    {
        let computer = () => {
            isLoading.updateState(true);
            let currentLocalEntry = player.currentLocalEntry.getState();
            let token = player.token.getState();
            while (is.present(currentVideo.lastChild)) {
                currentVideo.removeChild(currentVideo.lastChild);
            }
            if (is.absent(currentLocalEntry) || is.absent(token)) {
                currentVideo.src = ``;
                return;
            }
            else {
                currentVideo.src = `/api/files/${currentLocalEntry.media.file_id}/?token=${token}`;
                currentVideo.load();
            }
            if (objects_1.Movie.is(currentLocalEntry) || objects_1.Episode.is(currentLocalEntry)) {
                let subtitles = currentLocalEntry.subtitles;
                let defaultSubtitle = subtitles.find((subtitle) => subtitle.language === "swe") ?? subtitles.find((subtitle) => subtitle.language === "eng") ?? subtitles.find((subtitle) => true);
                for (let subtitle of subtitles) {
                    let element = document.createElement("track");
                    element.src = `/api/files/${subtitle.file_id}/?token=${token}`;
                    if (is.present(subtitle.language)) {
                        let language = languages.db[subtitle.language];
                        if (is.present(language)) {
                            element.label = language.title;
                            element.srclang = language.iso639_1;
                            element.kind = "subtitles";
                        }
                    }
                    if (subtitle === defaultSubtitle) {
                        element.setAttribute("default", "");
                    }
                    currentVideo.appendChild(element);
                }
            }
        };
        player.currentLocalEntry.addObserver(computer);
        player.token.addObserver(computer);
    }
    {
        let computer = () => {
            let nextLocalEntry = player.nextLocalEntry.getState();
            let token = player.token.getState();
            if (is.absent(nextLocalEntry) || is.absent(token)) {
                lastVideo.src = ``;
                return;
            }
            else {
                lastVideo.src = `/api/files/${nextLocalEntry.media.file_id}/?token=${token}`;
            }
        };
        player.nextLocalEntry.addObserver(computer);
        player.token.addObserver(computer);
    }
    const savedToken = new observers_1.ObservableClass(localStorage.getItem("token") ?? undefined);
    const verifiedToken = new observers_1.ObservableClass(undefined);
    savedToken.addObserver((savedToken) => {
        if (is.present(savedToken)) {
            localStorage.setItem("token", savedToken);
        }
        else {
            localStorage.removeItem("token");
        }
    });
    savedToken.addObserver(async (savedToken) => {
        if (is.present(savedToken)) {
            try {
                let response = await apiclient["GET:/users/<user_id>/"]({
                    options: {
                        user_id: "",
                        token: savedToken
                    }
                });
                if (response.status() === 200) {
                    verifiedToken.updateState(savedToken);
                    return;
                }
            }
            catch (error) { }
        }
        verifiedToken.updateState(undefined);
    });
    const contextMenuEntity = new observers_1.ObservableClass(undefined);
    const Grid = new Grid_1.GridFactory();
    document.head.appendChild(Grid_1.GridFactory.makeStyle().render());
    const Icon = new Icon_1.IconFactory();
    document.head.appendChild(Icon_1.IconFactory.makeStyle().render());
    const carouselFactory = new CarouselFactory_1.CarouselFactory(Icon);
    document.head.appendChild(CarouselFactory_1.CarouselFactory.makeStyle().render());
    const PlaybackButton = new PlaybackButton_1.PlaybackButtonFactory(player, Icon);
    document.head.appendChild(PlaybackButton_1.PlaybackButtonFactory.makeStyle().render());
    const ImageBox = new ImageBox_1.ImageBoxFactory(verifiedToken);
    document.head.appendChild(ImageBox_1.ImageBoxFactory.makeStyle().render());
    const EntityLink = new EntityLink_1.EntityLinkFactory(navigate, contextMenuEntity);
    document.head.appendChild(EntityLink_1.EntityLinkFactory.makeStyle().render());
    const entityTitleFactory = new EntityTitleFactory_1.EntityTitleFactory(EntityLink);
    document.head.appendChild(EntityTitleFactory_1.EntityTitleFactory.makeStyle().render());
    const EntityCard = new EntityCard_1.EntityCardFactory(entityTitleFactory, EntityLink, ImageBox, PlaybackButton);
    document.head.appendChild(EntityCard_1.EntityCardFactory.makeStyle().render());
    const EntityRow = new EntityRow_1.EntityRowFactory(entityTitleFactory, EntityLink, ImageBox, PlaybackButton);
    document.head.appendChild(EntityRow_1.EntityRowFactory.makeStyle().render());
    const entityNavLinkFactory = new EntityNavLinkFactory_1.EntityNavLinkFactory(Icon, EntityLink);
    document.head.appendChild(EntityNavLinkFactory_1.EntityNavLinkFactory.makeStyle().render());
    const showContextMenu = new observers_1.ObservableClass(false);
    const contextMenuItems = new observers_1.ArrayObservable(new Array());
    contextMenuEntity.addObserver(async (contextMenuEntity) => {
        contextMenuItems.update([]);
        if (apischema.objects.Entity.is(contextMenuEntity)) {
            contextMenuItems.append(xml.element("div")
                .set("style", "align-items: center; display: grid; gap: 16px; grid-template-columns: 1fr min-content;")
                .add(renderTextHeader(xml.text("Select action")))
                .add(makeButton()
                .on("click", () => {
                showContextMenu.updateState(false);
            })
                .add(Icon.makeCross())));
            contextMenuItems.append(EntityRow.forEntity(contextMenuEntity));
        }
        if (apischema.objects.Track.is(contextMenuEntity)) {
            let title = new observers_1.ObservableClass("");
            let canCreate = observers_1.computed((title) => {
                if (title === "") {
                    return false;
                }
                return true;
            }, title);
            let doCreate = async () => {
                if (canCreate.getState()) {
                    let playlist = await playlists.createPlaylist({
                        playlist: {
                            title: title.getState(),
                            description: ""
                        }
                    });
                    if (playlist.errors.length > 0) {
                        return;
                    }
                    let playlist_item = await playlists.createPlaylistItem({
                        playlist_item: {
                            playlist_id: playlist.playlist_id,
                            track_id: contextMenuEntity.track_id
                        }
                    });
                    if (playlist_item.errors.length > 0) {
                        return;
                    }
                    showContextMenu.updateState(false);
                }
            };
            contextMenuItems.append(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .add(xml.element("div")
                .set("style", "position: relative;")
                .add(xml.element("input")
                .bind2("value", title)
                .set("type", "text")
                .set("spellcheck", "false")
                .set("placeholder", "Title...")
                .on("keyup", async (event) => {
                if (event.code === "Enter") {
                    event.target.blur();
                    await doCreate();
                }
            }))
                .add(Icon.makeStar()
                .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
                .add(xml.element("button")
                .bind2("data-enabled", observers_1.computed((canCreate) => "" + canCreate, canCreate))
                .add(xml.text("New playlist"))
                .on("click", async () => {
                await doCreate();
            })));
            contextMenuItems.append(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .bind("data-hide", playlists.playlists.compute((playlists) => playlists.length === 0))
                .repeat(playlists.playlists, (playlist) => xml.element("button")
                .add(xml.text(`Add to "${playlist.getState().title}"`))
                .on("click", async () => {
                let playlist_item = await playlists.createPlaylistItem({
                    playlist_item: {
                        playlist_id: playlist.getState().playlist_id,
                        track_id: contextMenuEntity.track_id
                    }
                });
                if (playlist_item.errors.length > 0) {
                    return;
                }
                showContextMenu.updateState(false);
            })));
        }
        else if (apischema.objects.Playlist.is(contextMenuEntity)) {
            let hasWritePermission = (await playlists.getPermissions({
                playlist: {
                    playlist_id: contextMenuEntity.playlist_id
                }
            })).permissions === "write";
            let title = new observers_1.ObservableClass(contextMenuEntity.title);
            let description = new observers_1.ObservableClass(contextMenuEntity.description);
            let canUpdate = observers_1.computed((title, description) => {
                if (title === "") {
                    return false;
                }
                return true;
            }, title, description);
            let doUpdate = async () => {
                if (canUpdate.getState()) {
                    let playlist = await playlists.updatePlaylist({
                        playlist: {
                            playlist_id: contextMenuEntity.playlist_id,
                            title: title.getState(),
                            description: description.getState()
                        }
                    });
                    if (playlist.errors.length > 0) {
                        return;
                    }
                    showContextMenu.updateState(false);
                }
            };
            contextMenuItems.append(xml.element("div")
                .set("data-hide", `${!hasWritePermission}`)
                .set("style", "display: grid; gap: 16px;")
                .add(xml.element("div")
                .set("style", "position: relative;")
                .add(xml.element("input")
                .bind2("value", title)
                .set("type", "text")
                .set("spellcheck", "false")
                .set("placeholder", "Title..."))
                .add(Icon.makeStar()
                .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
                .add(xml.element("div")
                .set("style", "position: relative;")
                .add(xml.element("input")
                .bind2("value", description)
                .set("type", "text")
                .set("spellcheck", "false")
                .set("placeholder", "Description..."))
                .add(Icon.makeStar()
                .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
                .add(xml.element("button")
                .bind2("data-enabled", observers_1.computed((canUpdate) => "" + canUpdate, canUpdate))
                .add(xml.text("Update playlist"))
                .on("click", async () => {
                await doUpdate();
            })));
            contextMenuItems.append(xml.element("button")
                .add(xml.text("Delete playlist"))
                .on("click", async () => {
                let response = await playlists.deletePlaylist({
                    playlist: {
                        playlist_id: contextMenuEntity.playlist_id
                    }
                });
                if (response.errors.length > 0) {
                    return;
                }
                showContextMenu.updateState(false);
            }));
        }
        showContextMenu.updateState(contextMenuItems.getState().length > 0);
    });
    const ACCENT_COLOR = "rgb(223, 79, 127)";
    let style = document.createElement('style');
    style.innerText = `
	::-webkit-scrollbar {
		background-color: transparent;
		height: 8px;
		width: 8px;
	}

	::-webkit-scrollbar-corner {
		background-color: transparent;
	}

	::-webkit-scrollbar-thumb {
		background-color: rgba(255, 255, 255, 0.125);
		border-radius: 4px;
	}

	* {
		border: none;
		font-size: 0px;
		margin: 0px;
		line-height: 1;
		outline: none;
		padding: 0px;
	}

	a,
	span {
		color: inherit;
		font-size: inherit;
	}

	a {
		text-decoration: none;
		transition: color 0.125s;
	}

	@media (hover: hover) and (pointer: fine) {
		a:hover {
			color: rgb(255, 255, 255);
		}
	}

	html {
		height: 100%;
	}

	body {
		height: 100%;
	}

	.page-header {
		align-items: center;
		display: grid;
		gap: 16px;
		grid-template-columns: 1fr auto;
	}

	.page-header__title {
		color: rgb(255, 255, 255);
		cursor: pointer;
		font-family: "Pacifico", cursive;
		font-size: 32px;
		transform-origin: left;
		transition: transform 0.125s;
		white-space: nowrap;
	}

	.page-header__controls {
		display: grid;
		gap: 8px;
		grid-auto-columns: minmax(auto, min-content);
		grid-auto-flow: column;
	}

	@media (hover: hover) and (pointer: fine) {
		.page-header__title:hover {
			transform: scale(1.25);
		}
	}

	[data-hide="true"] {
		display: none !important;
	}

	body {
		background-color: ${ACCENT_COLOR};
		color: rgb(255, 255, 255);
		font-family: "Nunito", sans-serif;
		overflow: hidden;
		touch-callout: none;
			-webkit-touch-callout: none;
			-moz-touch-callout: none;
			-ms-touch-callout: none;
			-o-touch-callout: none;
		user-select: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			-o-user-select: none;
	}

	body ::selection {
		background-color: ${ACCENT_COLOR};
		color: rgb(255, 255, 255);
	}

	button {
		background-color: ${ACCENT_COLOR};
		border-radius: 64px;
		color: rgb(255, 255, 255);
		cursor: pointer;
		font-size: 16px;
		overflow: hidden;
		padding: 8px 16px;
		text-overflow: ellipsis;
		transition: background-color 0.125s, color 0.125s;
		white-space: nowrap;
	}

	button[data-enabled="false"] {
		background-color: rgb(79, 79, 79);
		color: rgb(159, 159, 159);
		cursor: default;
	}

	@media (hover: hover) and (pointer: fine) {
		button:not([data-enabled="false"]):hover {
			background-color: rgb(255, 255, 255);
			color: rgb(31, 31, 31);
		}

		button:active {
			transform: none;
		}
	}

	input {
		background-color: rgb(47, 47, 47);
		border-radius: 64px;
		box-sizing: border-box;
		color: rgb(255, 255, 255);
		font-size: 16px;
		padding: 8px 16px 8px 32px;
		width: 100%;
	}















	.slider-widget {
		padding: 4px;
	}

	.slider-widget__indicator {
		padding: 4px;
		border-radius: 4px;
		background-color: rgb(31, 31, 31);
	}

	.slider-widget__knob-wrapper {
		position: relative;
	}

	.slider-widget__knob {
		box-shadow: 0px 0px 8px 0px rgba(0, 0, 0, 0.5);
		width: 16px;
		height: 16px;
		border-radius: 50%;
		background-color: rgb(255, 255, 255);
		position: absolute;
		top: 0%;
		left: 0%;
		margin-top: -8px;
		margin-left: -8px;
	}



























	.content {
		box-sizing: border-box;
		display: grid;
		gap: 48px;
		margin: 0px auto;
		max-width: 1080px;
		padding: 24px;
	}

	.content--narrow {
		max-width: 480px;
	}












	.text-header {
		color: rgb(255, 255, 255);
		font-size: 20px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.text-paragraph {
		color: rgb(159, 159, 159);
		font-size: 16px;
		line-height: 1.25;
		word-break: break-word;
	}












































	.login-modal {
		display: grid;
		gap: 64px;
	}

	.login-modal__form {
		display: grid;
		gap: 16px;
	}








	.modal-container {
		background-color: rgb(31, 31, 31);
		box-shadow: 0px 0px 8px 4px rgb(0, 0, 0, 0.25);
		height: 100%;
		position: absolute; bottom: 0px; right: 0px;
		width: min(320px, 100%);
		z-index: 1;
	}

	.modal-container[data-hide] {
		display: initial!important;
	}

	.modal-container[data-hide=false] {
		transform: none;
		transition: transform 0.5s;
	}

	.modal-container[data-hide=true] {
		transform: translate(100%, 0%);
		transition: none;
	}









	.device-selector {
		display: grid;
		gap: 64px;
	}

	.device-selector__devices {
		display: grid;
		gap: 16px;
	}

	.device-selector__device {
		align-items: center;
		cursor: pointer;
		display: grid;
		gap: 16px;
		grid-template-columns: min-content 1fr;
	}

	.device-selector__device-info {
		display: grid;
		gap: 8px;
	}

	.device-selector__device-name {
		color: rgb(255, 255, 255);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.device-selector__device-type {
		color: rgb(159, 159, 159);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}














	.media-player {
		display: grid;
		gap: 16px;
	}

	.media-player__top {
		align-items: center;
		display: grid;
		gap: 16px;
		grid-template-columns: 1fr min-content;
	}

	.media-player__metadata {
		cursor: pointer;
		display: grid;
		gap: 8px;
	}

	.media-player__title {
		color: rgb(255, 255, 255);
		font-size: 16px;
		height: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.media-player__subtitle {
		color: rgb(159, 159, 159);
		font-size: 16px;
		height: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.media-player__controls {
		display: grid;
		gap: 8px;
		grid-auto-columns: minmax(auto, min-content);
		grid-auto-flow: column;
	}

	.media-player__bottom {

	}

	.media-player__progress {
		cursor: pointer;
		padding: 8px 0px;
	}

	.media-player__progress-container {
		background-color: rgb(31, 31, 31);
		border-radius: 4px;
		height: 8px;
		overflow: hidden;
		position: relative;
		z-index: 1;
	}

	.media-player__progress-track {
		background-color: ${ACCENT_COLOR};
		height: 100%;
		width: 100%;
		position: absolute;
		transform-origin: left;
		z-index: 0;
	}






	.icon-button {
		background-color: rgb(255, 255, 255);
		border-radius: 50%;
		box-shadow: 0px 0px 8px 4px rgba(0, 0, 0, 0.25);
		cursor: pointer;
		fill: rgb(31, 31, 31);
		padding: 8px;
		transition: background-color 0.125s, transform 0.125s;
	}

	.icon-button[data-enabled="false"] {
		background-color: rgb(79, 79, 79);
		cursor: default;
	}

	.icon-button--flat {
		background-color: transparent!important;
		box-shadow: none;
		fill: rgb(255, 255, 255);
	}

	.icon-button--flat[data-enabled="false"] {
		fill: rgb(31, 31, 31);
	}

	.icon-button[data-active="true"] {
		background-color: ${ACCENT_COLOR};
		fill: rgb(255, 255, 255);
	}

	@media (hover: hover) and (pointer: fine) {
		.icon-button:not([data-enabled="false"]):hover {
			transform: scale(1.50);
		}

		.icon-button:active {
			transform: none;
		}
	}











	.app {
		display: grid;
		height: 100%;
		position: relative;
	}

	.app__header {
		background-color: ${ACCENT_COLOR};
		box-shadow: 0px 0px 8px 4px rgba(0, 0, 0, 0.25);
		position: absolute;
			top: 0px;
			left: 0px;
			right: 0px;
		transition: transform 0.25s;
		z-index: 1;
	}

	.app__header[data-hide=true] {
		display: initial!important;
		transform: translate(0%, -100%);
	}

	.app__content {
		background-color: rgb(31, 31, 31);
		overflow: hidden;
		padding: 64px 0px 112px 0px;
		position: relative;
		z-index: 0;
	}

	.app__navigation {
		background-color: rgb(47, 47, 47);
		box-shadow: 0px 0px 8px 4px rgba(0, 0, 0, 0.25);
		position: absolute;
			bottom: 0px;
			left: 0px;
			right: 0px;
		transition: transform 0.25s;
		z-index: 1;
	}

	.app__navigation[data-hide=true] {
		display: initial!important;
		transform: translate(0%, 100%);
	}

	.app__message-bar {
		background-color: ${ACCENT_COLOR};
	}

	.app__video {
		background-color: rgb(0, 0, 0);
		height: 100%;
		position: absolute;
		width: 100%;
	}

	.offline-indicator {
		margin: 0px auto;
		max-width: 1080px;
		padding: 8px;
	}

	.offline-indicator__content {
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}





	.scroll-container {
		height: 100%;
		overflow-y: scroll;
		overflow-x: auto;
		width: 100%;
	}








	.statistic {
		display: grid;
		gap: 8px;
	}

	.statistic__title {
		color: rgb(255, 255, 255);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.statistic__subtitle {
		color: rgb(159, 159, 159);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}







	.icon-link {
		background-color: rgb(47, 47, 47);
		border-radius: 4px;
		cursor: pointer;
		padding-bottom: 100%;
		position: relative;
	}

	.icon-link__content {
		height: 100%;
		position: absolute;
			top: 0%;
			left: 0%;
		width: 100%;
		display: grid;
		gap: 12px;
		align-items: center;
		justify-content: center;
		justify-items: center;
		align-content: center;
	}

	.icon-link__icon {
		fill: rgb(255, 255, 255);
		transition: fill 0.125s;
	}

	.icon-link__title {
		color: rgb(159, 159, 159);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		transition: color 0.125s;
		white-space: nowrap;
	}

	@media (hover: hover) and (pointer: fine) {
		.icon-link:hover .icon-link__title {
			color: rgb(255, 255, 255)
		}
	}
`;
    document.head.appendChild(style);
    function makeStatistic(title, subtitle) {
        return xml.element("div.statistic")
            .add(xml.element("div.statistic__title")
            .add(xml.text(title)))
            .add(xml.element("div.statistic__subtitle")
            .add(xml.text(subtitle)));
    }
    function makeIconLink(icon, title, url) {
        return xml.element("div.icon-link")
            .add(xml.element("div.icon-link__content")
            .add(icon
            .set("class", "icon-link__icon")
            .set("width", "24px")
            .set("height", "24px"))
            .add(xml.element("div.icon-link__title")
            .add(xml.text(title))))
            .on("click", () => navigate(url));
    }
    function makeButton(options) {
        let style = options?.style ?? "normal";
        return xml.element(`div.icon-button${style === "normal" ? "" : ".icon-button--flat"}`);
    }
    const showPage = new observers_1.ObservableClass(false);
    const showDevices = new observers_1.ObservableClass(false);
    player.devices.addObserver({
        onappend: () => {
            if (player.devices.getState().length < 2) {
                showDevices.updateState(false);
            }
        },
        onsplice: () => {
            if (player.devices.getState().length < 2) {
                showDevices.updateState(false);
            }
        }
    });
    const showVideo = new observers_1.ObservableClass(false);
    {
        let computer = () => {
            let isDeviceLocal = player.isDeviceLocal.getState();
            let isCurrentEntryVideo = player.isCurrentEntryVideo.getState();
            let localPlayback = player.localPlayback.getState();
            showVideo.updateState(isDeviceLocal && isCurrentEntryVideo && localPlayback);
        };
        player.isDeviceLocal.addObserver(computer);
        player.isCurrentEntryVideo.addObserver(computer);
        player.localPlayback.addObserver(computer);
    }
    const showModal = new observers_1.ObservableClass(undefined);
    showContextMenu.addObserver((showContextMenu) => {
        if (showContextMenu) {
            showModal.updateState("context");
        }
        else {
            showModal.updateState(undefined);
        }
    });
    showDevices.addObserver((showDevices) => {
        if (showDevices) {
            showModal.updateState("devices");
        }
        else {
            showModal.updateState(undefined);
        }
    });
    showPage.addObserver((showPage) => {
        if (showPage) {
            showModal.updateState("page");
        }
        else {
            showModal.updateState(undefined);
        }
    });
    verifiedToken.addObserver((verifiedToken) => {
        if (is.absent(verifiedToken)) {
            showModal.updateState("login");
        }
        else {
            showModal.updateState(undefined);
        }
    });
    let token;
    verifiedToken.addObserver((verifiedToken) => {
        token = verifiedToken;
        player.authenticate(verifiedToken);
        playlists.authenticate(verifiedToken);
    });
    async function getNewToken(username, password) {
        let response = await apiclient["POST:/auth/"]({
            headers: {
                "x-circus-username": username,
                "x-circus-password": password
            }
        });
        let headers = await response.headers();
        savedToken.updateState(headers["x-circus-token"]);
        return savedToken.getState();
    }
    let mountwrapper = document.createElement('div');
    let showUserInterface = new observers_1.ObservableClass(true);
    let appcontainer = xml.element("div.app")
        .render();
    document.body.appendChild(appcontainer);
    let historyLength = new observers_1.ObservableClass(window.history.length);
    let historyIndex = new observers_1.ObservableClass(window.history.length - 1);
    let lastHistoryIndex = observers_1.computed((historyLength, historyIndex) => {
        if (historyLength === 0) {
            return;
        }
        if (historyIndex - 1 < 0) {
            return;
        }
        return historyIndex - 1;
    }, historyLength, historyIndex);
    let nextHistoryIndex = observers_1.computed((historyLength, historyIndex) => {
        if (historyLength === 0) {
            return;
        }
        if (historyIndex + 1 >= historyLength) {
            return;
        }
        return historyIndex + 1;
    }, historyLength, historyIndex);
    let appheader = xml.element("div.app__header")
        .bind("data-hide", showUserInterface.addObserver((showUserInterface) => !showUserInterface))
        .add(xml.element("div.content")
        .set("style", "padding: 16px")
        .add(xml.element("div.page-header")
        .add(xml.element("div.page-header__title")
        .add(xml.text(document.title))
        .on("click", () => {
        navigate("");
    }))
        .add(xml.element("div.page-header__controls")
        .add(makeButton({ style: "flat" })
        .add(Icon.makeReload()
        .set("width", "16px")
        .set("height", "16px"))
        .on("click", () => {
        window.location.reload();
    }))
        .add(makeButton({ style: "flat" })
        .bind("data-enabled", lastHistoryIndex.addObserver(is.present))
        .add(Icon.makeChevron({ direction: "left" })
        .set("width", "16px")
        .set("height", "16px"))
        .on("click", () => {
        if (is.present(lastHistoryIndex)) {
            window.history.back();
        }
    }))
        .add(makeButton({ style: "flat" })
        .bind("data-enabled", nextHistoryIndex.addObserver(is.present))
        .add(Icon.makeChevron()
        .set("width", "16px")
        .set("height", "16px"))
        .on("click", () => {
        if (is.present(nextHistoryIndex)) {
            window.history.forward();
        }
    }))
        .add(makeButton({ style: "flat" })
        .bind("data-enabled", verifiedToken.addObserver(is.present))
        .add(Icon.makeSettings()
        .set("width", "16px")
        .set("height", "16px"))
        .on("click", async () => {
        if (is.present(verifiedToken.getState())) {
            let user = await (await apiclient["GET:/users/<user_id>/"]({
                options: {
                    user_id: "",
                    token: token ?? ""
                }
            })).payload();
            let response = await apiclient["GET:/statistics/"]({
                options: {
                    token: token ?? ""
                }
            });
            let payload = await response.payload();
            let modalPage = xml.element("div.content.content--narrow")
                .add(xml.element("div")
                .set("style", "align-items: center; display: grid; gap: 16px; grid-template-columns: 1fr min-content;")
                .add(renderTextHeader(xml.text("Change settings")))
                .add(makeButton()
                .on("click", () => {
                modalPageElements.update([]);
            })
                .add(Icon.makeCross())))
                .add(EntityRow.forUser(user.user))
                .add(xml.element("button")
                .add(xml.text("Logout"))
                .on("click", async () => {
                savedToken.updateState(undefined);
            }))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .set("data-hide", `${payload.statistics.length === 0}`)
                .add(...payload.statistics.map((setting) => {
                let title = setting.title;
                let subtitle = "";
                if (setting.unit === "BYTES") {
                    subtitle = metadata_1.formatSize(setting.value);
                }
                else if (setting.unit === "MILLISECONDS") {
                    subtitle = metadata_1.formatDuration(setting.value);
                }
                else {
                    subtitle = new Intl.NumberFormat().format(setting.value);
                }
                return makeStatistic(title, subtitle);
            })));
            modalPageElements.update([modalPage]);
        }
    })))))
        .render();
    appcontainer.appendChild(appheader);
    mountwrapper.setAttribute("class", "app__content");
    appcontainer.appendChild(mountwrapper);
    let maincontent = document.createElement('div');
    maincontent.setAttribute("style", "position: relative; width: 100%; height: 100%;");
    mountwrapper.appendChild(maincontent);
    let devicelist = new observers_1.ArrayObservable([]);
    {
        let computer = () => {
            let devices = player.devices.getState();
            let activeDevice = player.device.getState();
            let localDevice = player.localDevice.getState();
            devicelist.update(devices.map((device) => {
                return {
                    ...device,
                    active: activeDevice?.id === device.id,
                    local: localDevice?.id === device.id
                };
            }));
        };
        player.devices.addObserver({
            onappend: computer,
            onsplice: computer
        });
        player.device.addObserver(computer);
        player.localDevice.addObserver(computer);
    }
    let username = new observers_1.ObservableClass("");
    let password = new observers_1.ObservableClass("");
    let canLogin = observers_1.computed((username, password) => {
        if (username === "") {
            return false;
        }
        if (password === "") {
            return false;
        }
        return true;
    }, username, password);
    let repeat_password = new observers_1.ObservableClass("");
    let display_name = new observers_1.ObservableClass("");
    let registration_key = new observers_1.ObservableClass("");
    let loginErrors = new observers_1.ArrayObservable(new Array());
    let canRegister = observers_1.computed((username, password, repeat_password, display_name, registration_key) => {
        if (username === "") {
            return false;
        }
        if (password === "") {
            return false;
        }
        if (repeat_password === "") {
            return false;
        }
        if (display_name === "") {
            return false;
        }
        if (registration_key === "") {
            return false;
        }
        if (password !== repeat_password) {
            return false;
        }
        return true;
    }, username, password, repeat_password, display_name, registration_key);
    async function doLogin() {
        if (canLogin.getState()) {
            loginErrors.update([]);
            try {
                let token = await getNewToken(username.getState(), password.getState());
                if (is.present(token)) {
                    loginErrors.update([]);
                    return;
                }
            }
            catch (error) { }
            loginErrors.update(["The login was unsuccessful! Please check your credentials and try again."]);
        }
    }
    async function doRegister() {
        if (canRegister.getState()) {
            loginErrors.update([]);
            let response = await apiclient["POST:/users/"]({
                payload: {
                    username: username.getState(),
                    password: password.getState(),
                    name: display_name.getState(),
                    key_id: registration_key.getState()
                }
            });
            let payload = await response.payload();
            if (apischema.messages.ErrorMessage.is(payload)) {
                loginErrors.update(payload.errors);
            }
            else {
                loginErrors.update([]);
                savedToken.updateState(payload.token);
            }
        }
    }
    let modalPageElements = new observers_1.ArrayObservable([]);
    modalPageElements.addObserver({
        onappend: (state) => {
            showPage.updateState(modalPageElements.getState().length > 0);
        },
        onsplice: (state, index) => {
            showPage.updateState(modalPageElements.getState().length > 0);
        }
    });
    let modals = xml.element("div.modal-container")
        .bind("data-hide", showModal.addObserver(is.absent))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "page"))
        .repeat(modalPageElements, (v) => v))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "devices"))
        .add(xml.element("div.content.content--narrow")
        .add(xml.element("div.device-selector")
        .add(xml.element("div")
        .set("style", "align-items: center; display: grid; gap: 16px; grid-template-columns: 1fr min-content;")
        .add(renderTextHeader(xml.text("Select playback device")))
        .add(makeButton()
        .on("click", () => {
        showDevices.updateState(false);
    })
        .add(Icon.makeCross())))
        .add(xml.element("div.device-selector__devices")
        .repeat(devicelist, (device) => xml.element("div.device-selector__device")
        .add(makeButton()
        .set("data-active", "" + device.active)
        .add(Icon.makeBroadcast()))
        .add(xml.element("div.device-selector__device-info")
        .add(xml.element("div.device-selector__device-name")
        .add(xml.text(device.name)))
        .add(xml.element("div.device-selector__device-type")
        .add(xml.text(device.local ? "Local device" : "Remote device"))))
        .on("click", () => {
        player.transfer({
            id: device.id,
            protocol: device.protocol,
            name: device.name,
            type: device.type
        });
        showDevices.updateState(false);
    }))))))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "login"))
        .add(xml.element("div.content.content--narrow")
        .add(xml.element("div.login-modal")
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__username")
        .bind2("value", username)
        .set("type", "text")
        .set("spellcheck", "false")
        .set("placeholder", "Username..."))
        .add(Icon.makePerson()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__password")
        .bind2("value", password)
        .set("type", "password")
        .set("spellcheck", "false")
        .set("placeholder", "Password...")
        .on("keyup", async (event) => {
        if (event.code === "Enter") {
            event.target.blur();
            await doLogin();
        }
    }))
        .add(Icon.makePadlock()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__password")
        .bind2("value", repeat_password)
        .set("type", "password")
        .set("spellcheck", "false")
        .set("placeholder", "Repeat password..."))
        .add(Icon.makePadlock()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__name")
        .bind2("value", display_name)
        .set("type", "text")
        .set("spellcheck", "false")
        .set("placeholder", "Display name..."))
        .add(Icon.makePerson()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__key")
        .bind2("value", registration_key)
        .set("type", "text")
        .set("spellcheck", "false")
        .set("placeholder", "Registration key...")
        .on("keyup", async (event) => {
        if (event.code === "Enter") {
            event.target.blur();
            await doRegister();
        }
    }))
        .add(Icon.makePadlock()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);"))))
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .bind("data-hide", loginErrors.compute((loginErrors) => loginErrors.length === 0))
        .repeat(loginErrors, (loginError) => renderTextParagraph(xml.text(loginError))))
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .add(xml.element("button")
        .bind2("data-enabled", observers_1.computed((canRegister) => "" + canRegister, canRegister))
        .add(xml.text("Register"))
        .on("click", async () => {
        await doRegister();
    }))
        .add(xml.element("button")
        .bind2("data-enabled", observers_1.computed((canLogin) => "" + canLogin, canLogin))
        .add(xml.text("Login"))
        .on("click", async () => {
        await doLogin();
    }))))))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "context"))
        .add(xml.element("div.content.content--narrow")
        .repeat(contextMenuItems, (contextMenuItem) => contextMenuItem)));
    let mount = xml.element("div.scroll-container")
        .bind("data-hide", showVideo.addObserver((showVideo) => showVideo))
        .render();
    maincontent.appendChild(mount);
    maincontent.appendChild(modals.render());
    let mpw = xml.element("div.app__navigation")
        .bind("data-hide", showUserInterface.addObserver((showUserInterface) => !showUserInterface))
        .add(xml.element("div.app__message-bar")
        .bind("data-hide", player.isOnline.addObserver((isOnline) => isOnline))
        .add(xml.element("div.offline-indicator")
        .add(xml.element("div.offline-indicator__content")
        .add(xml.text("The application is currently offline.")))))
        .render();
    let progress = xml.element("div.media-player__progress");
    let progresscontainer = xml.element("div.media-player__progress-container");
    let progresstrack = xml.element("div.media-player__progress-track");
    window.requestAnimationFrame(async function computer() {
        let currentEntry = player.currentEntry.getState();
        let playback = player.playback.getState();
        let estimatedProgress = player.estimatedProgress.getState();
        let estimatedProgressTimestamp = player.estimatedProgressTimestamp.getState();
        let scale = 0;
        if (is.present(currentEntry) && is.present(estimatedProgress) && is.present(estimatedProgressTimestamp)) {
            let progress = estimatedProgress;
            if (playback) {
                progress += (Date.now() - estimatedProgressTimestamp) / 1000;
            }
            scale = progress / (currentEntry.media.duration_ms / 1000);
        }
        let ref = await progresstrack.ref();
        ref.style.setProperty("transform", `scale(${scale}, 1.0)`);
        window.requestAnimationFrame(computer);
    });
    async function progressupdate(page_x) {
        let ref = await progresscontainer.ref();
        let x = page_x - ref.offsetLeft;
        let w = ref.offsetWidth;
        let factor = Math.max(0.0, Math.min(x / w, 1.0));
        let currentEntry = player.currentEntry.getState();
        if (is.present(currentEntry)) {
            let progress = factor * currentEntry.media.duration_ms / 1000;
            player.seek(progress);
        }
    }
    let progressactive = false;
    document.body.addEventListener("pointermove", async (event) => {
        if (progressactive) {
            await progressupdate(event.pageX);
        }
    });
    document.body.addEventListener("pointerup", async (event) => {
        progressactive = false;
    });
    document.body.addEventListener("pointerleave", async (event) => {
        progressactive = false;
    });
    progress
        .on("pointerdown", async (event) => {
        progressactive = true;
        await progressupdate(event.pageX);
    })
        .add(progresscontainer
        .add(progresstrack));
    let mp = xml.element("div.content")
        .set("style", "padding: 16px;")
        .add(xml.element("div.media-player")
        .add(xml.element("div.media-player__top")
        .add(xml.element("div.media-player__metadata")
        .add(xml.element("div.media-player__title")
        .add(xml.text(mediaPlayerTitle)))
        .add(xml.element("div.media-player__subtitle")
        .add(xml.text(mediaPlayerSubtitle)))
        .on("click", () => {
        let context = player.context.getState();
        if (is.present(context)) {
            if (objects_1.Album.is(context)) {
                navigate(`audio/albums/${context.album_id}/`);
            }
            else if (objects_1.Artist.is(context)) {
                navigate(`audio/artists/${context.artist_id}/`);
            }
            else if (objects_1.Disc.is(context)) {
                navigate(`audio/discs/${context.disc_id}/`);
            }
            else if (objects_1.Episode.is(context)) {
                navigate(`video/episodes/${context.episode_id}/`);
            }
            else if (objects_1.Movie.is(context)) {
                navigate(`video/movies/${context.movie_id}/`);
            }
            else if (objects_1.Playlist.is(context)) {
                navigate(`audio/playlists/${context.playlist_id}/`);
            }
            else if (objects_1.Season.is(context)) {
                navigate(`video/seasons/${context.season_id}/`);
            }
            else if (objects_1.Show.is(context)) {
                navigate(`video/shows/${context.show_id}/`);
            }
            else if (objects_1.Track.is(context)) {
                navigate(`audio/tracks/${context.track_id}/`);
            }
            else {
                throw `Expected code to be unreachable!`;
            }
        }
    }))
        .add(xml.element("div.media-player__controls")
        .add(makeButton()
        .bind("data-hide", player.devices.compute((devices) => {
        return devices.length < 2;
    }))
        .add(Icon.makeBroadcast())
        .on("click", () => {
        showDevices.updateState(!showDevices.getState());
    }))
        .add(makeButton()
        .bind("data-enabled", player.canPlayLast.addObserver(a => a))
        .add(Icon.makeSkip({ direction: "left" }))
        .on("click", () => {
        player.last();
    }))
        .add(makeButton()
        .bind("data-enabled", player.canPlayCurrent.addObserver(a => a))
        .add(Icon.makePlay()
        .bind("data-hide", player.playback.addObserver((playback) => {
        return playback === true;
    })))
        .add(Icon.makePause()
        .bind("data-hide", player.playback.addObserver((playback) => {
        return playback === false;
    })))
        .on("click", () => {
        player.toggle();
    }))
        .add(makeButton()
        .bind("data-enabled", player.canPlayNext.addObserver(a => a))
        .add(Icon.makeSkip())
        .on("click", () => {
        player.next();
    }))))
        .add(xml.element("div.media-player__bottom")
        .add(progress)))
        .render();
    appcontainer.appendChild(mpw);
    mpw.appendChild(mp);
    currentVideo.setAttribute('playsinline', '');
    currentVideo.setAttribute("preload", "auto");
    currentVideo.style.setProperty('height', '100%');
    currentVideo.style.setProperty('width', '100%');
    lastVideo.setAttribute("preload", "auto");
    lastVideo.style.setProperty("display", "none");
    nextVideo.setAttribute("preload", "auto");
    nextVideo.style.setProperty("display", "none");
    currentVideo.addEventListener("click", () => {
        player.pause();
    });
    showVideo.addObserver((showVideo) => {
        if (showVideo) {
            showUserInterface.updateState(false);
        }
        else {
            showUserInterface.updateState(true);
        }
    });
    let videowrapper = xml.element("div.app__video")
        .bind("data-hide", showVideo.addObserver((showVideo) => {
        return !showVideo;
    }))
        .render();
    appcontainer.appendChild(videowrapper);
    videowrapper.appendChild(currentVideo);
    videowrapper.appendChild(lastVideo);
    videowrapper.appendChild(nextVideo);
    /*
    let slider_wrapper = document.createElement("div");
    slider_wrapper.classList.add("slider-widget");
    let slider_indicator = document.createElement("div");
    slider_indicator.classList.add("slider-widget__indicator");
    let slider_knob_wrapper = document.createElement("div");
    slider_knob_wrapper.classList.add("slider-widget__knob-wrapper");
    let slider_knob = document.createElement("div");
    slider_knob.classList.add("slider-widget__knob");
    
    slider_knob_wrapper.appendChild(slider_knob);
    slider_indicator.appendChild(slider_knob_wrapper);
    slider_wrapper.appendChild(slider_indicator);
    chromecast.appendChild(slider_wrapper);
    {
        let percentage = 0.0;
        function update(event: MouseEvent): void {
            let rect = slider_knob_wrapper.getBoundingClientRect();
            let x = event.pageX;
            let factor = Math.max(0.0, Math.min((x - rect.x) / rect.width, 1.0));
            percentage = factor * 100.0;
            slider_knob.style.setProperty("left", `${percentage}%`);
        }
        function detach(event: MouseEvent) {
            window.removeEventListener("mousemove", update);
            window.removeEventListener("mouseup", detach);
            req(`/api/cc/seek/`, { percentage: percentage, token: token }, () => {});
        }
        function attach(event: MouseEvent) {
            window.addEventListener("mousemove", update);
            window.addEventListener("mouseup", detach);
            update(event);
        }
        slider_wrapper.addEventListener("mousedown", attach);
    }
    */
    function renderTextHeader(content) {
        return xml.element("div.text-header")
            .add(content);
    }
    function renderTextParagraph(content) {
        return xml.element("div.text-paragraph")
            .add(content);
    }
    function observe(element, handler) {
        element.ref().then((element) => {
            let observer = new IntersectionObserver(async (entries) => {
                for (let entry of entries) {
                    if (entry.target === element && entry.isIntersecting) {
                        await handler();
                    }
                }
            });
            observer.observe(element);
        });
        return element;
    }
    let updateviewforuri = (uri) => {
        let parts;
        if (false) {
        }
        else if ((parts = /^audio[/]tracks[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let track_id = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let playlists = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/tracks/<track_id>/playlists/"]({
                        options: {
                            track_id,
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let playlist of payload.playlists) {
                        playlists.append(playlist);
                    }
                    offset += payload.playlists.length;
                    if (payload.playlists.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            apiclient["GET:/tracks/<track_id>/"]({
                options: {
                    track_id: parts[1],
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let track = payload.track;
                let last = payload.last;
                let next = payload.next;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forTrack(track, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .add(entityNavLinkFactory.forTrack(last, next)))
                    .add(xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Appearances")))
                    .bind("data-hide", playlists.compute((playlists) => playlists.length === 0))
                    .add(Grid.make()
                    .repeat(playlists, (playlist) => EntityCard.forPlaylist(playlist))))
                    .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                    .render());
            });
        }
        else if ((parts = /^audio[/]tracks[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let tracks = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/tracks/<query>"]({
                        options: {
                            query: query,
                            offset: offset,
                            token: token ?? ""
                        }
                    });
                    let payload = await response.payload();
                    for (let track of payload.tracks) {
                        tracks.append(track);
                    }
                    offset += payload.tracks.length;
                    if (payload.tracks.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Tracks"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(tracks, (track) => EntityCard.forTrack(track))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^video[/]seasons[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let season_id = decodeURIComponent(parts[1]);
            apiclient["GET:/seasons/<season_id>/"]({
                options: {
                    season_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let season = payload.season;
                let last = payload.last;
                let next = payload.next;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forSeason(season, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(...season.episodes.map((episode, episodeIndex) => {
                    return EntityCard.forEpisode(episode, {
                        playbackButton: PlaybackButton.forSeason(season, episodeIndex)
                    });
                })))
                    .add(xml.element("div.content")
                    .add(entityNavLinkFactory.forSeason(last, next)))
                    .render());
            });
        }
        else if ((parts = /^video[/]seasons[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let seasons = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/seasons/<query>"]({
                        options: {
                            query,
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let season of payload.seasons) {
                        seasons.append(season);
                    }
                    offset += payload.seasons.length;
                    if (payload.seasons.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Seasons"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(seasons, (season) => EntityCard.forSeason(season))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^audio[/]discs[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let disc_id = decodeURIComponent(parts[1]);
            apiclient["GET:/discs/<disc_id>/"]({
                options: {
                    disc_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let disc = payload.disc;
                let last = payload.last;
                let next = payload.next;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forDisc(disc, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .set("style", "display: grid; gap: 16px;")
                    .add(...disc.tracks.map((track, trackIndex) => {
                    return EntityRow.forTrack(track, PlaybackButton.forDisc(disc, trackIndex));
                })))
                    .add(xml.element("div.content")
                    .add(entityNavLinkFactory.forDisc(last, next)))
                    .render());
            });
        }
        else if ((parts = /^audio[/]discs[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let discs = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/discs/<query>"]({
                        options: {
                            query,
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let disc of payload.discs) {
                        discs.append(disc);
                    }
                    offset += payload.discs.length;
                    if (payload.discs.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Discs"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(discs, (disc) => EntityCard.forDisc(disc))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^users[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let user_id = decodeURIComponent(parts[1]);
            apiclient["GET:/users/<user_id>/"]({
                options: {
                    user_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let user = payload.user;
                apiclient["GET:/users/<user_id>/playlists/"]({
                    options: {
                        user_id,
                        token: token ?? "",
                        offset: 0,
                        limit: 1000
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    let playlists = payload.playlists;
                    mount.appendChild(xml.element("div.content")
                        .add(renderTextHeader(xml.text(user.name)))
                        .add(xml.element("div")
                        .set("style", "display: grid; gap: 24px;")
                        .set("data-hide", `${playlists.length === 0}`)
                        .add(renderTextHeader(xml.text("Playlists")))
                        .add(Grid.make()
                        .add(...playlists.map((playlist) => EntityCard.forPlaylist(playlist)))))
                        .render());
                });
            });
        }
        else if ((parts = /^users[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let users = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/users/<query>"]({
                        options: {
                            query,
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let user of payload.users) {
                        users.append(user);
                    }
                    offset += payload.users.length;
                    if (payload.users.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Users"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(users, (user) => EntityCard.forUser(user))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^actors[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let actor_id = decodeURIComponent(parts[1]);
            apiclient["GET:/actors/<actor_id>/"]({
                options: {
                    actor_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let actor = payload.actor;
                apiclient["GET:/actors/<actor_id>/shows/"]({
                    options: {
                        actor_id,
                        token: token ?? "",
                        offset: 0,
                        limit: 1000
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    let shows = payload.shows;
                    apiclient["GET:/actors/<actor_id>/movies/"]({
                        options: {
                            actor_id,
                            token: token ?? "",
                            offset: 0,
                            limit: 1000
                        }
                    }).then(async (response) => {
                        let payload = await response.payload();
                        let movies = payload.movies;
                        mount.appendChild(xml.element("div.content")
                            .set("style", "display: grid; gap: 64px;")
                            .add(renderTextHeader(xml.text(actor.name)))
                            .add(xml.element("div")
                            .set("style", "display: grid; gap: 24px;")
                            .set("data-hide", `${shows.length === 0}`)
                            .add(renderTextHeader(xml.text("Shows")))
                            .add(carouselFactory.make(new observers_1.ArrayObservable(shows.map((show) => EntityCard.forShow(show))))))
                            .add(xml.element("div")
                            .set("style", "display: grid; gap: 24px;")
                            .set("data-hide", `${movies.length === 0}`)
                            .add(renderTextHeader(xml.text("Movies")))
                            .add(Grid.make()
                            .add(...movies.map((movie) => EntityCard.forMovie(movie)))))
                            .render());
                    });
                });
            });
        }
        else if ((parts = /^actors[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let actors = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/actors/<query>"]({
                        options: {
                            query,
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let actor of payload.actors) {
                        actors.append(actor);
                    }
                    offset += payload.actors.length;
                    if (payload.actors.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Actors"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(actors, (actor) => EntityCard.forActor(actor))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^audio[/]albums[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let album_id = decodeURIComponent(parts[1]);
            apiclient["GET:/albums/<album_id>/"]({
                options: {
                    album_id: album_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let album = payload.album;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forAlbum(album, { compactDescription: false })))
                    .add(...album.discs.map((disc, discIndex) => xml.element("div.content")
                    .set("style", "display: grid; gap: 16px;")
                    .add(renderTextHeader(xml.text(`Disc ${disc.number}`)))
                    .add(...disc.tracks.map((track, trackIndex) => {
                    return EntityRow.forTrack(track, PlaybackButton.forAlbum(album, discIndex, trackIndex));
                }))))
                    .render());
            });
        }
        else if ((parts = /^audio[/]albums[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let albums = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/albums/<query>"]({
                        options: {
                            query,
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let album of payload.albums) {
                        albums.append(album);
                    }
                    offset += payload.albums.length;
                    if (payload.albums.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Albums"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(albums, (album) => EntityCard.forAlbum(album))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^audio[/]artists[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let artist_id = decodeURIComponent(parts[1]);
            apiclient["GET:/artists/<artist_id>/"]({
                options: {
                    artist_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let artist = payload.artist;
                let tracks = payload.tracks;
                let appearances = payload.appearances;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forArtist(artist, { compactDescription: false })))
                    .add(tracks.length === 0 ? undefined : xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Popular tracks")))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 16px;")
                    .add(...tracks.map((track) => {
                    return EntityRow.forTrack(track);
                }))))
                    .add(artist.albums.length === 0 ? undefined : xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Discography")))
                    .add(Grid.make()
                    .add(...artist.albums.map((album, albumIndex) => {
                    return EntityCard.forAlbum(album, {
                        playbackButton: PlaybackButton.forArtist(artist, albumIndex)
                    });
                }))))
                    .add(appearances.length === 0 ? undefined : xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Appearances")))
                    .add(Grid.make()
                    .add(...appearances.map((album) => {
                    return EntityCard.forAlbum(album);
                }))))
                    .render());
            });
        }
        else if ((parts = /^audio[/]artists[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let artists = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/artists/<query>"]({
                        options: {
                            query,
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let artist of payload.artists) {
                        artists.append(artist);
                    }
                    offset += payload.artists.length;
                    if (payload.artists.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Artists"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(artists, (artist) => EntityCard.forArtist(artist))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^audio[/]playlists[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let playlist_id = decodeURIComponent(parts[1]);
            apiclient["GET:/playlists/<playlist_id>/"]({
                options: {
                    playlist_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let playlist = payload.playlist;
                let hasWritePermission = (await playlists.getPermissions({
                    playlist: {
                        playlist_id
                    }
                })).permissions === "write";
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forPlaylist(playlist, { compactDescription: false })))
                    .add(playlist.items.length === 0 ? undefined : xml.element("div.content")
                    .set("style", "display: grid; gap: 16px;")
                    .add(...playlist.items.map((item, itemIndex) => xml.element("div")
                    .set("style", "align-items: center; display: grid; grid-template-columns: 1fr min-content; gap: 16px;")
                    .add(EntityRow.forTrack(item.track, PlaybackButton.forPlaylist(playlist, itemIndex)))
                    .add(makeButton()
                    .set("data-hide", `${!hasWritePermission}`)
                    .on("click", async () => {
                    let response = await playlists.deletePlaylistItem({
                        playlist_item: {
                            playlist_item_id: item.playlist_item_id
                        }
                    });
                    if (response.errors.length > 0) {
                        return;
                    }
                    // TODO: Remove item instead of navigating.
                    navigate(uri);
                })
                    .add(Icon.makeMinus())))))
                    .render());
            });
        }
        else if ((parts = /^audio[/]playlists[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            apiclient["GET:/playlists/<query>"]({
                options: {
                    query,
                    token: token ?? "",
                    offset: 0,
                    limit: 1000
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let playlists = payload.playlists;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(renderTextHeader(xml.text("Playlists"))))
                    .add(xml.element("div.content")
                    .add(Grid.make()
                    .add(...playlists.map((playlist) => EntityCard.forPlaylist(playlist)))))
                    .render());
            });
        }
        else if ((parts = /^audio[/]/.exec(uri)) !== null) {
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let albums = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient.getNewAlbums({
                        options: {
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let album of payload.albums) {
                        albums.append(album);
                    }
                    offset += payload.albums.length;
                    if (payload.albums.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(Grid.make({ mini: true })
                .add(makeIconLink(Icon.makeDisc(), "Albums", "audio/albums/"))
                .add(makeIconLink(Icon.makePerson(), "Artists", "audio/artists/"))
                .add(makeIconLink(Icon.makeBulletList(), "Playlists", "audio/playlists/"))
                .add(makeIconLink(Icon.makeNote(), "Tracks", "audio/tracks/")))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px")
                .bind("data-hide", albums.compute((albums) => albums.length === 0))
                .add(renderTextHeader(xml.text("Recently added albums")))
                .add(Grid.make()
                .repeat(albums, (album) => EntityCard.forAlbum(album)))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^video[/]shows[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let show_id = decodeURIComponent(parts[1]);
            apiclient["GET:/shows/<show_id>/"]({
                options: {
                    show_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let show = payload.show;
                let indices = utils.getNextEpisode(show);
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forShow(show, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .set("data-hide", `${show.actors.length === 0}`)
                    .set("style", "display: grid; gap: 16px;")
                    .add(...show.actors.map((actor) => EntityRow.forActor(actor))))
                    .add(is.absent(indices) ? undefined : xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Next episode")))
                    .add(EntityCard.forEpisode(show.seasons[indices.seasonIndex].episodes[indices.episodeIndex], {
                    playbackButton: PlaybackButton.forShow(show, indices.seasonIndex, indices.episodeIndex)
                })))
                    .add(xml.element("div.content")
                    .add(Grid.make()
                    .add(...show.seasons.map((season, seasonIndex) => EntityCard.forSeason(season, {
                    playbackButton: PlaybackButton.forShow(show, seasonIndex)
                })))))
                    .render());
            });
        }
        else if ((parts = /^video[/]shows[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            apiclient["GET:/shows/<query>"]({
                options: {
                    query,
                    token: token ?? "",
                    offset: 0,
                    limit: 1000
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let shows = payload.shows;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(renderTextHeader(xml.text("Shows"))))
                    .add(xml.element("div.content")
                    .add(Grid.make()
                    .add(...shows.map((show) => EntityCard.forShow(show)))))
                    .render());
            });
        }
        else if ((parts = /^video[/]episodes[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let episode_id = decodeURIComponent(parts[1]);
            apiclient["GET:/episodes/<episode_id>/"]({
                options: {
                    episode_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let episode = payload.episode;
                let last = payload.last;
                let next = payload.next;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forEpisode(episode, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .add(entityNavLinkFactory.forEpisode(last, next)))
                    .render());
            });
        }
        else if ((parts = /^video[/]episodes[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let episodes = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/episodes/<query>"]({
                        options: {
                            query,
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let episode of payload.episodes) {
                        episodes.append(episode);
                    }
                    offset += payload.episodes.length;
                    if (payload.episodes.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Episodes"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(episodes, (episode) => EntityCard.forEpisode(episode))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^video[/]movies[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let movie_id = decodeURIComponent(parts[1]);
            apiclient["GET:/movies/<movie_id>/"]({
                options: {
                    movie_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let offset = 0;
                let reachedEnd = new observers_1.ObservableClass(false);
                let isLoading = new observers_1.ObservableClass(false);
                let movies = new observers_1.ArrayObservable([]);
                async function load() {
                    if (!reachedEnd.getState() && !isLoading.getState()) {
                        isLoading.updateState(true);
                        let response = await apiclient["GET:/movies/<movie_id>/suggestions/"]({
                            options: {
                                movie_id,
                                token: token ?? "",
                                offset
                            }
                        });
                        let payload = await response.payload();
                        for (let movie of payload.movies) {
                            movies.append(movie);
                        }
                        offset += payload.movies.length;
                        if (payload.movies.length === 0) {
                            reachedEnd.updateState(true);
                        }
                        isLoading.updateState(false);
                    }
                }
                ;
                let payload = await response.payload();
                let movie = payload.movie;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forMovie(movie, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .set("data-hide", `${movie.actors.length === 0}`)
                    .set("style", "display: grid; gap: 16px;")
                    .add(...movie.actors.map((actor) => EntityRow.forActor(actor))))
                    .add(xml.element("div.content")
                    .bind("data-hide", movies.compute((movies) => movies.length === 0))
                    .set("style", "display: grid; gap: 16px;")
                    .add(renderTextHeader(xml.text("Suggested movies")))
                    .add(Grid.make()
                    .repeat(movies, (movie) => EntityCard.forMovie(movie))))
                    .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                    .render());
            });
        }
        else if ((parts = /^video[/]movies[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let movies = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/movies/<query>"]({
                        options: {
                            query,
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let movie of payload.movies) {
                        movies.append(movie);
                    }
                    offset += payload.movies.length;
                    if (payload.movies.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Movies"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(movies, (movie) => EntityCard.forMovie(movie))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^video[/]genres[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let genre_id = decodeURIComponent(parts[1]);
            apiclient["GET:/genres/<genre_id>/"]({
                options: {
                    genre_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let genre = payload.genre;
                apiclient["GET:/genres/<genre_id>/shows/"]({
                    options: {
                        genre_id,
                        token: token ?? ""
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    let shows = payload.shows;
                    let offset = 0;
                    let reachedEnd = new observers_1.ObservableClass(false);
                    let isLoading = new observers_1.ObservableClass(false);
                    let movies = new observers_1.ArrayObservable([]);
                    async function load() {
                        if (!reachedEnd.getState() && !isLoading.getState()) {
                            isLoading.updateState(true);
                            let response = await apiclient["GET:/genres/<genre_id>/movies/"]({
                                options: {
                                    genre_id,
                                    token: token ?? "",
                                    offset
                                }
                            });
                            let payload = await response.payload();
                            for (let movie of payload.movies) {
                                movies.append(movie);
                            }
                            offset += payload.movies.length;
                            if (payload.movies.length === 0) {
                                reachedEnd.updateState(true);
                            }
                            isLoading.updateState(false);
                        }
                    }
                    ;
                    mount.appendChild(xml.element("div")
                        .add(xml.element("div.content")
                        .add(renderTextHeader(xml.text(genre.title))))
                        .add(shows.length === 0 ? undefined : xml.element("div.content")
                        .set("style", "display: grid; gap: 24px;")
                        .add(renderTextHeader(xml.text("Shows")))
                        .add(carouselFactory.make(new observers_1.ArrayObservable(shows.map((show) => EntityCard.forShow(show))))))
                        .add(xml.element("div.content")
                        .bind("data-hide", movies.compute((movies) => movies.length === 0))
                        .set("style", "display: grid; gap: 24px;")
                        .add(renderTextHeader(xml.text("Movies")))
                        .add(Grid.make()
                        .repeat(movies, (movie) => EntityCard.forMovie(movie))))
                        .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                        .render());
                });
            });
        }
        else if ((parts = /^video[/]genres[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            apiclient["GET:/genres/<query>"]({
                options: {
                    query,
                    token: token ?? "",
                    offset: 0,
                    limit: 1000
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let genres = payload.genres;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(Grid.make({ mini: true })
                    .add(...genres.map((genre) => makeIconLink(Icon.makePieChart(), genre.title, `video/genres/${genre.genre_id}/`)))))
                    .render());
            });
        }
        else if ((parts = /^video[/]/.exec(uri)) !== null) {
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let movies = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient.getNewMovies({
                        options: {
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let movie of payload.movies) {
                        movies.append(movie);
                    }
                    offset += payload.movies.length;
                    if (payload.movies.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(Grid.make({ mini: true })
                .add(makeIconLink(Icon.makeStar(), "Movies", "video/movies/"))
                .add(makeIconLink(Icon.makeMonitor(), "Shows", "video/shows/"))
                .add(makeIconLink(Icon.makePieChart(), "Genres", "video/genres/"))
                .add(makeIconLink(Icon.makePerson(), "Actors", "actors/")))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px")
                .bind("data-hide", movies.compute((movies) => movies.length === 0))
                .add(renderTextHeader(xml.text("Recently added movies")))
                .add(Grid.make()
                .repeat(movies, (movie) => EntityCard.forMovie(movie)))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^search[/]([^/?]*)/.exec(uri)) !== null) {
            function getBoolean(uri, key) {
                let url = new URL(uri, window.location.origin);
                let value = url.searchParams.get(key);
                if (value === "true") {
                    return true;
                }
                if (value === "false") {
                    return false;
                }
            }
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let cues = new observers_1.ObservableClass(getBoolean(uri, "cues") ?? false);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let entities = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/<query>"]({
                        options: {
                            query: query.getState(),
                            token: token ?? "",
                            offset,
                            cues: cues.getState()
                        }
                    });
                    let payload = await response.payload();
                    for (let entity of payload.entities) {
                        entities.append(entity);
                    }
                    offset += payload.entities.length;
                    if (payload.entities.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            function doSearch() {
                let uri = `search/${encodeURIComponent(query.getState())}?cues=${cues.getState()}`;
                window.history.replaceState({ ...window.history.state, uri }, "", uri);
                offset = 0;
                reachedEnd.updateState(false);
                entities.update([]);
                load();
            }
            let headEntities = new observers_1.ArrayObservable([]);
            let tailEntities = new observers_1.ArrayObservable([]);
            entities.addObserver({
                onappend(entity) {
                    if (headEntities.getState().length === 0) {
                        headEntities.append(entity);
                    }
                    else {
                        tailEntities.append(entity);
                    }
                },
                onsplice(entity, index) {
                    if (index === 0) {
                        headEntities.update([]);
                    }
                    else {
                        tailEntities.splice(index - 1);
                    }
                }
            });
            mount.appendChild(xml.element("div.content")
                .add(xml.element("div")
                .set("style", "align-items: center; display: grid; gap: 16px; grid-template-columns: 1fr auto;")
                .add(xml.element("div")
                .set("style", "position: relative;")
                .add(xml.element("input")
                .set("type", "text")
                .set("spellcheck", "false")
                .set("placeholder", "Search...")
                .bind2("value", query)
                .on("keyup", (event) => {
                if (event.code === "Enter") {
                    event.target.blur();
                }
            })
                .on("blur", () => {
                doSearch();
            }))
                .add(Icon.makeMagnifyingGlass()
                .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
                .add(makeButton()
                .bind("data-active", cues.addObserver(a => a))
                .add(Icon.makeQuotationMark())
                .on("click", () => {
                cues.updateState(!cues.getState());
                doSearch();
            })))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px;")
                .bind("data-hide", headEntities.compute((v) => v.length === 0))
                .repeat(headEntities, (entity) => EntityCard.forEntity(entity, { compactDescription: false })))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .bind("data-hide", tailEntities.compute((v) => v.length === 0))
                .repeat(tailEntities, (entity) => EntityRow.forEntity(entity)))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^years[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let year_id = decodeURIComponent(parts[1]);
            apiclient["GET:/years/<year_id>/"]({
                options: {
                    year_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let year = payload.year;
                apiclient["GET:/years/<year_id>/movies/"]({
                    options: {
                        year_id,
                        token: token ?? "",
                        offset: 0,
                        limit: 1000
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    let movies = payload.movies;
                    apiclient["GET:/years/<year_id>/albums/"]({
                        options: {
                            year_id,
                            token: token ?? "",
                            offset: 0,
                            limit: 1000
                        }
                    }).then(async (response) => {
                        let payload = await response.payload();
                        let albums = payload.albums;
                        mount.appendChild(xml.element("div")
                            .add(xml.element("div.content")
                            .add(renderTextHeader(xml.text(`${year.year}`)))
                            .add(xml.element("div")
                            .set("style", "display: grid; gap: 24px;")
                            .set("data-hide", `${movies.length === 0}`)
                            .add(renderTextHeader(xml.text("Movies")))
                            .add(carouselFactory.make(new observers_1.ArrayObservable(movies.map((movie) => EntityCard.forMovie(movie))))))
                            .add(xml.element("div")
                            .set("style", "display: grid; gap: 24px;")
                            .set("data-hide", `${albums.length === 0}`)
                            .add(renderTextHeader(xml.text("Albums")))
                            .add(Grid.make()
                            .add(...albums.map((album) => EntityCard.forAlbum(album))))))
                            .render());
                    });
                });
            });
        }
        else if ((parts = /^years[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            apiclient["GET:/years/<query>"]({
                options: {
                    query,
                    token: token ?? "",
                    offset: 0,
                    limit: 1000
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let years = payload.years;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(Grid.make({ mini: true })
                    .add(...years.map((year) => makeIconLink(Icon.makeCalendar(), `${year.year}`, `years/${year.year_id}/`)))))
                    .render());
            });
        }
        else {
            let shows = new observers_1.ArrayObservable([]);
            let albums = new observers_1.ArrayObservable([]);
            verifiedToken.addObserver(async (token) => {
                if (is.present(token)) {
                    {
                        let response = await apiclient["GET:/users/<user_id>/shows/"]({
                            options: {
                                user_id: "",
                                token: token ?? "",
                                offset: 0,
                                limit: 1000
                            }
                        });
                        let payload = await response.payload();
                        shows.update(payload.shows);
                    }
                    {
                        let response = await apiclient["GET:/users/<user_id>/albums/"]({
                            options: {
                                user_id: "",
                                token: token ?? "",
                                offset: 0,
                                limit: 1000
                            }
                        });
                        let payload = await response.payload();
                        albums.update(payload.albums);
                    }
                }
            });
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(Grid.make({ mini: true })
                .add(makeIconLink(Icon.makeMonitor(), "Watch", "video/"))
                .add(makeIconLink(Icon.makeSpeaker(), "Listen", "audio/"))
                .add(makeIconLink(Icon.makeMagnifyingGlass(), "Search", "search/"))
                .add(makeIconLink(Icon.makeCalendar(), "Revisit", "years/")))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px")
                .bind("data-hide", shows.compute((shows) => shows.length === 0))
                .add(renderTextHeader(xml.text("Popular shows")))
                .add(carouselFactory.make((() => {
                let widgets = new observers_1.ArrayObservable([]);
                shows.addObserver({
                    onappend(show) {
                        widgets.append(EntityCard.forShow(show));
                    },
                    onsplice(show, index) {
                        widgets.splice(index);
                    }
                });
                return widgets;
            })())))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px")
                .bind("data-hide", albums.compute((albums) => albums.length === 0))
                .add(renderTextHeader(xml.text("Popular albums")))
                .add(Grid.make()
                .repeat(albums, (album) => EntityCard.forAlbum(album)))))
                .render());
        }
    };
    let get_basehref = () => {
        let element = document.head.querySelector('base[href]');
        if (element !== null) {
            let attribute = element.getAttribute('href');
            if (attribute !== null) {
                return attribute;
            }
        }
        return "/";
    };
    let get_route = (pathname = window.location.pathname, basehref = get_basehref()) => {
        let pn = pathname.split('/');
        let bh = basehref.split('/');
        let i = 0;
        while (i < pn.length && i < bh.length && pn[i] === bh[i]) {
            i++;
        }
        let uri = pn.slice(i).join('/') + window.location.search;
        //return uri === '' ? './' : uri;
        return uri;
    };
    let mount_cache = new Array();
    let mounted_uri;
    function navigate(uri, use_cache = false) {
        hideModalMenu();
        if (is.absent(verifiedToken.getState())) {
            while (is.present(mount.lastChild)) {
                mount.lastChild.remove();
            }
            mount.appendChild(xml.element("div.content.content--narrow")
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px;")
                .add(renderTextHeader(xml.text("Not logged in")))
                .add(renderTextParagraph(xml.text("Please login using your credentials or register a new user using a registration key. Registration keys can be obtained from the circus manager and are consumed upon successful registration."))))
                .add(xml.element("button")
                .add(xml.text("Login or register"))
                .on("click", async () => {
                showModal.updateState("login");
            }))
                .render());
            return;
        }
        if (is.present(mounted_uri)) {
            let entry = mount_cache.find((entry) => entry.uri === mounted_uri);
            if (is.present(entry)) {
                mount_cache.splice(mount_cache.indexOf(entry), 1);
                entry.x = mount.scrollLeft;
                entry.y = mount.scrollTop;
            }
            else {
                entry = {
                    uri: mounted_uri,
                    element: mount.firstChild,
                    x: mount.scrollLeft,
                    y: mount.scrollTop
                };
            }
            mount_cache.unshift(entry);
        }
        mount_cache = mount_cache.slice(0, 10);
        while (is.present(mount.lastChild)) {
            mount.lastChild.remove();
        }
        let entry = mount_cache.find((entry) => entry.uri === uri);
        if (is.present(entry) && use_cache) {
            mount.appendChild(entry.element);
            mount.scrollLeft = entry.x;
            mount.scrollTop = entry.y;
        }
        else {
            updateviewforuri(uri);
        }
        if (is.absent(window.history.state)) {
            window.history.replaceState({ uri, index: historyIndex.getState() }, "", uri);
        }
        else {
            if (uri !== window.history.state.uri) {
                window.history.pushState({ uri, index: historyIndex.getState() + 1 }, "", uri);
                historyIndex.updateState(historyIndex.getState() + 1);
                historyLength.updateState(historyIndex.getState() + 1);
            }
            else {
                historyIndex.updateState(window.history.state.index);
            }
        }
        mounted_uri = uri;
    }
    function setupRouting() {
        window.addEventListener("popstate", (event) => {
            let uri = event.state.uri;
            navigate(uri, true);
        });
        verifiedToken.addObserver((verifiedToken) => {
            navigate(get_route());
        });
    }
    setupRouting();
});
function define(e,t,l){let n=define;function u(e){return require(e)}null==n.moduleStates&&(n.moduleStates=new Map),null==n.dependentsMap&&(n.dependentsMap=new Map);let d=n.moduleStates.get(e);if(null!=d)throw"Duplicate module found with name "+e+"!";d={callback:l,dependencies:t,module:null},n.moduleStates.set(e,d);for(let l of t){let t=n.dependentsMap.get(l);null==t&&(t=new Set,n.dependentsMap.set(l,t)),t.add(e)}!function e(t){let l=n.moduleStates.get(t);if(null==l||null!=l.module)return;let d=Array(),o={exports:{}};for(let e of l.dependencies){if("require"===e){d.push(u);continue}if("module"===e){d.push(o);continue}if("exports"===e){d.push(o.exports);continue}try{d.push(u(e));continue}catch(e){}let t=n.moduleStates.get(e);if(null==t||null==t.module)return;d.push(t.module.exports)}l.callback(...d),l.module=o;let p=n.dependentsMap.get(t);if(null!=p)for(let t of p)e(t)}(e)}