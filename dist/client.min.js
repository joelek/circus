var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
define("build/client/browserMediaSession", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.update = exports.setHandlers = exports.setMetadata = void 0;
    let storedMetadata;
    let storedHandlers;
    function setMetadata(metadata) {
        if (navigator.mediaSession) {
            storedMetadata = new MediaMetadata(metadata);
        }
    }
    exports.setMetadata = setMetadata;
    function setHandlers(handlers) {
        if (navigator.mediaSession) {
            storedHandlers = handlers;
        }
    }
    exports.setHandlers = setHandlers;
    function update() {
        if (navigator.mediaSession) {
            navigator.mediaSession.metadata = storedMetadata ?? null;
            for (let key in storedHandlers) {
                navigator.mediaSession.setActionHandler(key, storedHandlers[key]);
            }
        }
    }
    exports.update = update;
});
define("build/observers/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayObservable = exports.computed = exports.ObservableClass = void 0;
    class ObservableClass {
        state;
        observers;
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer, alwaysNotify) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push({
                observer: (state) => {
                    observable.updateState(observer(state));
                },
                alwaysNotify
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return this.state;
        }
        updateState(state) {
            let didChange = state !== this.state;
            this.state = state;
            for (let observer of this.observers) {
                if (didChange || observer.alwaysNotify) {
                    observer.observer(this.state);
                }
            }
        }
    }
    exports.ObservableClass = ObservableClass;
    // The computer is called once for every observable.
    function computed(computer, ...observables) {
        let observable = new ObservableClass(computer(...observables.map((observable) => observable.getState())));
        let updater = () => {
            observable.updateState(computer(...observables.map((observable) => observable.getState())));
        };
        for (let observable of observables) {
            observable.addObserver(updater);
        }
        return observable;
    }
    exports.computed = computed;
    class ArrayObservable {
        state;
        observers;
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer) {
            this.observers.push(observer);
            for (let [index, value] of this.state.entries()) {
                observer.onappend?.(value, index);
            }
        }
        compute(observer) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push({
                onappend: (state) => {
                    observable.updateState(observer(this.state));
                },
                onsplice: (state, index) => {
                    observable.updateState(observer(this.state));
                }
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return [...this.state];
        }
        append(state) {
            this.state.push(state);
            for (let observer of this.observers) {
                observer.onappend?.(state, this.state.length - 1);
            }
        }
        splice(index) {
            if (index < 0 || index >= this.state.length) {
                throw `Expected an index of at most ${this.state.length}, got ${index}!`;
            }
            let state = this.state[index];
            this.state.splice(index, 1);
            for (let observer of this.observers) {
                observer.onsplice?.(state, index);
            }
        }
        update(state) {
            for (let i = this.state.length - 1; i >= 0; i--) {
                this.splice(i);
            }
            for (let v of state) {
                this.append(v);
            }
        }
    }
    exports.ArrayObservable = ArrayObservable;
});
define("build/is", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.present = exports.absent = void 0;
    function absent(subject) {
        return subject == null;
    }
    exports.absent = absent;
    ;
    function present(subject) {
        return subject != null;
    }
    exports.present = present;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageSerializer = exports.MessageGuardError = exports.MessageGuardBase = void 0;
    ;
    class MessageGuardBase {
        constructor() { }
        is(subject, path) {
            try {
                this.as(subject, path);
                return true;
            }
            catch (error) {
                return false;
            }
        }
        decode(codec, buffer) {
            return this.as(codec.decode(buffer));
        }
        encode(codec, subject) {
            return codec.encode(this.as(subject));
        }
    }
    exports.MessageGuardBase = MessageGuardBase;
    ;
    class MessageGuardError {
        constructor(guard, subject, path) {
            this.guard = guard;
            this.subject = subject;
            this.path = path;
        }
        getSubjectType() {
            if (this.subject === null) {
                return "null";
            }
            if (this.subject instanceof Array) {
                return "array";
            }
            return typeof this.subject;
        }
        toString() {
            return `The type ${this.getSubjectType()} at ${this.path} is type-incompatible with the expected type: ${this.guard.ts()}`;
        }
    }
    exports.MessageGuardError = MessageGuardError;
    ;
    class MessageSerializer {
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let json = JSON.parse(string);
            if ((json != null) && (json.constructor === Object)) {
                if ((json.type != null) && (json.type.constructor === String)) {
                    let type = json.type;
                    let data = json.data;
                    let guard = this.guards[type];
                    if (guard === undefined) {
                        throw "Unknown message type \"" + String(type) + "\"!";
                    }
                    cb(type, guard.as(data));
                    return;
                }
            }
            throw "Invalid message envelope!";
        }
        serialize(type, data) {
            return JSON.stringify({
                type,
                data
            });
        }
    }
    exports.MessageSerializer = MessageSerializer;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/guards", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization"], function (require, exports, serialization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Union = exports.UnionGuard = exports.Undefined = exports.UndefinedGuard = exports.Tuple = exports.TupleGuard = exports.StringLiteral = exports.StringLiteralGuard = exports.String = exports.StringGuard = exports.Reference = exports.ReferenceGuard = exports.Record = exports.RecordGuard = exports.Object = exports.ObjectGuard = exports.NumberLiteral = exports.NumberLiteralGuard = exports.Number = exports.NumberGuard = exports.Null = exports.NullGuard = exports.Intersection = exports.IntersectionGuard = exports.Integer = exports.IntegerGuard = exports.Group = exports.GroupGuard = exports.BooleanLiteral = exports.BooleanLiteralGuard = exports.Boolean = exports.BooleanGuard = exports.Binary = exports.BinaryGuard = exports.BigInt = exports.BigIntGuard = exports.Array = exports.ArrayGuard = exports.Any = exports.AnyGuard = void 0;
    class AnyGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            return subject;
        }
        ts(eol = "\n") {
            return "any";
        }
    }
    exports.AnyGuard = AnyGuard;
    ;
    exports.Any = new AnyGuard();
    class ArrayGuard extends serialization.MessageGuardBase {
        constructor(guard) {
            super();
            this.guard = guard;
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Array)) {
                for (let i = 0; i < subject.length; i++) {
                    this.guard.as(subject[i], path + "[" + i + "]");
                }
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return `array<${this.guard.ts(eol)}>`;
        }
    }
    exports.ArrayGuard = ArrayGuard;
    ;
    exports.Array = {
        of(guard) {
            return new ArrayGuard(guard);
        }
    };
    class BigIntGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.BigInt)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "bigint";
        }
    }
    exports.BigIntGuard = BigIntGuard;
    ;
    exports.BigInt = new BigIntGuard();
    class BinaryGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if ((subject != null) && (subject instanceof Uint8Array)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "binary";
        }
    }
    exports.BinaryGuard = BinaryGuard;
    ;
    exports.Binary = new BinaryGuard();
    class BooleanGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Boolean)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "boolean";
        }
    }
    exports.BooleanGuard = BooleanGuard;
    ;
    exports.Boolean = new BooleanGuard();
    class BooleanLiteralGuard extends serialization.MessageGuardBase {
        constructor(value) {
            super();
            this.value = value;
        }
        as(subject, path = "") {
            if (subject === this.value) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return `${this.value}`;
        }
    }
    exports.BooleanLiteralGuard = BooleanLiteralGuard;
    ;
    exports.BooleanLiteral = {
        of(value) {
            return new BooleanLiteralGuard(value);
        }
    };
    class GroupGuard extends serialization.MessageGuardBase {
        constructor(guard, name) {
            super();
            this.guard = guard;
            this.name = name;
        }
        as(subject, path = "") {
            return this.guard.as(subject, path);
        }
        ts(eol = "\n") {
            var _a;
            return (_a = this.name) !== null && _a !== void 0 ? _a : this.guard.ts(eol);
        }
    }
    exports.GroupGuard = GroupGuard;
    ;
    exports.Group = {
        of(guard, name) {
            return new GroupGuard(guard, name);
        }
    };
    class IntegerGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Number) && globalThis.Number.isInteger(subject)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "number";
        }
    }
    exports.IntegerGuard = IntegerGuard;
    ;
    exports.Integer = new IntegerGuard();
    class IntersectionGuard extends serialization.MessageGuardBase {
        constructor(...guards) {
            super();
            this.guards = guards;
        }
        as(subject, path = "") {
            for (let guard of this.guards) {
                guard.as(subject, path);
            }
            return subject;
        }
        ts(eol = "\n") {
            let lines = new globalThis.Array();
            for (let guard of this.guards) {
                lines.push("\t" + guard.ts(eol + "\t"));
            }
            return lines.length === 0 ? "intersection<>" : "intersection<" + eol + lines.join("," + eol) + eol + ">";
        }
    }
    exports.IntersectionGuard = IntersectionGuard;
    ;
    exports.Intersection = {
        of(...guards) {
            return new IntersectionGuard(...guards);
        }
    };
    class NullGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if (subject === null) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "null";
        }
    }
    exports.NullGuard = NullGuard;
    ;
    exports.Null = new NullGuard();
    class NumberGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Number)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "number";
        }
    }
    exports.NumberGuard = NumberGuard;
    ;
    exports.Number = new NumberGuard();
    class NumberLiteralGuard extends serialization.MessageGuardBase {
        constructor(value) {
            super();
            this.value = value;
        }
        as(subject, path = "") {
            if (subject === this.value) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return `${this.value}`;
        }
    }
    exports.NumberLiteralGuard = NumberLiteralGuard;
    ;
    exports.NumberLiteral = {
        of(value) {
            return new NumberLiteralGuard(value);
        }
    };
    class ObjectGuard extends serialization.MessageGuardBase {
        constructor(required, optional) {
            super();
            this.required = required;
            this.optional = optional;
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Object)) {
                for (let key in this.required) {
                    this.required[key].as(subject[key], path + (/^([a-z][a-z0-9_]*)$/isu.test(key) ? "." + key : "[\"" + key + "\"]"));
                }
                for (let key in this.optional) {
                    if (key in subject && subject[key] !== undefined) {
                        this.optional[key].as(subject[key], path + (/^([a-z][a-z0-9_]*)$/isu.test(key) ? "." + key : "[\"" + key + "\"]"));
                    }
                }
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            let lines = new globalThis.Array();
            for (let [key, value] of globalThis.Object.entries(this.required)) {
                lines.push(`\t"${key}": ${value.ts(eol + "\t")}`);
            }
            for (let [key, value] of globalThis.Object.entries(this.optional)) {
                lines.push(`\t"${key}"?: ${value.ts(eol + "\t")}`);
            }
            return lines.length === 0 ? "object<>" : "object<" + eol + lines.join("," + eol) + eol + ">";
        }
    }
    exports.ObjectGuard = ObjectGuard;
    ;
    exports.Object = {
        of(required, optional = {}) {
            return new ObjectGuard(required, optional);
        }
    };
    class RecordGuard extends serialization.MessageGuardBase {
        constructor(guard) {
            super();
            this.guard = guard;
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Object)) {
                let wrapped = exports.Union.of(exports.Undefined, this.guard);
                for (let key of globalThis.Object.keys(subject)) {
                    wrapped.as(subject[key], path + "[\"" + key + "\"]");
                }
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return `record<${this.guard.ts(eol)}>`;
        }
    }
    exports.RecordGuard = RecordGuard;
    ;
    exports.Record = {
        of(guard) {
            return new RecordGuard(guard);
        }
    };
    class ReferenceGuard extends serialization.MessageGuardBase {
        constructor(guard) {
            super();
            this.guard = guard;
        }
        as(subject, path = "") {
            return this.guard().as(subject, path);
        }
        ts(eol = "\n") {
            return this.guard().ts(eol);
        }
    }
    exports.ReferenceGuard = ReferenceGuard;
    ;
    exports.Reference = {
        of(guard) {
            return new ReferenceGuard(guard);
        }
    };
    class StringGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.String)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "string";
        }
    }
    exports.StringGuard = StringGuard;
    ;
    exports.String = new StringGuard();
    class StringLiteralGuard extends serialization.MessageGuardBase {
        constructor(value) {
            super();
            this.value = value;
        }
        as(subject, path = "") {
            if (subject === this.value) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return `"${this.value}"`;
        }
    }
    exports.StringLiteralGuard = StringLiteralGuard;
    ;
    exports.StringLiteral = {
        of(value) {
            return new StringLiteralGuard(value);
        }
    };
    class TupleGuard extends serialization.MessageGuardBase {
        constructor(...guards) {
            super();
            this.guards = guards;
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Array)) {
                for (let i = 0; i < this.guards.length; i++) {
                    this.guards[i].as(subject[i], path + "[" + i + "]");
                }
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            let lines = new globalThis.Array();
            for (let guard of this.guards) {
                lines.push(`\t${guard.ts(eol + "\t")}`);
            }
            return lines.length === 0 ? "tuple<>" : "tuple<" + eol + lines.join("," + eol) + eol + ">";
        }
    }
    exports.TupleGuard = TupleGuard;
    ;
    exports.Tuple = {
        of(...guards) {
            return new TupleGuard(...guards);
        }
    };
    class UndefinedGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if (subject === undefined) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "undefined";
        }
    }
    exports.UndefinedGuard = UndefinedGuard;
    ;
    exports.Undefined = new UndefinedGuard();
    class UnionGuard extends serialization.MessageGuardBase {
        constructor(...guards) {
            super();
            this.guards = guards;
        }
        as(subject, path = "") {
            for (let guard of this.guards) {
                try {
                    return guard.as(subject, path);
                }
                catch (error) { }
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            let lines = new globalThis.Array();
            for (let guard of this.guards) {
                lines.push("\t" + guard.ts(eol + "\t"));
            }
            return lines.length === 0 ? "union<>" : "union<" + eol + lines.join("," + eol) + eol + ">";
        }
    }
    exports.UnionGuard = UnionGuard;
    ;
    exports.Union = {
        of(...guards) {
            return new UnionGuard(...guards);
        }
    };
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/api", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards"], function (require, exports, guards) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __asyncValues = (this && this.__asyncValues) || function (o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapMessageGuard = exports.deserializePayload = exports.deserializeStringPayload = exports.compareArrays = exports.serializePayload = exports.serializeStringPayload = exports.collectPayload = exports.deserializeValue = exports.serializeValue = exports.Headers = exports.Options = exports.JSON = exports.Primitive = exports.Binary = exports.SyncBinary = exports.AsyncBinary = exports.decodeUndeclaredHeaders = exports.decodeHeaderValue = exports.decodeHeaderValues = exports.decodeUndeclaredParameters = exports.decodeParameterValue = exports.decodeParameterValues = exports.encodeUndeclaredParameterPairs = exports.encodeParameterPairs = exports.escapeParameterValue = exports.escapeParameterKey = exports.encodeComponents = exports.escapeComponent = exports.encodeUndeclaredHeaderPairs = exports.encodeHeaderPairs = exports.escapeHeaderValue = exports.escapeHeaderKey = exports.splitHeaders = exports.combineParameters = exports.splitParameters = exports.combineComponents = exports.splitComponents = exports.decodeURIComponent = void 0;
    function decodeURIComponent(string) {
        try {
            return globalThis.decodeURIComponent(string);
        }
        catch (error) { }
    }
    exports.decodeURIComponent = decodeURIComponent;
    ;
    function splitComponents(url) {
        let components = new Array();
        for (let part of url.split("?")[0].split("/").slice(1)) {
            components.push(part);
        }
        return components;
    }
    exports.splitComponents = splitComponents;
    ;
    function combineComponents(components) {
        return "/" + components.join("/");
    }
    exports.combineComponents = combineComponents;
    ;
    function splitParameters(url) {
        let parameters = new Array();
        let query = url.split("?").slice(1).join("?");
        if (query !== "") {
            for (let part of query.split("&")) {
                let parts = part.split("=");
                if (parts.length === 1) {
                    let key = parts[0];
                    let value = "";
                    parameters.push([key, value]);
                }
                else {
                    let key = parts[0];
                    let value = parts.slice(1).join("=");
                    parameters.push([key, value]);
                }
            }
        }
        return parameters;
    }
    exports.splitParameters = splitParameters;
    ;
    function combineParameters(parameters) {
        let parts = parameters.map((parameters) => {
            let key = parameters[0];
            let value = parameters[1];
            return `${key}=${value}`;
        });
        if (parts.length === 0) {
            return "";
        }
        return `?${parts.join("&")}`;
    }
    exports.combineParameters = combineParameters;
    ;
    function splitHeaders(lines) {
        return lines.map((part) => {
            let parts = part.split(":");
            if (parts.length === 1) {
                let key = parts[0].toLowerCase();
                let value = "";
                return [key, value];
            }
            else {
                let key = parts[0].toLowerCase();
                let value = parts.slice(1).join(":").trim();
                return [key, value];
            }
        });
    }
    exports.splitHeaders = splitHeaders;
    ;
    const RFC7320_DELIMITERS = "\"(),/:;<=>?@[\\]{}";
    const RFC7320_WHITESPACE = "\t ";
    // The specification (rfc7320) allows octets 33-126 and forbids delimiters. Octets 128-255 have been deprecated since rfc2616.
    function escapeHeaderKey(string, alwaysEncode = "") {
        return escapeHeaderValue(string, RFC7320_DELIMITERS + RFC7320_WHITESPACE + alwaysEncode);
    }
    exports.escapeHeaderKey = escapeHeaderKey;
    ;
    // The specification (rfc7320) allows octets 33-126 and whitespace. Octets 128-255 have been deprecated since rfc2616.
    function escapeHeaderValue(string, alwaysEncode = "") {
        return [...string]
            .map((codePointString) => {
            var _a;
            if (!alwaysEncode.includes(codePointString) && codePointString !== "%") {
                let codePoint = (_a = codePointString.codePointAt(0)) !== null && _a !== void 0 ? _a : 0;
                if (codePoint >= 33 && codePoint <= 126) {
                    return codePointString;
                }
                if (RFC7320_WHITESPACE.includes(codePointString)) {
                    return codePointString;
                }
            }
            return encodeURIComponent(codePointString);
        })
            .join("");
    }
    exports.escapeHeaderValue = escapeHeaderValue;
    ;
    function encodeHeaderPairs(key, values, plain) {
        let pairs = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                if (plain) {
                    pairs.push([
                        escapeHeaderKey(key),
                        escapeHeaderValue(serialized)
                    ]);
                }
                else {
                    pairs.push([
                        escapeHeaderKey(key),
                        escapeHeaderKey(serialized)
                    ]);
                }
            }
        }
        return pairs;
    }
    exports.encodeHeaderPairs = encodeHeaderPairs;
    ;
    function encodeUndeclaredHeaderPairs(record, exclude) {
        let pairs = new Array();
        for (let [key, value] of Object.entries(record)) {
            if (!exclude.includes(key) && value !== undefined) {
                if (guards.String.is(value)) {
                    pairs.push(...encodeHeaderPairs(key, [value], true));
                }
                else if (guards.Array.of(guards.String).is(value)) {
                    pairs.push(...encodeHeaderPairs(key, value, true));
                }
                else {
                    throw `Expected type of undeclared header "${key}" to be string or string[]!`;
                }
            }
        }
        return pairs;
    }
    exports.encodeUndeclaredHeaderPairs = encodeUndeclaredHeaderPairs;
    ;
    function escapeComponent(string) {
        return encodeURIComponent(string);
    }
    exports.escapeComponent = escapeComponent;
    ;
    function encodeComponents(values, plain) {
        let array = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                array.push(escapeComponent(serialized));
            }
        }
        return array;
    }
    exports.encodeComponents = encodeComponents;
    ;
    function escapeParameterKey(string) {
        return encodeURIComponent(string);
    }
    exports.escapeParameterKey = escapeParameterKey;
    ;
    function escapeParameterValue(string) {
        return encodeURIComponent(string);
    }
    exports.escapeParameterValue = escapeParameterValue;
    ;
    function encodeParameterPairs(key, values, plain) {
        let pairs = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                pairs.push([
                    escapeParameterKey(key),
                    escapeParameterValue(serialized)
                ]);
            }
        }
        return pairs;
    }
    exports.encodeParameterPairs = encodeParameterPairs;
    ;
    function encodeUndeclaredParameterPairs(record, exclude) {
        let pairs = new Array();
        for (let [key, value] of Object.entries(record)) {
            if (!exclude.includes(key) && value !== undefined) {
                if (guards.String.is(value)) {
                    pairs.push(...encodeParameterPairs(key, [value], true));
                }
                else if (guards.Array.of(guards.String).is(value)) {
                    pairs.push(...encodeParameterPairs(key, value, true));
                }
                else {
                    throw `Expected type of undeclared parameter "${key}" to be string or string[]!`;
                }
            }
        }
        return pairs;
    }
    exports.encodeUndeclaredParameterPairs = encodeUndeclaredParameterPairs;
    ;
    function decodeParameterValues(pairs, key, plain) {
        let values = new Array();
        for (let pair of pairs) {
            if (key === decodeURIComponent(pair[0])) {
                let parts = pair[1].split(",");
                for (let part of parts) {
                    let value = deserializeValue(decodeURIComponent(part), plain);
                    if (value === undefined) {
                        throw `Expected parameter "${key}" to be properly encoded!`;
                    }
                    values.push(value);
                }
            }
        }
        return values;
    }
    exports.decodeParameterValues = decodeParameterValues;
    ;
    function decodeParameterValue(pairs, key, plain) {
        let values = decodeParameterValues(pairs, key, plain);
        if (values.length > 1) {
            throw `Expected no more than one "${key}" parameter!`;
        }
        return values[0];
    }
    exports.decodeParameterValue = decodeParameterValue;
    ;
    function decodeUndeclaredParameters(pairs, exclude) {
        let map = {};
        for (let pair of pairs) {
            let key = decodeURIComponent(pair[0]);
            let value = decodeURIComponent(pair[1]);
            if (key === undefined || value === undefined) {
                throw `Expected undeclared parameter "${key}" to be properly encoded!`;
            }
            if (!exclude.includes(key)) {
                let values = map[key];
                if (values === undefined) {
                    values = new Array();
                    map[key] = values;
                }
                values.push(value);
            }
        }
        let record = {};
        for (let [key, value] of Object.entries(map)) {
            if (value.length === 1) {
                record[key] = value[0];
            }
            else {
                record[key] = value;
            }
        }
        return record;
    }
    exports.decodeUndeclaredParameters = decodeUndeclaredParameters;
    ;
    function decodeHeaderValues(pairs, key, plain) {
        let values = new Array();
        for (let pair of pairs) {
            if (key === decodeURIComponent(pair[0])) {
                let parts = pair[1].split(",");
                for (let part of parts) {
                    let value = deserializeValue(decodeURIComponent(part.trim()), plain);
                    if (value === undefined) {
                        throw `Expected header "${key}" to be properly encoded!`;
                    }
                    values.push(value);
                }
            }
        }
        return values;
    }
    exports.decodeHeaderValues = decodeHeaderValues;
    ;
    function decodeHeaderValue(pairs, key, plain) {
        let values = decodeHeaderValues(pairs, key, plain);
        if (values.length > 1) {
            throw `Expected no more than one "${key}" header!`;
        }
        return values[0];
    }
    exports.decodeHeaderValue = decodeHeaderValue;
    ;
    function decodeUndeclaredHeaders(pairs, exclude) {
        let map = {};
        for (let pair of pairs) {
            let key = decodeURIComponent(pair[0]);
            let value = decodeURIComponent(pair[1]);
            if (key === undefined || value === undefined) {
                throw `Expected undeclared header "${key}" to be properly encoded!`;
            }
            if (!exclude.includes(key)) {
                let values = map[key];
                if (values === undefined) {
                    values = new Array();
                    map[key] = values;
                }
                values.push(value);
            }
        }
        let record = {};
        for (let [key, value] of Object.entries(map)) {
            if (value.length === 1) {
                record[key] = value[0];
            }
            else {
                record[key] = value;
            }
        }
        return record;
    }
    exports.decodeUndeclaredHeaders = decodeUndeclaredHeaders;
    ;
    exports.AsyncBinary = {
        as(subject, path = "") {
            if (subject != null) {
                let member = subject[Symbol.asyncIterator];
                if (member != null && member.constructor === globalThis.Function) {
                    return subject;
                }
            }
            throw "Expected AsyncBinary at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `AsyncBinary`;
        }
    };
    exports.SyncBinary = {
        as(subject, path = "") {
            if (subject != null) {
                let member = subject[Symbol.iterator];
                if (member != null && member.constructor === globalThis.Function) {
                    return subject;
                }
            }
            throw "Expected SyncBinary at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `SyncBinary`;
        }
    };
    exports.Binary = guards.Union.of(exports.AsyncBinary, exports.SyncBinary);
    exports.Primitive = guards.Union.of(guards.Boolean, guards.Number, guards.String, guards.Undefined);
    exports.JSON = guards.Group.of(guards.Union.of(guards.Boolean, guards.Null, guards.Number, guards.String, guards.Array.of(guards.Reference.of(() => exports.JSON)), guards.Record.of(guards.Reference.of(() => exports.JSON)), guards.Undefined), "JSON");
    exports.Options = guards.Record.of(exports.JSON);
    exports.Headers = guards.Record.of(exports.JSON);
    function serializeValue(value, plain) {
        if (value === undefined) {
            return;
        }
        return plain ? String(value) : globalThis.JSON.stringify(value);
    }
    exports.serializeValue = serializeValue;
    ;
    function deserializeValue(value, plain) {
        if (value === undefined || plain) {
            return value;
        }
        try {
            return globalThis.JSON.parse(value);
        }
        catch (error) { }
    }
    exports.deserializeValue = deserializeValue;
    ;
    function collectPayload(binary) {
        var _a, binary_1, binary_1_1;
        var _b, e_1, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let chunks = new Array();
            let length = 0;
            try {
                for (_a = true, binary_1 = __asyncValues(binary); binary_1_1 = yield binary_1.next(), _b = binary_1_1.done, !_b;) {
                    _d = binary_1_1.value;
                    _a = false;
                    try {
                        let chunk = _d;
                        chunks.push(chunk);
                        length += chunk.length;
                    }
                    finally {
                        _a = true;
                    }
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (!_a && !_b && (_c = binary_1.return))
                        yield _c.call(binary_1);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            let payload = new Uint8Array(length);
            let offset = 0;
            for (let chunk of chunks) {
                payload.set(chunk, offset);
                offset += chunk.length;
            }
            return payload;
        });
    }
    exports.collectPayload = collectPayload;
    ;
    function serializeStringPayload(string) {
        // @ts-ignore
        let encoder = new TextEncoder();
        let array = encoder.encode(string);
        return [array];
    }
    exports.serializeStringPayload = serializeStringPayload;
    ;
    function serializePayload(payload) {
        let serialized = serializeValue(payload, false);
        if (serialized === undefined) {
            return [];
        }
        return serializeStringPayload(serialized);
    }
    exports.serializePayload = serializePayload;
    ;
    function compareArrays(one, two) {
        if (one.length !== two.length) {
            return false;
        }
        for (let i = 0; i < one.length; i++) {
            if (one[i] !== two[i]) {
                return false;
            }
        }
        return true;
    }
    exports.compareArrays = compareArrays;
    ;
    function deserializeStringPayload(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            let buffer = yield collectPayload(binary);
            // @ts-ignore
            let decoder = new TextDecoder();
            let string = decoder.decode(buffer);
            // @ts-ignore
            let encoder = new TextEncoder();
            let encoded = encoder.encode(string);
            if (!compareArrays(buffer, encoded)) {
                throw `Expected payload to be UTF-8 encoded!`;
            }
            return string;
        });
    }
    exports.deserializeStringPayload = deserializeStringPayload;
    ;
    function deserializePayload(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            let string = yield deserializeStringPayload(binary);
            if (string === "") {
                return;
            }
            let value = deserializeValue(string, false);
            if (value === undefined) {
                throw `Expected payload to be JSON encoded!`;
            }
            return value;
        });
    }
    exports.deserializePayload = deserializePayload;
    ;
    function wrapMessageGuard(guard, log) {
        return Object.assign(Object.assign({}, guard), { as(subject, path) {
                if (log) {
                    console.log(subject);
                }
                return guard.as(subject, path);
            } });
    }
    exports.wrapMessageGuard = wrapMessageGuard;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/asserts/integer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntegerAssert = void 0;
    class IntegerAssert {
        constructor() { }
        static atLeast(min, value) {
            this.integer(min);
            this.integer(value);
            if (value < min) {
                throw new Error(`Expected ${value} to be at least ${min}!`);
            }
            return value;
        }
        static atMost(max, value) {
            this.integer(value);
            this.integer(max);
            if (value > max) {
                throw new Error(`Expected ${value} to be at most ${max}!`);
            }
            return value;
        }
        static between(min, value, max) {
            this.integer(min);
            this.integer(value);
            this.integer(max);
            if (value < min || value > max) {
                throw new Error(`Expected ${value} to be between ${min} and ${max}!`);
            }
            return value;
        }
        static exactly(value, expected) {
            this.integer(expected);
            this.integer(value);
            if (value !== expected) {
                throw new Error(`Expected ${value} to be exactly ${expected}!`);
            }
            return value;
        }
        static integer(value) {
            if (!Number.isInteger(value)) {
                throw new Error(`Expected ${value} to be an integer!`);
            }
            return value;
        }
    }
    exports.IntegerAssert = IntegerAssert;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/data/parser", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/asserts/integer"], function (require, exports, integer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    class Parser {
        constructor(buffer, offset) {
            this.buffer = buffer;
            this.offset = offset !== null && offset !== void 0 ? offset : 0;
        }
        chunk(length) {
            length = length !== null && length !== void 0 ? length : this.buffer.length - this.offset;
            if (this.offset + length > this.buffer.length) {
                throw new Error(`Expected to read at least ${length} bytes!`);
            }
            let buffer = this.buffer.slice(this.offset, this.offset + length);
            this.offset += length;
            return buffer;
        }
        eof() {
            return this.offset >= this.buffer.length;
        }
        signed(length, endian) {
            let value = this.unsigned(length, endian);
            let bias = Math.pow(2, (length * 8 - 1));
            if (value >= bias) {
                value -= bias + bias;
            }
            return value;
        }
        try(supplier) {
            let offset = this.offset;
            try {
                return supplier(this);
            }
            catch (error) {
                this.offset = offset;
                throw error;
            }
        }
        tryArray(suppliers) {
            let offset = this.offset;
            for (let supplier of suppliers) {
                try {
                    return supplier(this);
                }
                catch (error) {
                    this.offset = offset;
                }
            }
            throw new Error(`Expected one supplier to succeed!`);
        }
        unsigned(length, endian) {
            integer_1.IntegerAssert.between(1, length, 6);
            if (this.offset + length > this.buffer.length) {
                throw new Error(`Expected to read at least ${length} bytes!`);
            }
            if (endian === "little") {
                let value = 0;
                for (let i = length - 1; i >= 0; i--) {
                    value *= 256;
                    value += this.buffer[this.offset + i];
                }
                this.offset += length;
                return value;
            }
            else {
                let value = 0;
                for (let i = 0; i < length; i++) {
                    value *= 256;
                    value += this.buffer[this.offset + i];
                }
                this.offset += length;
                return value;
            }
        }
    }
    exports.Parser = Parser;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/data/chunk", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chunk = void 0;
    class Chunk {
        constructor() { }
        static fromString(string, encoding) {
            if (encoding === "binary") {
                let bytes = new Array();
                for (let i = 0; i < string.length; i += 1) {
                    let byte = string.charCodeAt(i);
                    bytes.push(byte);
                }
                return Uint8Array.from(bytes);
            }
            if (encoding === "base64") {
                // @ts-ignore
                return Chunk.fromString(atob(string), "binary");
            }
            if (encoding === "base64url") {
                return Chunk.fromString(string.replaceAll("-", "+").replaceAll("_", "/"), "base64");
            }
            if (encoding === "hex") {
                if (string.length % 2 === 1) {
                    string = `0${string}`;
                }
                let bytes = new Array();
                for (let i = 0; i < string.length; i += 2) {
                    let part = string.slice(i, i + 2);
                    let byte = Number.parseInt(part, 16);
                    bytes.push(byte);
                }
                return Uint8Array.from(bytes);
            }
            // @ts-ignore
            return new TextEncoder().encode(string);
        }
        static toString(chunk, encoding) {
            if (encoding === "binary") {
                let parts = new Array();
                for (let byte of chunk) {
                    let part = String.fromCharCode(byte);
                    parts.push(part);
                }
                return parts.join("");
            }
            if (encoding === "base64") {
                // @ts-ignore
                return btoa(Chunk.toString(chunk, "binary"));
            }
            if (encoding === "base64url") {
                return Chunk.toString(chunk, "base64").replaceAll("+", "-").replaceAll("/", "_").replaceAll("=", "");
            }
            if (encoding === "hex") {
                let parts = new Array();
                for (let byte of chunk) {
                    let part = byte.toString(16).toUpperCase().padStart(2, "0");
                    parts.push(part);
                }
                return parts.join("");
            }
            // @ts-ignore
            return new TextDecoder().decode(chunk);
        }
        static equals(one, two) {
            return this.comparePrefixes(one, two) === 0;
        }
        static comparePrefixes(one, two) {
            for (let i = 0; i < Math.min(one.length, two.length); i++) {
                let a = one[i];
                let b = two[i];
                if (a < b) {
                    return -1;
                }
                if (a > b) {
                    return 1;
                }
            }
            if (one.length < two.length) {
                return -1;
            }
            if (one.length > two.length) {
                return 1;
            }
            return 0;
        }
        static concat(buffers) {
            let length = buffers.reduce((sum, buffer) => sum + buffer.length, 0);
            let result = new Uint8Array(length);
            let offset = 0;
            for (let buffer of buffers) {
                result.set(buffer, offset);
                offset += buffer.length;
            }
            return result;
        }
    }
    exports.Chunk = Chunk;
    ;
});
define("node_modules/@joelek/bedrock/dist/lib/utils", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/asserts/integer", "node_modules/@joelek/ts-stdlib/dist/lib/data/parser", "node_modules/@joelek/ts-stdlib/dist/lib/asserts/integer", "node_modules/@joelek/ts-stdlib/dist/lib/data/chunk", "node_modules/@joelek/ts-stdlib/dist/lib/data/parser"], function (require, exports, integer_1, parser_1, integer_2, chunk_1, parser_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VarLength = exports.VarInteger = exports.VarCategory = exports.Parser = exports.Chunk = exports.IntegerAssert = void 0;
    Object.defineProperty(exports, "IntegerAssert", { enumerable: true, get: function () { return integer_2.IntegerAssert; } });
    Object.defineProperty(exports, "Chunk", { enumerable: true, get: function () { return chunk_1.Chunk; } });
    Object.defineProperty(exports, "Parser", { enumerable: true, get: function () { return parser_2.Parser; } });
    class VarCategory {
        constructor() { }
        static decode(parser, maxBytes = 8) {
            parser = parser instanceof parser_1.Parser ? parser : new parser_1.Parser(parser);
            return parser.try((parser) => {
                let value = 0;
                for (let i = 0; i < maxBytes; i++) {
                    let byte = parser.unsigned(1);
                    let asis = (byte >> 7) & 0x01;
                    let cont = (byte >> 6) & 0x01;
                    if (asis === 0) {
                        let bits = ~byte & 0x3F;
                        value = value + bits;
                        if (cont === 1) {
                            value = value + 1;
                            value = 0 - value;
                            return value;
                        }
                        if (i === 0 && bits === 0) {
                            throw new Error(`Expected a distinguished encoding!`);
                        }
                    }
                    else {
                        let bits = byte & 0x3F;
                        value = value + bits;
                        if (cont === 0) {
                            return value;
                        }
                        if (i === 0 && bits === 0) {
                            throw new Error(`Expected a distinguished encoding!`);
                        }
                    }
                }
                throw new Error(`Expected to decode at most ${maxBytes} bytes!`);
            });
        }
        ;
        static encode(value, maxBytes = 8) {
            integer_1.IntegerAssert.integer(value);
            let bytes = new Array();
            if (value >= 0) {
                do {
                    let bits = value > 63 ? 63 : value;
                    value = value - bits;
                    bytes.push(128 + bits);
                } while (value > 0);
                for (let i = 0; i < bytes.length - 1; i++) {
                    bytes[i] += 64;
                }
            }
            else {
                value = 0 - value;
                value = value - 1;
                do {
                    let bits = value > 63 ? 63 : value;
                    value = value - bits;
                    bytes.push(~bits & 0x3F);
                } while (value > 0);
                bytes[bytes.length - 1] += 64;
            }
            if (bytes.length > maxBytes) {
                throw new Error(`Expected to encode at most ${maxBytes} bytes!`);
            }
            return Uint8Array.from(bytes);
        }
        ;
    }
    exports.VarCategory = VarCategory;
    ;
    class VarInteger {
        constructor() { }
        static decode(parser, maxBytes = 8) {
            parser = parser instanceof parser_1.Parser ? parser : new parser_1.Parser(parser);
            return parser.try((parser) => {
                let value = 0;
                for (let i = 0; i < maxBytes; i++) {
                    let byte = parser.unsigned(1);
                    let asis = (byte >> 7) & 0x01;
                    let cont = (byte >> 6) & 0x01;
                    if (asis === 0) {
                        let bits = ~byte & 0x3F;
                        value = (value * 64) + bits;
                        if (cont === 1) {
                            value = value + 1;
                            value = 0 - value;
                            return value;
                        }
                        if (i === 0 && bits === 0) {
                            throw new Error(`Expected a distinguished encoding!`);
                        }
                    }
                    else {
                        let bits = byte & 0x3F;
                        value = (value * 64) + bits;
                        if (cont === 0) {
                            return value;
                        }
                        if (i === 0 && bits === 0) {
                            throw new Error(`Expected a distinguished encoding!`);
                        }
                    }
                }
                throw new Error(`Expected to decode at most ${maxBytes} bytes!`);
            });
        }
        ;
        static encode(value, maxBytes = 8) {
            integer_1.IntegerAssert.integer(value);
            let bytes = new Array();
            if (value >= 0) {
                do {
                    let bits = value % 64;
                    value = Math.floor(value / 64);
                    bytes.push(128 + bits);
                } while (value > 0);
                bytes.reverse();
                for (let i = 0; i < bytes.length - 1; i++) {
                    bytes[i] += 64;
                }
            }
            else {
                value = 0 - value;
                value = value - 1;
                do {
                    let bits = value % 64;
                    value = Math.floor(value / 64);
                    bytes.push(128 + ~bits & 0x3F);
                } while (value > 0);
                bytes.reverse();
                bytes[bytes.length - 1] += 64;
            }
            if (bytes.length > maxBytes) {
                throw new Error(`Expected to encode at most ${maxBytes} bytes!`);
            }
            return Uint8Array.from(bytes);
        }
        ;
    }
    exports.VarInteger = VarInteger;
    ;
    class VarLength {
        constructor() { }
        static decode(parser, maxBytes = 8) {
            parser = parser instanceof parser_1.Parser ? parser : new parser_1.Parser(parser);
            return parser.try((parser) => {
                let value = 0;
                for (let i = 0; i < maxBytes; i++) {
                    let byte = parser.unsigned(1);
                    let cont = (byte >> 7) & 0x01;
                    let bits = (byte >> 0) & 0x7F;
                    value = (value * 128) + bits;
                    if (cont === 0) {
                        return value;
                    }
                    if (i === 0 && bits === 0) {
                        throw new Error(`Expected a distinguished encoding!`);
                    }
                }
                throw new Error(`Expected to decode at most ${maxBytes} bytes!`);
            });
        }
        ;
        static encode(value, maxBytes = 8) {
            integer_1.IntegerAssert.atLeast(0, value);
            let bytes = new Array();
            do {
                let bits = value % 128;
                value = Math.floor(value / 128);
                bytes.push(bits);
            } while (value > 0);
            bytes.reverse();
            for (let i = 0; i < bytes.length - 1; i++) {
                bytes[i] += 128;
            }
            if (bytes.length > maxBytes) {
                throw new Error(`Expected to encode at most ${maxBytes} bytes!`);
            }
            return Uint8Array.from(bytes);
        }
        ;
    }
    exports.VarLength = VarLength;
    ;
});
define("node_modules/@joelek/bedrock/dist/lib/codecs", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/utils"], function (require, exports, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanLiteral = exports.BooleanLiteralCodec = exports.BigIntLiteral = exports.BigIntLiteralCodec = exports.NumberLiteral = exports.NumberLiteralCodec = exports.StringLiteral = exports.StringLiteralCodec = exports.Integer = exports.IntegerCodec = exports.Intersection = exports.IntersectionCodec = exports.Union = exports.UnionCodec = exports.Object = exports.ObjectCodec = exports.Tuple = exports.TupleCodec = exports.Record = exports.RecordCodec = exports.Array = exports.ArrayCodec = exports.Boolean = exports.BooleanCodec = exports.Unknown = exports.UnknownCodec = exports.UnknownValue = exports.Map = exports.MapCodec = exports.List = exports.ListCodec = exports.BigInt = exports.BigIntCodec = exports.Binary = exports.BinaryCodec = exports.String = exports.StringCodec = exports.Number = exports.NumberCodec = exports.True = exports.TrueCodec = exports.False = exports.FalseCodec = exports.Null = exports.NullCodec = exports.Any = exports.AnyCodec = exports.Codec = exports.Tag = exports.Packet = void 0;
    exports.IntegerLiteral = exports.IntegerLiteralCodec = void 0;
    class Packet {
        constructor() { }
        static decode(parser) {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                let length = utils.VarLength.decode(parser);
                let payload = parser.chunk(length);
                return payload;
            });
        }
        static encode(payload) {
            return utils.Chunk.concat([
                utils.VarLength.encode(payload.length),
                payload
            ]);
        }
    }
    exports.Packet = Packet;
    ;
    var Tag;
    (function (Tag) {
        Tag[Tag["NULL"] = 0] = "NULL";
        Tag[Tag["FALSE"] = 1] = "FALSE";
        Tag[Tag["TRUE"] = 2] = "TRUE";
        Tag[Tag["NUMBER"] = 3] = "NUMBER";
        Tag[Tag["STRING"] = 4] = "STRING";
        Tag[Tag["BINARY"] = 5] = "BINARY";
        Tag[Tag["BIGINT"] = 6] = "BIGINT";
        Tag[Tag["LIST"] = 7] = "LIST";
        Tag[Tag["MAP"] = 8] = "MAP";
    })(Tag = exports.Tag || (exports.Tag = {}));
    ;
    class Codec {
        constructor() { }
        decode(parser, path = "") {
            let payload = Packet.decode(parser);
            return this.decodePayload(payload, path);
        }
        encode(subject, path = "") {
            let payload = this.encodePayload(subject, path);
            return Packet.encode(payload);
        }
    }
    exports.Codec = Codec;
    ;
    class AnyCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.tryArray([
                (parser) => exports.Null.decodePayload(parser, path),
                (parser) => exports.False.decodePayload(parser, path),
                (parser) => exports.True.decodePayload(parser, path),
                (parser) => exports.Number.decodePayload(parser, path),
                (parser) => exports.String.decodePayload(parser, path),
                (parser) => exports.Binary.decodePayload(parser, path),
                (parser) => exports.BigInt.decodePayload(parser, path),
                (parser) => exports.List.decodePayload(parser, path),
                (parser) => exports.Map.decodePayload(parser, path),
                (parser) => exports.Unknown.decodePayload(parser, path)
            ]);
        }
        encodePayload(subject, path = "") {
            try {
                return exports.Null.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.False.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.True.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.Number.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.String.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.Binary.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.BigInt.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.List.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.Map.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.Unknown.encodePayload(subject, path);
            }
            catch (error) { }
            throw new Error(`Expected subject to be encodable!`);
        }
    }
    exports.AnyCodec = AnyCodec;
    ;
    exports.Any = new AnyCodec();
    class NullCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.NULL) {
                    throw new Error(`Expected Null at ${path}!`);
                }
                return null;
            });
        }
        encodePayload(subject, path = "") {
            if (subject !== null) {
                throw new Error(`Expected Null at ${path}!`);
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.NULL));
            return utils.Chunk.concat(chunks);
        }
    }
    exports.NullCodec = NullCodec;
    ;
    exports.Null = new NullCodec();
    class FalseCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.FALSE) {
                    throw new Error(`Expected False at ${path}!`);
                }
                return false;
            });
        }
        encodePayload(subject, path = "") {
            if (subject !== false) {
                throw new Error(`Expected False at ${path}!`);
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.FALSE));
            return utils.Chunk.concat(chunks);
        }
    }
    exports.FalseCodec = FalseCodec;
    ;
    exports.False = new FalseCodec();
    class TrueCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.TRUE) {
                    throw new Error(`Expected True at ${path}!`);
                }
                return true;
            });
        }
        encodePayload(subject, path = "") {
            if (subject !== true) {
                throw new Error(`Expected True at ${path}!`);
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.TRUE));
            return utils.Chunk.concat(chunks);
        }
    }
    exports.TrueCodec = TrueCodec;
    ;
    exports.True = new TrueCodec();
    class NumberCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.NUMBER) {
                    throw new Error(`Expected Number at ${path}!`);
                }
                let chunk = parser.chunk(8);
                if (((chunk[0] >> 7) & 0x01) === 0x01) {
                    chunk[0] ^= 0x80;
                    for (let i = 1; i < chunk.length; i++) {
                        chunk[i] ^= 0x00;
                    }
                }
                else {
                    chunk[0] ^= 0xFF;
                    for (let i = 1; i < chunk.length; i++) {
                        chunk[i] ^= 0xFF;
                    }
                }
                let value = new DataView(chunk.buffer).getFloat64(0, false);
                return value;
            });
        }
        encodePayload(subject, path = "") {
            if (subject == null || subject.constructor !== globalThis.Number) {
                throw new Error(`Expected Number at ${path}!`);
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.NUMBER));
            let chunk = new Uint8Array(8);
            new DataView(chunk.buffer).setFloat64(0, subject, false);
            if (((chunk[0] >> 7) & 0x01) === 0x00) {
                chunk[0] ^= 0x80;
                for (let i = 1; i < chunk.length; i++) {
                    chunk[i] ^= 0x00;
                }
            }
            else {
                chunk[0] ^= 0xFF;
                for (let i = 1; i < chunk.length; i++) {
                    chunk[i] ^= 0xFF;
                }
            }
            chunks.push(chunk);
            return utils.Chunk.concat(chunks);
        }
    }
    exports.NumberCodec = NumberCodec;
    ;
    exports.Number = new NumberCodec();
    class StringCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.STRING) {
                    throw new Error(`Expected String at ${path}!`);
                }
                let value = utils.Chunk.toString(parser.chunk(), "utf-8");
                return value;
            });
        }
        encodePayload(subject, path = "") {
            if (subject == null || subject.constructor !== globalThis.String) {
                throw new Error(`Expected String at ${path}!`);
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.STRING));
            chunks.push(utils.Chunk.fromString(subject, "utf-8"));
            return utils.Chunk.concat(chunks);
        }
    }
    exports.StringCodec = StringCodec;
    ;
    exports.String = new StringCodec();
    class BinaryCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.BINARY) {
                    throw new Error(`Expected Binary at ${path}!`);
                }
                let value = parser.chunk();
                return value;
            });
        }
        encodePayload(subject, path = "") {
            if (subject == null || !(subject instanceof globalThis.Uint8Array)) {
                throw new Error(`Expected Binary at ${path}!`);
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.BINARY));
            chunks.push(subject);
            return utils.Chunk.concat(chunks);
        }
    }
    exports.BinaryCodec = BinaryCodec;
    ;
    exports.Binary = new BinaryCodec();
    class BigIntCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.BIGINT) {
                    throw new Error(`Expected BigInt at ${path}!`);
                }
                let category = utils.VarCategory.decode(parser);
                let value = 0n;
                if (category >= 0) {
                    let size = category + 1;
                    for (let i = 0; i < size; i++) {
                        let byte = globalThis.BigInt(parser.unsigned(1));
                        value = value << 8n;
                        value = value | byte;
                    }
                }
                else {
                    let size = 0 - category;
                    for (let i = 0; i < size; i++) {
                        let byte = globalThis.BigInt(~parser.unsigned(1) & 0xFF);
                        value = value << 8n;
                        value = value | byte;
                    }
                    value = value + 1n;
                    value = 0n - value;
                }
                return value;
            });
        }
        encodePayload(subject, path = "") {
            if (subject == null || subject.constructor !== globalThis.BigInt) {
                throw new Error(`Expected BigInt at ${path}!`);
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.BIGINT));
            let bytes = [];
            let value = subject;
            if (value >= 0n) {
                do {
                    let byte = globalThis.Number(value & 0xffn);
                    value = value >> 8n;
                    bytes.push(byte);
                } while (value > 0n);
                let category = utils.VarCategory.encode(bytes.length - 1);
                chunks.push(category);
            }
            else {
                value = 0n - value;
                value = value - 1n;
                do {
                    let byte = ~globalThis.Number(value & 0xffn) & 0xFF;
                    value = value >> 8n;
                    bytes.push(byte);
                } while (value > 0n);
                let category = utils.VarCategory.encode(0 - bytes.length);
                chunks.push(category);
            }
            bytes.reverse();
            chunks.push(Uint8Array.from(bytes));
            return utils.Chunk.concat(chunks);
        }
    }
    exports.BigIntCodec = BigIntCodec;
    ;
    exports.BigInt = new BigIntCodec();
    class ListCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "", decode) {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.LIST) {
                    throw new Error(`Expected List at ${path}!`);
                }
                decode = decode ?? ((key, path, parser) => exports.Any.decode(parser, path));
                let value = [];
                let index = 0;
                while (!parser.eof()) {
                    let subpath = `${path}[${index}]`;
                    value.push(decode(index, subpath, parser));
                    index += 1;
                }
                return value;
            });
        }
        encodePayload(subject, path = "", encode) {
            if (subject == null || subject.constructor !== globalThis.Array) {
                throw new Error(`Expected List at ${path}!`);
            }
            encode = encode ?? ((key, path, subject) => exports.Any.encode(subject, path));
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.LIST));
            for (let index = 0; index < subject.length; index++) {
                let value = subject[index];
                if (value === undefined) {
                    value = null;
                }
                let subpath = `${path}[${index}]`;
                chunks.push(encode(index, subpath, value));
            }
            return utils.Chunk.concat(chunks);
        }
    }
    exports.ListCodec = ListCodec;
    ;
    exports.List = new ListCodec();
    class MapCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "", decode) {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.MAP) {
                    throw new Error(`Expected Map at ${path}!`);
                }
                decode = decode ?? ((key, path, parser) => exports.Any.decode(parser, path));
                let value = {};
                while (!parser.eof()) {
                    let key = exports.String.decode(parser);
                    let subpath = /^[a-z][a-z0-9_]*$/isu.test(key) ? `${path}.${key}` : `${path}["${key}"]`;
                    value[key] = decode(key, subpath, parser);
                }
                return value;
            });
        }
        encodePayload(subject, path = "", encode) {
            if (subject == null || subject.constructor !== globalThis.Object) {
                throw new Error(`Expected Map at ${path}!`);
            }
            encode = encode ?? ((key, path, subject) => exports.Any.encode(subject, path));
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.MAP));
            let pairs = [];
            for (let key in subject) {
                let value = subject[key];
                if (value === undefined) {
                    continue;
                }
                let subpath = /^[a-z][a-z0-9_]*$/isu.test(key) ? `${path}.${key}` : `${path}["${key}"]`;
                pairs.push({
                    key: exports.String.encodePayload(key),
                    value: encode(key, subpath, value)
                });
            }
            pairs.sort((one, two) => utils.Chunk.comparePrefixes(one.key, two.key));
            for (let pair of pairs) {
                chunks.push(Packet.encode(pair.key));
                chunks.push(pair.value);
            }
            return utils.Chunk.concat(chunks);
        }
    }
    exports.MapCodec = MapCodec;
    ;
    exports.Map = new MapCodec();
    class UnknownValue {
        chunk;
        constructor(chunk) {
            utils.IntegerAssert.atLeast(1, chunk.length);
            if (chunk[0] in Tag) {
                throw new Error(`Expected tag ${Tag[chunk[0]]} to be unknown!`);
            }
            this.chunk = chunk;
        }
        getChunk() {
            return this.chunk;
        }
    }
    exports.UnknownValue = UnknownValue;
    ;
    class UnknownCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                let value = parser.chunk();
                return new UnknownValue(value);
            });
        }
        encodePayload(subject, path = "") {
            if (subject == null || subject.constructor !== UnknownValue) {
                throw new Error(`Expected Unknown at ${path}!`);
            }
            let chunks = [];
            chunks.push(subject.getChunk());
            return utils.Chunk.concat(chunks);
        }
    }
    exports.UnknownCodec = UnknownCodec;
    ;
    exports.Unknown = new UnknownCodec();
    class BooleanCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.tryArray([
                (parser) => exports.True.decodePayload(parser, path),
                (parser) => exports.False.decodePayload(parser, path)
            ]);
        }
        encodePayload(subject, path = "") {
            if (subject) {
                return exports.True.encodePayload(subject, path);
            }
            else {
                return exports.False.encodePayload(subject, path);
            }
        }
    }
    exports.BooleanCodec = BooleanCodec;
    ;
    exports.Boolean = new BooleanCodec();
    class ArrayCodec extends Codec {
        codec;
        constructor(codec) {
            super();
            this.codec = codec;
        }
        decodePayload(parser, path = "") {
            return exports.List.decodePayload(parser, path, (index, path, parser) => {
                return this.codec.decode(parser, path);
            });
        }
        encodePayload(subject, path = "") {
            return exports.List.encodePayload(subject, path, (index, path, subject) => {
                return this.codec.encode(subject, path);
            });
        }
    }
    exports.ArrayCodec = ArrayCodec;
    ;
    exports.Array = {
        of(codec) {
            return new ArrayCodec(codec);
        }
    };
    class RecordCodec extends Codec {
        codec;
        constructor(codec) {
            super();
            this.codec = codec;
        }
        decodePayload(parser, path = "") {
            return exports.Map.decodePayload(parser, path, (key, path, parser) => {
                return this.codec.decode(parser, path);
            });
        }
        encodePayload(subject, path = "") {
            return exports.Map.encodePayload(subject, path, (key, path, subject) => {
                return this.codec.encode(subject, path);
            });
        }
    }
    exports.RecordCodec = RecordCodec;
    ;
    exports.Record = {
        of(codec) {
            return new RecordCodec(codec);
        }
    };
    class TupleCodec extends Codec {
        codecs;
        constructor(...codecs) {
            super();
            this.codecs = codecs;
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                let indices = new globalThis.Set(this.codecs.keys());
                let subject = exports.List.decodePayload(parser, path, (index, path, parser) => {
                    indices.delete(index);
                    if (index in this.codecs) {
                        return this.codecs[index].decode(parser, path);
                    }
                    else {
                        return exports.Any.decode(parser, path);
                    }
                });
                if (indices.size !== 0) {
                    throw new Error(`Expected members ${globalThis.Array.from(indices)} to be decoded!`);
                }
                return subject;
            });
        }
        encodePayload(subject, path = "") {
            let indices = new globalThis.Set(this.codecs.keys());
            let payload = exports.List.encodePayload(subject, path, (index, path, subject) => {
                indices.delete(index);
                if (index in this.codecs) {
                    return this.codecs[index].encode(subject, path);
                }
                else {
                    return exports.Any.encode(subject, path);
                }
            });
            if (indices.size !== 0) {
                throw new Error(`Expected members ${globalThis.Array.from(indices)} to be encoded!`);
            }
            return payload;
        }
    }
    exports.TupleCodec = TupleCodec;
    ;
    exports.Tuple = {
        of(...codecs) {
            return new TupleCodec(...codecs);
        }
    };
    class ObjectCodec extends Codec {
        required;
        optional;
        constructor(required, optional) {
            super();
            this.required = required;
            this.optional = optional ?? {};
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                let keys = new Set(globalThis.Object.keys(this.required));
                let subject = exports.Map.decodePayload(parser, path, (key, path, parser) => {
                    keys.delete(key);
                    if (key in this.required) {
                        return this.required[key].decode(parser, path);
                    }
                    else if (key in this.optional) {
                        return this.optional[key].decode(parser, path);
                    }
                    else {
                        return exports.Any.decode(parser, path);
                    }
                });
                if (keys.size !== 0) {
                    throw new Error(`Expected members ${globalThis.Array.from(keys)} to be decoded!`);
                }
                return subject;
            });
        }
        encodePayload(subject, path = "") {
            let keys = new Set(globalThis.Object.keys(this.required));
            let payload = exports.Map.encodePayload(subject, path, (key, path, subject) => {
                keys.delete(key);
                if (key in this.required) {
                    return this.required[key].encode(subject, path);
                }
                else if (key in this.optional) {
                    return this.optional[key].encode(subject, path);
                }
                else {
                    return exports.Any.encode(subject, path);
                }
            });
            if (keys.size !== 0) {
                throw new Error(`Expected members ${globalThis.Array.from(keys)} to be encoded!`);
            }
            return payload;
        }
    }
    exports.ObjectCodec = ObjectCodec;
    ;
    exports.Object = {
        of(required, optional) {
            return new ObjectCodec(required, optional);
        }
    };
    class UnionCodec extends Codec {
        codecs;
        constructor(...codecs) {
            super();
            this.codecs = codecs;
        }
        decodePayload(parser, path = "") {
            for (let codec of this.codecs) {
                try {
                    return codec.decodePayload(parser, path);
                }
                catch (error) { }
            }
            throw new Error(`Expected subject to be decodable!`);
        }
        encodePayload(subject, path = "") {
            for (let codec of this.codecs) {
                try {
                    return codec.encodePayload(subject, path);
                }
                catch (error) { }
            }
            throw new Error(`Expected subject to be encodable!`);
        }
    }
    exports.UnionCodec = UnionCodec;
    ;
    exports.Union = {
        of(...codecs) {
            return new UnionCodec(...codecs);
        }
    };
    class IntersectionCodec extends Codec {
        codecs;
        constructor(...codecs) {
            super();
            this.codecs = codecs;
        }
        decodePayload(parser, path = "") {
            for (let codec of this.codecs) {
                codec.decodePayload(parser, path);
            }
            return exports.Any.decodePayload(parser, path);
        }
        encodePayload(subject, path = "") {
            for (let codec of this.codecs) {
                codec.encodePayload(subject, path);
            }
            return exports.Any.encodePayload(subject, path);
        }
    }
    exports.IntersectionCodec = IntersectionCodec;
    ;
    exports.Intersection = {
        of(...codecs) {
            return new IntersectionCodec(...codecs);
        }
    };
    class IntegerCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            let subject = exports.BigInt.decodePayload(parser, path);
            if (subject < globalThis.BigInt(globalThis.Number.MIN_SAFE_INTEGER)) {
                throw new Error(`Expected ${subject} at ${path} to be within safe range!`);
            }
            if (subject > globalThis.BigInt(globalThis.Number.MAX_SAFE_INTEGER)) {
                throw new Error(`Expected ${subject} at ${path} to be within safe range!`);
            }
            return globalThis.Number(subject);
        }
        encodePayload(subject, path = "") {
            return exports.BigInt.encodePayload(globalThis.BigInt(subject), path);
        }
    }
    exports.IntegerCodec = IntegerCodec;
    ;
    exports.Integer = new IntegerCodec();
    class StringLiteralCodec extends Codec {
        value;
        constructor(value) {
            super();
            this.value = value;
        }
        decodePayload(parser, path = "") {
            let subject = exports.String.decodePayload(parser, path);
            if (subject !== this.value) {
                throw new Error(`Expected "${this.value}" at ${path}!`);
            }
            return this.value;
        }
        encodePayload(subject, path = "") {
            if (subject !== this.value) {
                throw new Error(`Expected "${this.value}" at ${path}!`);
            }
            return exports.String.encodePayload(subject, path);
        }
    }
    exports.StringLiteralCodec = StringLiteralCodec;
    ;
    exports.StringLiteral = {
        of(value) {
            return new StringLiteralCodec(value);
        }
    };
    class NumberLiteralCodec extends Codec {
        value;
        constructor(value) {
            super();
            this.value = value;
        }
        decodePayload(parser, path = "") {
            let subject = exports.Number.decodePayload(parser, path);
            if (subject !== this.value) {
                throw new Error(`Expected ${this.value} at ${path}!`);
            }
            return this.value;
        }
        encodePayload(subject, path = "") {
            if (subject !== this.value) {
                throw new Error(`Expected ${this.value} at ${path}!`);
            }
            return exports.Number.encodePayload(subject, path);
        }
    }
    exports.NumberLiteralCodec = NumberLiteralCodec;
    ;
    exports.NumberLiteral = {
        of(value) {
            return new NumberLiteralCodec(value);
        }
    };
    class BigIntLiteralCodec extends Codec {
        value;
        constructor(value) {
            super();
            this.value = value;
        }
        decodePayload(parser, path = "") {
            let subject = exports.BigInt.decodePayload(parser, path);
            if (subject !== this.value) {
                throw new Error(`Expected ${this.value} at ${path}!`);
            }
            return this.value;
        }
        encodePayload(subject, path = "") {
            if (subject !== this.value) {
                throw new Error(`Expected ${this.value} at ${path}!`);
            }
            return exports.BigInt.encodePayload(subject, path);
        }
    }
    exports.BigIntLiteralCodec = BigIntLiteralCodec;
    ;
    exports.BigIntLiteral = {
        of(value) {
            return new BigIntLiteralCodec(value);
        }
    };
    class BooleanLiteralCodec extends Codec {
        value;
        constructor(value) {
            super();
            this.value = value;
        }
        decodePayload(parser, path = "") {
            let subject = exports.Boolean.decodePayload(parser, path);
            if (subject !== this.value) {
                throw new Error(`Expected ${this.value} at ${path}!`);
            }
            return this.value;
        }
        encodePayload(subject, path = "") {
            if (subject !== this.value) {
                throw new Error(`Expected ${this.value} at ${path}!`);
            }
            return exports.Boolean.encodePayload(subject, path);
        }
    }
    exports.BooleanLiteralCodec = BooleanLiteralCodec;
    ;
    exports.BooleanLiteral = {
        of(value) {
            return new BooleanLiteralCodec(value);
        }
    };
    class IntegerLiteralCodec extends Codec {
        value;
        constructor(value) {
            super();
            this.value = value;
        }
        decodePayload(parser, path = "") {
            let subject = exports.Integer.decodePayload(parser, path);
            if (subject !== this.value) {
                throw new Error(`Expected ${this.value} at ${path}!`);
            }
            return this.value;
        }
        encodePayload(subject, path = "") {
            if (subject !== this.value) {
                throw new Error(`Expected ${this.value} at ${path}!`);
            }
            return exports.Integer.encodePayload(subject, path);
        }
    }
    exports.IntegerLiteralCodec = IntegerLiteralCodec;
    ;
    exports.IntegerLiteral = {
        of(value) {
            return new IntegerLiteralCodec(value);
        }
    };
});
define("node_modules/@joelek/bedrock/dist/lib/index", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/codecs", "node_modules/@joelek/bedrock/dist/lib/utils"], function (require, exports, codecs, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.codecs = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.codecs = void 0;
    exports.codecs = codecs;
    exports.utils = utils;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/bedrock", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/index"], function (require, exports, bedrock) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CODEC = exports.BedrockCodec = void 0;
    class BedrockCodec {
        constructor() { }
        decode(buffer) {
            return bedrock.codecs.Any.decode(buffer);
        }
        encode(subject) {
            return bedrock.codecs.Any.encode(subject);
        }
    }
    exports.BedrockCodec = BedrockCodec;
    ;
    exports.CODEC = new BedrockCodec();
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/json", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/index", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards"], function (require, exports, bedrock, guards) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CODEC = exports.JSONCodec = void 0;
    const BIGINT_GUARD = guards.Object.of({
        type: guards.StringLiteral.of("@bigint"),
        data: guards.String
    });
    const BINARY_GUARD = guards.Object.of({
        type: guards.StringLiteral.of("@binary"),
        data: guards.String
    });
    class JSONCodec {
        constructor() { }
        decode(buffer) {
            let string = bedrock.utils.Chunk.toString(buffer, "utf-8");
            let subject = string.length === 0 ? undefined : JSON.parse(string, (key, subject) => {
                if (BIGINT_GUARD.is(subject)) {
                    return BigInt(subject.data);
                }
                if (BINARY_GUARD.is(subject)) {
                    return bedrock.utils.Chunk.fromString(subject.data, "base64url");
                }
                return subject;
            });
            return subject;
        }
        encode(subject) {
            let string = subject === undefined ? "" : JSON.stringify(subject, (key, subject) => {
                if (guards.BigInt.is(subject)) {
                    return {
                        type: "@bigint",
                        data: subject.toString()
                    };
                }
                if (guards.Binary.is(subject)) {
                    return {
                        type: "@binary",
                        data: bedrock.utils.Chunk.toString(subject, "base64url")
                    };
                }
                return subject;
            });
            let packet = bedrock.utils.Chunk.fromString(string, "utf-8");
            return packet;
        }
    }
    exports.JSONCodec = JSONCodec;
    ;
    exports.CODEC = new JSONCodec();
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/bedrock", "node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/json"], function (require, exports, bedrock, json) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.json = exports.bedrock = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.json = exports.bedrock = void 0;
    exports.bedrock = bedrock;
    exports.json = json;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/api", "node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/index", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards", "node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization"], function (require, exports, api, codecs, guards, serialization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialization = exports.guards = exports.codecs = exports.api = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialization = exports.guards = exports.codecs = exports.api = void 0;
    exports.api = api;
    exports.codecs = codecs;
    exports.guards = guards;
    exports.serialization = serialization;
});
define("build/database/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Year = exports.PlaylistItem = exports.Playlist = exports.Stream = exports.Token = exports.Key = exports.User = exports.Cue = exports.Subtitle = exports.ShowGenre = exports.MovieGenre = exports.Genre = exports.ShowActor = exports.MovieActor = exports.Actor = exports.MovieFile = exports.Movie = exports.EpisodeFile = exports.Episode = exports.Season = exports.ShowFile = exports.Show = exports.AlbumCategory = exports.Category = exports.TrackArtist = exports.AlbumArtist = exports.TrackFile = exports.Track = exports.Disc = exports.AlbumFile = exports.Album = exports.Artist = exports.VideoSubtitle = exports.VideoFile = exports.SubtitleFile = exports.MetadataFile = exports.ImageFile = exports.AudioFile = exports.File = exports.Directory = void 0;
    exports.Directory = autoguard.guards.Object.of({
        "directory_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {
        "parent_directory_id": autoguard.guards.String
    });
    exports.File = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {
        "parent_directory_id": autoguard.guards.String,
        "index_timestamp": autoguard.guards.Number,
        "size": autoguard.guards.Number
    });
    exports.AudioFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("audio/mp4"), autoguard.guards.StringLiteral.of("audio/mp3")),
        "duration_ms": autoguard.guards.Number
    }, {
        "sample_rate_hz": autoguard.guards.Number,
        "channel_count": autoguard.guards.Number,
        "bits_per_sample": autoguard.guards.Number
    });
    exports.ImageFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("image/jpeg")),
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    }, {});
    exports.MetadataFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("application/json"))
    }, {});
    exports.SubtitleFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("text/vtt")),
        "duration_ms": autoguard.guards.Number
    }, {
        "language": autoguard.guards.String
    });
    exports.VideoFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("video/mp4")),
        "duration_ms": autoguard.guards.Number,
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    }, {});
    exports.VideoSubtitle = autoguard.guards.Object.of({
        "video_file_id": autoguard.guards.String,
        "subtitle_file_id": autoguard.guards.String
    }, {});
    exports.Artist = autoguard.guards.Object.of({
        "artist_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.Album = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "title": autoguard.guards.String
    }, {
        "year": autoguard.guards.Number
    });
    exports.AlbumFile = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.Disc = autoguard.guards.Object.of({
        "disc_id": autoguard.guards.String,
        "album_id": autoguard.guards.String,
        "number": autoguard.guards.Number
    }, {});
    exports.Track = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "disc_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number
    }, {
        "copyright": autoguard.guards.String
    });
    exports.TrackFile = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.AlbumArtist = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "artist_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.TrackArtist = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "artist_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.Category = autoguard.guards.Object.of({
        "category_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.AlbumCategory = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "category_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.Show = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {
        "summary": autoguard.guards.String,
        "imdb": autoguard.guards.String
    });
    exports.ShowFile = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.Season = autoguard.guards.Object.of({
        "season_id": autoguard.guards.String,
        "show_id": autoguard.guards.String,
        "number": autoguard.guards.Number
    }, {});
    exports.Episode = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "season_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number
    }, {
        "year": autoguard.guards.Number,
        "summary": autoguard.guards.String,
        "copyright": autoguard.guards.String,
        "imdb": autoguard.guards.String
    });
    exports.EpisodeFile = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.Movie = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "title": autoguard.guards.String
    }, {
        "year": autoguard.guards.Number,
        "summary": autoguard.guards.String,
        "copyright": autoguard.guards.String,
        "imdb": autoguard.guards.String
    });
    exports.MovieFile = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.Actor = autoguard.guards.Object.of({
        "actor_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.MovieActor = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "actor_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.ShowActor = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "actor_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.Genre = autoguard.guards.Object.of({
        "genre_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.MovieGenre = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "genre_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.ShowGenre = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "genre_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.Subtitle = autoguard.guards.Object.of({
        "subtitle_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.Cue = autoguard.guards.Object.of({
        "cue_id": autoguard.guards.String,
        "subtitle_id": autoguard.guards.String,
        "start_ms": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number,
        "lines": autoguard.guards.String
    }, {});
    exports.User = autoguard.guards.Object.of({
        "user_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "username": autoguard.guards.String,
        "password": autoguard.guards.String
    }, {});
    exports.Key = autoguard.guards.Object.of({
        "key_id": autoguard.guards.String
    }, {
        "user_id": autoguard.guards.String
    });
    exports.Token = autoguard.guards.Object.of({
        "token_id": autoguard.guards.String,
        "user_id": autoguard.guards.String,
        "hash": autoguard.guards.String,
        "expires_ms": autoguard.guards.Number
    }, {});
    exports.Stream = autoguard.guards.Object.of({
        "stream_id": autoguard.guards.String,
        "user_id": autoguard.guards.String,
        "file_id": autoguard.guards.String,
        "timestamp_ms": autoguard.guards.Number
    }, {});
    exports.Playlist = autoguard.guards.Object.of({
        "playlist_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "description": autoguard.guards.String,
        "user_id": autoguard.guards.String
    }, {});
    exports.PlaylistItem = autoguard.guards.Object.of({
        "playlist_item_id": autoguard.guards.String,
        "playlist_id": autoguard.guards.String,
        "track_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "added_ms": autoguard.guards.Number
    }, {});
    exports.Year = autoguard.guards.Object.of({
        "year_id": autoguard.guards.String,
        "year": autoguard.guards.Number
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Directory": autoguard.guards.Reference.of(() => exports.Directory),
            "File": autoguard.guards.Reference.of(() => exports.File),
            "AudioFile": autoguard.guards.Reference.of(() => exports.AudioFile),
            "ImageFile": autoguard.guards.Reference.of(() => exports.ImageFile),
            "MetadataFile": autoguard.guards.Reference.of(() => exports.MetadataFile),
            "SubtitleFile": autoguard.guards.Reference.of(() => exports.SubtitleFile),
            "VideoFile": autoguard.guards.Reference.of(() => exports.VideoFile),
            "VideoSubtitle": autoguard.guards.Reference.of(() => exports.VideoSubtitle),
            "Artist": autoguard.guards.Reference.of(() => exports.Artist),
            "Album": autoguard.guards.Reference.of(() => exports.Album),
            "AlbumFile": autoguard.guards.Reference.of(() => exports.AlbumFile),
            "Disc": autoguard.guards.Reference.of(() => exports.Disc),
            "Track": autoguard.guards.Reference.of(() => exports.Track),
            "TrackFile": autoguard.guards.Reference.of(() => exports.TrackFile),
            "AlbumArtist": autoguard.guards.Reference.of(() => exports.AlbumArtist),
            "TrackArtist": autoguard.guards.Reference.of(() => exports.TrackArtist),
            "Category": autoguard.guards.Reference.of(() => exports.Category),
            "AlbumCategory": autoguard.guards.Reference.of(() => exports.AlbumCategory),
            "Show": autoguard.guards.Reference.of(() => exports.Show),
            "ShowFile": autoguard.guards.Reference.of(() => exports.ShowFile),
            "Season": autoguard.guards.Reference.of(() => exports.Season),
            "Episode": autoguard.guards.Reference.of(() => exports.Episode),
            "EpisodeFile": autoguard.guards.Reference.of(() => exports.EpisodeFile),
            "Movie": autoguard.guards.Reference.of(() => exports.Movie),
            "MovieFile": autoguard.guards.Reference.of(() => exports.MovieFile),
            "Actor": autoguard.guards.Reference.of(() => exports.Actor),
            "MovieActor": autoguard.guards.Reference.of(() => exports.MovieActor),
            "ShowActor": autoguard.guards.Reference.of(() => exports.ShowActor),
            "Genre": autoguard.guards.Reference.of(() => exports.Genre),
            "MovieGenre": autoguard.guards.Reference.of(() => exports.MovieGenre),
            "ShowGenre": autoguard.guards.Reference.of(() => exports.ShowGenre),
            "Subtitle": autoguard.guards.Reference.of(() => exports.Subtitle),
            "Cue": autoguard.guards.Reference.of(() => exports.Cue),
            "User": autoguard.guards.Reference.of(() => exports.User),
            "Key": autoguard.guards.Reference.of(() => exports.Key),
            "Token": autoguard.guards.Reference.of(() => exports.Token),
            "Stream": autoguard.guards.Reference.of(() => exports.Stream),
            "Playlist": autoguard.guards.Reference.of(() => exports.Playlist),
            "PlaylistItem": autoguard.guards.Reference.of(() => exports.PlaylistItem),
            "Year": autoguard.guards.Reference.of(() => exports.Year)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/objects/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/database/schema/index", "build/database/schema/index", "build/database/schema/index", "build/database/schema/index"], function (require, exports, autoguard, schema_1, schema_2, schema_3, schema_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectoryContext = exports.Directory = exports.DirectoryBase = exports.YearContext = exports.Year = exports.YearBase = exports.Cue = exports.CueBase = exports.Subtitle = exports.SubtitleBase = exports.EpisodeContext = exports.Episode = exports.EpisodeBase = exports.SeasonContext = exports.Season = exports.SeasonBase = exports.ShowContext = exports.Show = exports.ShowBase = exports.MovieContext = exports.Movie = exports.MovieBase = exports.Genre = exports.GenreBase = exports.PlaylistItemContext = exports.PlaylistItem = exports.PlaylistItemBase = exports.PlaylistContext = exports.Playlist = exports.PlaylistBase = exports.User = exports.UserBase = exports.TrackContext = exports.Track = exports.TrackBase = exports.DiscContext = exports.Disc = exports.DiscBase = exports.AlbumContext = exports.Album = exports.AlbumBase = exports.ArtistContext = exports.Artist = exports.ArtistBase = exports.Actor = exports.ActorBase = exports.Category = exports.CategoryBase = exports.Language = exports.LanguageBase = void 0;
    exports.Autoguard = exports.Entity = exports.EntityBase = exports.FileContext = exports.File = exports.FileBase = void 0;
    exports.LanguageBase = autoguard.guards.Object.of({
        "language_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.Language = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.LanguageBase), autoguard.guards.Object.of({
        "iso_639_1": autoguard.guards.String,
        "iso_639_2": autoguard.guards.String
    }, {}));
    exports.CategoryBase = autoguard.guards.Object.of({
        "category_id": autoguard.guards.String,
        "title": autoguard.guards.String
    }, {});
    exports.Category = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.CategoryBase), autoguard.guards.Object.of({
        "affinity": autoguard.guards.Number
    }, {}));
    exports.ActorBase = autoguard.guards.Object.of({
        "actor_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.Actor = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ActorBase), autoguard.guards.Object.of({
        "affinity": autoguard.guards.Number
    }, {}));
    exports.ArtistBase = autoguard.guards.Object.of({
        "artist_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    }, {});
    exports.Artist = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ArtistBase), autoguard.guards.Object.of({
        "affinity": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number
    }, {
        "tidal": autoguard.guards.Number
    }));
    exports.ArtistContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Artist), autoguard.guards.Object.of({
        "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.AlbumContext))
    }, {}));
    exports.AlbumBase = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    }, {});
    exports.Album = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.AlbumBase), autoguard.guards.Object.of({
        "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ArtistBase)),
        "affinity": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number,
        "categories": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.CategoryBase))
    }, {
        "year": autoguard.guards.Reference.of(() => exports.YearBase),
        "copyright": autoguard.guards.String,
        "tidal": autoguard.guards.Number
    }));
    exports.AlbumContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Album), autoguard.guards.Object.of({
        "discs": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.DiscContext))
    }, {}));
    exports.DiscBase = autoguard.guards.Object.of({
        "disc_id": autoguard.guards.String,
        "album": autoguard.guards.Reference.of(() => exports.AlbumBase),
        "number": autoguard.guards.Number
    }, {
        "title": autoguard.guards.String
    });
    exports.Disc = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.DiscBase), autoguard.guards.Object.of({
        "affinity": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number
    }, {}));
    exports.DiscContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Disc), autoguard.guards.Object.of({
        "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.TrackContext))
    }, {}));
    exports.TrackBase = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "disc": autoguard.guards.Reference.of(() => exports.DiscBase),
        "number": autoguard.guards.Number
    }, {});
    exports.Track = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.TrackBase), autoguard.guards.Object.of({
        "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ArtistBase)),
        "media": autoguard.guards.Reference.of(() => schema_1.AudioFile),
        "affinity": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number
    }, {
        "last_stream_date": autoguard.guards.Number,
        "copyright": autoguard.guards.String
    }));
    exports.TrackContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Track), autoguard.guards.Object.of({}, {}));
    exports.UserBase = autoguard.guards.Object.of({
        "user_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "username": autoguard.guards.String
    }, {});
    exports.User = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.UserBase), autoguard.guards.Object.of({}, {}));
    exports.PlaylistBase = autoguard.guards.Object.of({
        "playlist_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "description": autoguard.guards.String,
        "user": autoguard.guards.Reference.of(() => exports.UserBase)
    }, {});
    exports.Playlist = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.PlaylistBase), autoguard.guards.Object.of({
        "affinity": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    }, {}));
    exports.PlaylistContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Playlist), autoguard.guards.Object.of({
        "items": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.PlaylistItemContext))
    }, {}));
    exports.PlaylistItemBase = autoguard.guards.Object.of({
        "playlist_item_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "playlist": autoguard.guards.Reference.of(() => exports.PlaylistBase),
        "track": autoguard.guards.Reference.of(() => exports.Track),
        "duration_ms": autoguard.guards.Number
    }, {});
    exports.PlaylistItem = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.PlaylistItemBase), autoguard.guards.Object.of({}, {}));
    exports.PlaylistItemContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.PlaylistItem), autoguard.guards.Object.of({}, {}));
    exports.GenreBase = autoguard.guards.Object.of({
        "genre_id": autoguard.guards.String,
        "title": autoguard.guards.String
    }, {});
    exports.Genre = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.GenreBase), autoguard.guards.Object.of({
        "affinity": autoguard.guards.Number
    }, {}));
    exports.MovieBase = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    }, {});
    exports.Movie = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.MovieBase), autoguard.guards.Object.of({
        "genres": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.GenreBase)),
        "media": autoguard.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": autoguard.guards.Array.of(autoguard.guards.Object.of({
            "file_id": autoguard.guards.String,
            "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("text/vtt")),
            "duration_ms": autoguard.guards.Number
        }, {
            "language": autoguard.guards.Reference.of(() => exports.Language)
        })),
        "affinity": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number
    }, {
        "year": autoguard.guards.Reference.of(() => exports.YearBase),
        "summary": autoguard.guards.String,
        "last_stream_date": autoguard.guards.Number,
        "copyright": autoguard.guards.String,
        "imdb": autoguard.guards.String
    }));
    exports.MovieContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Movie), autoguard.guards.Object.of({}, {}));
    exports.ShowBase = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    }, {});
    exports.Show = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ShowBase), autoguard.guards.Object.of({
        "genres": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.GenreBase)),
        "affinity": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number
    }, {
        "summary": autoguard.guards.String,
        "imdb": autoguard.guards.String
    }));
    exports.ShowContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Show), autoguard.guards.Object.of({
        "seasons": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.SeasonContext))
    }, {}));
    exports.SeasonBase = autoguard.guards.Object.of({
        "season_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "show": autoguard.guards.Reference.of(() => exports.ShowBase)
    }, {});
    exports.Season = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.SeasonBase), autoguard.guards.Object.of({
        "affinity": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number
    }, {}));
    exports.SeasonContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Season), autoguard.guards.Object.of({
        "episodes": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.EpisodeContext))
    }, {}));
    exports.EpisodeBase = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "season": autoguard.guards.Reference.of(() => exports.SeasonBase)
    }, {});
    exports.Episode = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.EpisodeBase), autoguard.guards.Object.of({
        "media": autoguard.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": autoguard.guards.Array.of(autoguard.guards.Object.of({
            "file_id": autoguard.guards.String,
            "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("text/vtt")),
            "duration_ms": autoguard.guards.Number
        }, {
            "language": autoguard.guards.Reference.of(() => exports.Language)
        })),
        "affinity": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number
    }, {
        "year": autoguard.guards.Reference.of(() => exports.YearBase),
        "summary": autoguard.guards.String,
        "last_stream_date": autoguard.guards.Number,
        "copyright": autoguard.guards.String,
        "imdb": autoguard.guards.String
    }));
    exports.EpisodeContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Episode), autoguard.guards.Object.of({}, {}));
    exports.SubtitleBase = autoguard.guards.Object.of({
        "subtitle_id": autoguard.guards.String,
        "subtitle": autoguard.guards.Reference.of(() => schema_3.SubtitleFile)
    }, {});
    exports.Subtitle = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.SubtitleBase), autoguard.guards.Object.of({
        "cues": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Cue))
    }, {}));
    exports.CueBase = autoguard.guards.Object.of({
        "cue_id": autoguard.guards.String,
        "subtitle": autoguard.guards.Reference.of(() => exports.SubtitleBase),
        "start_ms": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number,
        "lines": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.Cue = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.CueBase), autoguard.guards.Object.of({
        "media": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Episode), autoguard.guards.Reference.of(() => exports.Movie))
    }, {}));
    exports.YearBase = autoguard.guards.Object.of({
        "year_id": autoguard.guards.String,
        "year": autoguard.guards.Number
    }, {});
    exports.Year = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.YearBase), autoguard.guards.Object.of({
        "affinity": autoguard.guards.Number,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    }, {}));
    exports.YearContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Year), autoguard.guards.Object.of({
        "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.AlbumContext))
    }, {}));
    exports.DirectoryBase = autoguard.guards.Object.of({
        "directory_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.Directory = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.DirectoryBase), autoguard.guards.Object.of({}, {
        "parent": autoguard.guards.Reference.of(() => exports.DirectoryBase)
    }));
    exports.DirectoryContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Directory), autoguard.guards.Object.of({
        "files": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.FileContext))
    }, {}));
    exports.FileBase = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.File = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.FileBase), autoguard.guards.Object.of({
        "size": autoguard.guards.Number,
        "media": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => schema_1.AudioFile), autoguard.guards.Reference.of(() => schema_4.VideoFile))
    }, {
        "parent": autoguard.guards.Reference.of(() => exports.DirectoryBase)
    }));
    exports.FileContext = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.File), autoguard.guards.Object.of({}, {}));
    exports.EntityBase = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ActorBase), autoguard.guards.Reference.of(() => exports.AlbumBase), autoguard.guards.Reference.of(() => exports.ArtistBase), autoguard.guards.Reference.of(() => exports.CategoryBase), autoguard.guards.Reference.of(() => exports.CueBase), autoguard.guards.Reference.of(() => exports.DirectoryBase), autoguard.guards.Reference.of(() => exports.DiscBase), autoguard.guards.Reference.of(() => exports.EpisodeBase), autoguard.guards.Reference.of(() => exports.FileBase), autoguard.guards.Reference.of(() => exports.GenreBase), autoguard.guards.Reference.of(() => exports.MovieBase), autoguard.guards.Reference.of(() => exports.PlaylistBase), autoguard.guards.Reference.of(() => exports.SeasonBase), autoguard.guards.Reference.of(() => exports.ShowBase), autoguard.guards.Reference.of(() => exports.TrackBase), autoguard.guards.Reference.of(() => exports.UserBase), autoguard.guards.Reference.of(() => exports.YearBase));
    exports.Entity = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Actor), autoguard.guards.Reference.of(() => exports.Album), autoguard.guards.Reference.of(() => exports.Artist), autoguard.guards.Reference.of(() => exports.Category), autoguard.guards.Reference.of(() => exports.Cue), autoguard.guards.Reference.of(() => exports.Directory), autoguard.guards.Reference.of(() => exports.Disc), autoguard.guards.Reference.of(() => exports.Episode), autoguard.guards.Reference.of(() => exports.File), autoguard.guards.Reference.of(() => exports.Genre), autoguard.guards.Reference.of(() => exports.Movie), autoguard.guards.Reference.of(() => exports.Playlist), autoguard.guards.Reference.of(() => exports.Season), autoguard.guards.Reference.of(() => exports.Show), autoguard.guards.Reference.of(() => exports.Track), autoguard.guards.Reference.of(() => exports.User), autoguard.guards.Reference.of(() => exports.Year));
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "LanguageBase": autoguard.guards.Reference.of(() => exports.LanguageBase),
            "Language": autoguard.guards.Reference.of(() => exports.Language),
            "CategoryBase": autoguard.guards.Reference.of(() => exports.CategoryBase),
            "Category": autoguard.guards.Reference.of(() => exports.Category),
            "ActorBase": autoguard.guards.Reference.of(() => exports.ActorBase),
            "Actor": autoguard.guards.Reference.of(() => exports.Actor),
            "ArtistBase": autoguard.guards.Reference.of(() => exports.ArtistBase),
            "Artist": autoguard.guards.Reference.of(() => exports.Artist),
            "ArtistContext": autoguard.guards.Reference.of(() => exports.ArtistContext),
            "AlbumBase": autoguard.guards.Reference.of(() => exports.AlbumBase),
            "Album": autoguard.guards.Reference.of(() => exports.Album),
            "AlbumContext": autoguard.guards.Reference.of(() => exports.AlbumContext),
            "DiscBase": autoguard.guards.Reference.of(() => exports.DiscBase),
            "Disc": autoguard.guards.Reference.of(() => exports.Disc),
            "DiscContext": autoguard.guards.Reference.of(() => exports.DiscContext),
            "TrackBase": autoguard.guards.Reference.of(() => exports.TrackBase),
            "Track": autoguard.guards.Reference.of(() => exports.Track),
            "TrackContext": autoguard.guards.Reference.of(() => exports.TrackContext),
            "UserBase": autoguard.guards.Reference.of(() => exports.UserBase),
            "User": autoguard.guards.Reference.of(() => exports.User),
            "PlaylistBase": autoguard.guards.Reference.of(() => exports.PlaylistBase),
            "Playlist": autoguard.guards.Reference.of(() => exports.Playlist),
            "PlaylistContext": autoguard.guards.Reference.of(() => exports.PlaylistContext),
            "PlaylistItemBase": autoguard.guards.Reference.of(() => exports.PlaylistItemBase),
            "PlaylistItem": autoguard.guards.Reference.of(() => exports.PlaylistItem),
            "PlaylistItemContext": autoguard.guards.Reference.of(() => exports.PlaylistItemContext),
            "GenreBase": autoguard.guards.Reference.of(() => exports.GenreBase),
            "Genre": autoguard.guards.Reference.of(() => exports.Genre),
            "MovieBase": autoguard.guards.Reference.of(() => exports.MovieBase),
            "Movie": autoguard.guards.Reference.of(() => exports.Movie),
            "MovieContext": autoguard.guards.Reference.of(() => exports.MovieContext),
            "ShowBase": autoguard.guards.Reference.of(() => exports.ShowBase),
            "Show": autoguard.guards.Reference.of(() => exports.Show),
            "ShowContext": autoguard.guards.Reference.of(() => exports.ShowContext),
            "SeasonBase": autoguard.guards.Reference.of(() => exports.SeasonBase),
            "Season": autoguard.guards.Reference.of(() => exports.Season),
            "SeasonContext": autoguard.guards.Reference.of(() => exports.SeasonContext),
            "EpisodeBase": autoguard.guards.Reference.of(() => exports.EpisodeBase),
            "Episode": autoguard.guards.Reference.of(() => exports.Episode),
            "EpisodeContext": autoguard.guards.Reference.of(() => exports.EpisodeContext),
            "SubtitleBase": autoguard.guards.Reference.of(() => exports.SubtitleBase),
            "Subtitle": autoguard.guards.Reference.of(() => exports.Subtitle),
            "CueBase": autoguard.guards.Reference.of(() => exports.CueBase),
            "Cue": autoguard.guards.Reference.of(() => exports.Cue),
            "YearBase": autoguard.guards.Reference.of(() => exports.YearBase),
            "Year": autoguard.guards.Reference.of(() => exports.Year),
            "YearContext": autoguard.guards.Reference.of(() => exports.YearContext),
            "DirectoryBase": autoguard.guards.Reference.of(() => exports.DirectoryBase),
            "Directory": autoguard.guards.Reference.of(() => exports.Directory),
            "DirectoryContext": autoguard.guards.Reference.of(() => exports.DirectoryContext),
            "FileBase": autoguard.guards.Reference.of(() => exports.FileBase),
            "File": autoguard.guards.Reference.of(() => exports.File),
            "FileContext": autoguard.guards.Reference.of(() => exports.FileContext),
            "EntityBase": autoguard.guards.Reference.of(() => exports.EntityBase),
            "Entity": autoguard.guards.Reference.of(() => exports.Entity)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/player/schema/objects/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2, objects_3, objects_4, objects_5, objects_6, objects_7, objects_8, objects_9, objects_10, objects_11, objects_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Session = exports.Device = exports.ContextItem = exports.Context = exports.ContextFile = exports.ContextDirectory = exports.ContextYear = exports.ContextEpisode = exports.ContextSeason = exports.ContextShow = exports.ContextMovie = exports.ContextPlaylist = exports.ContextTrack = exports.ContextDisc = exports.ContextArtist = exports.ContextAlbum = void 0;
    exports.ContextAlbum = autoguard.guards.Reference.of(() => objects_1.AlbumContext);
    exports.ContextArtist = autoguard.guards.Reference.of(() => objects_2.ArtistContext);
    exports.ContextDisc = autoguard.guards.Reference.of(() => objects_4.DiscContext);
    exports.ContextTrack = autoguard.guards.Reference.of(() => objects_11.TrackContext);
    exports.ContextPlaylist = autoguard.guards.Reference.of(() => objects_8.PlaylistContext);
    exports.ContextMovie = autoguard.guards.Reference.of(() => objects_7.MovieContext);
    exports.ContextShow = autoguard.guards.Reference.of(() => objects_10.ShowContext);
    exports.ContextSeason = autoguard.guards.Reference.of(() => objects_9.SeasonContext);
    exports.ContextEpisode = autoguard.guards.Reference.of(() => objects_5.EpisodeContext);
    exports.ContextYear = autoguard.guards.Reference.of(() => objects_12.YearContext);
    exports.ContextDirectory = autoguard.guards.Reference.of(() => objects_3.DirectoryContext);
    exports.ContextFile = autoguard.guards.Reference.of(() => objects_6.FileContext);
    exports.Context = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ContextAlbum), autoguard.guards.Reference.of(() => exports.ContextArtist), autoguard.guards.Reference.of(() => exports.ContextDisc), autoguard.guards.Reference.of(() => exports.ContextTrack), autoguard.guards.Reference.of(() => exports.ContextPlaylist), autoguard.guards.Reference.of(() => exports.ContextMovie), autoguard.guards.Reference.of(() => exports.ContextShow), autoguard.guards.Reference.of(() => exports.ContextSeason), autoguard.guards.Reference.of(() => exports.ContextEpisode), autoguard.guards.Reference.of(() => exports.ContextYear), autoguard.guards.Reference.of(() => exports.ContextDirectory), autoguard.guards.Reference.of(() => exports.ContextFile));
    exports.ContextItem = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ContextTrack), autoguard.guards.Reference.of(() => exports.ContextMovie), autoguard.guards.Reference.of(() => exports.ContextEpisode), autoguard.guards.Reference.of(() => exports.ContextFile));
    exports.Device = autoguard.guards.Object.of({
        "did": autoguard.guards.String,
        "id": autoguard.guards.String,
        "protocol": autoguard.guards.String,
        "name": autoguard.guards.String,
        "type": autoguard.guards.String,
        "enabled": autoguard.guards.Boolean
    }, {});
    exports.Session = autoguard.guards.Object.of({
        "playback": autoguard.guards.Boolean,
        "playing": autoguard.guards.Boolean,
        "repeat": autoguard.guards.Boolean,
        "shuffle": autoguard.guards.Boolean
    }, {
        "context": autoguard.guards.Reference.of(() => exports.Context),
        "device": autoguard.guards.Reference.of(() => exports.Device),
        "index": autoguard.guards.Number,
        "order": autoguard.guards.Array.of(autoguard.guards.Number),
        "progress": autoguard.guards.Number
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ContextAlbum": autoguard.guards.Reference.of(() => exports.ContextAlbum),
            "ContextArtist": autoguard.guards.Reference.of(() => exports.ContextArtist),
            "ContextDisc": autoguard.guards.Reference.of(() => exports.ContextDisc),
            "ContextTrack": autoguard.guards.Reference.of(() => exports.ContextTrack),
            "ContextPlaylist": autoguard.guards.Reference.of(() => exports.ContextPlaylist),
            "ContextMovie": autoguard.guards.Reference.of(() => exports.ContextMovie),
            "ContextShow": autoguard.guards.Reference.of(() => exports.ContextShow),
            "ContextSeason": autoguard.guards.Reference.of(() => exports.ContextSeason),
            "ContextEpisode": autoguard.guards.Reference.of(() => exports.ContextEpisode),
            "ContextYear": autoguard.guards.Reference.of(() => exports.ContextYear),
            "ContextDirectory": autoguard.guards.Reference.of(() => exports.ContextDirectory),
            "ContextFile": autoguard.guards.Reference.of(() => exports.ContextFile),
            "Context": autoguard.guards.Reference.of(() => exports.Context),
            "ContextItem": autoguard.guards.Reference.of(() => exports.ContextItem),
            "Device": autoguard.guards.Reference.of(() => exports.Device),
            "Session": autoguard.guards.Reference.of(() => exports.Session)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/player/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/player/schema/objects/index", "build/player/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.SetToken = exports.SetShuffle = exports.SetRepeat = exports.SetProgress = exports.SetPlaying = exports.SetPlayback = exports.SetOrder = exports.SetLocalDevice = exports.SetIndex = exports.SetDevices = exports.SetDevice = exports.SetContext = void 0;
    exports.SetContext = autoguard.guards.Object.of({}, {
        "context": autoguard.guards.Reference.of(() => objects_1.Context)
    });
    exports.SetDevice = autoguard.guards.Object.of({}, {
        "device": autoguard.guards.Reference.of(() => objects_2.Device)
    });
    exports.SetDevices = autoguard.guards.Object.of({
        "devices": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Device))
    }, {});
    exports.SetIndex = autoguard.guards.Object.of({}, {
        "index": autoguard.guards.Number
    });
    exports.SetLocalDevice = autoguard.guards.Object.of({
        "device": autoguard.guards.Reference.of(() => objects_2.Device)
    }, {});
    exports.SetOrder = autoguard.guards.Object.of({}, {
        "order": autoguard.guards.Array.of(autoguard.guards.Number)
    });
    exports.SetPlayback = autoguard.guards.Object.of({
        "playback": autoguard.guards.Boolean
    }, {});
    exports.SetPlaying = autoguard.guards.Object.of({
        "playing": autoguard.guards.Boolean
    }, {});
    exports.SetProgress = autoguard.guards.Object.of({}, {
        "progress": autoguard.guards.Number
    });
    exports.SetRepeat = autoguard.guards.Object.of({
        "repeat": autoguard.guards.Boolean
    }, {});
    exports.SetShuffle = autoguard.guards.Object.of({
        "shuffle": autoguard.guards.Boolean
    }, {});
    exports.SetToken = autoguard.guards.Object.of({}, {
        "token": autoguard.guards.String
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "SetContext": autoguard.guards.Reference.of(() => exports.SetContext),
            "SetDevice": autoguard.guards.Reference.of(() => exports.SetDevice),
            "SetDevices": autoguard.guards.Reference.of(() => exports.SetDevices),
            "SetIndex": autoguard.guards.Reference.of(() => exports.SetIndex),
            "SetLocalDevice": autoguard.guards.Reference.of(() => exports.SetLocalDevice),
            "SetOrder": autoguard.guards.Reference.of(() => exports.SetOrder),
            "SetPlayback": autoguard.guards.Reference.of(() => exports.SetPlayback),
            "SetPlaying": autoguard.guards.Reference.of(() => exports.SetPlaying),
            "SetProgress": autoguard.guards.Reference.of(() => exports.SetProgress),
            "SetRepeat": autoguard.guards.Reference.of(() => exports.SetRepeat),
            "SetShuffle": autoguard.guards.Reference.of(() => exports.SetShuffle),
            "SetToken": autoguard.guards.Reference.of(() => exports.SetToken)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/player/schema/index", ["require", "exports", "build/player/schema/messages/index", "build/player/schema/objects/index"], function (require, exports, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    exports.messages = messages;
    exports.objects = objects;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/asserts/index", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/asserts/integer"], function (require, exports, integer) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.integer = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.integer = void 0;
    exports.integer = integer;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/collections/avl", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tree = exports.Node = void 0;
    class Node {
        constructor(key, value, height) {
            this.key = key;
            this.value = value;
            this.height = height !== null && height !== void 0 ? height : 1;
            this.parent = undefined;
            this.lower = undefined;
            this.upper = undefined;
        }
        compare(filter) {
            if (filter.operator === "<") {
                if (this.key > filter.key) {
                    return -1;
                }
                else if (this.key < filter.key) {
                    return 0;
                }
                else {
                    return -1;
                }
            }
            if (filter.operator === "<=") {
                if (this.key > filter.key) {
                    return -1;
                }
                else if (this.key < filter.key) {
                    return 0;
                }
                else {
                    return 0;
                }
            }
            if (filter.operator === "=") {
                if (this.key > filter.key) {
                    return -1;
                }
                else if (this.key < filter.key) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            if (filter.operator === ">=") {
                if (this.key > filter.key) {
                    return 0;
                }
                else if (this.key < filter.key) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            if (filter.operator === ">") {
                if (this.key > filter.key) {
                    return 0;
                }
                else if (this.key < filter.key) {
                    return 1;
                }
                else {
                    return 1;
                }
            }
            throw `Expected code to be unreachable!`;
        }
        computeBalance() {
            var _a, _b, _c, _d;
            return ((_b = (_a = this.upper) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0) - ((_d = (_c = this.lower) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0);
        }
        computeHeight() {
            var _a, _b, _c, _d;
            return Math.max(((_b = (_a = this.lower) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0), ((_d = (_c = this.upper) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0)) + 1;
        }
        entry() {
            return {
                key: this.key,
                value: this.value
            };
        }
        *filter(...filters) {
            let lower = true;
            let current = true;
            let upper = true;
            for (let filter of filters) {
                let comparison = this.compare(filter);
                lower = lower && comparison <= 0;
                current = current && comparison === 0;
                upper = upper && comparison >= 0;
            }
            if (lower && this.lower != null) {
                yield* this.lower.filter(...filters);
            }
            if (current) {
                yield this.entry();
            }
            if (upper && this.upper != null) {
                yield* this.upper.filter(...filters);
            }
        }
        getMaximum() {
            let node = this;
            while (node.upper != null) {
                node = node.upper;
            }
            return node;
        }
        getMinimum() {
            let node = this;
            while (node.lower != null) {
                node = node.lower;
            }
            return node;
        }
        getLowerParent() {
            let parent = this.parent;
            let child = this;
            while (parent != null && child === parent.lower) {
                child = parent;
                parent = parent.parent;
            }
            return parent;
        }
        getUpperParent() {
            let parent = this.parent;
            let child = this;
            while (parent != null && child === parent.upper) {
                child = parent;
                parent = parent.parent;
            }
            return parent;
        }
        getPredecessor() {
            if (this.lower != null) {
                return this.lower.getMaximum();
            }
            return this.getLowerParent();
        }
        getSuccessor() {
            if (this.upper != null) {
                return this.upper.getMinimum();
            }
            return this.getUpperParent();
        }
        insert(node) {
            if (node.key === this.key) {
                this.value = node.value;
                return this;
            }
            if (node.key < this.key) {
                if (this.lower == null) {
                    this.setLower(node);
                }
                else {
                    this.setLower(this.lower.insert(node));
                }
            }
            else {
                if (this.upper == null) {
                    this.setUpper(node);
                }
                else {
                    this.setUpper(this.upper.insert(node));
                }
            }
            this.setHeight(this.computeHeight());
            return this.rebalance();
        }
        locate(filter) {
            if (filter.key === this.key) {
                if (filter.operator === "<") {
                    return this.getPredecessor();
                }
                if (filter.operator === "<=") {
                    return this;
                }
                if (filter.operator === "=") {
                    return this;
                }
                if (filter.operator === ">=") {
                    return this;
                }
                if (filter.operator === ">") {
                    return this.getSuccessor();
                }
            }
            if (filter.key < this.key) {
                if (this.lower != null) {
                    return this.lower.locate(filter);
                }
                else {
                    if (filter.operator === "<") {
                        return this.getLowerParent();
                    }
                    if (filter.operator === "<=") {
                        return this.getLowerParent();
                    }
                    if (filter.operator === ">=") {
                        return this;
                    }
                    if (filter.operator === ">") {
                        return this;
                    }
                }
            }
            else {
                if (this.upper != null) {
                    return this.upper.locate(filter);
                }
                else {
                    if (filter.operator === "<") {
                        return this;
                    }
                    if (filter.operator === "<=") {
                        return this;
                    }
                    if (filter.operator === ">=") {
                        return this.getUpperParent();
                    }
                    if (filter.operator === ">") {
                        return this.getUpperParent();
                    }
                }
            }
        }
        rebalance() {
            let balance = this.computeBalance();
            if (balance < -1) {
                if (this.lower == null) {
                    throw `Expected lower child to be non-null!`;
                }
                let balance = this.lower.computeBalance();
                if (balance <= 0) {
                    return this.rotateRight();
                }
                else {
                    this.setLower(this.lower.rotateLeft());
                    return this.rotateRight();
                }
            }
            if (balance > 1) {
                if (this.upper == null) {
                    throw `Expected upper child to be non-null!`;
                }
                let balance = this.upper.computeBalance();
                if (balance >= 0) {
                    return this.rotateLeft();
                }
                else {
                    this.setUpper(this.upper.rotateRight());
                    return this.rotateLeft();
                }
            }
            return this;
        }
        remove(key) {
            if (key === this.key) {
                if (this.lower != null) {
                    if (this.upper != null) {
                        let { key, value } = this.upper.getMinimum();
                        this.setUpper(this.upper.remove(key));
                        this.key = key;
                        this.value = value;
                        this.setHeight(this.computeHeight());
                        return this.rebalance();
                    }
                    else {
                        return this.lower;
                    }
                }
                else {
                    if (this.upper != null) {
                        return this.upper;
                    }
                    else {
                        return;
                    }
                }
            }
            if (key < this.key) {
                if (this.lower != null) {
                    this.setLower(this.lower.remove(key));
                }
                else {
                    return this;
                }
            }
            else {
                if (this.upper != null) {
                    this.setUpper(this.upper.remove(key));
                }
                else {
                    return this;
                }
            }
            this.setHeight(this.computeHeight());
            return this.rebalance();
        }
        rotateLeft() {
            let upper = this.upper;
            if (upper == null) {
                throw `Expected upper child to be non-null!`;
            }
            this.setUpper(upper.lower);
            upper.setLower(this);
            this.setHeight(this.computeHeight());
            upper.setHeight(upper.computeHeight());
            return upper;
        }
        rotateRight() {
            let lower = this.lower;
            if (lower == null) {
                throw `Expected lower child to be non-null!`;
            }
            this.setLower(lower.upper);
            lower.setUpper(this);
            this.setHeight(this.computeHeight());
            lower.setHeight(lower.computeHeight());
            return lower;
        }
        getHeight() {
            return this.height;
        }
        setHeight(height) {
            return this.height = height;
        }
        getParent() {
            return this.parent;
        }
        setParent(parent) {
            if (this.parent != null) {
                if (this.parent.lower === this) {
                    this.parent.lower = undefined;
                }
                else if (this.parent.upper === this) {
                    this.parent.upper = undefined;
                }
            }
            this.parent = parent;
        }
        getLower() {
            return this.lower;
        }
        setLower(lower) {
            if (lower != null) {
                lower.setParent(this);
            }
            if (this.lower != null) {
                this.lower.setParent(undefined);
            }
            this.lower = lower;
        }
        getUpper() {
            return this.upper;
        }
        setUpper(upper) {
            if (upper != null) {
                upper.setParent(this);
            }
            if (this.upper != null) {
                this.upper.setParent(undefined);
            }
            this.upper = upper;
        }
    }
    exports.Node = Node;
    ;
    class Tree {
        constructor() {
            this.root = undefined;
        }
        *[Symbol.iterator]() {
            yield* this.filter();
        }
        clear() {
            this.vacate();
        }
        *filter(...filters) {
            if (this.root == null) {
                return;
            }
            for (let node of this.root.filter(...filters)) {
                yield {
                    key: node.key,
                    value: node.value
                };
            }
        }
        insert(key, value) {
            var _a;
            let node = new Node(key, value);
            if (this.root != null) {
                this.root = this.root.insert(node);
                (_a = this.root) === null || _a === void 0 ? void 0 : _a.setParent(undefined);
            }
            else {
                this.root = node;
            }
        }
        length() {
            let length = 0;
            for (let entry of this) {
                length += 1;
            }
            return length;
        }
        locate(filter) {
            var _a;
            if (this.root != null) {
                return (_a = this.root.locate(filter)) === null || _a === void 0 ? void 0 : _a.entry();
            }
        }
        lookup(key) {
            var _a;
            return (_a = this.locate({ operator: "=", key: key })) === null || _a === void 0 ? void 0 : _a.value;
        }
        remove(key) {
            var _a;
            if (this.root != null) {
                this.root = this.root.remove(key);
                (_a = this.root) === null || _a === void 0 ? void 0 : _a.setParent(undefined);
            }
        }
        vacate() {
            this.root = undefined;
        }
    }
    exports.Tree = Tree;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/collections/dll", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DoublyLinkedList = exports.DoublyLinkedListNode = void 0;
    class DoublyLinkedListNode {
        constructor(value) {
            this.value = value;
        }
        detach() {
            if (this.last != null) {
                this.last.setNext(this.next);
            }
            if (this.next != null) {
                this.next.setLast(this.last);
            }
        }
        getLast() {
            return this.last;
        }
        getNext() {
            return this.next;
        }
        getValue() {
            return this.value;
        }
        setLast(last) {
            if (this.last != null) {
                this.last.next = undefined;
            }
            this.last = last;
            if (last != null) {
                last.next = this;
            }
        }
        setNext(next) {
            if (this.next != null) {
                this.next.last = undefined;
            }
            this.next = next;
            if (next != null) {
                next.last = this;
            }
        }
        setValue(value) {
            this.value = value;
        }
    }
    exports.DoublyLinkedListNode = DoublyLinkedListNode;
    ;
    class DoublyLinkedList {
        constructor() {
            this.head = undefined;
            this.tail = undefined;
        }
        *[Symbol.iterator]() {
            let node = this.head;
            while (node != null) {
                yield node.getValue();
                node = node.getNext();
            }
        }
        append(value) {
            var _a;
            let node = new DoublyLinkedListNode(value);
            if (this.tail != null) {
                this.tail.setNext(node);
            }
            this.head = (_a = this.head) !== null && _a !== void 0 ? _a : node;
            this.tail = node;
            return node;
        }
        prepend(value) {
            var _a;
            let node = new DoublyLinkedListNode(value);
            if (this.head != null) {
                this.head.setLast(node);
            }
            this.head = node;
            this.tail = (_a = this.tail) !== null && _a !== void 0 ? _a : node;
            return node;
        }
        remove(node) {
            if (this.head === node) {
                this.head = node.getNext();
            }
            if (this.tail === node) {
                this.tail = node.getLast();
            }
            node.detach();
        }
        unappend() {
            if (this.tail == null) {
                return;
            }
            let node = this.tail;
            if (this.head === this.tail) {
                this.head = undefined;
                this.tail = undefined;
            }
            else {
                this.tail = node.getLast();
                if (this.tail != null) {
                    this.tail.setNext(undefined);
                }
            }
            return node;
        }
        unprepend() {
            if (this.head == null) {
                return;
            }
            let node = this.head;
            if (this.head === this.tail) {
                this.head = undefined;
                this.tail = undefined;
            }
            else {
                this.head = node.getNext();
                if (this.head != null) {
                    this.head.setLast(undefined);
                }
            }
            return node;
        }
    }
    exports.DoublyLinkedList = DoublyLinkedList;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/collections/rhh", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RobinHoodHash = void 0;
    class RobinHoodHash {
        constructor() {
            this.slots = new Array(1);
            this.slotsUsed = 0;
        }
        computeOptimalSlot(key) {
            let hash = 2166136261;
            while (key > 0) {
                let byte = key & 0xFF;
                hash = Math.imul(hash ^ byte, 16777619) >>> 0;
                key >>>= 8;
            }
            return hash % this.slots.length;
        }
        doInsert(key, value) {
            let slotIndex = this.computeOptimalSlot(key);
            let probeDistance = 0;
            for (let i = 0; i < this.slots.length; i++) {
                let slot = this.slots[slotIndex];
                if (slot == null) {
                    this.slots[slotIndex] = {
                        key,
                        value,
                        probeDistance
                    };
                    return slotIndex;
                }
                if (slot.key === key) {
                    slot.value = value;
                    return;
                }
                if (probeDistance > slot.probeDistance) {
                    this.slots[slotIndex] = {
                        key,
                        value,
                        probeDistance
                    };
                    key = slot.key;
                    value = slot.value;
                    probeDistance = slot.probeDistance;
                }
                slotIndex = (slotIndex + 1) % this.slots.length;
                probeDistance += 1;
            }
        }
        doLookup(key) {
            let slotIndex = this.computeOptimalSlot(key);
            let probeDistance = 0;
            for (let i = 0; i < this.slots.length; i++) {
                let slot = this.slots[slotIndex];
                if (slot == null || probeDistance > slot.probeDistance) {
                    return;
                }
                if (slot.key === key) {
                    return slotIndex;
                }
                slotIndex = (slotIndex + 1) % this.slots.length;
                probeDistance += 1;
            }
        }
        doRemove(key) {
            let slotIndex = this.computeOptimalSlot(key);
            let probeDistance = 0;
            for (let i = 0; i < this.slots.length; i++) {
                let slot = this.slots[slotIndex];
                if (slot == null || probeDistance > slot.probeDistance) {
                    return;
                }
                if (slot.key === key) {
                    this.slots[slotIndex] = undefined;
                    return slotIndex;
                }
                slotIndex = (slotIndex + 1) % this.slots.length;
                probeDistance += 1;
            }
        }
        propagateBackwards(slotIndex) {
            for (let i = 0; i < this.slots.length; i++) {
                let nextSlot = this.slots[(slotIndex + 1) % this.slots.length];
                if (nextSlot == null || nextSlot.probeDistance === 0) {
                    this.slots[slotIndex] = undefined;
                    break;
                }
                this.slots[slotIndex] = Object.assign(Object.assign({}, nextSlot), { probeDistance: nextSlot.probeDistance - 1 });
                slotIndex = (slotIndex + 1) % this.slots.length;
            }
        }
        resizeIfNecessary() {
            let currentLoadFactor = this.slotsUsed / this.slots.length;
            let desiredSlotCount = this.slots.length;
            if (currentLoadFactor <= 0.25) {
                desiredSlotCount = Math.ceil(this.slots.length / 2);
            }
            if (currentLoadFactor >= 0.75) {
                desiredSlotCount = this.slots.length * 2;
            }
            if (desiredSlotCount === this.slots.length) {
                return;
            }
            let entries = new Array();
            for (let i = 0; i < this.slots.length; i++) {
                let slot = this.slots[i];
                if (slot != null) {
                    entries.push(slot);
                }
            }
            this.slots = new Array(desiredSlotCount);
            for (let { key, value } of entries) {
                this.doInsert(key, value);
            }
        }
        *[Symbol.iterator]() {
            for (let slot of this.slots) {
                if (slot == null) {
                    continue;
                }
                let { key, value } = Object.assign({}, slot);
                yield {
                    key,
                    value
                };
            }
        }
        insert(key, value) {
            let slotIndex = this.doInsert(key, value);
            if (slotIndex == null) {
                return false;
            }
            this.slotsUsed += 1;
            this.resizeIfNecessary();
            return true;
        }
        length() {
            return this.slotsUsed;
        }
        lookup(key) {
            let slotIndex = this.doLookup(key);
            if (slotIndex == null) {
                return;
            }
            let slot = this.slots[slotIndex];
            if (slot == null) {
                return;
            }
            return slot.value;
        }
        remove(key) {
            let slotIndex = this.doRemove(key);
            if (slotIndex == null) {
                return false;
            }
            this.slotsUsed -= 1;
            this.propagateBackwards(slotIndex);
            this.resizeIfNecessary();
            return true;
        }
        vacate() {
            this.slots = new Array(1);
            this.slotsUsed = 0;
        }
    }
    exports.RobinHoodHash = RobinHoodHash;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/collections/lhm", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/collections/dll", "node_modules/@joelek/ts-stdlib/dist/lib/collections/rhh"], function (require, exports, dll_1, rhh_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedHashMap = void 0;
    class LinkedHashMap {
        constructor() {
            this.list = new dll_1.DoublyLinkedList();
            this.hash = new rhh_1.RobinHoodHash();
        }
        *[Symbol.iterator]() {
            yield* this.list;
        }
        insert(key, value) {
            let node = this.hash.lookup(key);
            if (node != null) {
                node.getValue().value = value;
                return false;
            }
            else {
                node = this.list.append({ key, value });
                this.hash.insert(key, node);
                return true;
            }
        }
        length() {
            return this.hash.length();
        }
        lookup(key) {
            let node = this.hash.lookup(key);
            if (node == null) {
                return;
            }
            return node.getValue().value;
        }
        remove(key) {
            let node = this.hash.lookup(key);
            if (node != null) {
                this.hash.remove(key);
                this.list.remove(node);
                return true;
            }
            else {
                return false;
            }
        }
        vacate() {
            this.list = new dll_1.DoublyLinkedList();
            this.hash = new rhh_1.RobinHoodHash();
        }
    }
    exports.LinkedHashMap = LinkedHashMap;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/collections/index", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/collections/avl", "node_modules/@joelek/ts-stdlib/dist/lib/collections/dll", "node_modules/@joelek/ts-stdlib/dist/lib/collections/lhm", "node_modules/@joelek/ts-stdlib/dist/lib/collections/rhh"], function (require, exports, avl, dll, lhm, rhh) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rhh = exports.lhm = exports.dll = exports.avl = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rhh = exports.lhm = exports.dll = exports.avl = void 0;
    exports.avl = avl;
    exports.dll = dll;
    exports.lhm = lhm;
    exports.rhh = rhh;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/data/index", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/data/chunk", "node_modules/@joelek/ts-stdlib/dist/lib/data/parser"], function (require, exports, chunk, parser) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parser = exports.chunk = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parser = exports.chunk = void 0;
    exports.chunk = chunk;
    exports.parser = parser;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/routing/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamespacedMessageRouter = exports.MessageRouter = void 0;
    class MessageRouter {
        constructor() {
            this.observers = Object.create(null);
        }
        addObserver(type, observer) {
            let observers = this.observers[type];
            if (observers === undefined) {
                observers = new Set();
                this.observers[type] = observers;
            }
            observers.add(observer);
        }
        removeObserver(type, observer) {
            let observers = this.observers[type];
            if (observers !== undefined) {
                observers.delete(observer);
                if (observers.size === 0) {
                    delete this.observers[type];
                }
            }
        }
        route(type, message) {
            let observers = this.observers[type];
            if (observers !== undefined) {
                for (let observer of observers) {
                    observer(message);
                }
            }
        }
        size() {
            return Object.keys(this.observers).length;
        }
    }
    exports.MessageRouter = MessageRouter;
    ;
    class NamespacedMessageRouter {
        constructor() {
            this.routers = Object.create(null);
        }
        addObserver(namespace, type, observer) {
            let router = this.routers[namespace];
            if (router === undefined) {
                router = new MessageRouter();
                this.routers[namespace] = router;
            }
            router.addObserver(type, observer);
        }
        removeObserver(namespace, type, observer) {
            let router = this.routers[namespace];
            if (router !== undefined) {
                router.removeObserver(type, observer);
                if (router.size() === 0) {
                    delete this.routers[namespace];
                }
            }
        }
        route(namespace, type, message) {
            let router = this.routers[namespace];
            if (router !== undefined) {
                router.route(type, message);
            }
        }
    }
    exports.NamespacedMessageRouter = NamespacedMessageRouter;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/index", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/asserts/index", "node_modules/@joelek/ts-stdlib/dist/lib/collections/index", "node_modules/@joelek/ts-stdlib/dist/lib/data/index", "node_modules/@joelek/ts-stdlib/dist/lib/routing/index"], function (require, exports, asserts, collections, data, routing) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = exports.data = exports.collections = exports.asserts = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = exports.data = exports.collections = exports.asserts = void 0;
    exports.asserts = asserts;
    exports.collections = collections;
    exports.data = data;
    exports.routing = routing;
});
define("node_modules/@joelek/ts-sockets/dist/lib/shared", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusCode = exports.ReadyState = void 0;
    var ReadyState;
    (function (ReadyState) {
        ReadyState[ReadyState["CONNECTING"] = 0] = "CONNECTING";
        ReadyState[ReadyState["OPEN"] = 1] = "OPEN";
        ReadyState[ReadyState["CLOSING"] = 2] = "CLOSING";
        ReadyState[ReadyState["CLOSED"] = 3] = "CLOSED";
    })(ReadyState = exports.ReadyState || (exports.ReadyState = {}));
    ;
    var StatusCode;
    (function (StatusCode) {
        StatusCode[StatusCode["NORMAL"] = 1000] = "NORMAL";
        StatusCode[StatusCode["GOING_AWAY"] = 1001] = "GOING_AWAY";
        StatusCode[StatusCode["PROTOCOL_ERROR"] = 1002] = "PROTOCOL_ERROR";
        StatusCode[StatusCode["DATA_TYPE_NOT_ACCEPTED"] = 1003] = "DATA_TYPE_NOT_ACCEPTED";
        StatusCode[StatusCode["RESERVED_1004"] = 1004] = "RESERVED_1004";
        StatusCode[StatusCode["RESERVED_1005"] = 1005] = "RESERVED_1005";
        StatusCode[StatusCode["RESERVED_1006"] = 1006] = "RESERVED_1006";
        StatusCode[StatusCode["BAD_DATA_TYPE"] = 1007] = "BAD_DATA_TYPE";
        StatusCode[StatusCode["POLICY_VIOLATION"] = 1008] = "POLICY_VIOLATION";
        StatusCode[StatusCode["MESSAGE_TOO_BIG"] = 1009] = "MESSAGE_TOO_BIG";
        StatusCode[StatusCode["CLIENT_EXPECTED_EXTENSION"] = 1010] = "CLIENT_EXPECTED_EXTENSION";
        StatusCode[StatusCode["SERVER_UNEXPECTED_CONDITION"] = 1011] = "SERVER_UNEXPECTED_CONDITION";
        StatusCode[StatusCode["RESERVED_1015"] = 1015] = "RESERVED_1015";
    })(StatusCode = exports.StatusCode || (exports.StatusCode = {}));
    ;
    ;
});
define("build/typesockets/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Envelope = void 0;
    exports.Envelope = autoguard.guards.Object.of({
        "type": autoguard.guards.String,
        "data": autoguard.guards.Any
    }, {
        "id": autoguard.guards.String
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Envelope": autoguard.guards.Reference.of(() => exports.Envelope)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/typesockets/shared", ["require", "exports", "build/typesockets/schema/index", "build/is"], function (require, exports, schema, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Serializer = void 0;
    class Serializer {
        guards;
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let envelope = schema.Envelope.as(JSON.parse(string));
            let id = envelope.id;
            let type = envelope.type;
            let data = envelope.data;
            let guard = this.guards[type];
            if (is.absent(guard)) {
                throw `Unknown message type "${String(type)}"!`;
            }
            cb(type, guard.as(data), id);
        }
        serialize(type, data, id) {
            return JSON.stringify({
                type,
                data,
                id
            });
        }
    }
    exports.Serializer = Serializer;
    ;
});
define("build/typesockets/client", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/index", "node_modules/@joelek/ts-sockets/dist/lib/shared", "build/typesockets/shared", "build/is"], function (require, exports, stdlib, sockets, shared, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketClient = void 0;
    class TypeSocketClient {
        nextConnectionAttemptDelayFactor;
        nextConnectionAttemptDelay;
        router;
        serializer;
        url;
        factory;
        socket;
        requests;
        makeId() {
            let string = "";
            for (let i = 0; i < 32; i++) {
                let number = Math.floor(Math.random() * 16);
                string += number.toString(16);
            }
            return string;
        }
        makeSocket() {
            let socket = this.factory(this.url);
            socket.addEventListener("close", this.onClose.bind(this));
            socket.addEventListener("error", this.onError.bind(this));
            socket.addEventListener("message", this.onMessage.bind(this));
            socket.addEventListener("open", this.onOpen.bind(this));
            return socket;
        }
        onClose(event) {
            this.router.route("sys", "disconnect", {});
        }
        onError(event) {
            setTimeout(() => {
                this.socket = this.makeSocket();
            }, this.nextConnectionAttemptDelay);
            this.nextConnectionAttemptDelay = Math.round(this.nextConnectionAttemptDelay * this.nextConnectionAttemptDelayFactor);
        }
        onMessage(event) {
            try {
                this.serializer.deserialize(event.data, (type, data, id) => {
                    this.router.route("sys", "message", {
                        type,
                        data
                    });
                    if (is.present(id)) {
                        let callback = this.requests.get(id);
                        if (is.present(callback)) {
                            this.requests.delete(id);
                            callback(type, data);
                        }
                    }
                    this.router.route("app", type, data);
                });
            }
            catch (error) {
                this.socket.close();
            }
        }
        onOpen(event) {
            this.nextConnectionAttemptDelay = 2000;
            this.router.route("sys", "connect", {});
        }
        queue(payload) {
            if (this.socket.readyState === sockets.ReadyState.OPEN) {
                this.socket.send(payload);
            }
            else {
                let onopen = () => {
                    this.socket.removeEventListener("open", onopen);
                    this.socket.send(payload);
                };
                this.socket.addEventListener("open", onopen);
            }
        }
        constructor(url, factory, guards) {
            this.nextConnectionAttemptDelayFactor = 2.0 + Math.random();
            this.nextConnectionAttemptDelay = 2000;
            this.router = new stdlib.routing.NamespacedMessageRouter();
            this.serializer = new shared.Serializer(guards);
            this.url = url;
            this.factory = factory;
            this.socket = this.makeSocket();
            this.requests = new Map();
        }
        addEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        close() {
            this.socket.close();
        }
        reconnect() {
            if (this.socket.readyState === sockets.ReadyState.CLOSED) {
                this.socket = this.makeSocket();
            }
        }
        removeEventListener(namespace, type, listener) {
            this.router.removeObserver(namespace, type, listener);
        }
        request(type, response_type, data) {
            return new Promise((resolve, reject) => {
                let id = this.makeId();
                let payload = this.serializer.serialize(type, data, id);
                this.requests.set(id, (type, data) => {
                    if (type !== response_type) {
                        reject(`Received response with type "${String(type)}" when expecting "${String(response_type)}"!`);
                    }
                    else {
                        resolve(data);
                    }
                });
                this.queue(payload);
            });
        }
        send(type, data) {
            let payload = this.serializer.serialize(type, data);
            this.queue(payload);
        }
    }
    exports.TypeSocketClient = TypeSocketClient;
    ;
});
define("build/player/client", ["require", "exports", "build/is", "build/observers/index", "build/player/schema/index", "build/typesockets/client"], function (require, exports, is, observers, schema, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextClient = void 0;
    class ContextClient {
        tsc;
        estimatedProgress = new observers.ObservableClass(undefined);
        estimatedProgressTimestamp = new observers.ObservableClass(undefined);
        token = new observers.ObservableClass(undefined);
        localDevice = new observers.ObservableClass(undefined);
        devices = new observers.ArrayObservable(new Array());
        device = new observers.ObservableClass(undefined);
        isDeviceLocal = new observers.ObservableClass(false);
        isDeviceRemote = new observers.ObservableClass(false);
        context = new observers.ObservableClass(undefined);
        contextPath = new observers.ObservableClass(undefined);
        shuffle = new observers.ObservableClass(false);
        repeat = new observers.ObservableClass(false);
        flattenedContext = new observers.ObservableClass(undefined);
        order = new observers.ObservableClass(undefined);
        lastEntryIndex = new observers.ObservableClass(undefined);
        lastEntry = new observers.ObservableClass(undefined);
        lastLocalEntry = new observers.ObservableClass(undefined);
        currentEntryIndex = new observers.ObservableClass(undefined);
        currentEntry = new observers.ObservableClass(undefined);
        currentLocalEntry = new observers.ObservableClass(undefined);
        nextEntryIndex = new observers.ObservableClass(undefined);
        nextEntry = new observers.ObservableClass(undefined);
        nextLocalEntry = new observers.ObservableClass(undefined);
        playback = new observers.ObservableClass(false);
        playing = new observers.ObservableClass(false);
        progress = new observers.ObservableClass(undefined);
        localPlayback = new observers.ObservableClass(false);
        canPlayLast = new observers.ObservableClass(false);
        canPlayCurrent = new observers.ObservableClass(false);
        canPlayNext = new observers.ObservableClass(false);
        isCurrentEntryVideo = new observers.ObservableClass(false);
        isOnline = new observers.ObservableClass(false);
        flattenContext(context) {
            if (schema.objects.ContextAlbum.is(context)) {
                let files = [];
                let album = context;
                for (let disc of album.discs) {
                    files.push(...disc.tracks);
                }
                return files;
            }
            else if (schema.objects.ContextArtist.is(context)) {
                let files = [];
                let artist = context;
                for (let album of artist.albums) {
                    for (let disc of album.discs) {
                        files.push(...disc.tracks);
                    }
                }
                return files;
            }
            else if (schema.objects.ContextDisc.is(context)) {
                let files = [];
                let disc = context;
                files.push(...disc.tracks);
                return files;
            }
            else if (schema.objects.ContextEpisode.is(context)) {
                let files = [];
                let episode = context;
                files.push(episode);
                return files;
            }
            else if (schema.objects.ContextMovie.is(context)) {
                let files = [];
                let movie = context;
                files.push(movie);
                return files;
            }
            else if (schema.objects.ContextPlaylist.is(context)) {
                let files = [];
                let playlist = context;
                for (let item of playlist.items) {
                    files.push(item.track);
                }
                return files;
            }
            else if (schema.objects.ContextSeason.is(context)) {
                let files = [];
                let season = context;
                files.push(...season.episodes);
                return files;
            }
            else if (schema.objects.ContextShow.is(context)) {
                let files = [];
                let show = context;
                for (let season of show.seasons) {
                    files.push(...season.episodes);
                }
                return files;
            }
            else if (schema.objects.ContextTrack.is(context)) {
                let files = [];
                let track = context;
                files.push(track);
                return files;
            }
            else if (schema.objects.ContextYear.is(context)) {
                let files = [];
                let year = context;
                for (let album of year.albums) {
                    for (let disc of album.discs) {
                        files.push(...disc.tracks);
                    }
                }
                return files;
            }
            else if (schema.objects.ContextDirectory.is(context)) {
                let files = [];
                let directory = context;
                for (let file of directory.files) {
                    files.push(file);
                }
                return files;
            }
            else if (schema.objects.ContextFile.is(context)) {
                let files = [];
                let file = context;
                files.push(file);
                return files;
            }
            else {
                throw `Expected code to be unreachable!`;
            }
        }
        generateRandomOrder(flattenedContext, index) {
            let order = [...new Array(flattenedContext.length).keys()];
            for (let i = 0; i < flattenedContext.length * 2; i++) {
                let one = Math.floor(Math.random() * flattenedContext.length);
                let two = Math.floor(Math.random() * flattenedContext.length);
                let temp = order[one];
                order[one] = order[two];
                order[two] = temp;
            }
            let one = 0;
            let two = order.indexOf(index);
            let temp = order[one];
            order[one] = order[two];
            order[two] = temp;
            return order;
        }
        sendPlay(context, index) {
            let flattenedContext = this.flattenContext(context);
            if (index == null) {
                index = this.shuffle.getState() ? Math.floor(Math.random() * flattenedContext.length) : 0;
            }
            let order = this.generateRandomOrder(flattenedContext, index);
            this.context.updateState(context);
            this.currentEntryIndex.updateState(index);
            this.order.updateState(order);
            this.progress.updateState(0);
            this.playback.updateState(true);
            this.playing.updateState(false);
            this.isCurrentEntryVideo.updateState(false);
            this.tsc.send("SetContext", {
                context
            });
            this.tsc.send("SetIndex", {
                index
            });
            this.tsc.send("SetOrder", {
                order
            });
            this.tsc.send("SetProgress", {
                progress: 0
            });
            this.tsc.send("SetPlayback", {
                playback: true
            });
            this.tsc.send("SetPlaying", {
                playing: false
            });
        }
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.tsc = new typesockets.TypeSocketClient(url, factory, schema.messages.Autoguard.Guards);
            this.tsc.addEventListener("sys", "connect", () => {
                this.isOnline.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.isOnline.updateState(false);
            });
            this.context.addObserver((context) => {
                if (is.present(context)) {
                    this.flattenedContext.updateState(this.flattenContext(context));
                }
            });
            {
                let computer = () => {
                    let context = this.context.getState();
                    let currentEntryIndex = this.currentEntryIndex.getState();
                    if (is.present(context) && is.present(currentEntryIndex)) {
                        if (schema.objects.ContextAlbum.is(context)) {
                            let discIndex = 0;
                            let trackIndex = currentEntryIndex;
                            let album = context;
                            let discs = album.discs;
                            for (let d = 0; d < discs.length; d++) {
                                let length = discs[d].tracks.length;
                                if (trackIndex >= length) {
                                    discIndex += 1;
                                    trackIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.album_id,
                                context.discs[discIndex]?.disc_id,
                                context.discs[discIndex]?.tracks[trackIndex]?.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextArtist.is(context)) {
                            let albumIndex = 0;
                            let discIndex = 0;
                            let trackIndex = currentEntryIndex;
                            let artist = context;
                            let albums = artist.albums;
                            outer: for (let a = 0; a < albums.length; a++) {
                                let discs = albums[a].discs;
                                for (let d = 0; d < discs.length; d++) {
                                    let length = discs[d].tracks.length;
                                    if (trackIndex >= length) {
                                        discIndex += 1;
                                        trackIndex -= length;
                                    }
                                    else {
                                        break outer;
                                    }
                                }
                                albumIndex += 1;
                                discIndex = 0;
                            }
                            return this.contextPath.updateState([
                                context.artist_id,
                                context.albums[albumIndex]?.album_id,
                                context.albums[albumIndex]?.discs[discIndex]?.disc_id,
                                context.albums[albumIndex]?.discs[discIndex]?.tracks[trackIndex]?.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextDisc.is(context)) {
                            let trackIndex = currentEntryIndex;
                            return this.contextPath.updateState([
                                context.disc_id,
                                context.tracks[trackIndex]?.track_id,
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextEpisode.is(context)) {
                            return this.contextPath.updateState([
                                context.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextMovie.is(context)) {
                            return this.contextPath.updateState([
                                context.movie_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextPlaylist.is(context)) {
                            let itemIndex = currentEntryIndex;
                            return this.contextPath.updateState([
                                context.playlist_id,
                                context.items[itemIndex]?.track.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextShow.is(context)) {
                            let seasonIndex = 0;
                            let episodeIndex = currentEntryIndex;
                            let show = context;
                            let seasons = show.seasons;
                            for (let d = 0; d < seasons.length; d++) {
                                let length = seasons[d].episodes.length;
                                if (episodeIndex >= length) {
                                    seasonIndex += 1;
                                    episodeIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.show_id,
                                context.seasons[seasonIndex]?.season_id,
                                context.seasons[seasonIndex]?.episodes[episodeIndex]?.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextSeason.is(context)) {
                            let episodeIndex = currentEntryIndex;
                            return this.contextPath.updateState([
                                context.season_id,
                                context.episodes[episodeIndex]?.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextTrack.is(context)) {
                            return this.contextPath.updateState([
                                context.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextYear.is(context)) {
                            return this.contextPath.updateState([
                                context.year_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextDirectory.is(context)) {
                            let entryIndex = currentEntryIndex;
                            return this.contextPath.updateState([
                                context.directory_id,
                                context.files[entryIndex]?.file_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextFile.is(context)) {
                            return this.contextPath.updateState([
                                context.file_id
                            ].filter(is.present));
                        }
                        else {
                            throw `Expected code to be unreachable!`;
                        }
                    }
                    this.contextPath.updateState(undefined);
                };
                this.context.addObserver(computer);
                this.currentEntryIndex.addObserver(computer);
            }
            this.lastEntry.addObserver((lastEntry) => {
                this.canPlayLast.updateState(is.present(lastEntry));
            });
            this.currentEntry.addObserver((currentEntry) => {
                this.canPlayCurrent.updateState(is.present(currentEntry));
            });
            this.nextEntry.addObserver((nextEntry) => {
                this.canPlayNext.updateState(is.present(nextEntry));
            });
            this.progress.addObserver((progress) => {
                this.estimatedProgress.updateState(progress);
                this.estimatedProgressTimestamp.updateState(Date.now());
            }, true);
            this.playing.addObserver((playing) => {
                let estimatedProgress = this.estimatedProgress.getState();
                let estimatedProgressTimestamp = this.estimatedProgressTimestamp.getState();
                let now = Date.now();
                if (!playing) {
                    if (is.present(estimatedProgress) && is.present(estimatedProgressTimestamp)) {
                        this.estimatedProgress.updateState(estimatedProgress + (now - estimatedProgressTimestamp) / 1000);
                    }
                }
                this.estimatedProgressTimestamp.updateState(now);
            });
            this.progress.addObserver((progress) => {
                console.log(`Progress: ${progress}`);
            });
            this.estimatedProgress.addObserver((estimatedProgress) => {
                console.log(`Estimated progress: ${estimatedProgress}`);
            });
            {
                let computer = () => {
                    let playback = this.playback.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.localPlayback.updateState(isDeviceLocal && playback);
                };
                this.playback.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let lastEntry = this.lastEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.lastLocalEntry.updateState(isDeviceLocal ? lastEntry : undefined);
                };
                this.lastEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let currentEntry = this.currentEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.currentLocalEntry.updateState(isDeviceLocal ? currentEntry : undefined);
                };
                this.currentEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let nextEntry = this.nextEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.nextLocalEntry.updateState(isDeviceLocal ? nextEntry : undefined);
                };
                this.nextEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id === device.id) {
                            return this.isDeviceLocal.updateState(true);
                        }
                    }
                    return this.isDeviceLocal.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id !== device.id) {
                            return this.isDeviceRemote.updateState(true);
                        }
                    }
                    return this.isDeviceRemote.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let order = this.order.getState();
                    let currentEntryIndex = this.currentEntryIndex.getState();
                    let repeat = this.repeat.getState();
                    let shuffle = this.shuffle.getState();
                    let lastEntryIndex;
                    if (is.present(order) && is.present(currentEntryIndex)) {
                        lastEntryIndex = shuffle ? order.indexOf(currentEntryIndex) : currentEntryIndex;
                        lastEntryIndex -= 1;
                        if (repeat) {
                            lastEntryIndex = (lastEntryIndex + order.length) % order.length;
                        }
                        if (lastEntryIndex < 0 || lastEntryIndex >= order.length) {
                            lastEntryIndex = undefined;
                        }
                        else {
                            lastEntryIndex = shuffle ? order[lastEntryIndex] : lastEntryIndex;
                        }
                    }
                    this.lastEntryIndex.updateState(lastEntryIndex);
                };
                this.order.addObserver(computer);
                this.currentEntryIndex.addObserver(computer);
                this.repeat.addObserver(computer);
                this.shuffle.addObserver(computer);
            }
            {
                let computer = () => {
                    let order = this.order.getState();
                    let currentEntryIndex = this.currentEntryIndex.getState();
                    let repeat = this.repeat.getState();
                    let shuffle = this.shuffle.getState();
                    let nextEntryIndex;
                    if (is.present(order) && is.present(currentEntryIndex)) {
                        nextEntryIndex = shuffle ? order.indexOf(currentEntryIndex) : currentEntryIndex;
                        nextEntryIndex += 1;
                        if (repeat) {
                            nextEntryIndex = (nextEntryIndex + order.length) % order.length;
                        }
                        if (nextEntryIndex < 0 || nextEntryIndex >= order.length) {
                            nextEntryIndex = undefined;
                        }
                        else {
                            nextEntryIndex = shuffle ? order[nextEntryIndex] : nextEntryIndex;
                        }
                    }
                    this.nextEntryIndex.updateState(nextEntryIndex);
                };
                this.order.addObserver(computer);
                this.currentEntryIndex.addObserver(computer);
                this.repeat.addObserver(computer);
                this.shuffle.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let lastEntryIndex = this.lastEntryIndex.getState();
                    let lastEntry;
                    if (is.present(flattenedContext) && is.present(lastEntryIndex)) {
                        if (lastEntryIndex >= 0 && lastEntryIndex < flattenedContext.length) {
                            lastEntry = flattenedContext[lastEntryIndex];
                        }
                    }
                    return this.lastEntry.updateState(lastEntry);
                };
                this.flattenedContext.addObserver(computer);
                this.lastEntryIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let currentEntryIndex = this.currentEntryIndex.getState();
                    let currentEntry;
                    if (is.present(flattenedContext) && is.present(currentEntryIndex)) {
                        if (currentEntryIndex >= 0 && currentEntryIndex < flattenedContext.length) {
                            currentEntry = flattenedContext[currentEntryIndex];
                        }
                    }
                    return this.currentEntry.updateState(currentEntry);
                };
                this.flattenedContext.addObserver(computer);
                this.currentEntryIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let nextEntryIndex = this.nextEntryIndex.getState();
                    let nextEntry;
                    if (is.present(flattenedContext) && is.present(nextEntryIndex)) {
                        if (nextEntryIndex >= 0 && nextEntryIndex < flattenedContext.length) {
                            nextEntry = flattenedContext[nextEntryIndex];
                        }
                    }
                    return this.nextEntry.updateState(nextEntry);
                };
                this.flattenedContext.addObserver(computer);
                this.nextEntryIndex.addObserver(computer);
            }
            this.tsc.addEventListener("app", "SetLocalDevice", (message) => {
                this.localDevice.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetDevices", (message) => {
                this.devices.update(message.devices);
            });
            this.tsc.addEventListener("app", "SetContext", (message) => {
                this.context.updateState(message.context);
            });
            this.tsc.addEventListener("app", "SetDevice", (message) => {
                this.device.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetIndex", (message) => {
                this.currentEntryIndex.updateState(message.index);
            });
            this.tsc.addEventListener("app", "SetOrder", (message) => {
                this.order.updateState(message.order);
            });
            this.tsc.addEventListener("app", "SetPlayback", (message) => {
                this.playback.updateState(message.playback);
            });
            this.tsc.addEventListener("app", "SetPlaying", (message) => {
                this.playing.updateState(message.playing);
            });
            this.tsc.addEventListener("app", "SetProgress", (message) => {
                this.progress.updateState(message.progress);
            });
            this.tsc.addEventListener("app", "SetRepeat", (message) => {
                this.repeat.updateState(message.repeat);
            });
            this.tsc.addEventListener("app", "SetShuffle", (message) => {
                this.shuffle.updateState(message.shuffle);
            });
            this.tsc.addEventListener("app", "SetToken", (message) => {
                this.token.updateState(message.token);
            });
            this.isOnline.addObserver((isOnline) => {
                if (!isOnline) {
                    this.context.updateState(undefined);
                    this.currentEntryIndex.updateState(undefined);
                    this.order.updateState(undefined);
                    this.playback.updateState(false);
                    this.progress.updateState(undefined);
                }
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.isOnline, this.token);
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        close() {
            this.tsc.close();
        }
        enable() {
            let localDevice = this.localDevice.getState();
            if (localDevice != null) {
                this.tsc.send("SetLocalDevice", {
                    device: {
                        ...localDevice,
                        enabled: true
                    }
                });
            }
        }
        last() {
            let lastEntryIndex = this.lastEntryIndex.getState();
            if (is.present(lastEntryIndex)) {
                this.progress.updateState(undefined);
                this.currentEntryIndex.updateState(lastEntryIndex);
                this.tsc.send("SetIndex", {
                    index: lastEntryIndex
                });
            }
            else {
                this.pause();
            }
        }
        next() {
            let nextEntryIndex = this.nextEntryIndex.getState();
            if (is.present(nextEntryIndex)) {
                this.progress.updateState(undefined);
                this.currentEntryIndex.updateState(nextEntryIndex);
                this.tsc.send("SetIndex", {
                    index: nextEntryIndex
                });
            }
            else {
                this.pause();
            }
        }
        pause() {
            this.playback.updateState(false);
            this.tsc.send("SetPlayback", {
                playback: false
            });
        }
        play() {
            this.resume();
        }
        playAlbum(album, discIndex, trackIndex) {
            let index;
            if (is.present(discIndex)) {
                index = index ?? 0;
                let discs = album.discs;
                if (discIndex < 0 || discIndex >= discs.length) {
                    throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                }
                index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                if (is.present(trackIndex)) {
                    let tracks = discs[discIndex].tracks;
                    if (trackIndex < 0 || trackIndex >= tracks.length) {
                        throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                    }
                    index += trackIndex;
                }
            }
            return this.sendPlay(album, index);
        }
        playArtist(artist, albumIndex, discIndex, trackIndex) {
            let index;
            if (is.present(albumIndex)) {
                index = index ?? 0;
                let albums = artist.albums;
                if (albumIndex < 0 || albumIndex >= albums.length) {
                    throw `Expected ${albumIndex} to be a number between 0 and ${albums.length}!`;
                }
                index += albums.slice(0, albumIndex).reduce((sum, album) => sum + album.discs.reduce((sum, disc) => sum + disc.tracks.length, 0), 0);
                if (is.present(discIndex)) {
                    let discs = albums[albumIndex].discs;
                    if (discIndex < 0 || discIndex >= discs.length) {
                        throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                    }
                    index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                    if (is.present(trackIndex)) {
                        let tracks = discs[discIndex].tracks;
                        if (trackIndex < 0 || trackIndex >= tracks.length) {
                            throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                        }
                        index += trackIndex;
                    }
                }
            }
            return this.sendPlay(artist, index);
        }
        playDirectory(directory, fileIndex) {
            let index;
            if (is.present(fileIndex)) {
                index = index ?? 0;
                let files = directory.files;
                if (fileIndex < 0 || fileIndex >= files.length) {
                    throw `Expected ${fileIndex} to be a number between 0 and ${files.length}!`;
                }
                index += fileIndex;
            }
            return this.sendPlay(directory, index);
        }
        playDisc(disc, trackIndex) {
            let index;
            if (is.present(trackIndex)) {
                index = index ?? 0;
                let tracks = disc.tracks;
                if (trackIndex < 0 || trackIndex >= tracks.length) {
                    throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                }
                index += trackIndex;
            }
            return this.sendPlay(disc, index);
        }
        playEpisode(episode) {
            this.sendPlay(episode);
        }
        playFile(file) {
            return this.sendPlay(file);
        }
        playMovie(movie) {
            this.sendPlay(movie);
        }
        playPlaylist(playlist, itemIndex) {
            let index;
            if (is.present(itemIndex)) {
                index = index ?? 0;
                let items = playlist.items;
                if (itemIndex < 0 || itemIndex >= items.length) {
                    throw `Expected ${itemIndex} to be a number between 0 and ${items.length}!`;
                }
                index += itemIndex;
            }
            return this.sendPlay(playlist, index);
        }
        playSeason(season, episodeIndex) {
            let index;
            if (is.present(episodeIndex)) {
                index = index ?? 0;
                let episodes = season.episodes;
                if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                    throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                }
                index += episodeIndex;
            }
            return this.sendPlay(season, index);
        }
        playShow(show, seasonIndex, episodeIndex) {
            let index;
            if (is.present(seasonIndex)) {
                index = index ?? 0;
                let seasons = show.seasons;
                if (seasonIndex < 0 || seasonIndex >= seasons.length) {
                    throw `Expected ${seasonIndex} to be a number between 0 and ${seasons.length}!`;
                }
                index += seasons.slice(0, seasonIndex).reduce((sum, season) => sum + season.episodes.length, 0);
                if (is.present(episodeIndex)) {
                    let episodes = seasons[seasonIndex].episodes;
                    if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                        throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                    }
                    index += episodeIndex;
                }
            }
            return this.sendPlay(show, index);
        }
        playTrack(track) {
            this.sendPlay(track);
        }
        playYear(year) {
            this.sendPlay(year);
        }
        reconnect() {
            this.tsc.reconnect();
        }
        resume() {
            if (this.canPlayCurrent.getState()) {
                this.playback.updateState(true);
                this.tsc.send("SetPlayback", {
                    playback: true
                });
            }
        }
        seek(progress) {
            this.progress.updateState(progress);
            this.tsc.send("SetProgress", {
                progress: progress
            });
        }
        setPlaying(playing) {
            this.playing.updateState(playing);
            this.tsc.send("SetPlaying", {
                playing: playing
            });
        }
        togglePlayback() {
            if (this.playback.getState()) {
                this.pause();
            }
            else {
                this.resume();
            }
        }
        toggleRepeat() {
            let repeat = !this.repeat.getState();
            this.repeat.updateState(repeat);
            this.tsc.send("SetRepeat", {
                repeat: repeat
            });
        }
        toggleShuffle() {
            let shuffle = !this.shuffle.getState();
            this.shuffle.updateState(shuffle);
            this.tsc.send("SetShuffle", {
                shuffle: shuffle
            });
        }
        transfer(device) {
            this.tsc.send("SetDevice", {
                device: device
            });
        }
    }
    exports.ContextClient = ContextClient;
});
define("build/xnode/index", ["require", "exports", "build/is", "build/observers/index"], function (require, exports, is, observers_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinarray = exports.text = exports.element = exports.XElement = exports.XText = void 0;
    class XText {
        content;
        constructor(content) {
            this.content = content;
        }
        render() {
            let node = document.createTextNode("");
            if (this.content instanceof observers_1.ObservableClass) {
                this.content.addObserver((content) => {
                    node.textContent = content;
                });
            }
            else {
                node.textContent = this.content;
            }
            return node;
        }
    }
    exports.XText = XText;
    class XElement {
        tag;
        attributes;
        children;
        bound;
        bound2;
        listeners;
        resolve;
        element;
        array;
        renderer;
        constructor(selector) {
            let parts = selector.split(".");
            this.tag = parts[0];
            this.attributes = new Map();
            this.children = new Array();
            this.bound = new Map();
            this.bound2 = new Map();
            this.listeners = new Map();
            this.resolve = () => { };
            this.element = new Promise((resolve, reject) => {
                this.resolve = resolve;
            });
            let classes = parts.slice(1).join(" ");
            if (classes !== "") {
                this.attributes.set("class", classes);
            }
        }
        add(...nodes) {
            // TODO: Detach node from current parent.
            for (let node of nodes) {
                if (node != null) {
                    this.children.push(node);
                }
            }
            return this;
        }
        bind(key, observable) {
            this.bound.set(key, observable);
            return this;
        }
        bind2(key, observable) {
            this.bound2.set(key, observable);
            return this;
        }
        on(kind, listener, override = true) {
            let listeners = this.listeners.get(kind);
            if (listeners == null) {
                listeners = new Array();
                this.listeners.set(kind, listeners);
            }
            listeners.push(async (event) => {
                if (override) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                await listener(event);
            });
            return this;
        }
        ref() {
            if (is.absent(this.element)) {
                throw `Expected element to be rendered!`;
            }
            return this.element;
        }
        render() {
            let ns = ["svg", "path", "circle"].indexOf(this.tag) >= 0 ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml";
            let element = document.createElementNS(ns, this.tag);
            element.setAttribute = (() => {
                let setAttribute = element.setAttribute.bind(element);
                return (key, value) => {
                    if (key === "src") {
                        let observer = new IntersectionObserver((entries) => {
                            for (let entry of entries) {
                                if (entry.target === element && entry.isIntersecting) {
                                    observer.unobserve(element);
                                    setAttribute(key, value);
                                }
                            }
                        }, { root: document.body });
                        observer.observe(element);
                    }
                    else {
                        setAttribute(key, value);
                    }
                };
            })();
            for (let [kind, listeners] of this.listeners) {
                for (let listener of listeners) {
                    element.addEventListener(kind, listener);
                }
            }
            for (let [key, value] of this.attributes) {
                element.setAttribute(key, value);
            }
            for (let [key, observable] of this.bound) {
                observable((value) => {
                    element.setAttribute(key, `${value}`);
                });
            }
            for (let [key, observable] of this.bound2) {
                observable.addObserver((value) => {
                    element.setAttribute(key, `${value}`);
                });
                if (this.tag === "input" && key === "value") {
                    element.addEventListener("input", () => {
                        observable.updateState(element.value);
                    });
                }
            }
            for (let child of this.children) {
                element.appendChild(child.render());
            }
            if (this.array) {
                this.array.addObserver({
                    onappend: (state, index) => {
                        if (this.renderer) {
                            let child = this.renderer(state, index);
                            element.appendChild(child.render());
                        }
                    },
                    onsplice: (state, index) => {
                        let child = element.children[index];
                        if (is.present(child)) {
                            element.removeChild(child);
                        }
                    }
                });
            }
            this.resolve(element);
            return element;
        }
        repeat(array, renderer) {
            this.array = array;
            this.renderer = renderer;
            return this;
        }
        set(key, value = "") {
            this.attributes.set(key, value);
            return this;
        }
    }
    exports.XElement = XElement;
    function element(selector) {
        return new XElement(selector);
    }
    exports.element = element;
    function text(content) {
        return new XText(content);
    }
    exports.text = text;
    function joinarray(nodes, joiner = " \u00b7 ") {
        let array = [];
        for (let node of nodes) {
            array.push(node);
            array.push(text(joiner));
        }
        array.pop();
        return array;
    }
    exports.joinarray = joinarray;
});
define("build/ui/metadata/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatDuration = exports.computeDuration = exports.formatTimestamp = exports.formatSize = void 0;
    function formatSize(b) {
        let kb = Math.floor(b / 1024);
        let mb = Math.floor(kb / 1024);
        let gb = Math.floor(mb / 1024);
        let tb = Math.floor(gb / 1024);
        if (tb >= 10) {
            return `${tb} TB`;
        }
        else if (gb >= 10) {
            return `${gb} GB`;
        }
        else if (mb >= 10) {
            return `${mb} MB`;
        }
        else if (kb >= 10) {
            return `${kb} kB`;
        }
        else {
            return `${b} B`;
        }
    }
    exports.formatSize = formatSize;
    ;
    function formatTimestamp(timestamp) {
        let iso = new Date(timestamp).toISOString();
        let date = iso.slice(0, 10);
        let time = iso.slice(11, 19);
        return `${date} ${time}`;
    }
    exports.formatTimestamp = formatTimestamp;
    ;
    function computeDuration(ms) {
        let s = Math.floor(ms / 1000);
        ms -= s * 1000;
        let m = Math.floor(s / 60);
        s -= m * 60;
        let h = Math.floor(m / 60);
        m -= h * 60;
        let d = Math.floor(h / 24);
        h -= d * 24;
        return {
            ms,
            s,
            m,
            h,
            d
        };
    }
    exports.computeDuration = computeDuration;
    ;
    function formatDuration(ms) {
        let duration = computeDuration(ms);
        if (duration.d >= 10) {
            return `${duration.d}d`;
        }
        else if (duration.d >= 1) {
            return `${duration.d}d ${duration.h}h`;
        }
        else if (duration.h >= 10) {
            return `${duration.h}h`;
        }
        else if (duration.h >= 1) {
            return `${duration.h}h ${duration.m}m`;
        }
        else if (duration.m >= 10) {
            return `${duration.m}m`;
        }
        else if (duration.m >= 1) {
            return `${duration.m}m ${duration.s}s`;
        }
        else {
            return `${duration.s}s`;
        }
    }
    exports.formatDuration = formatDuration;
    ;
});
define("build/api/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.RegisterResponse = exports.RegisterRequest = exports.ErrorMessage = void 0;
    exports.ErrorMessage = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.RegisterRequest = autoguard.guards.Object.of({
        "username": autoguard.guards.String,
        "password": autoguard.guards.String,
        "name": autoguard.guards.String,
        "key_id": autoguard.guards.String
    }, {});
    exports.RegisterResponse = autoguard.guards.Object.of({
        "token": autoguard.guards.String
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ErrorMessage": autoguard.guards.Reference.of(() => exports.ErrorMessage),
            "RegisterRequest": autoguard.guards.Reference.of(() => exports.RegisterRequest),
            "RegisterResponse": autoguard.guards.Reference.of(() => exports.RegisterResponse)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/api/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/messages/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/messages/index", "build/api/schema/messages/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2, objects_3, objects_4, objects_5, objects_6, objects_7, objects_8, objects_9, objects_10, objects_11, objects_12, objects_13, messages_1, objects_14, objects_15, objects_16, objects_17, objects_18, objects_19, objects_20, objects_21, messages_2, messages_3, objects_22, objects_23, objects_24, objects_25, objects_26, objects_27, objects_28, objects_29, objects_30) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.StringStatistic = exports.NumberStatistic = exports.YearResult = exports.UserResult = exports.TrackResult = exports.ShowResult = exports.SeasonResult = exports.PlaylistResult = exports.MovieResult = exports.CategoryResult = exports.GenreResult = exports.EpisodeResult = exports.DiscResult = exports.ArtistResult = exports.AlbumResult = exports.ActorResult = void 0;
    exports.ActorResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_1.Actor),
        "rank": autoguard.guards.Number
    }, {});
    exports.AlbumResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_2.Album),
        "rank": autoguard.guards.Number
    }, {});
    exports.ArtistResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_4.Artist),
        "rank": autoguard.guards.Number
    }, {});
    exports.DiscResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_9.Disc),
        "rank": autoguard.guards.Number
    }, {});
    exports.EpisodeResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_12.Episode),
        "rank": autoguard.guards.Number
    }, {});
    exports.GenreResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_16.Genre),
        "rank": autoguard.guards.Number
    }, {});
    exports.CategoryResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_6.Category),
        "rank": autoguard.guards.Number
    }, {});
    exports.MovieResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_17.Movie),
        "rank": autoguard.guards.Number
    }, {});
    exports.PlaylistResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_19.Playlist),
        "rank": autoguard.guards.Number
    }, {});
    exports.SeasonResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_22.Season),
        "rank": autoguard.guards.Number
    }, {});
    exports.ShowResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_24.Show),
        "rank": autoguard.guards.Number
    }, {});
    exports.TrackResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_26.Track),
        "rank": autoguard.guards.Number
    }, {});
    exports.UserResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_28.User),
        "rank": autoguard.guards.Number
    }, {});
    exports.YearResult = autoguard.guards.Object.of({
        "entity": autoguard.guards.Reference.of(() => objects_29.Year),
        "rank": autoguard.guards.Number
    }, {});
    exports.NumberStatistic = autoguard.guards.Object.of({
        "title": autoguard.guards.String,
        "value": autoguard.guards.Number
    }, {
        "unit": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("BYTES"), autoguard.guards.StringLiteral.of("MILLISECONDS"), autoguard.guards.StringLiteral.of("TIMESTAMP"))
    });
    exports.StringStatistic = autoguard.guards.Object.of({
        "title": autoguard.guards.String,
        "value": autoguard.guards.String
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ActorResult": autoguard.guards.Reference.of(() => exports.ActorResult),
            "AlbumResult": autoguard.guards.Reference.of(() => exports.AlbumResult),
            "ArtistResult": autoguard.guards.Reference.of(() => exports.ArtistResult),
            "DiscResult": autoguard.guards.Reference.of(() => exports.DiscResult),
            "EpisodeResult": autoguard.guards.Reference.of(() => exports.EpisodeResult),
            "GenreResult": autoguard.guards.Reference.of(() => exports.GenreResult),
            "CategoryResult": autoguard.guards.Reference.of(() => exports.CategoryResult),
            "MovieResult": autoguard.guards.Reference.of(() => exports.MovieResult),
            "PlaylistResult": autoguard.guards.Reference.of(() => exports.PlaylistResult),
            "SeasonResult": autoguard.guards.Reference.of(() => exports.SeasonResult),
            "ShowResult": autoguard.guards.Reference.of(() => exports.ShowResult),
            "TrackResult": autoguard.guards.Reference.of(() => exports.TrackResult),
            "UserResult": autoguard.guards.Reference.of(() => exports.UserResult),
            "YearResult": autoguard.guards.Reference.of(() => exports.YearResult),
            "NumberStatistic": autoguard.guards.Reference.of(() => exports.NumberStatistic),
            "StringStatistic": autoguard.guards.Reference.of(() => exports.StringStatistic)
        };
        Autoguard.Requests = {
            "POST:/auth/": autoguard.guards.Object.of({
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "x-circus-username": autoguard.guards.String,
                    "x-circus-password": autoguard.guards.String
                }, {}), autoguard.api.Headers)
            }, {
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Options),
                "payload": autoguard.api.Binary
            }),
            "POST:/users/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Reference.of(() => messages_2.RegisterRequest)
            }, {
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Options),
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number,
                    "cues": autoguard.guards.Boolean
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/actors/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/actors/<actor_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/actors/<actor_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/actors/<actor_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/albums/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getNewAlbums": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/albums/<album_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "album_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getAlbumDiscs": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "album_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getAlbumContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "album_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/artists/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/artists/<artist_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "artist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getArtistAlbums": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "artist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getArtistContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "artist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/discs/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/discs/<disc_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "disc_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getDiscTracks": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "disc_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getDiscContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "disc_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/episodes/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/episodes/<episode_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "episode_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getEpisodeContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "episode_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/genres/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/genres/<genre_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/genres/<genre_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/genres/<genre_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/categories/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/categories/<category_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "category_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/categories/<category_id>/albums/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "category_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/movies/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getNewMovies": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/movies/<movie_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "movie_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/movies/<movie_id>/suggestions/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "movie_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getMovieContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "movie_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getMovieActors": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "movie_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/playlists/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/playlists/<playlist_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "playlist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getPlaylistItems": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "playlist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getPlaylistContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "playlist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/seasons/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/seasons/<season_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "season_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getSeasonEpisodes": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "season_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getSeasonContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "season_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/shows/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/shows/<show_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "show_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getShowSeasons": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "show_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getShowContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "show_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getShowActors": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "show_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/tracks/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/tracks/<track_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "track_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/tracks/<track_id>/playlists/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "track_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getTrackContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "track_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/users/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/users/<user_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/users/<user_id>/albums/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getUserArtists": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/users/<user_id>/playlists/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/users/<user_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/years/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/years/<year_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/years/<year_id>/albums/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/years/<year_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getYearContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getDirectory": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "directory_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getDirectoryDirectories": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "directory_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Integer,
                    "limit": autoguard.guards.Integer
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getDirectoryFiles": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "directory_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Integer,
                    "limit": autoguard.guards.Integer
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getDirectoryContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "directory_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getFile": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "file_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getFileContext": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "file_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getFileContent": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "file_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/statistics/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            })
        };
        Autoguard.Responses = {
            "POST:/auth/": autoguard.guards.Object.of({
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "x-circus-token": autoguard.guards.String
                }, {}), autoguard.api.Headers)
            }, {
                "status": autoguard.guards.Number,
                "payload": autoguard.api.Binary
            }),
            "POST:/users/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => messages_3.RegisterResponse), autoguard.guards.Reference.of(() => messages_1.ErrorMessage))
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "entities": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Entity))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/actors/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ActorResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/actors/<actor_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "actor": autoguard.guards.Reference.of(() => objects_1.Actor)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/actors/<actor_id>/movies/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_17.Movie))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/actors/<actor_id>/shows/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_24.Show))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/albums/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.AlbumResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getNewAlbums": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/albums/<album_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "album": autoguard.guards.Reference.of(() => objects_2.Album)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getAlbumDiscs": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "discs": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_9.Disc))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getAlbumContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_3.AlbumContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/artists/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ArtistResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/artists/<artist_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "artist": autoguard.guards.Reference.of(() => objects_4.Artist),
                    "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_26.Track)),
                    "appearances": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getArtistAlbums": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getArtistContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_5.ArtistContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/discs/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.DiscResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/discs/<disc_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "disc": autoguard.guards.Reference.of(() => objects_9.Disc)
                }, {
                    "last": autoguard.guards.Reference.of(() => objects_9.Disc),
                    "next": autoguard.guards.Reference.of(() => objects_9.Disc)
                })
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getDiscTracks": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_26.Track))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getDiscContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_10.DiscContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/episodes/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.EpisodeResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/episodes/<episode_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "episode": autoguard.guards.Reference.of(() => objects_12.Episode)
                }, {
                    "last": autoguard.guards.Reference.of(() => objects_12.Episode),
                    "next": autoguard.guards.Reference.of(() => objects_12.Episode)
                })
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getEpisodeContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_13.EpisodeContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/genres/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.GenreResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/genres/<genre_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "genre": autoguard.guards.Reference.of(() => objects_16.Genre)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/genres/<genre_id>/movies/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_17.Movie))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/genres/<genre_id>/shows/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_24.Show))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/categories/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.CategoryResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/categories/<category_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "category": autoguard.guards.Reference.of(() => objects_6.Category)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/categories/<category_id>/albums/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/movies/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.MovieResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getNewMovies": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_17.Movie))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/movies/<movie_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movie": autoguard.guards.Reference.of(() => objects_17.Movie),
                    "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_1.Actor))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/movies/<movie_id>/suggestions/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_17.Movie))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getMovieContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_18.MovieContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getMovieActors": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_1.Actor))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/playlists/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.PlaylistResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/playlists/<playlist_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "playlist": autoguard.guards.Reference.of(() => objects_19.Playlist)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getPlaylistItems": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "items": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_21.PlaylistItem))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getPlaylistContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_20.PlaylistContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/seasons/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.SeasonResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/seasons/<season_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "season": autoguard.guards.Reference.of(() => objects_22.Season)
                }, {
                    "last": autoguard.guards.Reference.of(() => objects_22.Season),
                    "next": autoguard.guards.Reference.of(() => objects_22.Season)
                })
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getSeasonEpisodes": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "episodes": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_12.Episode))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getSeasonContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_23.SeasonContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/shows/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ShowResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/shows/<show_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "show": autoguard.guards.Reference.of(() => objects_24.Show),
                    "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_1.Actor))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getShowSeasons": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "seasons": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_22.Season))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getShowContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_25.ShowContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getShowActors": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_1.Actor))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/tracks/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.TrackResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/tracks/<track_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "track": autoguard.guards.Reference.of(() => objects_26.Track)
                }, {
                    "last": autoguard.guards.Reference.of(() => objects_26.Track),
                    "next": autoguard.guards.Reference.of(() => objects_26.Track)
                })
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/tracks/<track_id>/playlists/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "playlists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_19.Playlist))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getTrackContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_27.TrackContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/users/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.UserResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/users/<user_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "user": autoguard.guards.Reference.of(() => objects_28.User)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/users/<user_id>/albums/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getUserArtists": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_4.Artist))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/users/<user_id>/playlists/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "playlists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_19.Playlist))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/users/<user_id>/shows/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_24.Show))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/years/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "results": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.YearResult))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/years/<year_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "year": autoguard.guards.Reference.of(() => objects_29.Year)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/years/<year_id>/albums/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/years/<year_id>/movies/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_17.Movie))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getYearContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_30.YearContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getDirectory": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "directory": autoguard.guards.Reference.of(() => objects_7.Directory)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getDirectoryDirectories": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "directories": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_7.Directory))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getDirectoryFiles": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "files": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_14.File))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getDirectoryContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_8.DirectoryContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getFile": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "file": autoguard.guards.Reference.of(() => objects_14.File)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getFileContext": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "context": autoguard.guards.Reference.of(() => objects_15.FileContext)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getFileContent": autoguard.guards.Object.of({}, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/statistics/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "statistics": autoguard.guards.Array.of(autoguard.guards.Group.of(autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.NumberStatistic), autoguard.guards.Reference.of(() => exports.StringStatistic))))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            })
        };
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/index", ["require", "exports", "build/api/schema/api/index", "build/api/schema/messages/index", "build/api/schema/objects/index"], function (require, exports, api, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = exports.api = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = exports.api = void 0;
    exports.api = api;
    exports.messages = messages;
    exports.objects = objects;
});
define("build/ui/EntityTitleFactory", ["require", "exports", "build/api/schema/objects/index", "build/xnode/index"], function (require, exports, api, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityTitleFactory = void 0;
    const CSS = ``;
    class EntityTitleFactory {
        entityLinkFactory;
        make(link, title) {
            return link.add(xnode.text(title));
        }
        constructor(entityLinkFactory) {
            this.entityLinkFactory = entityLinkFactory;
        }
        forEntity(entity) {
            if (api.Actor.is(entity)) {
                return this.forActor(entity);
            }
            if (api.Album.is(entity)) {
                return this.forAlbum(entity);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity);
            }
            if (api.Directory.is(entity)) {
                return this.forDirectory(entity);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity);
            }
            if (api.File.is(entity)) {
                return this.forFile(entity);
            }
            if (api.Genre.is(entity)) {
                return this.forGenre(entity);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity);
            }
            if (api.User.is(entity)) {
                return this.forUser(entity);
            }
            throw `Expected code to be unreachable!`;
        }
        forActor(actor) {
            return this.make(this.entityLinkFactory.forActor(actor), actor.name);
        }
        forAlbum(album) {
            return this.make(this.entityLinkFactory.forAlbum(album), album.title);
        }
        forArtist(artist) {
            return this.make(this.entityLinkFactory.forArtist(artist), artist.title);
        }
        forCategory(category) {
            return this.make(this.entityLinkFactory.forCategory(category), category.title);
        }
        forDirectory(directory) {
            return this.make(this.entityLinkFactory.forDirectory(directory), directory.name);
        }
        forDisc(disc) {
            return this.make(this.entityLinkFactory.forDisc(disc), disc.title ?? `Disc ${disc.number}`);
        }
        forEpisode(episode) {
            return this.make(this.entityLinkFactory.forEpisode(episode), episode.title);
        }
        forFile(file) {
            return this.make(this.entityLinkFactory.forFile(file), file.name);
        }
        forGenre(genre) {
            return this.make(this.entityLinkFactory.forGenre(genre), genre.title);
        }
        forMovie(movie) {
            return this.make(this.entityLinkFactory.forMovie(movie), movie.title);
        }
        forPlaylist(playlist) {
            return this.make(this.entityLinkFactory.forPlaylist(playlist), playlist.title);
        }
        forSeason(season) {
            return this.make(this.entityLinkFactory.forSeason(season), `Season ${season.number}`);
        }
        forShow(show) {
            return this.make(this.entityLinkFactory.forShow(show), show.title);
        }
        forTrack(track) {
            return this.make(this.entityLinkFactory.forTrack(track), track.title);
        }
        forUser(user, options) {
            return this.make(this.entityLinkFactory.forUser(user), options?.title ?? user.name);
        }
        forYear(year) {
            return this.make(this.entityLinkFactory.forYear(year), year.year.toString());
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityTitleFactory = EntityTitleFactory;
    ;
});
define("build/ui/Grid", ["require", "exports", "build/xnode/index"], function (require, exports, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridFactory = void 0;
    const CSS = `
	.grid {
		align-items: baseline;
		display: grid;
		gap: 24px;
		grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
	}

	.grid--mini {
		align-items: start;
		grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
	}
`;
    class GridFactory {
        constructor() {
        }
        make(options) {
            let mini = options?.mini ?? false;
            return xnode.element(`div.grid${mini ? ".grid--mini" : ""}`);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.GridFactory = GridFactory;
    ;
});
define("build/ui/CarouselFactory", ["require", "exports", "build/observers/index", "build/xnode/index"], function (require, exports, observers, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CarouselFactory = void 0;
    const CSS = `
	.carousel {
		display: grid;
		gap: 24px;
	}

	.carousel__content {
		align-items: start;
		display: grid;
		gap: 24px;
		grid-auto-flow: column;
		grid-auto-columns: min-content;
		overflow: scroll hidden;
		scroll-behavior: smooth;
		scroll-snap-type: x mandatory;
	}

	@media (hover: hover) and (pointer: fine) {
		.carousel__content {
			overflow: hidden;
		}
	}

	.carousel__content > * {
		scroll-snap-align: start;
	}

	.carousel__controls {
		display: grid;
		gap: 16px;
		grid-auto-flow: column;
		justify-content: center;
	}

	.carousel__control {
		display: grid;
		gap: 8px;
		justify-items: center;
	}

	.carousel__control-title {
		color: rgb(159, 159, 159);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
    class CarouselFactory {
        iconFactory;
        constructor(iconFactory) {
            this.iconFactory = iconFactory;
        }
        make(children) {
            let childLength = new observers.ObservableClass(children.getState().length);
            children.compute((children) => {
                childLength.updateState(children.length);
            });
            let childVisibilities = new observers.ArrayObservable([]);
            children.addObserver({
                onappend(state) {
                    childVisibilities.append(false);
                },
                onsplice(state, index) {
                    childVisibilities.splice(index);
                }
            });
            let childrenBefore = new observers.ObservableClass(0);
            let childrenAfter = new observers.ObservableClass(0);
            let childrenVisible = observers.computed((before, after, length) => {
                return length - before - after;
            }, childrenBefore, childrenAfter, childLength);
            childVisibilities.compute((childVisibilities) => {
                let before = 0;
                let after = 0;
                for (let i = 0; i < childVisibilities.length; i += 1) {
                    if (childVisibilities[i] === true) {
                        break;
                    }
                    before += 1;
                }
                for (let i = childVisibilities.length - 1; i >= 0; i -= 1) {
                    if (childVisibilities[i] === true) {
                        break;
                    }
                    after += 1;
                }
                childrenBefore.updateState(before);
                childrenAfter.updateState(after);
            });
            let canScrollLast = observers.computed((childrenBefore) => {
                return childrenBefore > 0;
            }, childrenBefore);
            let canScrollNext = observers.computed((childrenAfter) => {
                return childrenAfter > 0;
            }, childrenAfter);
            let contentElement = xnode.element("div.carousel__content");
            contentElement.ref().then(async (contentElement) => {
                let observer = new IntersectionObserver(async (entries) => {
                    let vis = childVisibilities.getState();
                    for (let entry of entries) {
                        for (let [index, child] of children.getState().entries()) {
                            let ref = await child.ref();
                            if (entry.target === ref) {
                                vis[index] = entry.isIntersecting;
                                break;
                            }
                        }
                    }
                    childVisibilities.update(vis);
                }, {
                    root: contentElement,
                    threshold: 1
                });
                children.addObserver({
                    async onappend(state) {
                        observer.observe(await state.ref());
                    },
                    async onsplice(state, index) {
                        observer.unobserve(await state.ref());
                    }
                });
            });
            return xnode.element("div.carousel")
                .add(contentElement
                .repeat(children, (child) => child))
                .add(xnode.element("div.carousel__controls")
                .add(xnode.element("div.carousel__control")
                .on("click", async () => {
                if (canScrollLast.getState()) {
                    let content = await contentElement.ref();
                    let index = Math.max(0, childrenBefore.getState() - childrenVisible.getState());
                    let child = children.getState()[index];
                    let ref = await child.ref();
                    content.scrollTo({ left: ref.offsetLeft - content.offsetLeft, behavior: "smooth" });
                }
            })
                .add(xnode.element("div.icon-button")
                .bind("data-enabled", canScrollLast.addObserver((canScrollLast) => `${canScrollLast}`))
                .add(this.iconFactory.makeChevron({ direction: "left" }))))
                .add(xnode.element("div.carousel__control")
                .on("click", async () => {
                if (canScrollNext.getState()) {
                    let content = await contentElement.ref();
                    let index = Math.min(childLength.getState() - 1, childrenBefore.getState() + childrenVisible.getState());
                    let child = children.getState()[index];
                    let ref = await child.ref();
                    content.scrollTo({ left: ref.offsetLeft - content.offsetLeft, behavior: "smooth" });
                }
            })
                .add(xnode.element("div.icon-button")
                .bind("data-enabled", canScrollNext.addObserver((canScrollNext) => `${canScrollNext}`))
                .add(this.iconFactory.makeChevron()))));
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.CarouselFactory = CarouselFactory;
    ;
});
define("build/ui/Icon", ["require", "exports", "build/xnode/index"], function (require, exports, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IconFactory = void 0;
    const CSS = `
	.icon--right {
		transform: rotate(0deg);
	}

	.icon--down {
		transform: rotate(90deg);
	}

	.icon--left {
		transform: rotate(180deg);
	}

	.icon--up {
		transform: rotate(270deg);
	}
`;
    function getClass(direction) {
        if (direction === "right") {
            return "icon--right";
        }
        if (direction === "down") {
            return "icon--down";
        }
        if (direction === "left") {
            return "icon--left";
        }
        if (direction === "up") {
            return "icon--up";
        }
        return "";
    }
    class IconFactory {
        constructor() {
        }
        makeBroadcast(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M2,16c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2,0.9,2,2c0,1.1,0.9,2,2,2s2-0.9,2-2C8,18.7,5.3,16,2,16z"))
                .add(xnode.element("path")
                .set("d", "M2,8c-1.1,0-2,0.9-2,2s0.9,2,2,2c5.5,0,10,4.5,10,10c0,1.1,0.9,2,2,2s2-0.9,2-2C16,14.3,9.7,8,2,8z"))
                .add(xnode.element("path")
                .set("d", "M2,0C0.9,0,0,0.9,0,2s0.9,2,2,2c9.9,0,18,8.1,18,18c0,1.1,0.9,2,2,2s2-0.9,2-2C24,9.9,14.1,0,2,0z"));
        }
        makeBulletList(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M7,4h16c0.6,0,1-0.4,1-1s-0.4-1-1-1H7C6.4,2,6,2.4,6,3S6.4,4,7,4z"))
                .add(xnode.element("path")
                .set("d", "M23,8H7C6.4,8,6,8.4,6,9s0.4,1,1,1h16c0.6,0,1-0.4,1-1S23.6,8,23,8z"))
                .add(xnode.element("path")
                .set("d", "M23,20H7c-0.6,0-1,0.4-1,1s0.4,1,1,1h16c0.6,0,1-0.4,1-1S23.6,20,23,20z"))
                .add(xnode.element("path")
                .set("d", "M23,14H7c-0.6,0-1,0.4-1,1s0.4,1,1,1h16c0.6,0,1-0.4,1-1S23.6,14,23,14z"))
                .add(xnode.element("path")
                .set("d", "M2,1C0.9,1,0,1.9,0,3s0.9,2,2,2s2-0.9,2-2S3.1,1,2,1z"))
                .add(xnode.element("path")
                .set("d", "M2,7C0.9,7,0,7.9,0,9c0,1.1,0.9,2,2,2s2-0.9,2-2C4,7.9,3.1,7,2,7z"))
                .add(xnode.element("path")
                .set("d", "M2,13c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S3.1,13,2,13z"))
                .add(xnode.element("path")
                .set("d", "M2,19c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S3.1,19,2,19z"));
        }
        makeCalendar(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M21,2h-3V1c0-0.6-0.4-1-1-1s-1,0.4-1,1v1H8V1c0-0.6-0.4-1-1-1S6,0.4,6,1v1H3C1.3,2,0,3.3,0,5v4c0,0,0,0,0,0s0,0,0,0v12c0,1.7,1.3,3,3,3h18c1.7,0,3-1.3,3-3V5C24,3.3,22.7,2,21,2z M3,4h3v1c0,0.6,0.4,1,1,1s1-0.4,1-1V4h8v1c0,0.6,0.4,1,1,1s1-0.4,1-1V4h3c0.6,0,1,0.4,1,1v3H2V5C2,4.4,2.4,4,3,4z M21,22H3c-0.6,0-1-0.4-1-1V10h20v11C22,21.6,21.6,22,21,22z"));
        }
        makeChevron(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19.4,10.6l-10-10c-0.8-0.8-2-0.8-2.8,0c-0.8,0.8-0.8,2,0,2.8l8.6,8.6l-8.6,8.6c-0.8,0.8-0.8,2,0,2.8C7,23.8,7.5,24,8,24s1-0.2,1.4-0.6l10-10C20.2,12.6,20.2,11.4,19.4,10.6z"));
        }
        makeCross(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M14.8,12l6.6-6.6c0.8-0.8,0.8-2,0-2.8c-0.8-0.8-2-0.8-2.8,0L12,9.2L5.4,2.6c-0.8-0.8-2-0.8-2.8,0c-0.8,0.8-0.8,2,0,2.8L9.2,12l-6.6,6.6c-0.8,0.8-0.8,2,0,2.8C3,21.8,3.5,22,4,22s1-0.2,1.4-0.6l6.6-6.6l6.6,6.6C19,21.8,19.5,22,20,22s1-0.2,1.4-0.6c0.8-0.8,0.8-2,0-2.8L14.8,12z"));
        }
        makeDisc(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M12,0C5.4,0,0,5.4,0,12c0,6.6,5.4,12,12,12c6.6,0,12-5.4,12-12C24,5.4,18.6,0,12,0z M12,22C6.5,22,2,17.5,2,12C2,6.5,6.5,2,12,2c5.5,0,10,4.5,10,10C22,17.5,17.5,22,12,22z"))
                .add(xnode.element("path")
                .set("d", "M12,10c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S13.1,10,12,10z"));
        }
        makeMagnifyingGlass(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M23.7,22.3l-6-6c1.4-1.7,2.3-3.9,2.3-6.3c0-5.5-4.5-10-10-10C4.5,0,0,4.5,0,10c0,5.5,4.5,10,10,10c2.4,0,4.6-0.8,6.3-2.3l6,6c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3C24.1,23.3,24.1,22.7,23.7,22.3z M10,18c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S14.4,18,10,18z"));
        }
        makeMinus(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M22,10H2c-1.1,0-2,0.9-2,2s0.9,2,2,2h20c1.1,0,2-0.9,2-2S23.1,10,22,10z"));
        }
        makeMonitor(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M21,2H3C1.3,2,0,3.3,0,5v12c0,1.7,1.3,3,3,3h18c1.7,0,3-1.3,3-3V5C24,3.3,22.7,2,21,2z M22,17c0,0.6-0.4,1-1,1H3c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h18c0.6,0,1,0.4,1,1V17z"))
                .add(xnode.element("path")
                .set("d", "M17,22H7c-0.6,0-1,0.4-1,1s0.4,1,1,1h10c0.6,0,1-0.4,1-1S17.6,22,17,22z"));
        }
        makeNote(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M16.6,5.2C15.1,4.2,14,3.5,14,1c0-0.6-0.4-1-1-1s-1,0.4-1,1v14c-0.8-0.6-1.9-1-3-1c-2.8,0-5,2.2-5,5s2.2,5,5,5s5-2.2,5-5V5.8c0.5,0.4,1,0.8,1.4,1.1c1.4,1,2.6,1.7,2.6,4.2c0,0.6,0.4,1,1,1s1-0.4,1-1C20,7.5,18.1,6.2,16.6,5.2z M9,22c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3S10.7,22,9,22z"));
        }
        makePadlock(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19,10h-1V6c0-3.3-2.7-6-6-6C8.7,0,6,2.7,6,6v4H5c-0.6,0-1,0.4-1,1v12c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1V11C20,10.4,19.6,10,19,10z M8,6c0-2.2,1.8-4,4-4c2.2,0,4,1.8,4,4v4H8V6z M18,22H6V12h12V22z"));
        }
        makePause(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M6,0C4.9,0,4,0.9,4,2v20c0,1.1,0.9,2,2,2s2-0.9,2-2V2C8,0.9,7.1,0,6,0z"))
                .add(xnode.element("path")
                .set("d", "M18,0c-1.1,0-2,0.9-2,2v20c0,1.1,0.9,2,2,2s2-0.9,2-2V2C20,0.9,19.1,0,18,0z"));
        }
        makePerson(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M18.9,16.2C17,15.5,16,15,16,13c0-0.5,0.2-0.7,0.5-1.3c0.6-1,1.5-2.4,1.5-5.7c0-3.5-2.5-6-6-6C8.5,0,6,2.5,6,6c0,3.4,0.9,4.7,1.5,5.7C7.8,12.3,8,12.5,8,13c0,2-1,2.5-2.9,3.2C2.9,17,0,18.1,0,23c0,0.6,0.4,1,1,1h22c0.6,0,1-0.4,1-1C24,18.1,21.1,17,18.9,16.2z M2.1,22c0.3-2.7,1.8-3.2,3.7-3.9S10,16.5,10,13c0-1.1-0.4-1.7-0.8-2.4C8.6,9.8,8,8.8,8,6c0-2.4,1.6-4,4-4s4,1.6,4,4c0,2.8-0.6,3.8-1.2,4.6C14.4,11.3,14,11.9,14,13c0,3.5,2.3,4.4,4.2,5.1c1.9,0.7,3.4,1.3,3.7,3.9H2.1z"));
        }
        makePieChart(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M17,14h-7V7c0-0.6-0.4-1-1-1c-5,0-9,4-9,9s4,9,9,9c5,0,9-4,9-9C18,14.4,17.6,14,17,14z M9,22c-3.9,0-7-3.1-7-7c0-3.5,2.6-6.4,6-6.9V15c0,0.6,0.4,1,1,1h6.9C15.4,19.4,12.5,22,9,22z"))
                .add(xnode.element("path")
                .set("d", "M13,0c-0.6,0-1,0.4-1,1v10c0,0.6,0.4,1,1,1h10c0.6,0,1-0.4,1-1C24,4.9,19.1,0,13,0z M14,10V2.1c4.2,0.5,7.5,3.8,7.9,7.9H14z"));
        }
        makePlay(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M23.1,11L5.7,1C4.8,0.5,4,0.9,4,2v20c0,1.1,0.8,1.5,1.7,1l17.3-10C24,12.5,24,11.5,23.1,11z"));
        }
        makePlus(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M22,10h-8V2c0-1.1-0.9-2-2-2s-2,0.9-2,2v8H2c-1.1,0-2,0.9-2,2s0.9,2,2,2h8v8c0,1.1,0.9,2,2,2s2-0.9,2-2v-8h8c1.1,0,2-0.9,2-2S23.1,10,22,10z"));
        }
        makeQuotationMark(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M8,4H2C0.9,4,0,4.9,0,6v4c0,1.1,0.9,2,2,2h3.7c-1,2.9-4.1,4.1-4.3,4.1c-1,0.3-1.6,1.5-1.3,2.5C0.4,19.5,1.2,20,2,20c0.2,0,0.4,0,0.6-0.1C2.9,19.8,10,17.4,10,10V6C10,4.9,9.1,4,8,4z")).add(xnode.element("path")
                .set("d", "M22,4h-6c-1.1,0-2,0.9-2,2v4c0,1.1,0.9,2,2,2h3.7c-1,2.9-4.1,4.1-4.3,4.1c-1,0.3-1.6,1.5-1.3,2.5c0.3,0.8,1.1,1.4,1.9,1.4c0.2,0,0.4,0,0.6-0.1c0.3-0.1,7.4-2.5,7.4-9.9V6C24,4.9,23.1,4,22,4z"));
        }
        makeReload(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M20.5,3.5c-4.7-4.7-12.3-4.7-17,0L2.8,2.8C2,2,1.2,2.3,1.1,3.4L0.3,7.9C0.1,9,0.9,9.7,2,9.5l4.5-0.8c1.1-0.2,1.3-1,0.6-1.7L6.3,6.3c3.1-3.1,8.2-3.1,11.3,0c3.1,3.1,3.1,8.2,0,11.3c-3.1,3.1-8.2,3.1-11.3,0c-0.8-0.8-2-0.8-2.8,0c-0.8,0.8-0.8,2,0,2.8c4.7,4.7,12.3,4.7,17,0C25.2,15.8,25.2,8.2,20.5,3.5z"));
        }
        makeRepeat(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19,6h-0.4l-4-2.9C14.4,3,14.2,2.9,14,2.9c-0.2,0-0.3,0-0.5,0.1C13.2,3.2,13,3.6,13,3.9V6H5c-2.8,0-5,2.2-5,5v2c0,2.8,2.2,5,5,5h0.4l4,2.9c0.2,0.1,0.4,0.2,0.6,0.2c0.2,0,0.3,0,0.5-0.1c0.3-0.2,0.5-0.5,0.5-0.9V18h8c2.8,0,5-2.2,5-5v-2C24,8.2,21.8,6,19,6z M22,13c0,1.7-1.3,3-3,3h-8v-2.1c0-0.4-0.2-0.7-0.5-0.9c-0.1-0.1-0.3-0.1-0.5-0.1c-0.2,0-0.4,0.1-0.6,0.2l-4,2.9H5c-1.7,0-3-1.3-3-3v-2c0-1.7,1.3-3,3-3h8v2.1c0,0.4,0.2,0.7,0.5,0.9c0.1,0.1,0.3,0.1,0.5,0.1c0.2,0,0.4-0.1,0.6-0.2l4-2.9H19c1.7,0,3,1.3,3,3V13z"));
        }
        makeSettings(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M22,10h-1.2c-0.2-1-0.6-1.9-1.2-2.8l0.9-0.9c0.8-0.8,0.8-2.1,0-2.8c-0.8-0.8-2.1-0.8-2.8,0l-0.9,0.9C15.9,3.9,15,3.5,14,3.2V2c0-1.1-0.9-2-2-2c-1.1,0-2,0.9-2,2v1.2C9,3.5,8.1,3.9,7.2,4.4L6.3,3.5c-0.8-0.8-2.1-0.8-2.8,0c-0.8,0.8-0.8,2.1,0,2.8l0.9,0.9C3.9,8.1,3.5,9,3.2,10H2c-1.1,0-2,0.9-2,2c0,1.1,0.9,2,2,2h1.2c0.2,1,0.6,1.9,1.2,2.8l-0.9,0.9c-0.8,0.8-0.8,2,0,2.8c0.8,0.8,2.1,0.8,2.8,0l0.9-0.9c0.8,0.5,1.8,0.9,2.8,1.2V22c0,1.1,0.9,2,2,2c1.1,0,2-0.9,2-2v-1.2c1-0.2,1.9-0.6,2.8-1.2l0.9,0.9c0.8,0.8,2,0.8,2.8,0c0.8-0.8,0.8-2.1,0-2.8l-0.9-0.9c0.5-0.8,0.9-1.8,1.2-2.8H22c1.1,0,2-0.9,2-2S23.1,10,22,10z M12,17c-2.8,0-5-2.2-5-5s2.2-5,5-5s5,2.2,5,5S14.8,17,12,17z"));
        }
        makeShuffle(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M22.9,16.2l-4.3-3.1c-0.2-0.1-0.4-0.2-0.6-0.2c-0.2,0-0.3,0-0.5,0.1c-0.3,0.2-0.5,0.5-0.5,0.9v1.9c-1.8-0.4-3.3-2.1-4.7-3.9c1.5-1.8,2.9-3.4,4.7-3.9v1.9c0,0.4,0.2,0.7,0.5,0.9c0.1,0.1,0.3,0.1,0.5,0.1c0.2,0,0.4-0.1,0.6-0.2l4.3-3.1c0.3-0.2,0.4-0.5,0.4-0.8c0-0.3-0.2-0.6-0.4-0.8l-4.3-3.1C18.4,3,18.2,2.9,18,2.9c-0.2,0-0.3,0-0.5,0.1C17.2,3.2,17,3.6,17,3.9v2.1c-2.5,0.4-4.3,2.3-6,4.3C9.1,8.1,7.1,6,4,6H1C0.4,6,0,6.4,0,7s0.4,1,1,1h3c2.3,0,4,1.9,5.7,4C8,14.1,6.3,16,4,16H1c-0.6,0-1,0.4-1,1s0.4,1,1,1h3c3.1,0,5.1-2.1,7-4.4c1.7,2,3.5,3.9,6,4.3v2.1c0,0.4,0.2,0.7,0.5,0.9c0.1,0.1,0.3,0.1,0.5,0.1c0.2,0,0.4-0.1,0.6-0.2l4.3-3.1c0.3-0.2,0.4-0.5,0.4-0.8S23.1,16.4,22.9,16.2z"));
        }
        makeSkip(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19.1,11L1.7,1C0.8,0.5,0,0.9,0,2v20c0,1.1,0.8,1.5,1.7,1l17.3-10C20,12.5,20,11.5,19.1,11z"))
                .add(xnode.element("path")
                .set("d", "M22,0c-1.1,0-2,0.9-2,2v20c0,1.1,0.9,2,2,2s2-0.9,2-2V2C24,0.9,23.1,0,22,0z"));
        }
        makeSpeaker(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19,0H5C3.3,0,2,1.3,2,3v18c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V3C22,1.3,20.7,0,19,0z M20,21c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V3c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V21z"))
                .add(xnode.element("path")
                .set("d", "M12,10c-2.8,0-5,2.2-5,5s2.2,5,5,5s5-2.2,5-5S14.8,10,12,10z M12,18c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3S13.7,18,12,18z"))
                .add(xnode.element("path")
                .set("d", "M12,8c1.1,0,2-0.9,2-2s-0.9-2-2-2s-2,0.9-2,2S10.9,8,12,8z"));
        }
        makeStar(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M23.8,9.4c-0.2-0.7-0.9-1.2-1.6-1.4l-5.8-0.8L13.8,2c-0.3-0.7-1-1.1-1.8-1.1S10.5,1.3,10.2,2L7.6,7.2L1.9,8C1.1,8.1,0.5,8.7,0.2,9.4c-0.2,0.7,0,1.5,0.5,2l4.2,4.1l-1,5.7c-0.1,0.8,0.2,1.5,0.8,2c0.6,0.4,1.4,0.5,2.1,0.2l5.2-2.7l5.2,2.7c0.3,0.2,0.6,0.2,0.9,0.2c0.4,0,0.8-0.1,1.2-0.4c0.6-0.5,0.9-1.2,0.8-2l-1-5.7l4.2-4.1C23.8,10.9,24,10.1,23.8,9.4z M17.3,14.4C17.1,14.7,17,15,17,15.3l1.1,6.3c0,0,0,0,0,0l-5.6-3c-0.3-0.2-0.6-0.2-0.9,0l-5.6,3L7,15.3C7,15,6.9,14.7,6.7,14.4L2.1,10l6.3-0.9C8.8,9,9,8.8,9.2,8.5L12,2.8l2.8,5.7C15,8.8,15.2,9,15.6,9.1l6.3,0.9L17.3,14.4z"));
        }
        makeFolder(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "12px")
                .set("height", "12px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M21,6l-3.999,0c0,0,0,0-0.001,0h-1.455H15c-0.723,0-1.676-0.589-2-1.236L12.79,4.342C12.132,3.029,10.468,2,9,2L3,2C1.346,2,0,3.346,0,5v14c0,1.654,1.346,3,3,3h18c1.654,0,3-1.346,3-3V9C24,7.346,22.654,6,21,6z M3,4l6,0c0.723,0,1.676,0.589,2,1.236l0.211,0.422C11.271,5.776,11.346,5.888,11.42,6L2,6V5C2,4.449,2.449,4,3,4z M22,19c0,0.551-0.449,1-1,1H3c-0.551,0-1-0.449-1-1V8l13.546,0L21,8c0.551,0,1,0.449,1,1V19z"));
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.IconFactory = IconFactory;
    ;
});
define("build/ui/theme/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TEXT_ACCENT = exports.TEXT_2 = exports.TEXT_1 = exports.TEXT_0 = exports.BACKGROUND_ACCENT = exports.BACKGROUND_4 = exports.BACKGROUND_3 = exports.BACKGROUND_2 = exports.BACKGROUND_1 = exports.BACKGROUND_0 = void 0;
    exports.BACKGROUND_0 = "rgb(0, 0, 0)";
    exports.BACKGROUND_1 = "rgb(15, 15, 15)";
    exports.BACKGROUND_2 = "rgb(31, 31, 31)";
    exports.BACKGROUND_3 = "rgb(47, 47, 47)";
    exports.BACKGROUND_4 = "rgb(63, 63, 63)";
    exports.BACKGROUND_ACCENT = "rgb(223, 79, 127)";
    exports.TEXT_0 = "rgb(255, 255, 255)";
    exports.TEXT_1 = "rgb(159, 159, 159)";
    exports.TEXT_2 = "rgb(95, 95, 95)";
    exports.TEXT_ACCENT = "rgb(255, 255, 255)";
});
define("build/ui/ImageBox", ["require", "exports", "build/observers/index", "build/xnode/index", "build/ui/theme/index", "build/is"], function (require, exports, observables, xnode, theme, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageBoxFactory = exports.AspectRatio = void 0;
    const CSS = `
	.image-box {
		background-color: ${theme.BACKGROUND_3};
		border-radius: 4px;
		overflow: hidden;
		position: relative;
		will-change: opacity;
	}

	.image-box--1-1 {
		padding-bottom: ${1 / 1 * 100}%;
	}

	.image-box--4-3 {
		padding-bottom: ${3 / 4 * 100}%;
	}

	.image-box--3-4 {
		padding-bottom: ${4 / 3 * 100}%;
	}

	.image-box--3-2 {
		padding-bottom: ${2 / 3 * 100}%;
	}

	.image-box--2-3 {
		padding-bottom: ${3 / 2 * 100}%;
	}

	.image-box--16-9 {
		padding-bottom: ${9 / 16 * 100}%;
	}

	.image-box--9-16 {
		padding-bottom: ${9 / 16 * 100}%;
	}

	.image-box--multiple {

	}

	.image-box__content {
		height: 100%;
		object-fit: contain;
		position: absolute;
		width: 100%;
	}

	.image-box__image {
		height: 100%;
		position: absolute;
		object-fit: contain;
		width: 100%;
	}

	.image-box--multiple
	.image-box__image:nth-child(1) {
		border-radius: 2px;
		box-shadow: 0px 0px 32px rgb(0, 0, 0, 0.50);
		transform: translate(-50%, -50%) scale(75%);
		left: 50%;
		top: 50%;
		width: auto;
		z-index: 3;
	}

	.image-box--multiple
	.image-box__image:nth-child(2) {
		border-radius: 2px;
		box-shadow: 0px 0px 32px rgb(0, 0, 0, 0.50);
		transform: translate(-50%, -50%) scale(50%);
		left: 25%;
		top: 50%;
		width: auto;
		z-index: 2;
	}

	.image-box--multiple
	.image-box__image:nth-child(3) {
		border-radius: 2px;
		box-shadow: 0px 0px 32px rgb(0, 0, 0, 0.50);
		transform: translate(-50%, -50%) scale(50%);
		left: 75%;
		top: 50%;
		width: auto;
		z-index: 1;
	}

	.image-box--multiple
	.image-box__image:nth-child(n+4) {
		display: none;
	}

	[data-opaque] {
		opacity: 0;
		transition: opacity 1.000s;
	}

	[data-opaque="true"] {
		opacity: 1;
		//filter: blur(32px);
	}
`;
    const TARGETS = {
        "1:1": { x: 1, y: 1 },
        "4:3": { x: 4, y: 3 },
        "3:4": { x: 3, y: 4 },
        "3:2": { x: 3, y: 2 },
        "2:3": { x: 2, y: 3 },
        "16:9": { x: 16, y: 9 },
        "9:16": { x: 9, y: 16 }
    };
    exports.AspectRatio = {
        TARGETS,
        computeOverlap(target, source) {
            let a = source.x * target.y;
            let b = target.x * source.y;
            // If source is wider than target.
            if (a > b) {
                return b / a;
            }
            else {
                return a / b;
            }
        },
        getOptimal(source) {
            let candidates = Object.values(TARGETS).map((target) => {
                let overlap = exports.AspectRatio.computeOverlap(target, source);
                return {
                    target,
                    overlap
                };
            });
            candidates.sort((one, two) => one.overlap - two.overlap);
            let candidate = candidates.pop();
            if (candidate == null) {
                throw new Error();
            }
            return candidate.target;
        }
    };
    class ImageBoxFactory {
        token;
        constructor(token) {
            this.token = token;
        }
        for(urls, multiple, ar) {
            ar = ar ?? TARGETS["1:1"];
            let node = xnode.element(`div.image-box.image-box--${ar.x}-${ar.y}${multiple ? ".image-box--multiple" : ""}`);
            let content = xnode.element(`div.image-box__content`);
            for (let url of urls) {
                if (is.absent(url)) {
                    continue;
                }
                let isLoaded = new observables.ObservableClass(false);
                content.add(xnode.element("img.image-box__image")
                    .bind("data-opaque", isLoaded.addObserver((isLoaded) => isLoaded))
                    .bind("src", this.token.addObserver((token) => {
                    if (is.present(token) && is.present(url)) {
                        return `${url}?token=${token}`;
                    }
                }))
                    .on("load", () => {
                    isLoaded.updateState(true);
                }));
            }
            return node
                .add(content);
        }
        forPortrait(urls, multiple) {
            return this.for(urls, multiple, TARGETS["2:3"]);
        }
        forSquare(urls, multiple) {
            return this.for(urls, multiple, TARGETS["1:1"]);
        }
        forVideo(urls, multiple) {
            return this.for(urls, multiple, TARGETS["16:9"]);
        }
        forLandscape(urls, multiple) {
            return this.for(urls, multiple, TARGETS["3:2"]);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.ImageBoxFactory = ImageBoxFactory;
    ;
});
define("build/ui/EntityLink", ["require", "exports", "build/api/schema/objects/index", "build/xnode/index"], function (require, exports, api, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityLinkFactory = void 0;
    const CSS = ``;
    class EntityLinkFactory {
        navigator;
        contextMenuEntity;
        make(url, entity) {
            let onclick = () => {
                this.navigator(url);
            };
            let oncontextmenu = () => {
                this.contextMenuEntity.updateState(undefined);
                this.contextMenuEntity.updateState(entity);
            };
            let timer;
            return xnode.element("a")
                .set("href", url)
                .on("click", onclick)
                .on("contextmenu", oncontextmenu)
                .on("touchstart", () => {
                timer = window.setTimeout(() => {
                    window.clearTimeout(timer);
                    timer = undefined;
                    oncontextmenu();
                }, 500);
            }, false)
                .on("touchcancel", () => {
                window.clearTimeout(timer);
                timer = undefined;
            }, false)
                .on("touchmove", () => {
                window.clearTimeout(timer);
                timer = undefined;
            }, false)
                .on("touchend", () => {
                window.clearTimeout(timer);
                timer = undefined;
            }, false);
        }
        constructor(navigator, contextMenuEntity) {
            this.navigator = navigator;
            this.contextMenuEntity = contextMenuEntity;
        }
        forActor(actor) {
            return this.make(`actors/${actor.actor_id}/`, actor);
        }
        forActors() {
            return this.make(`actors/`);
        }
        forAlbum(album) {
            return this.make(`audio/albums/${album.album_id}/`, album);
        }
        forAlbums() {
            return this.make(`audio/albums/`);
        }
        forArtist(artist) {
            return this.make(`audio/artists/${artist.artist_id}/`, artist);
        }
        forArtists() {
            return this.make(`audio/artists/`);
        }
        forCategory(category) {
            return this.make(`audio/genres/${category.category_id}/`, category);
        }
        forCue(cue) {
            return this.make(`video/cues/${cue.cue_id}/`, cue);
        }
        forDirectory(directory) {
            return this.make(`directories/${directory.directory_id}/`, directory);
        }
        forDisc(disc) {
            return this.make(`audio/discs/${disc.disc_id}/`, disc);
        }
        forDiscs() {
            return this.make(`audio/discs/`);
        }
        forEpisode(episode) {
            return this.make(`video/episodes/${episode.episode_id}/`, episode);
        }
        forEpisodes() {
            return this.make(`video/episodes/`);
        }
        forFile(file) {
            return this.make(`files/${file.file_id}/`, file);
        }
        forGenre(genre) {
            return this.make(`video/genres/${genre.genre_id}/`, genre);
        }
        forGenres() {
            return this.make(`video/genres/`);
        }
        forMovie(movie) {
            return this.make(`video/movies/${movie.movie_id}/`, movie);
        }
        forMovies() {
            return this.make(`video/movies/`);
        }
        forPlaylist(playlist) {
            return this.make(`audio/playlists/${playlist.playlist_id}/`, playlist);
        }
        forPlaylists() {
            return this.make(`audio/playlists/`);
        }
        forSeason(season) {
            return this.make(`video/seasons/${season.season_id}/`, season);
        }
        forSeasons() {
            return this.make(`video/seasons/`);
        }
        forShow(show) {
            return this.make(`video/shows/${show.show_id}/`, show);
        }
        forShows() {
            return this.make(`video/shows/`);
        }
        forTrack(track) {
            return this.make(`audio/tracks/${track.track_id}/`, track);
        }
        forTracks() {
            return this.make(`audio/tracks/`);
        }
        forUser(user) {
            return this.make(`users/${user.user_id}/`, user);
        }
        forUsers() {
            return this.make(`users/`);
        }
        forYear(year) {
            return this.make(`years/${year.year_id}/`, year);
        }
        forYears() {
            return this.make(`years/`);
        }
        forEntity(entity) {
            if (api.ActorBase.is(entity)) {
                return this.forActor(entity);
            }
            if (api.AlbumBase.is(entity)) {
                return this.forAlbum(entity);
            }
            if (api.ArtistBase.is(entity)) {
                return this.forArtist(entity);
            }
            if (api.CueBase.is(entity)) {
                return this.forCue(entity);
            }
            if (api.DirectoryBase.is(entity)) {
                return this.forDirectory(entity);
            }
            if (api.DiscBase.is(entity)) {
                return this.forDisc(entity);
            }
            if (api.EpisodeBase.is(entity)) {
                return this.forEpisode(entity);
            }
            if (api.FileBase.is(entity)) {
                return this.forFile(entity);
            }
            if (api.GenreBase.is(entity)) {
                return this.forGenre(entity);
            }
            if (api.PlaylistBase.is(entity)) {
                return this.forPlaylist(entity);
            }
            if (api.MovieBase.is(entity)) {
                return this.forMovie(entity);
            }
            if (api.SeasonBase.is(entity)) {
                return this.forSeason(entity);
            }
            if (api.ShowBase.is(entity)) {
                return this.forShow(entity);
            }
            if (api.TrackBase.is(entity)) {
                return this.forTrack(entity);
            }
            if (api.UserBase.is(entity)) {
                return this.forUser(entity);
            }
            if (api.YearBase.is(entity)) {
                return this.forYear(entity);
            }
            throw `Expected code to be unreachable!`;
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityLinkFactory = EntityLinkFactory;
    ;
});
define("build/ui/EntityCard", ["require", "exports", "build/api/schema/objects/index", "build/xnode/index", "build/ui/theme/index", "build/ui/metadata/index", "build/is", "build/ui/ImageBox"], function (require, exports, api, xnode, theme, metadata, is, ImageBox_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityCardFactory = void 0;
    const CSS = `
	.entity-card {
		align-items: start;
		display: grid;
		gap: 24px;
		grid-auto-rows: min-content;
		grid-template-columns: repeat(auto-fit, minmax(240px, auto));
	}

	.entity-card__artwork {
		position: relative;
	}

	.entity-card__playback {
		position: absolute;
			bottom: 16px;
			right: 16px;
	}

	.entity-card__content {

	}

	.entity-card__pusher {
		width: 100vw;
	}

	.entity-card__metadata {
		display: grid;
		gap: 16px;
	}

	.entity-card__titles {
		display: grid;
		gap: 8px;
	}

	.entity-card__title {
		color: ${theme.TEXT_0};
		font-size: 20px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-card__subtitle {
		color: ${theme.TEXT_1};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-card__tags {
		display: grid;
		gap: 8px;
		grid-auto-columns: minmax(auto, max-content);
		grid-auto-flow: column;
	}

	.entity-card__tag {
		background-color: ${theme.BACKGROUND_3};
		border-radius: 2px;
		color: ${theme.TEXT_1};
		font-size: 12px;
		padding: 4px 8px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-card__tag--accent {
		background-color: ${theme.BACKGROUND_ACCENT};
		color: ${theme.TEXT_ACCENT};
	}

	.entity-card__description {
		color: ${theme.TEXT_1};
		font-size: 16px;
		line-height: 1.25;
		word-break: break-word;
	}

	.entity-card__description--compact {
		display: -webkit-box;
			-webkit-box-orient: vertical;
			-webkit-line-clamp: 3;
		max-height: 60px;
		overflow: hidden;
	}

	.entity-card__footer {
		color: ${theme.TEXT_2};
		font-size: 12px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
    function isHighQualityAudioFile({ sample_rate_hz, channel_count, bits_per_sample }) {
        if (sample_rate_hz == null || sample_rate_hz < 44100) {
            return false;
        }
        if (channel_count == null || channel_count < 2) {
            return false;
        }
        if (bits_per_sample == null || bits_per_sample < 16) {
            return false;
        }
        return true;
    }
    function isHighQualityVideoFile({ width, height }) {
        let is_ultrawide = width * 9 > 16 * height;
        if (is_ultrawide) {
            return width >= 1280;
        }
        else {
            return height >= 720;
        }
    }
    class EntityCardFactory {
        entityTitleFactory;
        entityLinkFactory;
        ImageBox;
        PlaybackButton;
        make(link, image, titles, subtitles, tags, description, footer, options = {}) {
            return link.add(xnode.element("div.entity-card")
                .add(xnode.element("div.entity-card__artwork")
                .add(options.image ?? image)
                .add(xnode.element("div.entity-card__playback")
                .add(options.playbackButton)))
                .add(xnode.element("div.entity-card__content")
                .add(xnode.element("div.entity-card__pusher"))
                .add(xnode.element("div.entity-card__metadata")
                .add(xnode.element("div.entity-card__titles")
                .add(titles.length === 0 ? undefined : xnode.element("div.entity-card__title")
                .add(...xnode.joinarray(titles)))
                .add(subtitles.length === 0 ? undefined : xnode.element("div.entity-card__subtitle")
                .add(...xnode.joinarray(subtitles))))
                .add(tags.length === 0 ? undefined : xnode.element("div.entity-card__tags")
                .add(...tags))
                .add(is.absent(description) ? undefined : xnode.element(options.compactDescription === false ? "div.entity-card__description" : "div.entity-card__description.entity-card__description--compact")
                .add(xnode.text(description)))
                .add(is.absent(footer) ? undefined : xnode.element("div.entity-card__footer")
                .add(xnode.text(footer))))));
        }
        makeImage(artwork, default_ar) {
            let shared_ar;
            for (let image_file of artwork) {
                let optimal_ar = ImageBox_1.AspectRatio.getOptimal({ x: image_file.width, y: image_file.height });
                if (shared_ar == null) {
                    shared_ar = optimal_ar;
                }
                else {
                    // If optimal aspect ratio is tall.
                    if (optimal_ar.y > optimal_ar.x) {
                        // If optimal aspect ratio is taller than shared aspect ratio.
                        if (optimal_ar.y * shared_ar.x > shared_ar.y * optimal_ar.x) {
                            shared_ar = optimal_ar;
                        }
                    }
                }
            }
            return this.ImageBox.for(artwork.map((image) => `/api/files/${image.file_id}/content/`), undefined, shared_ar ?? default_ar);
        }
        constructor(entityTitleFactory, entityLinkFactory, ImageBox, PlaybackButton) {
            this.entityTitleFactory = entityTitleFactory;
            this.entityLinkFactory = entityLinkFactory;
            this.ImageBox = ImageBox;
            this.PlaybackButton = PlaybackButton;
        }
        forEntity(entity, options = {}) {
            if (api.Actor.is(entity)) {
                return this.forActor(entity, options);
            }
            if (api.Album.is(entity)) {
                return this.forAlbum(entity, options);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity, options);
            }
            if (api.Category.is(entity)) {
                return this.forCategory(entity, options);
            }
            if (api.Cue.is(entity)) {
                return this.forCue(entity, options);
            }
            if (api.Directory.is(entity)) {
                return this.forDirectory(entity, options);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity, options);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity, options);
            }
            if (api.File.is(entity)) {
                return this.forFile(entity, options);
            }
            if (api.Genre.is(entity)) {
                return this.forGenre(entity, options);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity, options);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity, options);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity, options);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity, options);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity, options);
            }
            if (api.User.is(entity)) {
                return this.forUser(entity, options);
            }
            if (api.Year.is(entity)) {
                return this.forYear(entity, options);
            }
            throw `Expected code to be unreachable!`;
        }
        forActor(actor, options = {}) {
            let link = this.entityLinkFactory.forActor(actor);
            let image = this.makeImage([], ImageBox_1.AspectRatio.TARGETS["1:1"]);
            let titles = [
                this.entityTitleFactory.forActor(actor)
            ];
            let subtitles = [];
            let tags = [
                "Actor"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forAlbum(album, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forAlbum(album);
            let link = this.entityLinkFactory.forAlbum(album);
            let image = this.makeImage(album.artwork, ImageBox_1.AspectRatio.TARGETS["1:1"]);
            let titles = [
                this.entityTitleFactory.forAlbum(album)
            ];
            let subtitles = album.artists.map((artist) => this.entityTitleFactory.forArtist(artist));
            let tags = [
                "Album",
                is.present(album.year) ? `${album.year.year}` : undefined,
                metadata.formatDuration(album.duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, album.copyright, options);
        }
        forArtist(artist, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forArtist(artist);
            let link = this.entityLinkFactory.forArtist(artist);
            let image = this.makeImage(artist.artwork, ImageBox_1.AspectRatio.TARGETS["1:1"]);
            let titles = [
                this.entityTitleFactory.forArtist(artist)
            ];
            let subtitles = new Array();
            let tags = [
                "Artist",
                metadata.formatDuration(artist.duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forCategory(category, options = {}) {
            let link = this.entityLinkFactory.forCategory(category);
            let image = this.makeImage([], ImageBox_1.AspectRatio.TARGETS["1:1"]);
            let titles = [
                this.entityTitleFactory.forCategory(category)
            ];
            let subtitles = [];
            let tags = [
                "Genre"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forCue(cue, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forCue(cue);
            options.image = this.ImageBox.forVideo([`/media/gifs/${cue.cue_id}/`]);
            if (false) {
            }
            else if (api.Episode.is(cue.media)) {
                return this.forEpisode(cue.media, options);
            }
            else if (api.Movie.is(cue.media)) {
                return this.forMovie(cue.media, options);
            }
            else {
                throw `Expected code to be unreachable!`;
            }
        }
        forDirectory(directory, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forDirectory(directory);
            let link = this.entityLinkFactory.forDirectory(directory);
            let image = this.makeImage([], ImageBox_1.AspectRatio.TARGETS["1:1"]);
            let titles = [
                this.entityTitleFactory.forDirectory(directory)
            ];
            let subtitles = is.present(directory.parent) ? [
                this.entityTitleFactory.forDirectory(directory.parent)
            ] : [];
            let tags = [
                "Directory"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forDisc(disc, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forDisc(disc);
            let link = this.entityLinkFactory.forDisc(disc);
            let image = this.makeImage(disc.album.artwork, ImageBox_1.AspectRatio.TARGETS["1:1"]);
            let titles = [
                this.entityTitleFactory.forDisc(disc)
            ];
            let subtitles = [
                this.entityTitleFactory.forAlbum(disc.album)
            ];
            let tags = [
                "Disc",
                metadata.formatDuration(disc.duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forEpisode(episode, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forEpisode(episode);
            let link = this.entityLinkFactory.forEpisode(episode);
            let image = this.ImageBox.forVideo([`/media/stills/${episode.media.file_id}/`]);
            let titles = [
                this.entityTitleFactory.forEpisode(episode)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(episode.season.show),
                this.entityTitleFactory.forSeason(episode.season)
            ];
            let tags = [
                "Episode",
                is.present(episode.year) ? `${episode.year.year}` : undefined,
                metadata.formatDuration(episode.duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            if (isHighQualityVideoFile(episode.media)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("HQ")));
            }
            if (is.present(episode.last_stream_date)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("\u2713")));
            }
            return this.make(link, image, titles, subtitles, tags, episode.summary, episode.copyright, options);
        }
        forFile(file, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forFile(file);
            let link = this.entityLinkFactory.forFile(file);
            let image = this.makeImage([], ImageBox_1.AspectRatio.TARGETS["1:1"]);
            let titles = [
                this.entityTitleFactory.forFile(file)
            ];
            let subtitles = is.present(file.parent) ? [
                this.entityTitleFactory.forDirectory(file.parent)
            ] : [];
            let tags = [
                "File",
                metadata.formatSize(file.size)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forGenre(genre, options = {}) {
            let link = this.entityLinkFactory.forGenre(genre);
            let image = this.makeImage([], ImageBox_1.AspectRatio.TARGETS["1:1"]);
            let titles = [
                this.entityTitleFactory.forGenre(genre)
            ];
            let subtitles = [];
            let tags = [
                "Genre"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forMovie(movie, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forMovie(movie);
            let link = this.entityLinkFactory.forMovie(movie);
            let image = this.makeImage(movie.artwork, ImageBox_1.AspectRatio.TARGETS["2:3"]);
            let titles = [
                this.entityTitleFactory.forMovie(movie)
            ];
            let subtitles = movie.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            let tags = [
                "Movie",
                is.present(movie.year) ? `${movie.year.year}` : undefined,
                metadata.formatDuration(movie.duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            if (isHighQualityVideoFile(movie.media)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("HQ")));
            }
            if (is.present(movie.last_stream_date)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("\u2713")));
            }
            return this.make(link, image, titles, subtitles, tags, movie.summary, movie.copyright, options);
        }
        forPlaylist(playlist, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forPlaylist(playlist);
            let link = this.entityLinkFactory.forPlaylist(playlist);
            let image = this.ImageBox.forLandscape(playlist.artwork.map((image) => `/api/files/${image.file_id}/content/`), true);
            let titles = [
                this.entityTitleFactory.forPlaylist(playlist)
            ];
            let subtitles = [
                this.entityTitleFactory.forUser(playlist.user)
            ];
            let tags = [
                "Playlist",
                metadata.formatDuration(playlist.duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, playlist.description, undefined, options);
        }
        forSeason(season, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forSeason(season);
            let link = this.entityLinkFactory.forSeason(season);
            let image = this.makeImage(season.show.artwork, ImageBox_1.AspectRatio.TARGETS["2:3"]);
            let titles = [
                this.entityTitleFactory.forSeason(season)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(season.show)
            ];
            let tags = [
                "Season",
                metadata.formatDuration(season.duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forShow(show, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forShow(show);
            let link = this.entityLinkFactory.forShow(show);
            let image = this.makeImage(show.artwork, ImageBox_1.AspectRatio.TARGETS["2:3"]);
            let titles = [
                this.entityTitleFactory.forShow(show)
            ];
            let subtitles = show.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            let tags = [
                "Show",
                metadata.formatDuration(show.duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, show.summary, undefined, options);
        }
        forTrack(track, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forTrack(track);
            let link = this.entityLinkFactory.forTrack(track);
            let image = this.makeImage(track.disc.album.artwork, ImageBox_1.AspectRatio.TARGETS["1:1"]);
            let titles = [
                this.entityTitleFactory.forTrack(track)
            ];
            let subtitles = [
                ...track.artists.map((artist) => this.entityTitleFactory.forArtist(artist)),
                this.entityTitleFactory.forAlbum(track.disc.album)
            ];
            let tags = [
                "Track",
                metadata.formatDuration(track.duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            if (isHighQualityAudioFile(track.media)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("HQ")));
            }
            return this.make(link, image, titles, subtitles, tags, undefined, track.copyright, options);
        }
        forUser(user, options = {}) {
            let link = this.entityLinkFactory.forUser(user);
            let image = this.makeImage([], ImageBox_1.AspectRatio.TARGETS["1:1"]);
            let titles = [
                this.entityTitleFactory.forUser(user)
            ];
            let subtitles = [
                this.entityTitleFactory.forUser(user, {
                    title: user.username
                })
            ];
            let tags = [
                "User"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        forYear(year, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forYear(year);
            let link = this.entityLinkFactory.forYear(year);
            let image = this.ImageBox.forLandscape(year.artwork.map((image) => `/api/files/${image.file_id}/content/`), true);
            let titles = [
                this.entityTitleFactory.forYear(year)
            ];
            let subtitles = [];
            let tags = [
                "Year"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, undefined, options);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityCardFactory = EntityCardFactory;
    ;
});
define("build/ui/EntityRow", ["require", "exports", "build/api/schema/objects/index", "build/xnode/index", "build/ui/theme/index", "build/is"], function (require, exports, api, xnode, theme, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityRowFactory = void 0;
    const CSS = `
	.entity-row {
		align-items: center;
		display: grid;
		gap: 16px;
		grid-template-columns: 40px 1fr;
	}

	.entity-row__artwork {
		position: relative;
	}

	.entity-row__playback {
		position: absolute;
			top: 50%; left: 50%;
		transform: translate(-50%, -50%);
	}

	.entity-row__content {

	}

	.entity-row__metadata {
		display: grid;
		gap: 16px;
	}

	.entity-row__titles {
		display: grid;
		gap: 8px;
	}

	.entity-row__title {
		color: ${theme.TEXT_0};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-row__subtitle {
		color: ${theme.TEXT_1};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
    class EntityRowFactory {
        entityTitleFactory;
        entityLinkFactory;
        ImageBox;
        PlaybackButton;
        make(link, image, playbackButton, titles, subtitles) {
            return link.add(xnode.element("div.entity-row")
                .add(xnode.element("div.entity-row__artwork")
                .add(image)
                .add(xnode.element("div.entity-row__playback")
                .add(playbackButton)))
                .add(xnode.element("div.entity-row__content")
                .add(xnode.element("div.entity-row__metadata")
                .add(xnode.element("div.entity-row__titles")
                .add(titles.length === 0 ? undefined : xnode.element("div.entity-row__title")
                .add(...xnode.joinarray(titles)))
                .add(subtitles.length === 0 ? undefined : xnode.element("div.entity-row__subtitle")
                .add(...xnode.joinarray(subtitles)))))));
        }
        constructor(entityTitleFactory, entityLinkFactory, ImageBox, PlaybackButton) {
            this.entityTitleFactory = entityTitleFactory;
            this.entityLinkFactory = entityLinkFactory;
            this.ImageBox = ImageBox;
            this.PlaybackButton = PlaybackButton;
        }
        forEntity(entity, options = {}) {
            if (api.Actor.is(entity)) {
                return this.forActor(entity, options);
            }
            if (api.Album.is(entity)) {
                return this.forAlbum(entity, options);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity, options);
            }
            if (api.Category.is(entity)) {
                return this.forCategory(entity, options);
            }
            if (api.Cue.is(entity)) {
                return this.forCue(entity, options);
            }
            if (api.Directory.is(entity)) {
                return this.forDirectory(entity, options);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity, options);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity, options);
            }
            if (api.File.is(entity)) {
                return this.forFile(entity, options);
            }
            if (api.Genre.is(entity)) {
                return this.forGenre(entity, options);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity, options);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity, options);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity, options);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity, options);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity, options);
            }
            if (api.User.is(entity)) {
                return this.forUser(entity, options);
            }
            if (api.Year.is(entity)) {
                return this.forYear(entity, options);
            }
            throw `Expected code to be unreachable!`;
        }
        forActor(actor, options = {}) {
            let link = options.link ?? this.entityLinkFactory.forActor(actor);
            let image = this.ImageBox.forSquare([]);
            let titles = [
                this.entityTitleFactory.forActor(actor)
            ];
            let subtitles = [];
            return this.make(link, image, undefined, titles, subtitles);
        }
        forAlbum(album, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forAlbum(album);
            let link = options.link ?? this.entityLinkFactory.forAlbum(album);
            let image = this.ImageBox.forSquare(album.artwork.map((image) => `/api/files/${image.file_id}/content/`));
            let titles = [
                this.entityTitleFactory.forAlbum(album)
            ];
            let subtitles = album.artists.map((artist) => this.entityTitleFactory.forArtist(artist));
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forArtist(artist, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forArtist(artist);
            let link = options.link ?? this.entityLinkFactory.forArtist(artist);
            let image = this.ImageBox.forSquare(artist.artwork.map((image) => `/api/files/${image.file_id}/content/`));
            let titles = [
                this.entityTitleFactory.forArtist(artist)
            ];
            let subtitles = new Array();
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forCategory(category, options = {}) {
            let link = options.link ?? this.entityLinkFactory.forCategory(category);
            let image = this.ImageBox.forSquare([]);
            let titles = [
                this.entityTitleFactory.forCategory(category)
            ];
            let subtitles = [];
            return this.make(link, image, undefined, titles, subtitles);
        }
        forCue(cue, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forCue(cue);
            if (false) {
            }
            else if (api.Episode.is(cue.media)) {
                return this.forEpisode(cue.media, { ...options, playbackButton });
            }
            else if (api.Movie.is(cue.media)) {
                return this.forMovie(cue.media, { ...options, playbackButton });
            }
            else {
                throw `Expected code to be unreachable!`;
            }
        }
        forDirectory(directory, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forDirectory(directory);
            let link = options.link ?? this.entityLinkFactory.forDirectory(directory);
            let image = this.ImageBox.forSquare([]);
            let titles = [
                this.entityTitleFactory.forDirectory(directory)
            ];
            let subtitles = is.present(directory.parent) ? [
                this.entityTitleFactory.forDirectory(directory.parent)
            ] : [];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forDisc(disc, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forDisc(disc);
            let link = options.link ?? this.entityLinkFactory.forDisc(disc);
            let image = this.ImageBox.forSquare(disc.album.artwork.map((image) => `/api/files/${image.file_id}/content/`));
            let titles = [
                this.entityTitleFactory.forDisc(disc)
            ];
            let subtitles = [
                this.entityTitleFactory.forAlbum(disc.album)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forEpisode(episode, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forEpisode(episode);
            let link = options.link ?? this.entityLinkFactory.forEpisode(episode);
            let image = this.ImageBox.forSquare([`/media/stills/${episode.media.file_id}/`]);
            let titles = [
                this.entityTitleFactory.forEpisode(episode)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(episode.season.show),
                this.entityTitleFactory.forSeason(episode.season)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forFile(file, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forFile(file);
            let link = options.link ?? this.entityLinkFactory.forFile(file);
            let image = this.ImageBox.forSquare([]);
            let titles = [
                this.entityTitleFactory.forFile(file)
            ];
            let subtitles = is.present(file.parent) ? [
                this.entityTitleFactory.forDirectory(file.parent)
            ] : [];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forGenre(genre, options = {}) {
            let link = options.link ?? this.entityLinkFactory.forGenre(genre);
            let image = this.ImageBox.forSquare([]);
            let titles = [
                this.entityTitleFactory.forGenre(genre)
            ];
            let subtitles = [];
            return this.make(link, image, undefined, titles, subtitles);
        }
        forMovie(movie, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forMovie(movie);
            let link = options.link ?? this.entityLinkFactory.forMovie(movie);
            let image = this.ImageBox.forSquare(movie.artwork.map((image) => `/api/files/${image.file_id}/content/`));
            let titles = [
                this.entityTitleFactory.forMovie(movie)
            ];
            let subtitles = movie.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forPlaylist(playlist, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forPlaylist(playlist);
            let link = options.link ?? this.entityLinkFactory.forPlaylist(playlist);
            let image = this.ImageBox.forSquare(playlist.artwork.map((image) => `/api/files/${image.file_id}/content/`), true);
            let titles = [
                this.entityTitleFactory.forPlaylist(playlist)
            ];
            let subtitles = [
                this.entityTitleFactory.forUser(playlist.user)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forSeason(season, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forSeason(season);
            let link = options.link ?? this.entityLinkFactory.forSeason(season);
            let image = this.ImageBox.forSquare(season.show.artwork.map((image) => `/api/files/${image.file_id}/content/`));
            let titles = [
                this.entityTitleFactory.forSeason(season)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(season.show)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forShow(show, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forShow(show);
            let link = options.link ?? this.entityLinkFactory.forShow(show);
            let image = this.ImageBox.forSquare(show.artwork.map((image) => `/api/files/${image.file_id}/content/`));
            let titles = [
                this.entityTitleFactory.forShow(show)
            ];
            let subtitles = show.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forTrack(track, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forTrack(track);
            let link = options.link ?? this.entityLinkFactory.forTrack(track);
            let image = this.ImageBox.forSquare(track.disc.album.artwork.map((image) => `/api/files/${image.file_id}/content/`));
            let titles = [
                this.entityTitleFactory.forTrack(track)
            ];
            let subtitles = [
                ...track.artists.map((artist) => this.entityTitleFactory.forArtist(artist)),
                this.entityTitleFactory.forAlbum(track.disc.album)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forUser(user, options = {}) {
            let link = options.link ?? this.entityLinkFactory.forUser(user);
            let image = this.ImageBox.forSquare([]);
            let titles = [
                this.entityTitleFactory.forUser(user)
            ];
            let subtitles = [
                this.entityTitleFactory.forUser(user, {
                    title: user.username
                })
            ];
            return this.make(link, image, undefined, titles, subtitles);
        }
        forYear(year, options = {}) {
            let playbackButton = "playbackButton" in options ? options.playbackButton : this.PlaybackButton.forYear(year);
            let link = options.link ?? this.entityLinkFactory.forYear(year);
            let image = this.ImageBox.forSquare(year.artwork.map((image) => `/api/files/${image.file_id}/content/`), true);
            let titles = [
                this.entityTitleFactory.forYear(year)
            ];
            let subtitles = [];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityRowFactory = EntityRowFactory;
    ;
});
define("build/utils", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateHexId = exports.getNextEpisode = exports.formatTimestamp = exports.join = exports.binid = exports.hexid = void 0;
    function hexid(buffer) {
        return Buffer.from(buffer).toString("hex");
    }
    exports.hexid = hexid;
    ;
    function binid(string) {
        return Uint8Array.from(Buffer.from(string, "hex"));
    }
    exports.binid = binid;
    ;
    function join(...parameters) {
        return parameters.map((parameter) => {
            return String(parameter);
        }).join("");
    }
    exports.join = join;
    function formatTimestamp(ms) {
        let s = Math.floor(ms / 1000);
        ms -= (s * 1000);
        let m = Math.floor(s / 60);
        s -= (m * 60);
        let h = Math.floor(m / 60);
        m -= (h * 60);
        let fh = join("00", h).slice(-2);
        let fm = join("00", m).slice(-2);
        let fs = join("00", s).slice(-2);
        let fms = join("000", ms).slice(-3);
        return join(fh, ":", fm, ":", fs, ".", fms);
    }
    exports.formatTimestamp = formatTimestamp;
    function getNextEpisode(show) {
        let indices;
        show.seasons.forEach((season, seasonIndex) => {
            season.episodes.forEach((episode, episodeIndex) => {
                if (is.present(episode.last_stream_date)) {
                    if (is.present(indices)) {
                        if (episode.last_stream_date < (show.seasons[indices.seasonIndex].episodes[indices.episodeIndex].last_stream_date ?? 0)) {
                            return;
                        }
                    }
                    indices = {
                        seasonIndex,
                        episodeIndex
                    };
                }
            });
        });
        if (is.present(indices)) {
            indices.episodeIndex += 1;
            if (indices.episodeIndex === show.seasons[indices.seasonIndex].episodes.length) {
                indices.episodeIndex = 0;
                indices.seasonIndex += 1;
                if (indices.seasonIndex === show.seasons.length) {
                    indices.seasonIndex = 0;
                }
            }
        }
        else {
            if (show.seasons.length > 0 && show.seasons[0].episodes.length > 0) {
                indices = {
                    seasonIndex: 0,
                    episodeIndex: 0
                };
            }
        }
        return indices;
    }
    exports.getNextEpisode = getNextEpisode;
    function generateHexId(length) {
        let alphabet = "0123456789abcdef";
        let result = "";
        for (let i = 0; i < length; i++) {
            result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        }
        return result;
    }
    exports.generateHexId = generateHexId;
    ;
});
define("build/ui/PlaybackButton", ["require", "exports", "build/api/schema/objects/index", "build/observers/index", "build/xnode/index", "build/ui/theme/index", "build/is", "build/utils", "build/player/schema/objects/index"], function (require, exports, api, observables, xnode, theme, is, utils, objects_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaybackButtonFactory = void 0;
    const CSS = `
	.playback-button {
		background-color: ${theme.TEXT_0};
		border-radius: 50%;
		box-shadow: 0px 0px 8px 4px rgba(0, 0, 0, 0.25);
		cursor: pointer;
		fill: ${theme.BACKGROUND_2};
		padding: 8px;
		transition: transform 0.125s;
	}

	@media (hover: hover) and (pointer: fine) {
		.playback-button:not([data-enabled="false"]):hover {
			transform: scale(1.50);
		}

		.playback-button:active {
			transform: none;
		}
	}
`;
    class PlaybackButtonFactory {
        rpc;
        player;
        iconFactory;
        make(isContext, controller) {
            let isPlaying = observables.computed((isContext, playback) => {
                return isContext && playback;
            }, isContext, this.player.playback);
            return xnode.element("div.playback-button")
                .add(this.iconFactory.makePlay()
                .bind("data-hide", isPlaying.addObserver((isPlaying) => isPlaying)))
                .add(this.iconFactory.makePause()
                .bind("data-hide", isPlaying.addObserver((isPlaying) => !isPlaying)))
                .on("click", () => {
                let pause = controller.pause ?? (() => this.player.pause());
                let play = controller.play ?? (() => this.player.play());
                let resume = controller.resume ?? (() => this.player.resume());
                if (isPlaying.getState()) {
                    pause();
                }
                else {
                    if (isContext.getState()) {
                        resume();
                    }
                    else {
                        play();
                    }
                }
            });
        }
        async getAlbumContext(album) {
            let response = await this.rpc.getAlbumContext({
                options: {
                    album_id: album.album_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        async getArtistContext(artist) {
            let response = await this.rpc.getArtistContext({
                options: {
                    artist_id: artist.artist_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        async getDirectoryContext(directory) {
            let response = await this.rpc.getDirectoryContext({
                options: {
                    directory_id: directory.directory_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        async getDiscContext(disc) {
            let response = await this.rpc.getDiscContext({
                options: {
                    disc_id: disc.disc_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        async getEpisodeContext(episode) {
            let response = await this.rpc.getEpisodeContext({
                options: {
                    episode_id: episode.episode_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        async getFileContext(file) {
            let response = await this.rpc.getFileContext({
                options: {
                    file_id: file.file_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        async getMovieContext(movie) {
            let response = await this.rpc.getMovieContext({
                options: {
                    movie_id: movie.movie_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        async getPlaylistContext(playlist) {
            let response = await this.rpc.getPlaylistContext({
                options: {
                    playlist_id: playlist.playlist_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        async getSeasonContext(season) {
            let response = await this.rpc.getSeasonContext({
                options: {
                    season_id: season.season_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        async getShowContext(show) {
            let response = await this.rpc.getShowContext({
                options: {
                    show_id: show.show_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        async getTrackContext(track) {
            let response = await this.rpc.getTrackContext({
                options: {
                    track_id: track.track_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        async getYearContext(year) {
            let response = await this.rpc.getYearContext({
                options: {
                    year_id: year.year_id,
                    token: this.player.token.getState() ?? ""
                }
            });
            let payload = await response.payload();
            return payload.context;
        }
        constructor(rpc, player, iconFactory) {
            this.rpc = rpc;
            this.player = player;
            this.iconFactory = iconFactory;
        }
        forEntity(entity) {
            if (api.Album.is(entity)) {
                return this.forAlbum(entity);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity);
            }
            if (api.Cue.is(entity)) {
                return this.forCue(entity);
            }
            if (api.Directory.is(entity)) {
                return this.forDirectory(entity);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity);
            }
            if (api.File.is(entity)) {
                return this.forFile(entity);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity);
            }
            throw `Expected code to be unreachable!`;
        }
        forAlbum(album, discIndex, trackIndex) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextAlbum.is(context) || !objects_1.ContextTrack.is(currentEntry)) {
                    return false;
                }
                if (context.album_id !== album.album_id) {
                    return false;
                }
                if (discIndex != null) {
                    if (context.discs[discIndex].disc_id !== currentEntry.disc.disc_id) {
                        return false;
                    }
                    if (trackIndex != null) {
                        if (context.discs[discIndex].tracks[trackIndex].track_id !== currentEntry.track_id) {
                            return false;
                        }
                    }
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => this.player.playAlbum(await this.getAlbumContext(album), discIndex, trackIndex)
            });
        }
        forArtist(artist, albumIndex, discIndex, trackIndex) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextArtist.is(context) || !objects_1.ContextTrack.is(currentEntry)) {
                    return false;
                }
                if (context.artist_id !== artist.artist_id) {
                    return false;
                }
                if (albumIndex != null) {
                    if (context.albums[albumIndex].album_id !== currentEntry.disc.album.album_id) {
                        return false;
                    }
                    if (discIndex != null) {
                        if (context.albums[albumIndex].discs[discIndex].disc_id !== currentEntry.disc.disc_id) {
                            return false;
                        }
                        if (trackIndex != null) {
                            if (context.albums[albumIndex].discs[discIndex].tracks[trackIndex].track_id !== currentEntry.track_id) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => this.player.playArtist(await this.getArtistContext(artist), albumIndex, discIndex, trackIndex)
            });
        }
        forCue(cue) {
            let start_s = Math.max(0, cue.start_ms / 1000 - 0.25);
            if (false) {
            }
            else if (api.Episode.is(cue.media)) {
                let episode = cue.media;
                let isContext = observables.computed((context) => {
                    return objects_1.ContextEpisode.is(context) && context.episode_id === episode.episode_id;
                }, this.player.context);
                return this.make(isContext, {
                    play: () => {
                        this.player.playEpisode(episode);
                        this.player.seek(start_s);
                    },
                    resume: () => {
                        this.player.seek(0);
                        this.player.seek(start_s);
                        this.player.resume();
                    }
                });
            }
            else if (api.Movie.is(cue.media)) {
                let movie = cue.media;
                let isContext = observables.computed((context) => {
                    return objects_1.ContextMovie.is(context) && context.movie_id === movie.movie_id;
                }, this.player.context);
                return this.make(isContext, {
                    play: () => {
                        this.player.playMovie(movie);
                        this.player.seek(start_s);
                    },
                    resume: () => {
                        this.player.seek(0);
                        this.player.seek(start_s);
                        this.player.resume();
                    }
                });
            }
            throw `Expected code to be unreachable!`;
        }
        forDirectory(directory, fileIndex) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextDirectory.is(context) || !objects_1.ContextFile.is(currentEntry)) {
                    return false;
                }
                if (context.directory_id !== directory.directory_id) {
                    return false;
                }
                if (fileIndex != null) {
                    if (context.files[fileIndex].file_id !== currentEntry.file_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => this.player.playDirectory(await this.getDirectoryContext(directory), fileIndex)
            });
        }
        forDisc(disc, trackIndex) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextDisc.is(context) || !objects_1.ContextTrack.is(currentEntry)) {
                    return false;
                }
                if (context.disc_id !== disc.disc_id) {
                    return false;
                }
                if (trackIndex != null) {
                    if (context.tracks[trackIndex].track_id !== currentEntry.track_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => this.player.playDisc(await this.getDiscContext(disc), trackIndex)
            });
        }
        forFile(file) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextFile.is(context) || !objects_1.ContextFile.is(currentEntry)) {
                    return false;
                }
                if (context.file_id !== file.file_id) {
                    return false;
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => this.player.playFile(await this.getFileContext(file))
            });
        }
        forEpisode(episode) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextEpisode.is(context) || !objects_1.ContextEpisode.is(currentEntry)) {
                    return false;
                }
                if (context.episode_id !== episode.episode_id) {
                    return false;
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => this.player.playEpisode(await this.getEpisodeContext(episode))
            });
        }
        forMovie(movie) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextMovie.is(context) || !objects_1.ContextMovie.is(currentEntry)) {
                    return false;
                }
                if (context.movie_id !== movie.movie_id) {
                    return false;
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => this.player.playMovie(await this.getMovieContext(movie))
            });
        }
        forPlaylist(playlist, itemIndex) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextPlaylist.is(context) || !objects_1.ContextTrack.is(currentEntry)) {
                    return false;
                }
                if (context.playlist_id !== playlist.playlist_id) {
                    return false;
                }
                if (itemIndex != null) {
                    if (context.items[itemIndex].track.track_id !== currentEntry.track_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => this.player.playPlaylist(await this.getPlaylistContext(playlist), itemIndex)
            });
        }
        forSeason(season, episodeIndex) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextSeason.is(context) || !objects_1.ContextEpisode.is(currentEntry)) {
                    return false;
                }
                if (context.season_id !== season.season_id) {
                    return false;
                }
                if (episodeIndex != null) {
                    if (context.episodes[episodeIndex].episode_id !== currentEntry.episode_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => this.player.playSeason(await this.getSeasonContext(season), episodeIndex)
            });
        }
        forShow(show, seasonIndex, episodeIndex) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextShow.is(context) || !objects_1.ContextEpisode.is(currentEntry)) {
                    return false;
                }
                if (context.show_id !== show.show_id) {
                    return false;
                }
                if (seasonIndex != null) {
                    if (context.seasons[seasonIndex].season_id !== currentEntry.season.season_id) {
                        return false;
                    }
                    if (episodeIndex != null) {
                        if (context.seasons[seasonIndex].episodes[episodeIndex].episode_id !== currentEntry.episode_id) {
                            return false;
                        }
                    }
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => {
                    let context = await this.getShowContext(show);
                    if (is.absent(seasonIndex)) {
                        let indices = utils.getNextEpisode(context);
                        seasonIndex = indices?.seasonIndex;
                        episodeIndex = indices?.episodeIndex;
                    }
                    this.player.playShow(context, seasonIndex, episodeIndex);
                }
            });
        }
        forTrack(track) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextTrack.is(context) || !objects_1.ContextTrack.is(currentEntry)) {
                    return false;
                }
                if (context.track_id !== track.track_id) {
                    return false;
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => this.player.playTrack(await this.getTrackContext(track))
            });
        }
        forYear(year) {
            let isContext = observables.computed((context, currentEntry) => {
                if (!objects_1.ContextYear.is(context) || !objects_1.ContextTrack.is(currentEntry)) {
                    return false;
                }
                if (context.year_id !== year.year_id) {
                    return false;
                }
                return true;
            }, this.player.context, this.player.currentEntry);
            return this.make(isContext, {
                play: async () => this.player.playYear(await this.getYearContext(year))
            });
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.PlaybackButtonFactory = PlaybackButtonFactory;
    ;
});
define("build/ui/EntityNavLinkFactory", ["require", "exports", "build/is", "build/ui/theme/index", "build/xnode/index"], function (require, exports, is, theme, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityNavLinkFactory = void 0;
    const CSS = `
	.entity-nav-link {
		display: grid;
		gap: 16px;
		grid-auto-flow: column;
		justify-content: center;
	}

	.entity-nav-link__last,
	.entity-nav-link__next {
		display: grid;
		gap: 8px;
		justify-items: center;
	}

	.entity-nav-link__title {
		color: ${theme.TEXT_1};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
    class EntityNavLinkFactory {
        iconFactory;
        entityLinkFactory;
        make(type, last, next) {
            let lastLink = is.absent(last) ? xnode.element("span") : this.entityLinkFactory.forEntity(last);
            let nextLink = is.absent(next) ? xnode.element("span") : this.entityLinkFactory.forEntity(next);
            return xnode.element("div.entity-nav-link")
                .add(lastLink.add(xnode.element("div.entity-nav-link__last")
                .add(xnode.element("div.icon-button")
                .set("data-enabled", `${is.present(last)}`)
                .add(this.iconFactory.makeChevron({ direction: "left" })))
                .add(xnode.element("div.entity-nav-link__title")
                .add(xnode.text(`Last ${type}`)))))
                .add(nextLink.add(xnode.element("div.entity-nav-link__next")
                .add(xnode.element("div.icon-button")
                .set("data-enabled", `${is.present(next)}`)
                .add(this.iconFactory.makeChevron()))
                .add(xnode.element("div.entity-nav-link__title")
                .add(xnode.text(`Next ${type}`)))));
        }
        constructor(iconFactory, entityLinkFactory) {
            this.iconFactory = iconFactory;
            this.entityLinkFactory = entityLinkFactory;
        }
        forEntity(last, next) {
            return this.make("item", last, next);
        }
        forActor(last, next) {
            return this.make("actor", last, next);
        }
        forAlbum(last, next) {
            return this.make("album", last, next);
        }
        forArtist(last, next) {
            return this.make("artist", last, next);
        }
        forCue(last, next) {
            return this.make("cue", last, next);
        }
        forDisc(last, next) {
            return this.make("disc", last, next);
        }
        forEpisode(last, next) {
            return this.make("episode", last, next);
        }
        forGenre(last, next) {
            return this.make("genre", last, next);
        }
        forMovie(last, next) {
            return this.make("movie", last, next);
        }
        forPlaylist(last, next) {
            return this.make("playlist", last, next);
        }
        forSeason(last, next) {
            return this.make("season", last, next);
        }
        forShow(last, next) {
            return this.make("show", last, next);
        }
        forTrack(last, next) {
            return this.make("track", last, next);
        }
        forUser(last, next) {
            return this.make("user", last, next);
        }
        forYear(last, next) {
            return this.make("year", last, next);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityNavLinkFactory = EntityNavLinkFactory;
    ;
});
define("build/jsondb/sorters", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = void 0;
    exports.CombinedSort = {
        of(...rankers) {
            return (one, two) => {
                for (let ranker of rankers) {
                    let rank = ranker(one, two);
                    if (rank !== 0) {
                        return rank;
                    }
                }
                return 0;
            };
        }
    };
    exports.CustomSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return (t ? 1 : 0) - (o ? 1 : 0);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return (o ? 1 : 0) - (t ? 1 : 0);
            };
        }
    };
    exports.LexicalSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t.localeCompare(o);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o.localeCompare(t);
            };
        }
    };
    exports.NumericSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t - o;
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o - t;
            };
        }
    };
});
define("build/jsondb/indices", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/is", "build/jsondb/sorters"], function (require, exports, stdlib, is, sorters) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SearchIndex = exports.getTokens = exports.RecordIndex = exports.CollectionIndex = void 0;
    class CollectionIndex {
        getPrimaryKeysFromIndexedValue;
        lookupRecord;
        getPrimaryKey;
        getIndexedValue;
        constructor(lookupRecord, getPrimaryKey, getIndexedValue) {
            this.getPrimaryKeysFromIndexedValue = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValue = getIndexedValue;
        }
        insert(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.absent(primaryKeys)) {
                primaryKeys = new Set();
                this.getPrimaryKeysFromIndexedValue.set(indexedValue, primaryKeys);
            }
            let primaryKey = this.getPrimaryKey(record);
            primaryKeys.add(primaryKey);
        }
        lookup(key) {
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(key);
            if (is.present(primaryKeys)) {
                return Array.from(primaryKeys).map(this.lookupRecord);
            }
            return new Array();
        }
        remove(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.present(primaryKeys)) {
                let primaryKey = this.getPrimaryKey(record);
                primaryKeys.delete(primaryKey);
                if (primaryKeys.size === 0) {
                    this.getPrimaryKeysFromIndexedValue.delete(indexedValue);
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
        static fromTable(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
    }
    exports.CollectionIndex = CollectionIndex;
    ;
    class RecordIndex {
        getRecordFromKey;
        getKey;
        router;
        insertOrUpdate(next, action = "replace") {
            let key = this.getKey(next);
            let last = this.getRecordFromKey.get(key);
            if (is.present(last)) {
                if (action === "combine") {
                    for (let key in last) {
                        let lastValue = last[key];
                        let nextValue = next[key];
                        if (is.present(lastValue) && is.absent(nextValue)) {
                            next[key] = last[key];
                        }
                    }
                }
                this.getRecordFromKey.set(key, next);
                this.router.route("update", { last, next });
                this.router.route("*", {});
            }
            else {
                this.getRecordFromKey.set(key, next);
                this.router.route("insert", { next });
                this.router.route("*", {});
            }
        }
        constructor(getKey) {
            this.getRecordFromKey = new Map();
            this.getKey = getKey;
            this.router = new stdlib.routing.MessageRouter();
        }
        [Symbol.iterator]() {
            return this.getRecordFromKey.values();
        }
        insert(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        keyof(record) {
            return this.getKey(record);
        }
        length() {
            return this.getRecordFromKey.size;
        }
        lookup(key) {
            let record = this.getRecordFromKey.get(key);
            if (is.absent(record)) {
                throw `Expected "${key}" to match a record!`;
            }
            return record;
        }
        on(type, listener) {
            this.router.addObserver(type, listener);
            if (type === "insert") {
                for (let record of this.getRecordFromKey.values()) {
                    listener({ next: record });
                }
            }
        }
        off(type, listener) {
            this.router.addObserver(type, listener);
        }
        remove(record) {
            let key = this.getKey(record);
            if (this.getRecordFromKey.has(key)) {
                this.getRecordFromKey.delete(key);
                this.router.route("remove", { last: record });
                this.router.route("*", {});
            }
        }
        update(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        static from(records, getKey) {
            let index = new RecordIndex(getKey);
            for (let record of records) {
                index.insert(record);
            }
            return index;
        }
    }
    exports.RecordIndex = RecordIndex;
    ;
    function getTokens(query) {
        let normalized = query;
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFKD");
        normalized = normalized.replace(/[\p{M}]/gu, "");
        return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
    }
    exports.getTokens = getTokens;
    ;
    class SearchIndex {
        getPrimaryKeysFromToken;
        lookupRecord;
        getPrimaryKey;
        getIndexedValues;
        minTokenLength;
        constructor(lookupRecord, getPrimaryKey, getIndexedValues, minTokenLength) {
            this.getPrimaryKeysFromToken = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValues = getIndexedValues;
            this.minTokenLength = minTokenLength;
        }
        insert(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value).filter((token) => token.length >= this.minTokenLength);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.absent(primaryKeys)) {
                        primaryKeys = new Set();
                        this.getPrimaryKeysFromToken.set(token, primaryKeys);
                    }
                    let primaryKey = this.getPrimaryKey(record);
                    primaryKeys.add(primaryKey);
                }
            }
        }
        lookup(query) {
            let tokens = getTokens(query).filter((token) => token.length >= this.minTokenLength);
            let primaryKeySets = tokens.map((token) => {
                return this.getPrimaryKeysFromToken.get(token);
            }).filter(is.present);
            let map = new Map();
            for (let primaryKeys of primaryKeySets) {
                for (let primaryKey of primaryKeys) {
                    let rank = map.get(primaryKey) ?? (0 - tokens.length);
                    map.set(primaryKey, rank + 2);
                }
            }
            return Array.from(map.entries())
                .filter((entry) => entry[1] >= 0)
                .sort(sorters.NumericSort.decreasing((entry) => entry[1]))
                .map((entry) => ({
                id: entry[0],
                rank: entry[1]
            }));
        }
        remove(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.present(primaryKeys)) {
                        let primaryKey = this.getPrimaryKey(record);
                        primaryKeys.delete(primaryKey);
                        if (primaryKeys.size === 0) {
                            this.getPrimaryKeysFromToken.delete(token);
                        }
                    }
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
        static fromTable(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            for (let record of records) {
                index.insert(record);
            }
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
    }
    exports.SearchIndex = SearchIndex;
    ;
});
define("build/jsondb/index", ["require", "exports", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters"], function (require, exports, indices, sorters, indices_1, indices_2, indices_3, sorters_1, sorters_2, sorters_3, sorters_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sorters = exports.indices = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = exports.SearchIndex = exports.RecordIndex = exports.CollectionIndex = exports.sorters = exports.indices = void 0;
    exports.indices = indices;
    exports.sorters = sorters;
    Object.defineProperty(exports, "CollectionIndex", { enumerable: true, get: function () { return indices_1.CollectionIndex; } });
    Object.defineProperty(exports, "RecordIndex", { enumerable: true, get: function () { return indices_2.RecordIndex; } });
    Object.defineProperty(exports, "SearchIndex", { enumerable: true, get: function () { return indices_3.SearchIndex; } });
    Object.defineProperty(exports, "CombinedSort", { enumerable: true, get: function () { return sorters_1.CombinedSort; } });
    Object.defineProperty(exports, "CustomSort", { enumerable: true, get: function () { return sorters_2.CustomSort; } });
    Object.defineProperty(exports, "LexicalSort", { enumerable: true, get: function () { return sorters_3.LexicalSort; } });
    Object.defineProperty(exports, "NumericSort", { enumerable: true, get: function () { return sorters_4.NumericSort; } });
});
define("build/playlists/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.UpdatePlaylistItem = exports.UpdatePlaylistItemResponse = exports.UpdatePlaylistItemRequest = exports.DeletePlaylistItem = exports.DeletePlaylistItemResponse = exports.DeletePlaylistItemRequest = exports.CreatePlaylistItem = exports.CreatePlaylistItemResponse = exports.CreatePlaylistItemRequest = exports.UpdatePlaylist = exports.UpdatePlaylistResponse = exports.UpdatePlaylistRequest = exports.DeletePlaylist = exports.DeletePlaylistResponse = exports.DeletePlaylistRequest = exports.CreatePlaylist = exports.CreatePlaylistResponse = exports.CreatePlaylistRequest = exports.PermissionsResponse = exports.PermissionsRequest = exports.SetToken = void 0;
    exports.SetToken = autoguard.guards.Object.of({}, {
        "token": autoguard.guards.String
    });
    exports.PermissionsRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String
        }, {})
    }, {});
    exports.PermissionsResponse = autoguard.guards.Object.of({
        "permissions": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("read"), autoguard.guards.StringLiteral.of("write"))
    }, {});
    exports.CreatePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "title": autoguard.guards.String,
            "description": autoguard.guards.String
        }, {})
    }, {});
    exports.CreatePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String),
        "playlist_id": autoguard.guards.String
    }, {});
    exports.CreatePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    }, {});
    exports.DeletePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String
        }, {})
    }, {});
    exports.DeletePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.DeletePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    }, {});
    exports.UpdatePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String,
            "title": autoguard.guards.String,
            "description": autoguard.guards.String
        }, {})
    }, {});
    exports.UpdatePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.UpdatePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    }, {});
    exports.CreatePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String,
            "track_id": autoguard.guards.String
        }, {})
    }, {});
    exports.CreatePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String),
        "playlist_item_id": autoguard.guards.String
    }, {});
    exports.CreatePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    }, {});
    exports.DeletePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_item_id": autoguard.guards.String
        }, {})
    }, {});
    exports.DeletePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.DeletePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    }, {});
    exports.UpdatePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_item_id": autoguard.guards.String,
            "number": autoguard.guards.Number
        }, {})
    }, {});
    exports.UpdatePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.UpdatePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "SetToken": autoguard.guards.Reference.of(() => exports.SetToken),
            "PermissionsRequest": autoguard.guards.Reference.of(() => exports.PermissionsRequest),
            "PermissionsResponse": autoguard.guards.Reference.of(() => exports.PermissionsResponse),
            "CreatePlaylistRequest": autoguard.guards.Reference.of(() => exports.CreatePlaylistRequest),
            "CreatePlaylistResponse": autoguard.guards.Reference.of(() => exports.CreatePlaylistResponse),
            "CreatePlaylist": autoguard.guards.Reference.of(() => exports.CreatePlaylist),
            "DeletePlaylistRequest": autoguard.guards.Reference.of(() => exports.DeletePlaylistRequest),
            "DeletePlaylistResponse": autoguard.guards.Reference.of(() => exports.DeletePlaylistResponse),
            "DeletePlaylist": autoguard.guards.Reference.of(() => exports.DeletePlaylist),
            "UpdatePlaylistRequest": autoguard.guards.Reference.of(() => exports.UpdatePlaylistRequest),
            "UpdatePlaylistResponse": autoguard.guards.Reference.of(() => exports.UpdatePlaylistResponse),
            "UpdatePlaylist": autoguard.guards.Reference.of(() => exports.UpdatePlaylist),
            "CreatePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.CreatePlaylistItemRequest),
            "CreatePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.CreatePlaylistItemResponse),
            "CreatePlaylistItem": autoguard.guards.Reference.of(() => exports.CreatePlaylistItem),
            "DeletePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.DeletePlaylistItemRequest),
            "DeletePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.DeletePlaylistItemResponse),
            "DeletePlaylistItem": autoguard.guards.Reference.of(() => exports.DeletePlaylistItem),
            "UpdatePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItemRequest),
            "UpdatePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItemResponse),
            "UpdatePlaylistItem": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItem)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/playlists/client", ["require", "exports", "build/observers/index", "build/jsondb/index", "build/playlists/schema/messages/index", "build/typesockets/client"], function (require, exports, observers, jsondb, messages, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaylistsClient = void 0;
    class PlaylistsClient {
        tsc;
        token = new observers.ObservableClass(undefined);
        online = new observers.ObservableClass(false);
        playlists = new observers.ArrayObservable(new Array());
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.tsc = new typesockets.TypeSocketClient(url, factory, messages.Autoguard.Guards);
            this.tsc.addEventListener("sys", "connect", () => {
                this.online.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.online.updateState(false);
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.online, this.token);
            this.tsc.addEventListener("app", "CreatePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
                let playlist = {
                    ...message.playlist,
                    items: new Array(),
                    affinity: 0,
                    duration_ms: 0,
                    artwork: []
                };
                this.playlists.append(new observers.ObservableClass(playlist));
            });
            this.tsc.addEventListener("app", "DeletePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylist", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        playlist.updateState({
                            ...state,
                            ...message.playlist
                        });
                    }
                }
            });
            this.tsc.addEventListener("app", "CreatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        items.push(message.playlist_item);
                        let additions = 1;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "DeletePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        let additions = 0;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let old_index = state.items.findIndex((item) => item.playlist_item_id === message.playlist_item.playlist_item_id);
                        if (old_index >= 0) {
                            let new_index = message.playlist_item.number - 1;
                            if (new_index > old_index) {
                                for (let i = old_index + 1; i < new_index; i++) {
                                    state.items[i].number -= 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            else if (new_index < old_index) {
                                for (let i = new_index; i < old_index; i++) {
                                    state.items[i].number += 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            state.items[new_index] = {
                                ...state.items[new_index],
                                ...message.playlist_item
                            };
                            playlist.updateState({
                                ...state
                            });
                        }
                    }
                }
            });
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        isOnline() {
            return this.online.getState();
        }
        getPermissions(request) {
            return this.tsc.request("PermissionsRequest", "PermissionsResponse", request);
        }
        createPlaylist(request) {
            return this.tsc.request("CreatePlaylistRequest", "CreatePlaylistResponse", request);
        }
        deletePlaylist(request) {
            return this.tsc.request("DeletePlaylistRequest", "DeletePlaylistResponse", request);
        }
        updatePlaylist(request) {
            return this.tsc.request("UpdatePlaylistRequest", "UpdatePlaylistResponse", request);
        }
        createPlaylistItem(request) {
            return this.tsc.request("CreatePlaylistItemRequest", "CreatePlaylistItemResponse", request);
        }
        deletePlaylistItem(request) {
            return this.tsc.request("DeletePlaylistItemRequest", "DeletePlaylistItemResponse", request);
        }
        updatePlaylistItem(request) {
            return this.tsc.request("UpdatePlaylistItemRequest", "UpdatePlaylistItemResponse", request);
        }
        close() {
            this.tsc.close();
        }
        reconnect() {
            this.tsc.reconnect();
        }
    }
    exports.PlaylistsClient = PlaylistsClient;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-client/api", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-autoguard/dist/lib-shared/api"], function (require, exports, shared, api_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function () { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (this && this.__exportStar) || function (m, exports) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
                __createBinding(exports, m, p);
    };
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.finalizeRequest = exports.xhr = exports.ServerResponse = void 0;
    __exportStar(api_1, exports);
    class ServerResponse {
        constructor(response, collect) {
            this.response = response;
            this.collect = collect;
        }
        status() {
            let status = this.response.status;
            return status !== null && status !== void 0 ? status : 200;
        }
        headers() {
            let headers = this.response.headers;
            return Object.assign({}, headers);
        }
        payload() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.collectedPayload !== undefined) {
                    return this.collectedPayload;
                }
                let payload = this.response.payload;
                let collectedPayload = (this.collect ? yield shared.api.collectPayload(payload) : payload);
                this.collectedPayload = collectedPayload;
                return collectedPayload;
            });
        }
    }
    exports.ServerResponse = ServerResponse;
    ;
    function xhr(raw, clientOptions) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            // @ts-ignore
            let xhr = new XMLHttpRequest();
            xhr.onerror = reject;
            xhr.onabort = reject;
            xhr.onload = () => {
                let status = xhr.status;
                // Header values for the same header name are joined by he XHR implementation.
                let headers = shared.api.splitHeaders(xhr.getAllResponseHeaders().split("\r\n").slice(0, -1));
                let payload = [new Uint8Array(xhr.response)];
                let raw = {
                    status,
                    headers,
                    payload
                };
                resolve(raw);
            };
            let url = (_a = clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.urlPrefix) !== null && _a !== void 0 ? _a : "";
            url += shared.api.combineComponents(raw.components);
            url += shared.api.combineParameters(raw.parameters);
            xhr.open(raw.method, url, true);
            xhr.responseType = "arraybuffer";
            for (let header of raw.headers) {
                // Header values for the same header name are joined by he XHR implementation.
                xhr.setRequestHeader(header[0], header[1]);
            }
            xhr.send(yield shared.api.collectPayload(raw.payload));
        }));
    }
    exports.xhr = xhr;
    ;
    function finalizeRequest(raw, defaultHeaders) {
        let headersToAppend = defaultHeaders.filter((defaultHeader) => {
            let found = raw.headers.find((header) => header[0].toLowerCase() === defaultHeader[0].toLowerCase());
            return found === undefined;
        });
        return Object.assign(Object.assign({}, raw), { headers: [
                ...raw.headers,
                ...headersToAppend
            ] });
    }
    exports.finalizeRequest = finalizeRequest;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-client/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-autoguard/dist/lib-client/api"], function (require, exports, lib_shared_1, api) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.api = void 0;
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function () { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (this && this.__exportStar) || function (m, exports) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
                __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.api = void 0;
    __exportStar(lib_shared_1, exports);
    exports.api = api;
});
define("build/api/schema/api/client", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-client/index", "build/api/schema/api/index"], function (require, exports, autoguard, shared) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeClient = void 0;
    const makeClient = (clientOptions) => ({
        "POST:/auth/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["POST:/auth/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "POST";
            let components = new Array();
            components.push("auth");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...[], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeHeaderPairs("x-circus-username", [request.headers?.["x-circus-username"]], true));
            headers.push(...autoguard.api.encodeHeaderPairs("x-circus-password", [request.headers?.["x-circus-password"]], true));
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/octet-stream"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers["x-circus-token"] = autoguard.api.decodeHeaderValue(raw.headers, "x-circus-token", true);
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = raw.payload;
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["POST:/auth/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, true);
            }
        },
        "POST:/users/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["POST:/users/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "POST";
            let components = new Array();
            components.push("users");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...[], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = autoguard.api.serializePayload(request.payload);
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["POST:/users/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("cues", [request.options?.["cues"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/actors/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("actors");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/actors/<actor_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<actor_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("actors");
            components.push(...autoguard.api.encodeComponents([request.options?.["actor_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["actor_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<actor_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/actors/<actor_id>/movies/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<actor_id>/movies/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("actors");
            components.push(...autoguard.api.encodeComponents([request.options?.["actor_id"]], true));
            components.push("movies");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["actor_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<actor_id>/movies/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/actors/<actor_id>/shows/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<actor_id>/shows/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("actors");
            components.push(...autoguard.api.encodeComponents([request.options?.["actor_id"]], true));
            components.push("shows");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["actor_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<actor_id>/shows/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/albums/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/albums/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("albums");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/albums/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getNewAlbums": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getNewAlbums"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("albums");
            components.push("new");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...[], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getNewAlbums"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/albums/<album_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/albums/<album_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("albums");
            components.push(...autoguard.api.encodeComponents([request.options?.["album_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["album_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/albums/<album_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getAlbumDiscs": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getAlbumDiscs"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("albums");
            components.push(...autoguard.api.encodeComponents([request.options?.["album_id"]], true));
            components.push("discs");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["album_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getAlbumDiscs"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getAlbumContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getAlbumContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("albums");
            components.push(...autoguard.api.encodeComponents([request.options?.["album_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["album_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getAlbumContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/artists/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/artists/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("artists");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/artists/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/artists/<artist_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/artists/<artist_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("artists");
            components.push(...autoguard.api.encodeComponents([request.options?.["artist_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["artist_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/artists/<artist_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getArtistAlbums": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getArtistAlbums"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("artists");
            components.push(...autoguard.api.encodeComponents([request.options?.["artist_id"]], true));
            components.push("albums");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["artist_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getArtistAlbums"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getArtistContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getArtistContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("artists");
            components.push(...autoguard.api.encodeComponents([request.options?.["artist_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["artist_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getArtistContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/discs/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/discs/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("discs");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/discs/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/discs/<disc_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/discs/<disc_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("discs");
            components.push(...autoguard.api.encodeComponents([request.options?.["disc_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["disc_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/discs/<disc_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getDiscTracks": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getDiscTracks"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("discs");
            components.push(...autoguard.api.encodeComponents([request.options?.["disc_id"]], true));
            components.push("tracks");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["disc_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getDiscTracks"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getDiscContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getDiscContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("discs");
            components.push(...autoguard.api.encodeComponents([request.options?.["disc_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["disc_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getDiscContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/episodes/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/episodes/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("episodes");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/episodes/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/episodes/<episode_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/episodes/<episode_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("episodes");
            components.push(...autoguard.api.encodeComponents([request.options?.["episode_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["episode_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/episodes/<episode_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getEpisodeContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getEpisodeContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("episodes");
            components.push(...autoguard.api.encodeComponents([request.options?.["episode_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["episode_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getEpisodeContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/genres/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("genres");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/genres/<genre_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<genre_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("genres");
            components.push(...autoguard.api.encodeComponents([request.options?.["genre_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["genre_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<genre_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/genres/<genre_id>/movies/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<genre_id>/movies/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("genres");
            components.push(...autoguard.api.encodeComponents([request.options?.["genre_id"]], true));
            components.push("movies");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["genre_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<genre_id>/movies/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/genres/<genre_id>/shows/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<genre_id>/shows/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("genres");
            components.push(...autoguard.api.encodeComponents([request.options?.["genre_id"]], true));
            components.push("shows");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["genre_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<genre_id>/shows/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/categories/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/categories/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("categories");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/categories/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/categories/<category_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/categories/<category_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("categories");
            components.push(...autoguard.api.encodeComponents([request.options?.["category_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["category_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/categories/<category_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/categories/<category_id>/albums/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/categories/<category_id>/albums/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("categories");
            components.push(...autoguard.api.encodeComponents([request.options?.["category_id"]], true));
            components.push("albums");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["category_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/categories/<category_id>/albums/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/movies/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/movies/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("movies");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/movies/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getNewMovies": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getNewMovies"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("movies");
            components.push("new");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...[], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getNewMovies"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/movies/<movie_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/movies/<movie_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("movies");
            components.push(...autoguard.api.encodeComponents([request.options?.["movie_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["movie_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/movies/<movie_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/movies/<movie_id>/suggestions/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/movies/<movie_id>/suggestions/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("movies");
            components.push(...autoguard.api.encodeComponents([request.options?.["movie_id"]], true));
            components.push("suggestions");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["movie_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/movies/<movie_id>/suggestions/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getMovieContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getMovieContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("movies");
            components.push(...autoguard.api.encodeComponents([request.options?.["movie_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["movie_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getMovieContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getMovieActors": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getMovieActors"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("movies");
            components.push(...autoguard.api.encodeComponents([request.options?.["movie_id"]], true));
            components.push("actors");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["movie_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getMovieActors"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/playlists/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/playlists/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("playlists");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/playlists/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/playlists/<playlist_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/playlists/<playlist_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("playlists");
            components.push(...autoguard.api.encodeComponents([request.options?.["playlist_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["playlist_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/playlists/<playlist_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getPlaylistItems": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getPlaylistItems"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("playlists");
            components.push(...autoguard.api.encodeComponents([request.options?.["playlist_id"]], true));
            components.push("items");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["playlist_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getPlaylistItems"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getPlaylistContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getPlaylistContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("playlists");
            components.push(...autoguard.api.encodeComponents([request.options?.["playlist_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["playlist_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getPlaylistContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/seasons/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/seasons/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("seasons");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/seasons/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/seasons/<season_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/seasons/<season_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("seasons");
            components.push(...autoguard.api.encodeComponents([request.options?.["season_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["season_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/seasons/<season_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getSeasonEpisodes": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getSeasonEpisodes"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("seasons");
            components.push(...autoguard.api.encodeComponents([request.options?.["season_id"]], true));
            components.push("episodes");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["season_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getSeasonEpisodes"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getSeasonContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getSeasonContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("seasons");
            components.push(...autoguard.api.encodeComponents([request.options?.["season_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["season_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getSeasonContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/shows/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/shows/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("shows");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/shows/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/shows/<show_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/shows/<show_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("shows");
            components.push(...autoguard.api.encodeComponents([request.options?.["show_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["show_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/shows/<show_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getShowSeasons": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getShowSeasons"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("shows");
            components.push(...autoguard.api.encodeComponents([request.options?.["show_id"]], true));
            components.push("seasons");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["show_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getShowSeasons"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getShowContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getShowContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("shows");
            components.push(...autoguard.api.encodeComponents([request.options?.["show_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["show_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getShowContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getShowActors": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getShowActors"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("shows");
            components.push(...autoguard.api.encodeComponents([request.options?.["show_id"]], true));
            components.push("actors");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["show_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getShowActors"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/tracks/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/tracks/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("tracks");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/tracks/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/tracks/<track_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/tracks/<track_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("tracks");
            components.push(...autoguard.api.encodeComponents([request.options?.["track_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["track_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/tracks/<track_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/tracks/<track_id>/playlists/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/tracks/<track_id>/playlists/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("tracks");
            components.push(...autoguard.api.encodeComponents([request.options?.["track_id"]], true));
            components.push("playlists");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["track_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/tracks/<track_id>/playlists/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getTrackContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getTrackContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("tracks");
            components.push(...autoguard.api.encodeComponents([request.options?.["track_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["track_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getTrackContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/users/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("users");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/users/<user_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("users");
            components.push(...autoguard.api.encodeComponents([request.options?.["user_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["user_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/users/<user_id>/albums/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/albums/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("users");
            components.push(...autoguard.api.encodeComponents([request.options?.["user_id"]], true));
            components.push("albums");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["user_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/albums/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getUserArtists": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getUserArtists"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("users");
            components.push(...autoguard.api.encodeComponents([request.options?.["user_id"]], true));
            components.push("artists");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["user_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getUserArtists"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/users/<user_id>/playlists/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/playlists/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("users");
            components.push(...autoguard.api.encodeComponents([request.options?.["user_id"]], true));
            components.push("playlists");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["user_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/playlists/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/users/<user_id>/shows/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/shows/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("users");
            components.push(...autoguard.api.encodeComponents([request.options?.["user_id"]], true));
            components.push("shows");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["user_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/shows/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/years/<query>": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<query>"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("years");
            components.push(...autoguard.api.encodeComponents([request.options?.["query"]], true));
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["query"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<query>"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/years/<year_id>/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<year_id>/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("years");
            components.push(...autoguard.api.encodeComponents([request.options?.["year_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["year_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<year_id>/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/years/<year_id>/albums/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<year_id>/albums/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("years");
            components.push(...autoguard.api.encodeComponents([request.options?.["year_id"]], true));
            components.push("albums");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["year_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<year_id>/albums/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "GET:/years/<year_id>/movies/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<year_id>/movies/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("years");
            components.push(...autoguard.api.encodeComponents([request.options?.["year_id"]], true));
            components.push("movies");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["year_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<year_id>/movies/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getYearContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getYearContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("years");
            components.push(...autoguard.api.encodeComponents([request.options?.["year_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["year_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getYearContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getDirectory": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getDirectory"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("directories");
            components.push(...autoguard.api.encodeComponents([request.options?.["directory_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["directory_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getDirectory"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getDirectoryDirectories": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getDirectoryDirectories"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("directories");
            components.push(...autoguard.api.encodeComponents([request.options?.["directory_id"]], true));
            components.push("directories");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["directory_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getDirectoryDirectories"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getDirectoryFiles": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getDirectoryFiles"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("directories");
            components.push(...autoguard.api.encodeComponents([request.options?.["directory_id"]], true));
            components.push("files");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("anchor", [request.options?.["anchor"]], true));
            parameters.push(...autoguard.api.encodeParameterPairs("offset", [request.options?.["offset"]], false));
            parameters.push(...autoguard.api.encodeParameterPairs("limit", [request.options?.["limit"]], false));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["directory_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getDirectoryFiles"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getDirectoryContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getDirectoryContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("directories");
            components.push(...autoguard.api.encodeComponents([request.options?.["directory_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["directory_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getDirectoryContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getFile": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getFile"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("files");
            components.push(...autoguard.api.encodeComponents([request.options?.["file_id"]], true));
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["file_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getFile"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getFileContext": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getFileContext"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("files");
            components.push(...autoguard.api.encodeComponents([request.options?.["file_id"]], true));
            components.push("context");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["file_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getFileContext"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
        "getFileContent": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getFileContent"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("files");
            components.push(...autoguard.api.encodeComponents([request.options?.["file_id"]], true));
            components.push("content");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...["file_id"], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/octet-stream"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = raw.payload;
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getFileContent"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, true);
            }
        },
        "GET:/statistics/": async (request) => {
            let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/statistics/"], clientOptions?.debugMode);
            guard.as(request, "request");
            let method = "GET";
            let components = new Array();
            components.push("statistics");
            components.push("");
            let parameters = new Array();
            parameters.push(...autoguard.api.encodeParameterPairs("token", [request.options?.["token"]], true));
            parameters.push(...autoguard.api.encodeUndeclaredParameterPairs(request.options ?? {}, [...[], ...parameters.map((parameter) => parameter[0])]));
            let headers = new Array();
            headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(request.headers ?? {}, headers.map((header) => header[0])));
            let payload = request.payload ?? [];
            let requestHandler = clientOptions?.requestHandler ?? autoguard.api.xhr;
            let defaultHeaders = clientOptions?.defaultHeaders?.slice() ?? [];
            defaultHeaders.push(["Content-Type", "application/octet-stream"]);
            defaultHeaders.push(["Accept", "application/json; charset=utf-8"]);
            let raw = await requestHandler(autoguard.api.finalizeRequest({ method, components, parameters, headers, payload }, defaultHeaders), clientOptions);
            {
                let status = raw.status;
                let headers = {};
                headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                let payload = await autoguard.api.deserializePayload(raw.payload);
                let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/statistics/"], clientOptions?.debugMode);
                let response = guard.as({ status, headers, payload }, "response");
                return new autoguard.api.ServerResponse(response, false);
            }
        },
    });
    exports.makeClient = makeClient;
});
define("build/client/client", ["require", "exports", "build/client/browserMediaSession", "build/observers/index", "build/player/client", "build/is", "build/player/schema/objects/index", "build/api/schema/objects/index", "build/xnode/index", "build/ui/metadata/index", "build/api/schema/index", "build/ui/EntityTitleFactory", "build/ui/Grid", "build/ui/CarouselFactory", "build/ui/Icon", "build/ui/ImageBox", "build/ui/EntityLink", "build/ui/EntityCard", "build/ui/EntityRow", "build/ui/PlaybackButton", "build/ui/EntityNavLinkFactory", "build/playlists/client", "build/api/schema/api/client", "build/utils", "build/api/schema/api/index"], function (require, exports, session, observers_1, client, is, objects_1, objects_2, xml, metadata_1, apischema, EntityTitleFactory_1, Grid_1, CarouselFactory_1, Icon_1, ImageBox_1, EntityLink_1, EntityCard_1, EntityRow_1, PlaybackButton_1, EntityNavLinkFactory_1, client_1, apiv2, utils, api_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    const apiclient = apiv2.makeClient({ urlPrefix: "/api" });
    function makeUrl(tail) {
        let path = `/sockets/${tail}`;
        let protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        let host = window.location.host;
        return `${protocol}//${host}${path}`;
    }
    let did = utils.generateHexId(16);
    let player = new client.ContextClient(makeUrl(`context/?type=browser&name=Client&did=${did}&enabled=false`));
    let playlists = new client_1.PlaylistsClient(makeUrl(`playlists/`));
    window.addEventListener("focus", () => {
        if (!player.isOnline.getState()) {
            player.reconnect();
        }
        if (!playlists.isOnline()) {
            playlists.reconnect();
        }
    });
    function hideModalMenu() {
        showDevices.updateState(false);
        showContextMenu.updateState(false);
        showPage.updateState(false);
        modalPageElements.update([]);
        showModal.updateState(undefined);
    }
    window.addEventListener("keydown", (event) => {
        if (event.code === "Space") {
            if (event.target instanceof HTMLInputElement) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            player.togglePlayback();
        }
        else if (event.code === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            hideModalMenu();
        }
    });
    // Attach a mousedown listener to the body element in order to trigger the listener before all click handlers.
    let videoElementMayBeLocked = new observers_1.ObservableClass(true);
    function setupVideoElementUnlocker(element) {
        if (!videoElementMayBeLocked.getState()) {
            return;
        }
        async function unlock(event) {
            event.stopPropagation();
            event.preventDefault();
            document.body.removeEventListener("mousedown", unlock);
            // The source needs to have a duration greater than 0ms in order for "ended" to fire properly on Safari for IOS.
            element.src = "data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAAAwAAAbAAqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV////////////////////////////////////////////AAAAAExhdmM1OC4xMwAAAAAAAAAAAAAAACQDkAAAAAAAAAGw9wrNaQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+MYxAAAAANIAAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDsAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxHYAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV";
            element.addEventListener("ended", function ended() {
                element.removeEventListener("ended", ended);
                videoElementMayBeLocked.updateState(false);
            });
            await element.play();
        }
        document.body.addEventListener("mousedown", unlock, false);
    }
    ;
    let lastVideo = document.createElement("video");
    let currentVideo = document.createElement("video");
    let nextVideo = document.createElement("video");
    setupVideoElementUnlocker(currentVideo);
    let canCurrentVideoSeek = new observers_1.ObservableClass(false);
    let canCurrentVideoPlay = new observers_1.ObservableClass(false);
    let videoEventLog = new observers_1.ArrayObservable([]);
    videoElementMayBeLocked.addObserver((videoElementMayBeLocked) => {
        if (videoElementMayBeLocked) {
            return;
        }
        player.enable();
        // @ts-ignore
        player.tsc.url = makeUrl(`context/?type=browser&name=Client&did=${did}&enabled=true`);
        currentVideo.addEventListener("loadstart", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "loadstart" });
        });
        currentVideo.addEventListener("durationchange", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "durationchange" });
            session.update();
            canCurrentVideoSeek.updateState(true);
        });
        currentVideo.addEventListener("loadedmetadata", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "loadedmetadata" });
        });
        currentVideo.addEventListener("loadeddata", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "loadeddata" });
        });
        currentVideo.addEventListener("canplay", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "canplay" });
        });
        currentVideo.addEventListener("canplaythrough", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "canplaythrough" });
            canCurrentVideoPlay.updateState(true);
        });
        currentVideo.addEventListener("waiting", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "waiting" });
            canCurrentVideoPlay.updateState(false);
            player.setPlaying(false);
        });
        currentVideo.addEventListener("stalled", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "stalled" });
        });
        currentVideo.addEventListener("suspend", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "suspend" });
        });
        currentVideo.addEventListener("seeking", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "seeking" });
        });
        currentVideo.addEventListener("seeked", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "seeked" });
        });
        currentVideo.addEventListener("play", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "play" });
            player.play();
        });
        currentVideo.addEventListener("playing", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "playing" });
            player.isCurrentEntryVideo.updateState(currentVideo.videoWidth > 0 && currentVideo.videoHeight > 0);
            player.setPlaying(true);
        });
        currentVideo.addEventListener("pause", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "pause" });
            player.setPlaying(false);
            // Ignore the pause event emitted just before the "ended" event in order not to disrupt auto playback.
            if (currentVideo.currentTime < currentVideo.duration) {
                player.pause();
            }
        });
        currentVideo.addEventListener("ended", () => {
            videoEventLog.append({ timestamp: Date.now(), type: "ended" });
            player.next();
        });
        currentVideo.addEventListener("error", (event) => {
            videoEventLog.append({ timestamp: Date.now(), type: "error" });
            if (player.currentLocalEntry.getState() != null) {
                player.pause();
            }
        });
        currentVideo.addEventListener("emptied", (event) => {
            videoEventLog.append({ timestamp: Date.now(), type: "emptied" });
        });
        {
            let computer = () => {
                if (canCurrentVideoSeek.getState()) {
                    currentVideo.currentTime = player.progress.getState() ?? 0;
                }
            };
            canCurrentVideoSeek.addObserver(computer);
            player.progress.addObserver(computer);
        }
        {
            let computer = async () => {
                if (canCurrentVideoPlay.getState()) {
                    if (player.playback.getState()) {
                        await currentVideo.play();
                    }
                    else {
                        currentVideo.pause();
                    }
                }
            };
            // The computer will not be awaited by ObservableClass since it doesn't handle async observers. This may throw errors when play() is interrupted.
            canCurrentVideoPlay.addObserver(computer);
            player.playback.addObserver(computer);
        }
        {
            let computer = () => {
                let canPlayLast = player.canPlayLast.getState();
                let canPlayCurrent = player.canPlayCurrent.getState();
                let canPlayNext = player.canPlayNext.getState();
                session.setHandlers({
                    play: canPlayCurrent ? player.resume.bind(player) : null,
                    pause: canPlayCurrent ? player.pause.bind(player) : null,
                    previoustrack: canPlayLast ? player.last.bind(player) : null,
                    seekto: canPlayCurrent ? (details) => {
                        player.seek(details.seekTime ?? undefined);
                    } : null,
                    nexttrack: canPlayNext ? player.next.bind(player) : null
                });
            };
            player.canPlayLast.addObserver(computer);
            player.canPlayCurrent.addObserver(computer);
            player.canPlayNext.addObserver(computer);
        }
        let mediaPlayerTitle = new observers_1.ObservableClass(""); // not used
        let mediaPlayerSubtitle = new observers_1.ObservableClass(""); // not used
        player.currentEntry.addObserver((currentEntry) => {
            if (is.present(currentEntry)) {
                if (objects_2.Episode.is(currentEntry)) {
                    let episode = currentEntry;
                    let season = episode.season;
                    let show = season.show;
                    mediaPlayerTitle.updateState(episode.title);
                    mediaPlayerSubtitle.updateState([show.title, `Season ${episode.season.number}`].join(" \u00b7 "));
                    session.setMetadata({
                        title: episode.title
                    });
                }
                else if (objects_2.Movie.is(currentEntry)) {
                    let movie = currentEntry;
                    mediaPlayerTitle.updateState(movie.title);
                    mediaPlayerSubtitle.updateState(movie.genres.map((genre) => genre.title).join(" \u00b7 "));
                    session.setMetadata({
                        title: movie.title,
                        artwork: movie.artwork.map((image) => ({
                            src: `/api/files/${image.file_id}/content/?token=${token}`,
                            sizes: `${image.width}x${image.height}`,
                            type: image.mime
                        }))
                    });
                }
                else if (objects_2.Track.is(currentEntry)) {
                    let track = currentEntry;
                    let disc = track.disc;
                    let album = disc.album;
                    mediaPlayerTitle.updateState(track.title);
                    mediaPlayerSubtitle.updateState([...track.artists.map((artist) => artist.title), track.disc.album.title].join(" \u00b7 "));
                    session.setMetadata({
                        title: track.title,
                        artist: track.artists.map((artist) => artist.title).join(" \u00b7 "),
                        album: album.title,
                        artwork: album.artwork.map((image) => ({
                            src: `/api/files/${image.file_id}/content/?token=${token}`,
                            sizes: `${image.width}x${image.height}`,
                            type: image.mime
                        }))
                    });
                }
                else if (objects_1.ContextFile.is(currentEntry)) {
                    let file = currentEntry;
                    mediaPlayerTitle.updateState(file.name);
                    mediaPlayerSubtitle.updateState([
                        currentEntry.parent?.name
                    ].filter((string) => string != null).join(" \u00b7 "));
                    session.setMetadata({
                        title: file.name
                    });
                }
                else {
                    throw `Expected code to be unreachable!`;
                }
            }
            else {
                mediaPlayerTitle.updateState("");
                mediaPlayerSubtitle.updateState("");
                session.setMetadata({});
            }
        });
        {
            let computer = () => {
                let lastLocalEntry = player.lastLocalEntry.getState();
                let token = player.token.getState();
                if (is.absent(lastLocalEntry) || is.absent(token)) {
                    lastVideo.src = ``;
                    return;
                }
                else {
                    lastVideo.src = `/api/files/${lastLocalEntry.media.file_id}/content/?token=${token}`;
                }
            };
            player.lastLocalEntry.addObserver(computer);
            player.token.addObserver(computer);
        }
        {
            let computer = () => {
                canCurrentVideoPlay.updateState(false);
                canCurrentVideoSeek.updateState(false);
                let currentLocalEntry = player.currentLocalEntry.getState();
                let token = player.token.getState();
                while (is.present(currentVideo.lastChild)) {
                    currentVideo.removeChild(currentVideo.lastChild);
                }
                if (is.absent(currentLocalEntry) || is.absent(token)) {
                    videoEventLog.append({ timestamp: Date.now(), type: `file_id: ""` });
                    currentVideo.src = ``;
                    return;
                }
                else {
                    videoEventLog.append({ timestamp: Date.now(), type: `file_id: "${currentLocalEntry.media.file_id}"` });
                    currentVideo.src = `/api/files/${currentLocalEntry.media.file_id}/content/?token=${token}`;
                    currentVideo.load();
                }
                if (objects_2.Movie.is(currentLocalEntry) || objects_2.Episode.is(currentLocalEntry)) {
                    let subtitles = currentLocalEntry.subtitles;
                    let defaultSubtitle = subtitles.find((subtitle) => subtitle.language?.iso_639_2 === "swe") ?? subtitles.find((subtitle) => subtitle.language?.iso_639_2 === "eng") ?? subtitles.find((subtitle) => true);
                    for (let subtitle of subtitles) {
                        let element = document.createElement("track");
                        element.src = `/api/files/${subtitle.file_id}/content/?token=${token}`;
                        if (is.present(subtitle.language)) {
                            element.label = subtitle.language.name;
                            element.srclang = subtitle.language.iso_639_1;
                            element.kind = "subtitles";
                        }
                        if (subtitle === defaultSubtitle) {
                            element.setAttribute("default", "");
                        }
                        currentVideo.appendChild(element);
                    }
                }
            };
            player.currentLocalEntry.addObserver(computer);
            player.token.addObserver(computer);
        }
        {
            let computer = () => {
                let nextLocalEntry = player.nextLocalEntry.getState();
                let token = player.token.getState();
                if (is.absent(nextLocalEntry) || is.absent(token)) {
                    nextVideo.src = ``;
                    return;
                }
                else {
                    nextVideo.src = `/api/files/${nextLocalEntry.media.file_id}/content/?token=${token}`;
                }
            };
            player.nextLocalEntry.addObserver(computer);
            player.token.addObserver(computer);
        }
    });
    const savedToken = new observers_1.ObservableClass(localStorage.getItem("token") ?? undefined);
    const verifiedToken = new observers_1.ObservableClass(undefined);
    savedToken.addObserver((savedToken) => {
        if (is.present(savedToken)) {
            localStorage.setItem("token", savedToken);
        }
        else {
            localStorage.removeItem("token");
        }
    });
    savedToken.addObserver(async (savedToken) => {
        if (is.present(savedToken)) {
            try {
                let response = await apiclient["GET:/users/<user_id>/"]({
                    options: {
                        user_id: "",
                        token: savedToken
                    }
                });
                if (response.status() === 200) {
                    verifiedToken.updateState(savedToken);
                    return;
                }
            }
            catch (error) { }
        }
        verifiedToken.updateState(undefined);
    });
    const contextMenuEntity = new observers_1.ObservableClass(undefined);
    const Grid = new Grid_1.GridFactory();
    document.head.appendChild(Grid_1.GridFactory.makeStyle().render());
    const Icon = new Icon_1.IconFactory();
    document.head.appendChild(Icon_1.IconFactory.makeStyle().render());
    const carouselFactory = new CarouselFactory_1.CarouselFactory(Icon);
    document.head.appendChild(CarouselFactory_1.CarouselFactory.makeStyle().render());
    const PlaybackButton = new PlaybackButton_1.PlaybackButtonFactory(apiclient, player, Icon);
    document.head.appendChild(PlaybackButton_1.PlaybackButtonFactory.makeStyle().render());
    const ImageBox = new ImageBox_1.ImageBoxFactory(verifiedToken);
    document.head.appendChild(ImageBox_1.ImageBoxFactory.makeStyle().render());
    const EntityLink = new EntityLink_1.EntityLinkFactory(navigate, contextMenuEntity);
    document.head.appendChild(EntityLink_1.EntityLinkFactory.makeStyle().render());
    const entityTitleFactory = new EntityTitleFactory_1.EntityTitleFactory(EntityLink);
    document.head.appendChild(EntityTitleFactory_1.EntityTitleFactory.makeStyle().render());
    const EntityCard = new EntityCard_1.EntityCardFactory(entityTitleFactory, EntityLink, ImageBox, PlaybackButton);
    document.head.appendChild(EntityCard_1.EntityCardFactory.makeStyle().render());
    const EntityRow = new EntityRow_1.EntityRowFactory(entityTitleFactory, EntityLink, ImageBox, PlaybackButton);
    document.head.appendChild(EntityRow_1.EntityRowFactory.makeStyle().render());
    const entityNavLinkFactory = new EntityNavLinkFactory_1.EntityNavLinkFactory(Icon, EntityLink);
    document.head.appendChild(EntityNavLinkFactory_1.EntityNavLinkFactory.makeStyle().render());
    const showContextMenu = new observers_1.ObservableClass(false);
    const contextMenuItems = new observers_1.ArrayObservable(new Array());
    contextMenuEntity.addObserver(async (contextMenuEntity) => {
        contextMenuItems.update([]);
        if (apischema.objects.Entity.is(contextMenuEntity)) {
            contextMenuItems.append(xml.element("div")
                .set("style", "align-items: center; display: grid; gap: 16px; grid-template-columns: 1fr min-content;")
                .add(renderTextHeader(xml.text("Select action")))
                .add(makeButton()
                .on("click", () => {
                showContextMenu.updateState(false);
            })
                .add(Icon.makeCross())));
            contextMenuItems.append(EntityRow.forEntity(contextMenuEntity));
        }
        if (apischema.objects.Track.is(contextMenuEntity)) {
            let title = new observers_1.ObservableClass("");
            let canCreate = (0, observers_1.computed)((title) => {
                if (title === "") {
                    return false;
                }
                return true;
            }, title);
            let doCreate = async () => {
                if (canCreate.getState()) {
                    let playlist = await playlists.createPlaylist({
                        playlist: {
                            title: title.getState(),
                            description: ""
                        }
                    });
                    if (playlist.errors.length > 0) {
                        return;
                    }
                    let playlist_item = await playlists.createPlaylistItem({
                        playlist_item: {
                            playlist_id: playlist.playlist_id,
                            track_id: contextMenuEntity.track_id
                        }
                    });
                    if (playlist_item.errors.length > 0) {
                        return;
                    }
                    showContextMenu.updateState(false);
                }
            };
            contextMenuItems.append(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .add(xml.element("div")
                .set("style", "position: relative;")
                .add(xml.element("input")
                .bind2("value", title)
                .set("type", "text")
                .set("spellcheck", "false")
                .set("placeholder", "Title...")
                .on("keyup", async (event) => {
                if (event.code === "Enter") {
                    event.target.blur();
                    await doCreate();
                }
            }))
                .add(Icon.makeStar()
                .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
                .add(xml.element("button")
                .bind2("data-enabled", (0, observers_1.computed)((canCreate) => "" + canCreate, canCreate))
                .add(xml.text("New playlist"))
                .on("click", async () => {
                await doCreate();
            })));
            contextMenuItems.append(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .bind("data-hide", playlists.playlists.compute((playlists) => playlists.length === 0))
                .repeat(playlists.playlists, (playlist) => xml.element("button")
                .add(xml.text(`Add to "${playlist.getState().title}"`))
                .on("click", async () => {
                let playlist_item = await playlists.createPlaylistItem({
                    playlist_item: {
                        playlist_id: playlist.getState().playlist_id,
                        track_id: contextMenuEntity.track_id
                    }
                });
                if (playlist_item.errors.length > 0) {
                    return;
                }
                showContextMenu.updateState(false);
            })));
        }
        else if (apischema.objects.Playlist.is(contextMenuEntity)) {
            let hasWritePermission = (await playlists.getPermissions({
                playlist: {
                    playlist_id: contextMenuEntity.playlist_id
                }
            })).permissions === "write";
            let title = new observers_1.ObservableClass(contextMenuEntity.title);
            let description = new observers_1.ObservableClass(contextMenuEntity.description);
            let canUpdate = (0, observers_1.computed)((title, description) => {
                if (title === "") {
                    return false;
                }
                return true;
            }, title, description);
            let doUpdate = async () => {
                if (canUpdate.getState()) {
                    let playlist = await playlists.updatePlaylist({
                        playlist: {
                            playlist_id: contextMenuEntity.playlist_id,
                            title: title.getState(),
                            description: description.getState()
                        }
                    });
                    if (playlist.errors.length > 0) {
                        return;
                    }
                    showContextMenu.updateState(false);
                }
            };
            contextMenuItems.append(xml.element("div")
                .set("data-hide", `${!hasWritePermission}`)
                .set("style", "display: grid; gap: 16px;")
                .add(xml.element("div")
                .set("style", "position: relative;")
                .add(xml.element("input")
                .bind2("value", title)
                .set("type", "text")
                .set("spellcheck", "false")
                .set("placeholder", "Title..."))
                .add(Icon.makeStar()
                .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
                .add(xml.element("div")
                .set("style", "position: relative;")
                .add(xml.element("input")
                .bind2("value", description)
                .set("type", "text")
                .set("spellcheck", "false")
                .set("placeholder", "Description..."))
                .add(Icon.makeStar()
                .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
                .add(xml.element("button")
                .bind2("data-enabled", (0, observers_1.computed)((canUpdate) => "" + canUpdate, canUpdate))
                .add(xml.text("Update playlist"))
                .on("click", async () => {
                await doUpdate();
            })));
            contextMenuItems.append(xml.element("button")
                .add(xml.text("Delete playlist"))
                .on("click", async () => {
                let response = await playlists.deletePlaylist({
                    playlist: {
                        playlist_id: contextMenuEntity.playlist_id
                    }
                });
                if (response.errors.length > 0) {
                    return;
                }
                showContextMenu.updateState(false);
            }));
        }
        else if (apischema.objects.Movie.is(contextMenuEntity)) {
            let imdb = contextMenuEntity.imdb;
            if (is.present(imdb)) {
                contextMenuItems.append(xml.element("button")
                    .add(xml.text("IMDB"))
                    .on("click", async () => {
                    window.open(`https://www.imdb.com/title/${imdb}`);
                    showContextMenu.updateState(false);
                }));
            }
        }
        else if (apischema.objects.Show.is(contextMenuEntity)) {
            let imdb = contextMenuEntity.imdb;
            if (is.present(imdb)) {
                contextMenuItems.append(xml.element("button")
                    .add(xml.text("IMDB"))
                    .on("click", async () => {
                    window.open(`https://www.imdb.com/title/${imdb}`);
                    showContextMenu.updateState(false);
                }));
            }
        }
        else if (apischema.objects.Episode.is(contextMenuEntity)) {
            let imdb = contextMenuEntity.imdb;
            if (is.present(imdb)) {
                contextMenuItems.append(xml.element("button")
                    .add(xml.text("IMDB"))
                    .on("click", async () => {
                    window.open(`https://www.imdb.com/title/${imdb}`);
                    showContextMenu.updateState(false);
                }));
            }
        }
        else if (apischema.objects.Artist.is(contextMenuEntity)) {
            let tidal = contextMenuEntity.tidal;
            if (is.present(tidal)) {
                contextMenuItems.append(xml.element("button")
                    .add(xml.text("TIDAL"))
                    .on("click", async () => {
                    window.open(`https://listen.tidal.com/artist/${tidal}/`);
                    showContextMenu.updateState(false);
                }));
            }
        }
        else if (apischema.objects.Album.is(contextMenuEntity)) {
            let tidal = contextMenuEntity.tidal;
            if (is.present(tidal)) {
                contextMenuItems.append(xml.element("button")
                    .add(xml.text("TIDAL"))
                    .on("click", async () => {
                    window.open(`https://listen.tidal.com/album/${tidal}/`);
                    showContextMenu.updateState(false);
                }));
            }
        }
        showContextMenu.updateState(contextMenuItems.getState().length > 0);
    });
    const ACCENT_COLOR = "rgb(223, 79, 127)";
    let style = document.createElement('style');
    style.innerText = `
	::-webkit-scrollbar {
		background-color: transparent;
		height: 8px;
		width: 8px;
	}

	::-webkit-scrollbar-corner {
		background-color: transparent;
	}

	::-webkit-scrollbar-thumb {
		background-color: rgba(255, 255, 255, 0.125);
		border-radius: 4px;
	}

	* {
		border: none;
		font-size: 0px;
		margin: 0px;
		line-height: 1;
		outline: none;
		padding: 0px;
	}

	a,
	span {
		color: inherit;
		font-size: inherit;
	}

	a {
		text-decoration: none;
		transition: color 0.125s;
	}

	@media (hover: hover) and (pointer: fine) {
		a:hover {
			color: rgb(255, 255, 255);
		}
	}

	html {
		height: 100%;
	}

	body {
		height: 100%;
	}

	.page-header {
		align-items: center;
		display: grid;
		gap: 16px;
		grid-template-columns: 1fr auto;
	}

	.page-header__title {
		color: rgb(255, 255, 255);
		cursor: pointer;
		font-family: "Pacifico", cursive;
		font-size: 32px;
		transform-origin: left;
		transition: transform 0.125s;
		white-space: nowrap;
	}

	.page-header__controls {
		display: grid;
		gap: 8px;
		grid-auto-columns: minmax(auto, min-content);
		grid-auto-flow: column;
	}

	@media (hover: hover) and (pointer: fine) {
		.page-header__title:hover {
			transform: scale(1.25);
		}
	}

	[data-hide="true"] {
		display: none !important;
	}

	body {
		background-color: ${ACCENT_COLOR};
		color: rgb(255, 255, 255);
		font-family: "Nunito", sans-serif;
		overflow: hidden;
		touch-callout: none;
			-webkit-touch-callout: none;
			-moz-touch-callout: none;
			-ms-touch-callout: none;
			-o-touch-callout: none;
		user-select: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			-o-user-select: none;
	}

	body ::selection {
		background-color: ${ACCENT_COLOR};
		color: rgb(255, 255, 255);
	}

	button {
		background-color: ${ACCENT_COLOR};
		border-radius: 64px;
		color: rgb(255, 255, 255);
		cursor: pointer;
		font-size: 16px;
		overflow: hidden;
		padding: 8px 16px;
		text-overflow: ellipsis;
		transition: background-color 0.125s, color 0.125s;
		white-space: nowrap;
	}

	button[data-enabled="false"] {
		background-color: rgb(79, 79, 79);
		color: rgb(159, 159, 159);
		cursor: default;
	}

	@media (hover: hover) and (pointer: fine) {
		button:not([data-enabled="false"]):hover {
			background-color: rgb(255, 255, 255);
			color: rgb(31, 31, 31);
		}

		button:active {
			transform: none;
		}
	}

	input {
		background-color: rgb(47, 47, 47);
		border-radius: 64px;
		box-sizing: border-box;
		color: rgb(255, 255, 255);
		font-size: 16px;
		padding: 8px 16px 8px 32px;
		width: 100%;
	}















	.slider-widget {
		padding: 4px;
	}

	.slider-widget__indicator {
		padding: 4px;
		border-radius: 4px;
		background-color: rgb(31, 31, 31);
	}

	.slider-widget__knob-wrapper {
		position: relative;
	}

	.slider-widget__knob {
		box-shadow: 0px 0px 8px 0px rgba(0, 0, 0, 0.5);
		width: 16px;
		height: 16px;
		border-radius: 50%;
		background-color: rgb(255, 255, 255);
		position: absolute;
		top: 0%;
		left: 0%;
		margin-top: -8px;
		margin-left: -8px;
	}



























	.content {
		box-sizing: border-box;
		display: grid;
		gap: 48px;
		margin: 0px auto;
		max-width: 1656px;
		padding: clamp(24px, 7.5vw, 48px);
	}

	.drawer-content {
		display: grid;
		gap: 48px;
		padding: 24px;
	}













	.text-header {
		color: rgb(255, 255, 255);
		font-size: 20px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.text-paragraph {
		color: rgb(159, 159, 159);
		font-size: 16px;
		line-height: 1.25;
		word-break: break-word;
	}












































	.login-modal {
		display: grid;
		gap: 48px;
	}

	.login-modal__form {
		display: grid;
		gap: 16px;
	}








	.modal-container {
		background-color: rgb(31, 31, 31);
		box-shadow: 0px 0px 8px 4px rgb(0, 0, 0, 0.25);
		height: 100%;
		position: absolute; bottom: 0px; right: 0px;
		width: min(320px, 100%);
		z-index: 1;
	}

	.modal-container[data-hide] {
		display: initial!important;
	}

	.modal-container[data-hide=false] {
		transform: none;
		transition: transform 0.5s;
	}

	.modal-container[data-hide=true] {
		transform: translate(100%, 0%);
		transition: none;
	}









	.device-selector {
		display: grid;
		gap: 48px;
	}

	.device-selector__devices {
		display: grid;
		gap: 16px;
	}

	.device-selector__device {
		align-items: center;
		display: grid;
		gap: 16px;
		grid-template-columns: min-content 1fr;
	}

	.device-selector__device-info {
		display: grid;
		gap: 8px;
	}

	.device-selector__device-name {
		color: rgb(255, 255, 255);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.device-selector__device-type {
		color: rgb(159, 159, 159);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}














	.media-player {
		display: grid;
		gap: 16px;
	}

	.media-player__top {
		align-items: center;
		display: grid;
		gap: 16px;
		grid-template-columns: 1fr min-content;
	}

	.media-player__metadata {
		cursor: pointer;
		display: grid;
		gap: 8px;
		height: 40px;
	}

	.media-player__title {
		color: rgb(255, 255, 255);
		font-size: 16px;
		height: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.media-player__subtitle {
		color: rgb(159, 159, 159);
		font-size: 16px;
		height: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.media-player__controls {
		align-items: center;
		display: grid;
		gap: 8px;
		grid-auto-columns: minmax(auto, min-content);
		grid-auto-flow: column;
	}

	.media-player__bottom {
		align-items: center;
		display: grid;
		gap: 16px;
		grid-template-columns: min-content auto min-content;
	}

	.media-player__progress {
		display: grid;
		gap: 4px;
	}

	.media-player__progress-bar {
		cursor: pointer;
		padding: 8px 0px;
	}

	.media-player__progress-container {
		background-color: rgb(31, 31, 31);
		border-radius: 4px;
		height: 8px;
		overflow: hidden;
		position: relative;
		z-index: 1;
	}

	.media-player__progress-track {
		background-color: ${ACCENT_COLOR};
		height: 100%;
		width: 100%;
		position: absolute;
		transform-origin: left;
		z-index: 0;
	}

	.media-player__progress-metadata {
		color: rgb(159, 159, 159);
		font-size: 12px;
		overflow: hidden;
		text-align: center;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.media-player .image-box {
		background-color: rgb(31, 31, 31);
	}




	.icon-button {
		background-color: rgb(255, 255, 255);
		border-radius: 50%;
		box-shadow: 0px 0px 8px 4px rgba(0, 0, 0, 0.25);
		cursor: pointer;
		fill: rgb(31, 31, 31);
		padding: 8px;
		transition: background-color 0.125s, fill 0.125s, transform 0.125s;
	}

	.icon-button[data-enabled="false"] {
		background-color: rgb(79, 79, 79);
		cursor: default;
	}

	.icon-button--flat {
		background-color: transparent!important;
		box-shadow: none;
		fill: rgb(255, 255, 255);
	}

	.icon-button--flat[data-enabled="false"] {
		fill: rgb(31, 31, 31);
	}

	.icon-button[data-active="true"] {
		background-color: ${ACCENT_COLOR};
		fill: rgb(255, 255, 255);
	}

	.icon-button--flat[data-active="false"] {
		fill: rgb(31, 31, 31);
	}

	.icon-button--flat[data-active="true"] {
		fill: ${ACCENT_COLOR};
	}

	@media (hover: hover) and (pointer: fine) {
		.icon-button:not([data-enabled="false"]):hover {
			transform: scale(1.50);
		}

		.icon-button:active {
			transform: none;
		}
	}











	.app {
		display: grid;
		height: 100%;
		position: relative;
	}

	.app__header {
		background-color: ${ACCENT_COLOR};
		box-shadow: 0px 0px 8px 4px rgba(0, 0, 0, 0.25);
		position: absolute;
			top: 0px;
			left: 0px;
			right: 0px;
		transition: transform 0.25s;
		z-index: 1;
	}

	.app__header[data-hide=true] {
		display: initial!important;
		transform: translate(0%, -100%);
	}

	.app__content {
		background-color: rgb(31, 31, 31);
		overflow: hidden;
		padding: 64px 0px 128px 0px;
		position: relative;
		z-index: 0;
	}

	.app__navigation {
		background-color: rgb(47, 47, 47);
		box-shadow: 0px 0px 8px 4px rgba(0, 0, 0, 0.25);
		position: absolute;
			bottom: 0px;
			left: 0px;
			right: 0px;
		transition: transform 0.25s;
		z-index: 1;
	}

	.app__navigation[data-hide=true] {
		display: initial!important;
		transform: translate(0%, 100%);
	}

	.app__message-bar {
		background-color: ${ACCENT_COLOR};
	}

	.app__video {
		background-color: rgb(0, 0, 0);
		height: 100%;
		position: absolute;
		width: 100%;
	}

	.offline-indicator {
		box-sizing: border-box;
		margin: 0px auto;
		max-width: 1656px;
		padding: 8px;
	}

	.offline-indicator__content {
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}





	.scroll-container {
		height: 100%;
		overflow-y: scroll;
		overflow-x: auto;
		width: 100%;
	}








	.statistic {
		display: grid;
		gap: 8px;
	}

	.statistic__title {
		color: rgb(255, 255, 255);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.statistic__subtitle {
		color: rgb(159, 159, 159);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}







	.icon-link {
		background-color: rgb(47, 47, 47);
		border-radius: 4px;
		cursor: pointer;
		padding-bottom: 100%;
		position: relative;
	}

	.icon-link__content {
		height: 100%;
		position: absolute;
			top: 0%;
			left: 0%;
		width: 100%;
		display: grid;
		gap: 12px;
		align-items: center;
		justify-content: center;
		justify-items: center;
		align-content: center;
	}

	.icon-link__icon {
		fill: rgb(255, 255, 255);
		transition: fill 0.125s;
	}

	.icon-link__title {
		color: rgb(159, 159, 159);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		transition: color 0.125s;
		white-space: nowrap;
	}

	@media (hover: hover) and (pointer: fine) {
		.icon-link:hover .icon-link__title {
			color: rgb(255, 255, 255)
		}
	}
`;
    document.head.appendChild(style);
    function makeStatistic(title, subtitle) {
        return xml.element("div.statistic")
            .add(xml.element("div.statistic__title")
            .add(xml.text(title)))
            .add(xml.element("div.statistic__subtitle")
            .add(xml.text(subtitle)));
    }
    function makeIconLink(icon, title, url) {
        return xml.element("div.icon-link")
            .add(xml.element("div.icon-link__content")
            .add(icon
            .set("class", "icon-link__icon")
            .set("width", "24px")
            .set("height", "24px"))
            .add(xml.element("div.icon-link__title")
            .add(xml.text(title))))
            .on("click", () => navigate(url));
    }
    function makeButton(options) {
        let style = options?.style ?? "normal";
        return xml.element(`div.icon-button${style === "normal" ? "" : ".icon-button--flat"}`);
    }
    function makeSearchField(query) {
        return (xml.element("div")
            .set("style", "position: relative;")
            .add(xml.element("input")
            .set("type", "text")
            .set("spellcheck", "false")
            .set("placeholder", "Search...")
            .set("value", query.getState())
            .on("keyup", (event) => {
            if (event.code === "Enter") {
                event.target.blur();
            }
        })
            .on("change", (event) => {
            query.updateState(event.target.value);
        }))
            .add(Icon.makeMagnifyingGlass()
            .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")));
    }
    ;
    const showPage = new observers_1.ObservableClass(false);
    const showDevices = new observers_1.ObservableClass(false);
    player.devices.addObserver({
        onappend: () => {
            if (player.devices.getState().length < 2) {
                showDevices.updateState(false);
            }
        },
        onsplice: () => {
            if (player.devices.getState().length < 2) {
                showDevices.updateState(false);
            }
        }
    });
    const showVideo = new observers_1.ObservableClass(false);
    {
        let computer = () => {
            let isDeviceLocal = player.isDeviceLocal.getState();
            let isCurrentEntryVideo = player.isCurrentEntryVideo.getState();
            let localPlayback = player.localPlayback.getState();
            showVideo.updateState(isDeviceLocal && isCurrentEntryVideo && localPlayback);
        };
        player.isDeviceLocal.addObserver(computer);
        player.isCurrentEntryVideo.addObserver(computer);
        player.localPlayback.addObserver(computer);
    }
    const showModal = new observers_1.ObservableClass(undefined);
    showContextMenu.addObserver((showContextMenu) => {
        if (showContextMenu) {
            showModal.updateState("context");
        }
        else {
            showModal.updateState(undefined);
        }
    });
    showDevices.addObserver((showDevices) => {
        if (showDevices) {
            showModal.updateState("devices");
        }
        else {
            showModal.updateState(undefined);
        }
    });
    showPage.addObserver((showPage) => {
        if (showPage) {
            showModal.updateState("page");
        }
        else {
            showModal.updateState(undefined);
        }
    });
    verifiedToken.addObserver((verifiedToken) => {
        if (is.absent(verifiedToken)) {
            showModal.updateState("login");
        }
        else {
            showModal.updateState(undefined);
        }
    });
    let token;
    verifiedToken.addObserver((verifiedToken) => {
        token = verifiedToken;
        player.authenticate(verifiedToken);
        playlists.authenticate(verifiedToken);
    });
    async function getNewToken(username, password) {
        let response = await apiclient["POST:/auth/"]({
            headers: {
                "x-circus-username": username,
                "x-circus-password": password
            }
        });
        let headers = await response.headers();
        savedToken.updateState(headers["x-circus-token"]);
        return savedToken.getState();
    }
    let mountwrapper = document.createElement('div');
    let showUserInterface = new observers_1.ObservableClass(true);
    let appcontainer = xml.element("div.app")
        .render();
    document.body.appendChild(appcontainer);
    let historyLength = new observers_1.ObservableClass(window.history.length);
    let historyIndex = new observers_1.ObservableClass(window.history.length - 1);
    let lastHistoryIndex = (0, observers_1.computed)((historyLength, historyIndex) => {
        if (historyLength === 0) {
            return;
        }
        if (historyIndex - 1 < 0) {
            return;
        }
        return historyIndex - 1;
    }, historyLength, historyIndex);
    let nextHistoryIndex = (0, observers_1.computed)((historyLength, historyIndex) => {
        if (historyLength === 0) {
            return;
        }
        if (historyIndex + 1 >= historyLength) {
            return;
        }
        return historyIndex + 1;
    }, historyLength, historyIndex);
    let appheader = xml.element("div.app__header")
        .bind("data-hide", showUserInterface.addObserver((showUserInterface) => !showUserInterface))
        .add(xml.element("div.content")
        .set("style", "padding: 16px")
        .add(xml.element("div.page-header")
        .add(xml.element("div.page-header__title")
        .add(xml.text(document.title))
        .on("click", () => {
        navigate("");
    }))
        .add(xml.element("div.page-header__controls")
        .add(makeButton({ style: "flat" })
        .add(Icon.makeReload()
        .set("width", "16px")
        .set("height", "16px"))
        .on("click", () => {
        window.location.reload();
    }))
        .add(makeButton({ style: "flat" })
        .bind("data-enabled", lastHistoryIndex.addObserver(is.present))
        .add(Icon.makeChevron({ direction: "left" })
        .set("width", "16px")
        .set("height", "16px"))
        .on("click", () => {
        if (is.present(lastHistoryIndex)) {
            window.history.back();
        }
    }))
        .add(makeButton({ style: "flat" })
        .bind("data-enabled", nextHistoryIndex.addObserver(is.present))
        .add(Icon.makeChevron()
        .set("width", "16px")
        .set("height", "16px"))
        .on("click", () => {
        if (is.present(nextHistoryIndex)) {
            window.history.forward();
        }
    }))
        .add(makeButton({ style: "flat" })
        .bind("data-enabled", verifiedToken.addObserver(is.present))
        .add(Icon.makeSettings()
        .set("width", "16px")
        .set("height", "16px"))
        .on("click", async () => {
        if (is.present(verifiedToken.getState())) {
            let user = await (await apiclient["GET:/users/<user_id>/"]({
                options: {
                    user_id: "",
                    token: token ?? ""
                }
            })).payload();
            let response = await apiclient["GET:/statistics/"]({
                options: {
                    token: token ?? ""
                }
            });
            let payload = await response.payload();
            let modalPage = xml.element("div.drawer-content")
                .add(xml.element("div")
                .set("style", "align-items: center; display: grid; gap: 16px; grid-template-columns: 1fr min-content;")
                .add(renderTextHeader(xml.text("Change settings")))
                .add(makeButton()
                .on("click", () => {
                modalPageElements.update([]);
            })
                .add(Icon.makeCross())))
                .add(EntityRow.forUser(user.user))
                .add(xml.element("button")
                .add(xml.text("Logout"))
                .on("click", async () => {
                savedToken.updateState(undefined);
            }))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .repeat(devicelist, (device) => xml.element("div.device-selector__device")
                .add(makeButton()
                .set("data-active", "" + device.active)
                .set("data-enabled", "" + device.enabled)
                .add(Icon.makeBroadcast())
                .on("click", () => {
                if (device.enabled) {
                    player.transfer({
                        did: device.did,
                        id: device.id,
                        protocol: device.protocol,
                        name: device.name,
                        type: device.type,
                        enabled: device.enabled
                    });
                    modalPageElements.update([]);
                }
            }))
                .add(xml.element("div.device-selector__device-info")
                .add(xml.element("div.device-selector__device-name")
                .add(xml.text(device.name)))
                .add(xml.element("div.device-selector__device-type")
                .add(xml.text(device.local ? "Local device" : "Remote device"))))))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .set("data-hide", `${payload.statistics.length === 0}`)
                .add(...payload.statistics.map((statistic) => {
                let title = statistic.title;
                let subtitle = `${statistic.value}`;
                if (api_1.NumberStatistic.is(statistic)) {
                    if (statistic.unit === "BYTES") {
                        subtitle = (0, metadata_1.formatSize)(statistic.value);
                    }
                    else if (statistic.unit === "MILLISECONDS") {
                        subtitle = (0, metadata_1.formatDuration)(statistic.value);
                    }
                    else if (statistic.unit === "TIMESTAMP") {
                        subtitle = (0, metadata_1.formatTimestamp)(statistic.value);
                    }
                }
                return makeStatistic(title, subtitle);
            })))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .add(xml.element("a")
                .set("href", "internal/player-status/")
                .on("click", () => navigate("internal/player-status/"))
                .add(xml.element("div.statistic__title")
                .add(xml.text("Player Status")))));
            modalPageElements.update([modalPage]);
        }
    })))))
        .render();
    appcontainer.appendChild(appheader);
    mountwrapper.setAttribute("class", "app__content");
    appcontainer.appendChild(mountwrapper);
    let maincontent = document.createElement('div');
    maincontent.setAttribute("style", "position: relative; width: 100%; height: 100%;");
    mountwrapper.appendChild(maincontent);
    let devicelist = new observers_1.ArrayObservable([]);
    {
        let computer = () => {
            let devices = player.devices.getState();
            let activeDevice = player.device.getState();
            let localDevice = player.localDevice.getState();
            devicelist.update(devices.map((device) => {
                return {
                    ...device,
                    active: activeDevice?.id === device.id,
                    local: localDevice?.id === device.id
                };
            }));
        };
        player.devices.addObserver({
            onappend: computer,
            onsplice: computer
        });
        player.device.addObserver(computer);
        player.localDevice.addObserver(computer);
    }
    let username = new observers_1.ObservableClass("");
    let password = new observers_1.ObservableClass("");
    let canLogin = (0, observers_1.computed)((username, password) => {
        if (username === "") {
            return false;
        }
        if (password === "") {
            return false;
        }
        return true;
    }, username, password);
    let repeat_password = new observers_1.ObservableClass("");
    let display_name = new observers_1.ObservableClass("");
    let registration_key = new observers_1.ObservableClass("");
    let loginErrors = new observers_1.ArrayObservable(new Array());
    let canRegister = (0, observers_1.computed)((username, password, repeat_password, display_name) => {
        if (username === "") {
            return false;
        }
        if (password === "") {
            return false;
        }
        if (repeat_password === "") {
            return false;
        }
        if (display_name === "") {
            return false;
        }
        if (password !== repeat_password) {
            return false;
        }
        return true;
    }, username, password, repeat_password, display_name);
    async function doLogin() {
        if (canLogin.getState()) {
            loginErrors.update([]);
            try {
                let token = await getNewToken(username.getState(), password.getState());
                if (is.present(token)) {
                    loginErrors.update([]);
                    return;
                }
            }
            catch (error) { }
            loginErrors.update(["The login was unsuccessful! Please check your credentials and try again."]);
        }
    }
    async function doRegister() {
        if (canRegister.getState()) {
            loginErrors.update([]);
            let response = await apiclient["POST:/users/"]({
                payload: {
                    username: username.getState(),
                    password: password.getState(),
                    name: display_name.getState(),
                    key_id: registration_key.getState()
                }
            });
            let payload = await response.payload();
            if (apischema.messages.ErrorMessage.is(payload)) {
                loginErrors.update(payload.errors);
            }
            else {
                loginErrors.update([]);
                savedToken.updateState(payload.token);
            }
        }
    }
    let modalPageElements = new observers_1.ArrayObservable([]);
    modalPageElements.addObserver({
        onappend: (state) => {
            showPage.updateState(modalPageElements.getState().length > 0);
        },
        onsplice: (state, index) => {
            showPage.updateState(modalPageElements.getState().length > 0);
        }
    });
    let modals = xml.element("div.modal-container")
        .bind("data-hide", showModal.addObserver(is.absent))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "page"))
        .repeat(modalPageElements, (v) => v))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "devices"))
        .add(xml.element("div.drawer-content")
        .add(xml.element("div.device-selector")
        .add(xml.element("div")
        .set("style", "align-items: center; display: grid; gap: 16px; grid-template-columns: 1fr min-content;")
        .add(renderTextHeader(xml.text("Select playback device")))
        .add(makeButton()
        .on("click", () => {
        showDevices.updateState(false);
    })
        .add(Icon.makeCross())))
        .add(xml.element("div.device-selector__devices")
        .repeat(devicelist, (device) => xml.element("div.device-selector__device")
        .add(makeButton()
        .set("data-active", "" + device.active)
        .set("data-enabled", "" + device.enabled)
        .add(Icon.makeBroadcast())
        .on("click", () => {
        if (device.enabled) {
            player.transfer({
                did: device.did,
                id: device.id,
                protocol: device.protocol,
                name: device.name,
                type: device.type,
                enabled: device.enabled
            });
            showDevices.updateState(false);
        }
    }))
        .add(xml.element("div.device-selector__device-info")
        .add(xml.element("div.device-selector__device-name")
        .add(xml.text(device.name)))
        .add(xml.element("div.device-selector__device-type")
        .add(xml.text(device.local ? "Local device" : "Remote device")))))))))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "login"))
        .add(xml.element("div.drawer-content")
        .add(xml.element("div.login-modal")
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__username")
        .bind2("value", username)
        .set("type", "text")
        .set("spellcheck", "false")
        .set("placeholder", "Username..."))
        .add(Icon.makePerson()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__password")
        .bind2("value", password)
        .set("type", "password")
        .set("spellcheck", "false")
        .set("placeholder", "Password...")
        .on("keyup", async (event) => {
        if (event.code === "Enter") {
            event.target.blur();
            await doLogin();
        }
    }))
        .add(Icon.makePadlock()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);"))))
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .bind("data-hide", loginErrors.compute((loginErrors) => loginErrors.length === 0))
        .repeat(loginErrors, (loginError) => renderTextParagraph(xml.text(loginError))))
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .add(xml.element("button")
        .bind2("data-enabled", (0, observers_1.computed)((canLogin) => "" + canLogin, canLogin))
        .add(xml.text("Login"))
        .on("click", async () => {
        await doLogin();
    }))))))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "register"))
        .add(xml.element("div.drawer-content")
        .add(xml.element("div.login-modal")
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__username")
        .bind2("value", username)
        .set("type", "text")
        .set("spellcheck", "false")
        .set("placeholder", "Username..."))
        .add(Icon.makePerson()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__password")
        .bind2("value", password)
        .set("type", "password")
        .set("spellcheck", "false")
        .set("placeholder", "Password..."))
        .add(Icon.makePadlock()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__password")
        .bind2("value", repeat_password)
        .set("type", "password")
        .set("spellcheck", "false")
        .set("placeholder", "Repeat password..."))
        .add(Icon.makePadlock()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__name")
        .bind2("value", display_name)
        .set("type", "text")
        .set("spellcheck", "false")
        .set("placeholder", "Display name..."))
        .add(Icon.makePerson()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__key")
        .bind2("value", registration_key)
        .set("type", "text")
        .set("spellcheck", "false")
        .set("placeholder", "Registration key...")
        .on("keyup", async (event) => {
        if (event.code === "Enter") {
            event.target.blur();
            await doRegister();
        }
    }))
        .add(Icon.makePadlock()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);"))))
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .bind("data-hide", loginErrors.compute((loginErrors) => loginErrors.length === 0))
        .repeat(loginErrors, (loginError) => renderTextParagraph(xml.text(loginError))))
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .add(xml.element("button")
        .bind2("data-enabled", (0, observers_1.computed)((canRegister) => "" + canRegister, canRegister))
        .add(xml.text("Register"))
        .on("click", async () => {
        await doRegister();
    }))))))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "context"))
        .add(xml.element("div.drawer-content")
        .repeat(contextMenuItems, (contextMenuItem) => contextMenuItem)));
    let mount = xml.element("div.scroll-container")
        .bind("data-hide", showVideo.addObserver((showVideo) => showVideo))
        .render();
    maincontent.appendChild(mount);
    maincontent.appendChild(modals.render());
    let messageBarMessage = new observers_1.ObservableClass("");
    let hideMessageBar = messageBarMessage.addObserver((message) => message === "");
    {
        let computer = () => {
            if (!player.isOnline.getState()) {
                messageBarMessage.updateState("Playback system offline, attempting to reconnect...");
            }
            else {
                messageBarMessage.updateState("");
            }
        };
        player.isOnline.addObserver(computer);
    }
    let mpw = xml.element("div.app__navigation")
        .bind("data-hide", showUserInterface.addObserver((showUserInterface) => !showUserInterface))
        .add(xml.element("div.app__message-bar")
        .bind("data-hide", hideMessageBar)
        .add(xml.element("div.offline-indicator")
        .add(xml.element("div.offline-indicator__content")
        .add(xml.text(messageBarMessage)))))
        .render();
    let progress = xml.element("div.media-player__progress");
    let progressbar = xml.element("div.media-player__progress-bar");
    let progresscontainer = xml.element("div.media-player__progress-container");
    let progresstrack = xml.element("div.media-player__progress-track");
    let progressmetadata = xml.element("div.media-player__progress-metadata");
    progress.add(progressbar.add(progresscontainer.add(progresstrack)), progressmetadata);
    function formatTimestamp(ms) {
        let s = Math.floor(ms / 1000);
        ms -= (s * 1000);
        let m = Math.floor(s / 60);
        s -= (m * 60);
        let h = Math.floor(m / 60);
        m -= (h * 60);
        if (h > 0) {
            return `${h}:${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
        }
        else {
            return `${m}:${s.toString().padStart(2, "0")}`;
        }
    }
    ;
    window.requestAnimationFrame(async function computer() {
        let currentEntry = player.currentEntry.getState();
        let playback = player.playback.getState();
        let playing = player.playing.getState();
        let estimatedProgress = player.estimatedProgress.getState();
        let estimatedProgressTimestamp = player.estimatedProgressTimestamp.getState();
        let scale = 0;
        let metadata = "- / -";
        if (is.present(currentEntry) && is.present(estimatedProgress) && is.present(estimatedProgressTimestamp)) {
            let progress = estimatedProgress;
            if (playing) {
                progress += (Date.now() - estimatedProgressTimestamp) / 1000;
            }
            scale = progress / (currentEntry.media.duration_ms / 1000);
            metadata = `${formatTimestamp(Math.min(progress * 1000, currentEntry.media.duration_ms))} / ${formatTimestamp(currentEntry.media.duration_ms)}`;
        }
        if (playback && !playing) {
            metadata = "Loading...";
        }
        let ref = await progresstrack.ref();
        ref.style.setProperty("transform", `scale(${scale}, 1.0)`);
        progressmetadata.ref().then((ref) => ref.textContent = metadata);
        window.requestAnimationFrame(computer);
    });
    async function progressupdate(page_x) {
        let ref = await progresscontainer.ref();
        let x = page_x - ref.offsetLeft;
        let w = ref.offsetWidth;
        let factor = Math.max(0.0, Math.min(x / w, 1.0));
        let currentEntry = player.currentEntry.getState();
        if (is.present(currentEntry)) {
            let progress = factor * currentEntry.media.duration_ms / 1000;
            player.seek(progress);
        }
    }
    let progressactive = false;
    document.body.addEventListener("pointermove", async (event) => {
        if (progressactive) {
            await progressupdate(event.pageX);
        }
    });
    document.body.addEventListener("pointerup", async (event) => {
        progressactive = false;
    });
    document.body.addEventListener("pointerleave", async (event) => {
        progressactive = false;
    });
    progressbar
        .on("pointerdown", async (event) => {
        progressactive = true;
        await progressupdate(event.pageX);
    });
    let mediaPlayerItems = new observers_1.ArrayObservable([]);
    (0, observers_1.computed)((context, currentEntry) => {
        if (context != null && currentEntry != null) {
            mediaPlayerItems.update([
                EntityRow.forEntity(currentEntry, {
                    playbackButton: undefined,
                    link: EntityLink.forEntity(context)
                })
            ]);
        }
        else {
            mediaPlayerItems.update([]);
        }
    }, player.context, player.currentEntry);
    let mp = xml.element("div.content")
        .set("style", "padding: 16px;")
        .add(xml.element("div.media-player")
        .add(xml.element("div.media-player__top")
        .add(xml.element("div.media-player__metadata")
        .repeat(mediaPlayerItems, (mediaPlayerItem) => mediaPlayerItem) /*
.add(xml.element("div.media-player__title")
.add(xml.text(mediaPlayerTitle))
)
.add(xml.element("div.media-player__subtitle")
.add(xml.text(mediaPlayerSubtitle))
)
.on("click", () => {
let context = player.context.getState();
if (is.present(context)) {
    if (Album.is(context)) {
        navigate(`audio/albums/${context.album_id}/`);
    } else if (Artist.is(context)) {
        navigate(`audio/artists/${context.artist_id}/`);
    } else if (Disc.is(context)) {
        navigate(`audio/discs/${context.disc_id}/`);
    } else if (Episode.is(context)) {
        navigate(`video/episodes/${context.episode_id}/`);
    } else if (Movie.is(context)) {
        navigate(`video/movies/${context.movie_id}/`);
    } else if (Playlist.is(context)) {
        navigate(`audio/playlists/${context.playlist_id}/`);
    } else if (Season.is(context)) {
        navigate(`video/seasons/${context.season_id}/`);
    } else if (Show.is(context)) {
        navigate(`video/shows/${context.show_id}/`);
    } else if (Track.is(context)) {
        navigate(`audio/tracks/${context.track_id}/`);
    } else {
        throw `Expected code to be unreachable!`;
    }
}
}) */)
        .add(xml.element("div.media-player__controls") /*
.add(makeButton()
    .bind("data-hide", player.devices.compute((devices) => {
        return devices.length < 2;
    }))
    .add(Icon.makeBroadcast())
    .on("click", () => {
        showDevices.updateState(!showDevices.getState());
    })
) */
        .add(makeButton()
        .bind("data-enabled", player.canPlayLast.addObserver(a => a))
        .add(Icon.makeSkip({ direction: "left" }))
        .on("click", () => {
        player.last();
    }))
        .add(makeButton()
        .bind("data-enabled", player.canPlayCurrent.addObserver(a => a))
        .add(Icon.makePlay()
        .bind("data-hide", player.playback.addObserver((playback) => {
        return playback === true;
    })))
        .add(Icon.makePause()
        .bind("data-hide", player.playback.addObserver((playback) => {
        return playback === false;
    })))
        .on("click", () => {
        player.togglePlayback();
    }))
        .add(makeButton()
        .bind("data-enabled", player.canPlayNext.addObserver(a => a))
        .add(Icon.makeSkip())
        .on("click", () => {
        player.next();
    }))))
        .add(xml.element("div.media-player__bottom")
        .add(makeButton({ style: "flat" })
        .bind("data-active", player.shuffle.addObserver(a => a))
        .bind("data-enabled", player.isOnline.addObserver(a => a))
        .add(Icon.makeShuffle()
        .set("width", "16px")
        .set("height", "16px"))
        .on("click", () => {
        if (player.isOnline.getState()) {
            player.toggleShuffle();
        }
    }))
        .add(progress)
        .add(makeButton({ style: "flat" })
        .bind("data-active", player.repeat.addObserver(a => a))
        .bind("data-enabled", player.isOnline.addObserver(a => a))
        .add(Icon.makeRepeat()
        .set("width", "16px")
        .set("height", "16px"))
        .on("click", () => {
        if (player.isOnline.getState()) {
            player.toggleRepeat();
        }
    }))))
        .render();
    appcontainer.appendChild(mpw);
    mpw.appendChild(mp);
    currentVideo.setAttribute('playsinline', '');
    currentVideo.setAttribute("preload", "auto");
    currentVideo.style.setProperty('height', '100%');
    currentVideo.style.setProperty('width', '100%');
    lastVideo.setAttribute("preload", "auto");
    lastVideo.style.setProperty("display", "none");
    nextVideo.setAttribute("preload", "auto");
    nextVideo.style.setProperty("display", "none");
    currentVideo.addEventListener("click", () => {
        player.pause();
    });
    showVideo.addObserver((showVideo) => {
        if (showVideo) {
            showUserInterface.updateState(false);
        }
        else {
            showUserInterface.updateState(true);
        }
    });
    let videowrapper = xml.element("div.app__video")
        .bind("data-hide", showVideo.addObserver((showVideo) => {
        return !showVideo;
    }))
        .render();
    appcontainer.appendChild(videowrapper);
    videowrapper.appendChild(currentVideo);
    videowrapper.appendChild(lastVideo);
    videowrapper.appendChild(nextVideo);
    /*
    let slider_wrapper = document.createElement("div");
    slider_wrapper.classList.add("slider-widget");
    let slider_indicator = document.createElement("div");
    slider_indicator.classList.add("slider-widget__indicator");
    let slider_knob_wrapper = document.createElement("div");
    slider_knob_wrapper.classList.add("slider-widget__knob-wrapper");
    let slider_knob = document.createElement("div");
    slider_knob.classList.add("slider-widget__knob");
    
    slider_knob_wrapper.appendChild(slider_knob);
    slider_indicator.appendChild(slider_knob_wrapper);
    slider_wrapper.appendChild(slider_indicator);
    chromecast.appendChild(slider_wrapper);
    {
        let percentage = 0.0;
        function update(event: MouseEvent): void {
            let rect = slider_knob_wrapper.getBoundingClientRect();
            let x = event.pageX;
            let factor = Math.max(0.0, Math.min((x - rect.x) / rect.width, 1.0));
            percentage = factor * 100.0;
            slider_knob.style.setProperty("left", `${percentage}%`);
        }
        function detach(event: MouseEvent) {
            window.removeEventListener("mousemove", update);
            window.removeEventListener("mouseup", detach);
            req(`/api/cc/seek/`, { percentage: percentage, token: token }, () => {});
        }
        function attach(event: MouseEvent) {
            window.addEventListener("mousemove", update);
            window.addEventListener("mouseup", detach);
            update(event);
        }
        slider_wrapper.addEventListener("mousedown", attach);
    }
    */
    function renderTextHeader(content) {
        return xml.element("div.text-header")
            .add(content);
    }
    function renderTextParagraph(content) {
        return xml.element("div.text-paragraph")
            .add(content);
    }
    function observe(element, handler) {
        element.ref().then((element) => {
            let observer = new IntersectionObserver(async (entries) => {
                for (let entry of entries) {
                    if (entry.target === element && entry.isIntersecting) {
                        await handler();
                    }
                }
            });
            observer.observe(element);
        });
        return element;
    }
    let updateviewforuri = async (uri) => {
        let parts;
        if (false) {
        }
        else if ((parts = /^internal[/]player-status[/]/.exec(uri)) !== null) {
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Player Status")))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px;")
                .add(renderTextHeader(xml.text("Event Log")))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .repeat(videoEventLog, ({ timestamp, type }) => makeStatistic(type, new Date(timestamp).toISOString().slice(11, 11 + 8))))))
                .render();
            return {
                element,
                title: "Player Status"
            };
        }
        else if ((parts = /^audio[/]genres[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let category_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/categories/<category_id>/"]({
                options: {
                    category_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let category = payload.category;
                let offset = 0;
                let reachedEnd = new observers_1.ObservableClass(false);
                let isLoading = new observers_1.ObservableClass(false);
                let albums = new observers_1.ArrayObservable([]);
                let anchor = new observers_1.ObservableClass(undefined);
                async function load() {
                    if (!reachedEnd.getState() && !isLoading.getState()) {
                        isLoading.updateState(true);
                        let response = await apiclient["GET:/categories/<category_id>/albums/"]({
                            options: {
                                category_id: category_id,
                                token: token ?? "",
                                anchor: anchor.getState()?.album_id,
                                offset
                            }
                        });
                        let payload = await response.payload();
                        for (let album of payload.albums) {
                            albums.append(album);
                            anchor.updateState(album);
                        }
                        offset += payload.albums.length;
                        if (payload.albums.length === 0) {
                            reachedEnd.updateState(true);
                        }
                        isLoading.updateState(false);
                    }
                }
                ;
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(renderTextHeader(xml.text(category.title)))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 24px;")
                    .bind("data-hide", albums.compute((albums) => albums.length === 0))
                    .add(renderTextHeader(xml.text("Albums")))
                    .add(Grid.make()
                    .repeat(albums, (album) => EntityCard.forAlbum(album)))))
                    .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                    .render();
                return {
                    element,
                    title: `${category.title}`
                };
            });
        }
        else if ((parts = /^audio[/]genres[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let categories = new observers_1.ArrayObservable([]);
            let anchor = new observers_1.ObservableClass(undefined);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/categories/<query>"]({
                        options: {
                            query,
                            token: token ?? "",
                            anchor: anchor.getState()?.category_id,
                            offset,
                            limit: 100
                        }
                    });
                    let payload = await response.payload();
                    for (let { entity } of payload.results) {
                        categories.append(entity);
                        anchor.updateState(entity);
                    }
                    offset += payload.results.length;
                    if (payload.results.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(Grid.make({ mini: true })
                .repeat(categories, (category) => makeIconLink(Icon.makePieChart(), category.title, `audio/genres/${category.category_id}/`))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Genres`
            };
        }
        else if ((parts = /^audio[/]tracks[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let track_id = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let playlists = new observers_1.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/tracks/<track_id>/playlists/"]({
                        options: {
                            track_id,
                            token: token ?? "",
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let playlist of payload.playlists) {
                        playlists.append(playlist);
                    }
                    offset += payload.playlists.length;
                    if (payload.playlists.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            return apiclient["GET:/tracks/<track_id>/"]({
                options: {
                    track_id: parts[1],
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let track = payload.track;
                let last = payload.last;
                let next = payload.next;
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forTrack(track, { compactDescription: false }))
                    .add(entityNavLinkFactory.forTrack(last, next))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Appearances")))
                    .bind("data-hide", playlists.compute((playlists) => playlists.length === 0))
                    .add(Grid.make()
                    .repeat(playlists, (playlist) => EntityCard.forPlaylist(playlist)))))
                    .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                    .render();
                return {
                    element,
                    title: `${track.title}`
                };
            });
        }
        else if ((parts = /^audio[/]tracks[/]([^/?]*)/.exec(uri)) !== null) {
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let tracks = new observers_1.ArrayObservable([]);
            let provider;
            async function load() {
                if (provider != null) {
                    let results = await provider.fetch();
                    for (let { entity } of results) {
                        tracks.append(entity);
                    }
                }
            }
            ;
            window.requestAnimationFrame(() => {
                query.addObserver((query) => {
                    replaceUrl(`audio/tracks/${encodeURIComponent(query)}`, `Tracks`);
                    tracks.update([]);
                    provider = new TrackSearchResultProvider(token ?? "", query);
                    load();
                });
            });
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Tracks")))
                .add(makeSearchField(query))
                .add(Grid.make()
                .repeat(tracks, (track) => EntityCard.forTrack(track))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Tracks`
            };
        }
        else if ((parts = /^video[/]seasons[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let season_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/seasons/<season_id>/"]({
                options: {
                    season_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let season = payload.season;
                let last = payload.last;
                let next = payload.next;
                let episodes = new observers_1.ArrayObservable([]);
                apiclient.getSeasonEpisodes({
                    options: {
                        season_id,
                        token: token ?? ""
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    episodes.update(payload.episodes);
                });
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forSeason(season, { compactDescription: false }))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 24px;")
                    .repeat(episodes, (episode, episodeIndex) => {
                    return EntityCard.forEpisode(episode, {
                        playbackButton: PlaybackButton.forSeason(season, episodeIndex)
                    });
                }))
                    .add(entityNavLinkFactory.forSeason(last, next)))
                    .render();
                return {
                    element,
                    title: `Season ${season.number}`
                };
            });
        }
        else if ((parts = /^video[/]seasons[/]([^/?]*)/.exec(uri)) !== null) {
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let seasons = new observers_1.ArrayObservable([]);
            let provider;
            async function load() {
                if (provider != null) {
                    let results = await provider.fetch();
                    for (let { entity } of results) {
                        seasons.append(entity);
                    }
                }
            }
            ;
            window.requestAnimationFrame(() => {
                query.addObserver((query) => {
                    replaceUrl(`video/seasons/${encodeURIComponent(query)}`, `Seasons`);
                    seasons.update([]);
                    provider = new SeasonSearchResultProvider(token ?? "", query);
                    load();
                });
            });
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Seasons")))
                .add(makeSearchField(query))
                .add(Grid.make()
                .repeat(seasons, (season) => EntityCard.forSeason(season))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Seasons`
            };
        }
        else if ((parts = /^audio[/]discs[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let disc_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/discs/<disc_id>/"]({
                options: {
                    disc_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let disc = payload.disc;
                let last = payload.last;
                let next = payload.next;
                let tracks = new observers_1.ArrayObservable([]);
                apiclient.getDiscTracks({
                    options: {
                        disc_id,
                        token: token ?? ""
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    tracks.update(payload.tracks);
                });
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forDisc(disc, { compactDescription: false }))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 16px;")
                    .repeat(tracks, (track, trackIndex) => {
                    return EntityRow.forTrack(track, {
                        playbackButton: PlaybackButton.forDisc(disc, trackIndex)
                    });
                }))
                    .add(entityNavLinkFactory.forDisc(last, next)))
                    .render();
                return {
                    element,
                    title: disc.title ?? `Disc ${disc.number}`
                };
            });
        }
        else if ((parts = /^audio[/]discs[/]([^/?]*)/.exec(uri)) !== null) {
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let discs = new observers_1.ArrayObservable([]);
            let provider;
            async function load() {
                if (provider != null) {
                    let results = await provider.fetch();
                    for (let { entity } of results) {
                        discs.append(entity);
                    }
                }
            }
            ;
            window.requestAnimationFrame(() => {
                query.addObserver((query) => {
                    replaceUrl(`audio/discs/${encodeURIComponent(query)}`, `Discs`);
                    discs.update([]);
                    provider = new DiscSearchResultProvider(token ?? "", query);
                    load();
                });
            });
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Discs")))
                .add(makeSearchField(query))
                .add(Grid.make()
                .repeat(discs, (disc) => EntityCard.forDisc(disc))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Discs`
            };
        }
        else if ((parts = /^users[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let user_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/users/<user_id>/"]({
                options: {
                    user_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let user = payload.user;
                let offset = 0;
                let reachedEnd = new observers_1.ObservableClass(false);
                let isLoading = new observers_1.ObservableClass(false);
                let playlists = new observers_1.ArrayObservable([]);
                let anchor = new observers_1.ObservableClass(undefined);
                async function load() {
                    if (!reachedEnd.getState() && !isLoading.getState()) {
                        isLoading.updateState(true);
                        let response = await apiclient["GET:/users/<user_id>/playlists/"]({
                            options: {
                                user_id,
                                token: token ?? "",
                                anchor: anchor.getState()?.playlist_id,
                                offset
                            }
                        });
                        let payload = await response.payload();
                        for (let playlist of payload.playlists) {
                            playlists.append(playlist);
                            anchor.updateState(playlist);
                        }
                        offset += payload.playlists.length;
                        if (payload.playlists.length === 0) {
                            reachedEnd.updateState(true);
                        }
                        isLoading.updateState(false);
                    }
                }
                ;
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(renderTextHeader(xml.text(user.name)))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 24px")
                    .bind("data-hide", playlists.compute((playlists) => playlists.length === 0))
                    .add(renderTextHeader(xml.text("Playlists")))
                    .add(Grid.make()
                    .repeat(playlists, (playlist) => EntityCard.forPlaylist(playlist)))))
                    .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                    .render();
                return {
                    element,
                    title: `${user.name}`
                };
            });
        }
        else if ((parts = /^users[/]([^/?]*)/.exec(uri)) !== null) {
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let users = new observers_1.ArrayObservable([]);
            let provider;
            async function load() {
                if (provider != null) {
                    let results = await provider.fetch();
                    for (let { entity } of results) {
                        users.append(entity);
                    }
                }
            }
            ;
            window.requestAnimationFrame(() => {
                query.addObserver((query) => {
                    replaceUrl(`users/${encodeURIComponent(query)}`, `Users`);
                    users.update([]);
                    provider = new UserSearchResultProvider(token ?? "", query);
                    load();
                });
            });
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Users")))
                .add(makeSearchField(query))
                .add(xml.element("div")
                .add(Grid.make()
                .repeat(users, (user) => EntityCard.forUser(user)))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Users`
            };
        }
        else if ((parts = /^actors[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let actor_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/actors/<actor_id>/"]({
                options: {
                    actor_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let actor = payload.actor;
                return apiclient["GET:/actors/<actor_id>/shows/"]({
                    options: {
                        actor_id,
                        token: token ?? "",
                        anchor: undefined
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    let shows = payload.shows;
                    let offset = 0;
                    let reachedEnd = new observers_1.ObservableClass(false);
                    let isLoading = new observers_1.ObservableClass(false);
                    let movies = new observers_1.ArrayObservable([]);
                    let anchor = new observers_1.ObservableClass(undefined);
                    async function load() {
                        if (!reachedEnd.getState() && !isLoading.getState()) {
                            isLoading.updateState(true);
                            let response = await apiclient["GET:/actors/<actor_id>/movies/"]({
                                options: {
                                    actor_id,
                                    token: token ?? "",
                                    anchor: anchor.getState()?.movie_id,
                                    offset
                                }
                            });
                            let payload = await response.payload();
                            for (let movie of payload.movies) {
                                movies.append(movie);
                                anchor.updateState(movie);
                            }
                            offset += payload.movies.length;
                            if (payload.movies.length === 0) {
                                reachedEnd.updateState(true);
                            }
                            isLoading.updateState(false);
                        }
                    }
                    ;
                    let element = xml.element("div.content")
                        .set("style", "display: grid; gap: 48px;")
                        .add(renderTextHeader(xml.text(actor.name)))
                        .add(xml.element("div")
                        .set("style", "display: grid; gap: 24px;")
                        .set("data-hide", `${shows.length === 0}`)
                        .add(renderTextHeader(xml.text("Shows")))
                        .add(carouselFactory.make(new observers_1.ArrayObservable(shows.map((show) => EntityCard.forShow(show))))))
                        .add(xml.element("div")
                        .set("style", "display: grid; gap: 24px;")
                        .bind("data-hide", movies.compute((movies) => movies.length === 0))
                        .add(renderTextHeader(xml.text("Movies")))
                        .add(Grid.make()
                        .repeat(movies, (movie) => EntityCard.forMovie(movie))))
                        .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                        .render();
                    return {
                        element,
                        title: `${actor.name}`
                    };
                });
            });
        }
        else if ((parts = /^actors[/]([^/?]*)/.exec(uri)) !== null) {
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let actors = new observers_1.ArrayObservable([]);
            let provider;
            async function load() {
                if (provider != null) {
                    let results = await provider.fetch();
                    for (let { entity } of results) {
                        actors.append(entity);
                    }
                }
            }
            ;
            window.requestAnimationFrame(() => {
                query.addObserver((query) => {
                    replaceUrl(`actors/${encodeURIComponent(query)}`, `Actors`);
                    actors.update([]);
                    provider = new ActorSearchResultProvider(token ?? "", query);
                    load();
                });
            });
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Actors")))
                .add(makeSearchField(query))
                .add(Grid.make()
                .repeat(actors, (actor) => EntityCard.forActor(actor))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Actors`
            };
        }
        else if ((parts = /^audio[/]albums[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let album_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/albums/<album_id>/"]({
                options: {
                    album_id: album_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let album = payload.album;
                let discs = new observers_1.ArrayObservable([]);
                apiclient.getAlbumDiscs({
                    options: {
                        album_id,
                        token: token ?? ""
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    discs.update(payload.discs);
                });
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forAlbum(album, { compactDescription: false }))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 16px;")
                    .set("data-hide", `${album.categories.length === 0}`)
                    .add(...album.categories.slice(0, 3).map((category) => EntityRow.forCategory(category))))
                    .repeat(discs, (disc, discIndex) => {
                    let tracks = new observers_1.ArrayObservable([]);
                    apiclient.getDiscTracks({
                        options: {
                            disc_id: disc.disc_id,
                            token: token ?? ""
                        }
                    }).then(async (response) => {
                        let payload = await response.payload();
                        tracks.update(payload.tracks);
                    });
                    let element = xml.element("div")
                        .set("style", "display: grid; gap: 24px;")
                        .add(renderTextHeader(entityTitleFactory.forDisc(disc)))
                        .add(xml.element("div")
                        .set("style", "display: grid; gap: 16px;")
                        .repeat(tracks, (track, trackIndex) => {
                        return EntityRow.forTrack(track, {
                            playbackButton: PlaybackButton.forAlbum(album, discIndex, trackIndex)
                        });
                    }));
                    return element;
                }))
                    .render();
                return {
                    element,
                    title: `${album.title}`
                };
            });
        }
        else if ((parts = /^audio[/]albums[/]([^/?]*)/.exec(uri)) !== null) {
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let albums = new observers_1.ArrayObservable([]);
            let provider;
            async function load() {
                if (provider != null) {
                    let results = await provider.fetch();
                    for (let { entity } of results) {
                        albums.append(entity);
                    }
                }
            }
            ;
            window.requestAnimationFrame(() => {
                query.addObserver((query) => {
                    replaceUrl(`audio/albums/${encodeURIComponent(query)}`, `Albums`);
                    albums.update([]);
                    provider = new AlbumSearchResultProvider(token ?? "", query);
                    load();
                });
            });
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Albums")))
                .add(makeSearchField(query))
                .add(Grid.make()
                .repeat(albums, (album) => EntityCard.forAlbum(album))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Albums`
            };
        }
        else if ((parts = /^audio[/]artists[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let artist_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/artists/<artist_id>/"]({
                options: {
                    artist_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let artist = payload.artist;
                let tracks = payload.tracks;
                let appearances = payload.appearances;
                let albums = new observers_1.ArrayObservable([]);
                apiclient.getArtistAlbums({
                    options: {
                        artist_id,
                        token: token ?? ""
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    albums.update(payload.albums);
                });
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forArtist(artist, { compactDescription: false }))
                    .add(tracks.length === 0 ? undefined : xml.element("div")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Popular tracks")))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 16px;")
                    .add(...tracks.map((track) => {
                    return EntityRow.forTrack(track);
                }))))
                    .add(xml.element("div")
                    .bind("data-hide", albums.compute((albums) => albums.length === 0))
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Discography")))
                    .add(Grid.make()
                    .repeat(albums, (album, albumIndex) => {
                    return EntityCard.forAlbum(album, {
                        playbackButton: PlaybackButton.forArtist(artist, albumIndex)
                    });
                })))
                    .add(appearances.length === 0 ? undefined : xml.element("div")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Appearances")))
                    .add(Grid.make()
                    .add(...appearances.map((album) => {
                    return EntityCard.forAlbum(album);
                })))))
                    .render();
                return {
                    element,
                    title: `${artist.title}`
                };
            });
        }
        else if ((parts = /^audio[/]artists[/]([^/?]*)/.exec(uri)) !== null) {
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let artists = new observers_1.ArrayObservable([]);
            let provider;
            async function load() {
                if (provider != null) {
                    let results = await provider.fetch();
                    for (let { entity } of results) {
                        artists.append(entity);
                    }
                }
            }
            ;
            window.requestAnimationFrame(() => {
                query.addObserver((query) => {
                    replaceUrl(`audio/artists/${encodeURIComponent(query)}`, `Artists`);
                    artists.update([]);
                    provider = new ArtistSearchResultProvider(token ?? "", query);
                    load();
                });
            });
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Artists")))
                .add(makeSearchField(query))
                .add(Grid.make()
                .repeat(artists, (artist) => EntityCard.forArtist(artist))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Artists`
            };
        }
        else if ((parts = /^audio[/]playlists[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let playlist_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/playlists/<playlist_id>/"]({
                options: {
                    playlist_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let playlist = payload.playlist;
                let hasWritePermission = (await playlists.getPermissions({
                    playlist: {
                        playlist_id
                    }
                })).permissions === "write";
                let items = new observers_1.ArrayObservable([]);
                apiclient.getPlaylistItems({
                    options: {
                        playlist_id,
                        token: token ?? ""
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    items.update(payload.items);
                });
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forPlaylist(playlist, { compactDescription: false }))
                    .add(xml.element("div")
                    .bind("data-hide", items.compute((items) => items.length === 0))
                    .set("style", "display: grid; gap: 16px;")
                    .repeat(items, (item, itemIndex) => xml.element("div")
                    .set("style", "align-items: center; display: grid; grid-template-columns: 1fr min-content; gap: 16px;")
                    .add(EntityRow.forTrack(item.track, {
                    playbackButton: PlaybackButton.forPlaylist(playlist, itemIndex)
                }))
                    .add(makeButton()
                    .set("data-hide", `${!hasWritePermission}`)
                    .on("click", async () => {
                    let response = await playlists.deletePlaylistItem({
                        playlist_item: {
                            playlist_item_id: item.playlist_item_id
                        }
                    });
                    if (response.errors.length > 0) {
                        return;
                    }
                    // TODO: Remove item instead of navigating.
                    navigate(uri);
                })
                    .add(Icon.makeMinus())))))
                    .render();
                return {
                    element,
                    title: `${playlist.title}`
                };
            });
        }
        else if ((parts = /^audio[/]playlists[/]([^/?]*)/.exec(uri)) !== null) {
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let playlists = new observers_1.ArrayObservable([]);
            let provider;
            async function load() {
                if (provider != null) {
                    let results = await provider.fetch();
                    for (let { entity } of results) {
                        playlists.append(entity);
                    }
                }
            }
            ;
            window.requestAnimationFrame(() => {
                query.addObserver((query) => {
                    replaceUrl(`audio/playlists/${encodeURIComponent(query)}`, `Playlists`);
                    playlists.update([]);
                    provider = new PlaylistSearchResultProvider(token ?? "", query);
                    load();
                });
            });
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Playlists")))
                .add(makeSearchField(query))
                .add(Grid.make()
                .repeat(playlists, (playlist) => EntityCard.forPlaylist(playlist))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Playlists`
            };
        }
        else if ((parts = /^audio[/]/.exec(uri)) !== null) {
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let albums = new observers_1.ArrayObservable([]);
            let anchor = new observers_1.ObservableClass(undefined);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient.getNewAlbums({
                        options: {
                            token: token ?? "",
                            anchor: anchor.getState()?.album_id,
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let album of payload.albums) {
                        albums.append(album);
                        anchor.updateState(album);
                    }
                    offset += payload.albums.length;
                    if (payload.albums.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(Grid.make({ mini: true })
                .add(makeIconLink(Icon.makeDisc(), "Albums", "audio/albums/"))
                .add(makeIconLink(Icon.makePerson(), "Artists", "audio/artists/"))
                .add(makeIconLink(Icon.makePieChart(), "Genres", "audio/genres/"))
                .add(makeIconLink(Icon.makeBulletList(), "Playlists", "audio/playlists/"))
                .add(makeIconLink(Icon.makeNote(), "Tracks", "audio/tracks/")))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px")
                .bind("data-hide", albums.compute((albums) => albums.length === 0))
                .add(renderTextHeader(xml.text("Recently added albums")))
                .add(Grid.make()
                .repeat(albums, (album) => EntityCard.forAlbum(album)))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Listen`
            };
        }
        else if ((parts = /^video[/]shows[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let show_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/shows/<show_id>/"]({
                options: {
                    show_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let show = payload.show;
                let actors = payload.actors;
                let seasons = new observers_1.ArrayObservable([]);
                apiclient.getShowSeasons({
                    options: {
                        show_id,
                        token: token ?? ""
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    seasons.update(payload.seasons);
                });
                let nextEpisodeElements = new observers_1.ArrayObservable([]);
                apiclient.getShowContext({
                    options: {
                        show_id,
                        token: token ?? ""
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    let context = payload.context;
                    let next = utils.getNextEpisode(context);
                    if (next != null) {
                        let element = EntityCard.forEpisode(context.seasons[next.seasonIndex].episodes[next.episodeIndex], {
                            playbackButton: PlaybackButton.forShow(show, next.seasonIndex, next.episodeIndex)
                        });
                        nextEpisodeElements.update([element]);
                    }
                });
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forShow(show, { compactDescription: false }))
                    .add(xml.element("div")
                    .set("data-hide", `${actors.length === 0}`)
                    .set("style", "display: grid; gap: 16px;")
                    .add(...actors.slice(0, 3).map((actor) => EntityRow.forActor(actor))))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Next episode")))
                    .repeat(nextEpisodeElements, (element) => element))
                    .add(Grid.make()
                    .repeat(seasons, (season, seasonIndex) => EntityCard.forSeason(season, {
                    playbackButton: PlaybackButton.forShow(show, seasonIndex)
                }))))
                    .render();
                return {
                    element,
                    title: `${show.title}`
                };
            });
        }
        else if ((parts = /^video[/]shows[/]([^/?]*)/.exec(uri)) !== null) {
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let shows = new observers_1.ArrayObservable([]);
            let provider;
            async function load() {
                if (provider != null) {
                    let results = await provider.fetch();
                    for (let { entity } of results) {
                        shows.append(entity);
                    }
                }
            }
            ;
            window.requestAnimationFrame(() => {
                query.addObserver((query) => {
                    replaceUrl(`video/shows/${encodeURIComponent(query)}`, `Shows`);
                    shows.update([]);
                    provider = new ShowSearchResultProvider(token ?? "", query);
                    load();
                });
            });
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Shows")))
                .add(makeSearchField(query))
                .add(Grid.make()
                .repeat(shows, (show) => EntityCard.forShow(show))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Shows`
            };
        }
        else if ((parts = /^video[/]episodes[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let episode_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/episodes/<episode_id>/"]({
                options: {
                    episode_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let episode = payload.episode;
                let last = payload.last;
                let next = payload.next;
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forEpisode(episode, { compactDescription: false }))
                    .add(entityNavLinkFactory.forEpisode(last, next)))
                    .render();
                return {
                    element,
                    title: `${episode.title}`
                };
            });
        }
        else if ((parts = /^video[/]episodes[/]([^/?]*)/.exec(uri)) !== null) {
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let episodes = new observers_1.ArrayObservable([]);
            let provider;
            async function load() {
                if (provider != null) {
                    let results = await provider.fetch();
                    for (let { entity } of results) {
                        episodes.append(entity);
                    }
                }
            }
            ;
            window.requestAnimationFrame(() => {
                query.addObserver((query) => {
                    replaceUrl(`video/episodes/${encodeURIComponent(query)}`, `Episodes`);
                    episodes.update([]);
                    provider = new EpisodeSearchResultProvider(token ?? "", query);
                    load();
                });
            });
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Episodes")))
                .add(makeSearchField(query))
                .add(Grid.make()
                .repeat(episodes, (episode) => EntityCard.forEpisode(episode))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Episodes`
            };
        }
        else if ((parts = /^video[/]movies[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let movie_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/movies/<movie_id>/"]({
                options: {
                    movie_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let offset = 0;
                let reachedEnd = new observers_1.ObservableClass(false);
                let isLoading = new observers_1.ObservableClass(false);
                let movies = new observers_1.ArrayObservable([]);
                let anchor = new observers_1.ObservableClass(undefined);
                async function load() {
                    if (!reachedEnd.getState() && !isLoading.getState()) {
                        isLoading.updateState(true);
                        let response = await apiclient["GET:/movies/<movie_id>/suggestions/"]({
                            options: {
                                movie_id,
                                token: token ?? "",
                                anchor: anchor.getState()?.movie_id,
                                offset
                            }
                        });
                        let payload = await response.payload();
                        for (let movie of payload.movies) {
                            movies.append(movie);
                            anchor.updateState(movie);
                        }
                        offset += payload.movies.length;
                        if (payload.movies.length === 0) {
                            reachedEnd.updateState(true);
                        }
                        isLoading.updateState(false);
                    }
                }
                ;
                let payload = await response.payload();
                let movie = payload.movie;
                let actors = payload.actors;
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forMovie(movie, { compactDescription: false }))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 16px;")
                    .set("data-hide", `${actors.length === 0}`)
                    .add(...actors.slice(0, 3).map((actor) => EntityRow.forActor(actor))))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 24px;")
                    .bind("data-hide", movies.compute((movies) => movies.length === 0))
                    .add(renderTextHeader(xml.text("Suggested movies")))
                    .add(Grid.make()
                    .repeat(movies, (movie) => EntityCard.forMovie(movie)))))
                    .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                    .render();
                return {
                    element,
                    title: `${movie.title}`
                };
            });
        }
        else if ((parts = /^video[/]movies[/]([^/?]*)/.exec(uri)) !== null) {
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let movies = new observers_1.ArrayObservable([]);
            let provider;
            async function load() {
                if (provider != null) {
                    let results = await provider.fetch();
                    for (let { entity } of results) {
                        movies.append(entity);
                    }
                }
            }
            ;
            window.requestAnimationFrame(() => {
                query.addObserver((query) => {
                    replaceUrl(`video/movies/${encodeURIComponent(query)}`, `Movies`);
                    movies.update([]);
                    provider = new MovieSearchResultProvider(token ?? "", query);
                    load();
                });
            });
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Movies")))
                .add(makeSearchField(query))
                .add(Grid.make()
                .repeat(movies, (movie) => EntityCard.forMovie(movie))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Movies`
            };
        }
        else if ((parts = /^video[/]genres[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let genre_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/genres/<genre_id>/"]({
                options: {
                    genre_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let genre = payload.genre;
                return apiclient["GET:/genres/<genre_id>/shows/"]({
                    options: {
                        genre_id,
                        token: token ?? "",
                        anchor: undefined
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    let shows = payload.shows;
                    let offset = 0;
                    let reachedEnd = new observers_1.ObservableClass(false);
                    let isLoading = new observers_1.ObservableClass(false);
                    let movies = new observers_1.ArrayObservable([]);
                    let anchor = new observers_1.ObservableClass(undefined);
                    async function load() {
                        if (!reachedEnd.getState() && !isLoading.getState()) {
                            isLoading.updateState(true);
                            let response = await apiclient["GET:/genres/<genre_id>/movies/"]({
                                options: {
                                    genre_id,
                                    token: token ?? "",
                                    anchor: anchor.getState()?.movie_id,
                                    offset
                                }
                            });
                            let payload = await response.payload();
                            for (let movie of payload.movies) {
                                movies.append(movie);
                                anchor.updateState(movie);
                            }
                            offset += payload.movies.length;
                            if (payload.movies.length === 0) {
                                reachedEnd.updateState(true);
                            }
                            isLoading.updateState(false);
                        }
                    }
                    ;
                    let element = xml.element("div")
                        .add(xml.element("div.content")
                        .add(renderTextHeader(xml.text(genre.title)))
                        .add(shows.length === 0 ? undefined : xml.element("div")
                        .set("style", "display: grid; gap: 24px;")
                        .add(renderTextHeader(xml.text("Shows")))
                        .add(carouselFactory.make(new observers_1.ArrayObservable(shows.map((show) => EntityCard.forShow(show))))))
                        .add(xml.element("div")
                        .set("style", "display: grid; gap: 24px;")
                        .bind("data-hide", movies.compute((movies) => movies.length === 0))
                        .add(renderTextHeader(xml.text("Movies")))
                        .add(Grid.make()
                        .repeat(movies, (movie) => EntityCard.forMovie(movie)))))
                        .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                        .render();
                    return {
                        element,
                        title: `${genre.title}`
                    };
                });
            });
        }
        else if ((parts = /^video[/]genres[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let genres = new observers_1.ArrayObservable([]);
            let anchor = new observers_1.ObservableClass(undefined);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/genres/<query>"]({
                        options: {
                            query,
                            token: token ?? "",
                            anchor: anchor.getState()?.genre_id,
                            offset,
                            limit: 100
                        }
                    });
                    let payload = await response.payload();
                    for (let { entity } of payload.results) {
                        genres.append(entity);
                        anchor.updateState(entity);
                    }
                    offset += payload.results.length;
                    if (payload.results.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(Grid.make({ mini: true })
                .repeat(genres, (genre) => makeIconLink(Icon.makePieChart(), genre.title, `video/genres/${genre.genre_id}/`))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Genres`
            };
        }
        else if ((parts = /^video[/]/.exec(uri)) !== null) {
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let movies = new observers_1.ArrayObservable([]);
            let anchor = new observers_1.ObservableClass(undefined);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient.getNewMovies({
                        options: {
                            token: token ?? "",
                            anchor: anchor.getState()?.movie_id,
                            offset
                        }
                    });
                    let payload = await response.payload();
                    for (let movie of payload.movies) {
                        movies.append(movie);
                        anchor.updateState(movie);
                    }
                    offset += payload.movies.length;
                    if (payload.movies.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(Grid.make({ mini: true })
                .add(makeIconLink(Icon.makeStar(), "Movies", "video/movies/"))
                .add(makeIconLink(Icon.makeMonitor(), "Shows", "video/shows/"))
                .add(makeIconLink(Icon.makePieChart(), "Genres", "video/genres/"))
                .add(makeIconLink(Icon.makePerson(), "Actors", "actors/")))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px;")
                .bind("data-hide", movies.compute((movies) => movies.length === 0))
                .add(renderTextHeader(xml.text("Recently added movies")))
                .add(Grid.make()
                .repeat(movies, (movie) => EntityCard.forMovie(movie)))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Watch`
            };
        }
        else if ((parts = /^search[/]([^/?]*)/.exec(uri)) !== null) {
            function getBoolean(uri, key) {
                let url = new URL(uri, window.location.origin);
                let value = url.searchParams.get(key);
                if (value === "true") {
                    return true;
                }
                if (value === "false") {
                    return false;
                }
            }
            let query = new observers_1.ObservableClass(decodeURIComponent(parts[1]));
            let cues = new observers_1.ObservableClass(getBoolean(uri, "cues") ?? false);
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let entities = new observers_1.ArrayObservable([]);
            let merger;
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState() && merger != null) {
                    isLoading.updateState(true);
                    let results = await merger.fetch(12);
                    for (let { entity } of results) {
                        entities.append(entity);
                    }
                    if (results.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            window.requestAnimationFrame(() => {
                (0, observers_1.computed)((query, cues) => {
                    if (!isLoading.getState()) {
                        replaceUrl(`search/${encodeURIComponent(query)}?cues=${cues}`, `Search`);
                        entities.update([]);
                        reachedEnd.updateState(false);
                        if (query === "") {
                            merger = undefined;
                        }
                        else {
                            merger = new SearchResultsMerger(token ?? "", query);
                            load();
                        }
                    }
                }, query, cues);
            });
            let headEntities = new observers_1.ArrayObservable([]);
            let tailEntities = new observers_1.ArrayObservable([]);
            entities.addObserver({
                onappend(entity) {
                    if (headEntities.getState().length === 0) {
                        headEntities.append(entity);
                    }
                    else {
                        tailEntities.append(entity);
                    }
                },
                onsplice(entity, index) {
                    if (index === 0) {
                        headEntities.update([]);
                    }
                    else {
                        tailEntities.splice(index - 1);
                    }
                }
            });
            let element = xml.element("div.content")
                .add(xml.element("div")
                .set("style", "align-items: center; display: grid; gap: 16px; grid-template-columns: 1fr auto;")
                .add(makeSearchField(query))
                .add(makeButton()
                .bind("data-active", cues.addObserver(a => a))
                .add(Icon.makeQuotationMark())
                .on("click", () => {
                cues.updateState(!cues.getState());
            })))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px;")
                .bind("data-hide", headEntities.compute((v) => v.length === 0))
                .repeat(headEntities, (entity) => EntityCard.forEntity(entity, { compactDescription: false })))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .bind("data-hide", tailEntities.compute((v) => v.length === 0))
                .repeat(tailEntities, (entity) => EntityRow.forEntity(entity)))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Search`
            };
        }
        else if ((parts = /^years[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let year_id = decodeURIComponent(parts[1]);
            return apiclient["GET:/years/<year_id>/"]({
                options: {
                    year_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let year = payload.year;
                return apiclient["GET:/years/<year_id>/movies/"]({
                    options: {
                        year_id,
                        token: token ?? "",
                        offset: 0,
                        anchor: undefined
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    let movies = payload.movies;
                    let offset = 0;
                    let reachedEnd = new observers_1.ObservableClass(false);
                    let isLoading = new observers_1.ObservableClass(false);
                    let albums = new observers_1.ArrayObservable([]);
                    let anchor = new observers_1.ObservableClass(undefined);
                    async function load() {
                        if (!reachedEnd.getState() && !isLoading.getState()) {
                            isLoading.updateState(true);
                            let response = await apiclient["GET:/years/<year_id>/albums/"]({
                                options: {
                                    year_id,
                                    token: token ?? "",
                                    anchor: anchor.getState()?.album_id,
                                    offset
                                }
                            });
                            let payload = await response.payload();
                            for (let album of payload.albums) {
                                albums.append(album);
                                anchor.updateState(album);
                            }
                            offset += payload.albums.length;
                            if (payload.albums.length === 0) {
                                reachedEnd.updateState(true);
                            }
                            isLoading.updateState(false);
                        }
                    }
                    ;
                    let element = xml.element("div")
                        .add(xml.element("div.content")
                        .add(EntityCard.forYear(year))
                        .add(xml.element("div")
                        .set("style", "display: grid; gap: 24px;")
                        .set("data-hide", `${movies.length === 0}`)
                        .add(renderTextHeader(xml.text("Movies")))
                        .add(carouselFactory.make(new observers_1.ArrayObservable(movies.map((movie) => EntityCard.forMovie(movie))))))
                        .add(xml.element("div")
                        .set("style", "display: grid; gap: 24px;")
                        .bind("data-hide", albums.compute((albums) => albums.length === 0))
                        .add(renderTextHeader(xml.text("Albums")))
                        .add(Grid.make()
                        .repeat(albums, (album) => EntityCard.forAlbum(album)))))
                        .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                        .render();
                    return {
                        element,
                        title: `${year.year}`
                    };
                });
            });
        }
        else if ((parts = /^years[/]([^/?]*)/.exec(uri)) !== null) {
            let query = decodeURIComponent(parts[1]);
            let offset = 0;
            let reachedEnd = new observers_1.ObservableClass(false);
            let isLoading = new observers_1.ObservableClass(false);
            let years = new observers_1.ArrayObservable([]);
            let anchor = new observers_1.ObservableClass(undefined);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await apiclient["GET:/years/<query>"]({
                        options: {
                            query,
                            token: token ?? "",
                            anchor: anchor.getState()?.year_id,
                            offset,
                            limit: 100
                        }
                    });
                    let payload = await response.payload();
                    for (let { entity } of payload.results) {
                        years.append(entity);
                        anchor.updateState(entity);
                    }
                    offset += payload.results.length;
                    if (payload.results.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            let element = xml.element("div")
                .add(xml.element("div.content")
                .add(Grid.make({ mini: true })
                .repeat(years, (year) => makeIconLink(Icon.makeCalendar(), `${year.year}`, `years/${year.year_id}/`))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render();
            return {
                element,
                title: `Years`
            };
        }
        else if ((parts = /^directories[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let directory_id = decodeURIComponent(parts[1]);
            return apiclient.getDirectory({
                options: {
                    directory_id: directory_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let directory = payload.directory;
                let reachedEnd = new observers_1.ObservableClass(false);
                let isLoading = new observers_1.ObservableClass(false);
                let directories = new observers_1.ArrayObservable([]);
                let files = new observers_1.ArrayObservable([]);
                let merger = new DirectoryContentMerger(token ?? "", directory_id);
                async function load() {
                    if (!reachedEnd.getState() && !isLoading.getState()) {
                        isLoading.updateState(true);
                        let results = await merger.fetch(12);
                        for (let { entity } of results) {
                            if (objects_2.Directory.is(entity)) {
                                directories.append(entity);
                            }
                            else {
                                files.append(entity);
                            }
                        }
                        if (results.length === 0) {
                            reachedEnd.updateState(true);
                        }
                        isLoading.updateState(false);
                    }
                }
                ;
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forDirectory(directory))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 16px;")
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 16px;")
                    .bind("data-hide", directories.compute((directories) => directories.length === 0))
                    .repeat(directories, (directory, directoryIndex) => {
                    return EntityRow.forDirectory(directory, {
                        playbackButton: undefined
                    });
                }))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 16px;")
                    .bind("data-hide", files.compute((files) => files.length === 0))
                    .repeat(files, (file, fileIndex) => {
                    return EntityRow.forFile(file, {
                        playbackButton: PlaybackButton.forDirectory(directory, fileIndex)
                    });
                }))))
                    .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                    .render();
                return {
                    element,
                    title: `${directory.name}`
                };
            });
        }
        else if ((parts = /^files[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let file_id = decodeURIComponent(parts[1]);
            return apiclient.getFile({
                options: {
                    file_id: file_id,
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let file = payload.file;
                let element = xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forFile(file, { compactDescription: false })))
                    .render();
                return {
                    element,
                    title: `${file.name}`
                };
            });
        }
        else {
            return apiclient["GET:/users/<user_id>/shows/"]({
                options: {
                    user_id: "",
                    token: token ?? ""
                }
            }).then(async (response) => {
                let payload = await response.payload();
                let shows = new observers_1.ArrayObservable(payload.shows);
                return apiclient.getUserArtists({
                    options: {
                        user_id: "",
                        token: token ?? ""
                    }
                }).then(async (response) => {
                    let payload = await response.payload();
                    let artists = new observers_1.ArrayObservable(payload.artists);
                    let offset = 0;
                    let reachedEnd = new observers_1.ObservableClass(false);
                    let isLoading = new observers_1.ObservableClass(false);
                    let albums = new observers_1.ArrayObservable([]);
                    let anchor = new observers_1.ObservableClass(undefined);
                    async function load() {
                        if (!reachedEnd.getState() && !isLoading.getState()) {
                            isLoading.updateState(true);
                            let response = await apiclient["GET:/users/<user_id>/albums/"]({
                                options: {
                                    user_id: "",
                                    token: token ?? "",
                                    anchor: anchor.getState()?.album_id,
                                    offset
                                }
                            });
                            let payload = await response.payload();
                            for (let album of payload.albums) {
                                albums.append(album);
                                anchor.updateState(album);
                            }
                            offset += payload.albums.length;
                            if (payload.albums.length === 0) {
                                reachedEnd.updateState(true);
                            }
                            isLoading.updateState(false);
                        }
                    }
                    ;
                    let element = xml.element("div")
                        .add(xml.element("div.content")
                        .add(Grid.make({ mini: true })
                        .add(makeIconLink(Icon.makeMonitor(), "Watch", "video/"))
                        .add(makeIconLink(Icon.makeSpeaker(), "Listen", "audio/"))
                        .add(makeIconLink(Icon.makeMagnifyingGlass(), "Search", "search/"))
                        .add(makeIconLink(Icon.makeCalendar(), "Years", "years/"))
                        .add(makeIconLink(Icon.makeFolder(), "Directories", "directories/0000000000000000/")))
                        .add(xml.element("div")
                        .set("style", "display: grid; gap: 24px")
                        .bind("data-hide", shows.compute((shows) => shows.length === 0))
                        .add(renderTextHeader(xml.text("Suggested shows")))
                        .add(carouselFactory.make((() => {
                        let widgets = new observers_1.ArrayObservable([]);
                        shows.addObserver({
                            onappend(show) {
                                widgets.append(EntityCard.forShow(show));
                            },
                            onsplice(show, index) {
                                widgets.splice(index);
                            }
                        });
                        return widgets;
                    })())))
                        .add(xml.element("div")
                        .set("style", "display: grid; gap: 24px")
                        .bind("data-hide", artists.compute((artists) => artists.length === 0))
                        .add(renderTextHeader(xml.text("Suggested artists")))
                        .add(carouselFactory.make((() => {
                        let widgets = new observers_1.ArrayObservable([]);
                        artists.addObserver({
                            onappend(artist) {
                                widgets.append(EntityCard.forArtist(artist));
                            },
                            onsplice(show, index) {
                                widgets.splice(index);
                            }
                        });
                        return widgets;
                    })())))
                        .add(xml.element("div")
                        .set("style", "display: grid; gap: 24px")
                        .bind("data-hide", albums.compute((albums) => albums.length === 0))
                        .add(renderTextHeader(xml.text("Suggested albums")))
                        .add(Grid.make()
                        .repeat(albums, (album) => EntityCard.forAlbum(album)))))
                        .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                        .render();
                    return {
                        element,
                        title: `Circus`
                    };
                });
            });
        }
    };
    let get_basehref = () => {
        let element = document.head.querySelector('base[href]');
        if (element !== null) {
            let attribute = element.getAttribute('href');
            if (attribute !== null) {
                return attribute;
            }
        }
        return "/";
    };
    let get_route = (pathname = window.location.pathname, basehref = get_basehref()) => {
        let pn = pathname.split('/');
        let bh = basehref.split('/');
        let i = 0;
        while (i < pn.length && i < bh.length && pn[i] === bh[i]) {
            i++;
        }
        let uri = pn.slice(i).join('/') + window.location.search;
        //return uri === '' ? './' : uri;
        return uri;
    };
    let mount_cache = new Array();
    let mounted_uri;
    function replaceUrl(uri, title) {
        if (mounted_uri != null) {
            let entry = mount_cache.find((entry) => entry.uri === mounted_uri);
            if (entry != null) {
                entry.uri = uri;
                entry.title = title;
                window.history.replaceState({ ...window.history.state, uri }, "", uri);
                document.title = title;
                mounted_uri = uri;
            }
        }
    }
    async function navigate(uri, use_cache = false) {
        hideModalMenu();
        if (is.absent(verifiedToken.getState())) {
            while (is.present(mount.lastChild)) {
                mount.lastChild.remove();
            }
            mount.appendChild(xml.element("div.content")
                .set("style", "max-width: 720px;")
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px;")
                .add(renderTextHeader(xml.text("Not logged in")))
                .add(renderTextParagraph(xml.text("Please login using your credentials or register a new user with your user information. The server operator, a.k.a. the circus manager, might require that you provide a valid registration key in order to register. Registration keys can be obtained from the circus manager and are consumed upon successful registration."))))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));")
                .add(xml.element("button")
                .add(xml.text("Login"))
                .on("click", async () => {
                showModal.updateState("login");
            }))
                .add(xml.element("button")
                .add(xml.text("Register"))
                .on("click", async () => {
                showModal.updateState("register");
            })))
                .render());
            return;
        }
        if (is.present(mounted_uri)) {
            let entry = mount_cache.find((entry) => entry.uri === mounted_uri);
            if (is.present(entry)) {
                mount_cache.splice(mount_cache.indexOf(entry), 1);
                entry.x = mount.scrollLeft;
                entry.y = mount.scrollTop;
            }
            else {
                entry = {
                    uri: mounted_uri,
                    element: mount.firstChild,
                    title: document.title,
                    x: mount.scrollLeft,
                    y: mount.scrollTop
                };
            }
            mount_cache.unshift(entry);
        }
        mount_cache = mount_cache.slice(0, 10);
        while (is.present(mount.lastChild)) {
            mount.lastChild.remove();
        }
        let entry = mount_cache.find((entry) => entry.uri === uri);
        if (is.present(entry) && use_cache) {
        }
        else {
            let { element, title } = await updateviewforuri(uri);
            entry = {
                uri: uri,
                element: element,
                title: title,
                x: 0,
                y: 0
            };
            mount_cache.unshift(entry);
        }
        mount.appendChild(entry.element);
        mount.scrollLeft = entry.x;
        mount.scrollTop = entry.y;
        if (is.absent(window.history.state)) {
            window.history.replaceState({ uri, index: historyIndex.getState() }, "", uri);
        }
        else {
            if (uri !== window.history.state.uri) {
                window.history.pushState({ uri, index: historyIndex.getState() + 1 }, "", uri);
                historyIndex.updateState(historyIndex.getState() + 1);
                historyLength.updateState(historyIndex.getState() + 1);
            }
            else {
                historyIndex.updateState(window.history.state.index);
            }
        }
        mounted_uri = entry.uri;
        document.title = entry.title;
    }
    function setupRouting() {
        window.addEventListener("popstate", (event) => {
            let uri = event.state.uri;
            navigate(uri, true);
        });
        verifiedToken.addObserver((verifiedToken) => {
            navigate(get_route());
        });
    }
    setupRouting();
    class ResultProvider {
        fetcher;
        anchor;
        results;
        exhausted;
        pending;
        index;
        constructor(fetcher) {
            this.fetcher = fetcher;
            this.anchor = undefined;
            this.results = [];
            this.exhausted = false;
            this.pending = false;
            this.index = 0;
        }
        async fetch() {
            if (this.exhausted || this.pending) {
                return [];
            }
            this.pending = true;
            let results = await this.fetcher(this.anchor);
            this.pending = false;
            if (results.length === 0) {
                this.exhausted = true;
                return [];
            }
            this.results.push(...results);
            this.anchor = results[results.length - 1].entity;
            this.index = this.results.length;
            return results;
        }
        async peek() {
            if (this.exhausted || this.pending) {
                return;
            }
            if (this.index >= this.results.length) {
                this.pending = true;
                let results = await this.fetcher(this.anchor);
                this.pending = false;
                if (results.length === 0) {
                    this.exhausted = true;
                    return;
                }
                this.results.push(...results);
            }
            let result = this.results[this.index];
            return result;
        }
        async read() {
            if (this.exhausted || this.pending) {
                return;
            }
            if (this.index >= this.results.length) {
                this.pending = true;
                let results = await this.fetcher(this.anchor);
                this.pending = false;
                if (results.length === 0) {
                    this.exhausted = true;
                    return;
                }
                this.results.push(...results);
            }
            let result = this.results[this.index];
            this.anchor = result.entity;
            this.index += 1;
            return result;
        }
    }
    ;
    class AlbumSearchResultProvider extends ResultProvider {
        constructor(token, query) {
            super(async (anchor) => {
                let response = await apiclient["GET:/albums/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.album_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
        }
    }
    ;
    class ArtistSearchResultProvider extends ResultProvider {
        constructor(token, query) {
            super(async (anchor) => {
                let response = await apiclient["GET:/artists/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.artist_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
        }
    }
    ;
    class PlaylistSearchResultProvider extends ResultProvider {
        constructor(token, query) {
            super(async (anchor) => {
                let response = await apiclient["GET:/playlists/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.playlist_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
        }
    }
    ;
    class ShowSearchResultProvider extends ResultProvider {
        constructor(token, query) {
            super(async (anchor) => {
                let response = await apiclient["GET:/shows/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.show_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
        }
    }
    ;
    class EpisodeSearchResultProvider extends ResultProvider {
        constructor(token, query) {
            super(async (anchor) => {
                let response = await apiclient["GET:/episodes/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.episode_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
        }
    }
    ;
    class MovieSearchResultProvider extends ResultProvider {
        constructor(token, query) {
            super(async (anchor) => {
                let response = await apiclient["GET:/movies/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.movie_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
        }
    }
    ;
    class TrackSearchResultProvider extends ResultProvider {
        constructor(token, query) {
            super(async (anchor) => {
                let response = await apiclient["GET:/tracks/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.track_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
        }
    }
    ;
    class SeasonSearchResultProvider extends ResultProvider {
        constructor(token, query) {
            super(async (anchor) => {
                let response = await apiclient["GET:/seasons/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.season_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
        }
    }
    ;
    class DiscSearchResultProvider extends ResultProvider {
        constructor(token, query) {
            super(async (anchor) => {
                let response = await apiclient["GET:/discs/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.disc_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
        }
    }
    ;
    class UserSearchResultProvider extends ResultProvider {
        constructor(token, query) {
            super(async (anchor) => {
                let response = await apiclient["GET:/users/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.user_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
        }
    }
    ;
    class ActorSearchResultProvider extends ResultProvider {
        constructor(token, query) {
            super(async (anchor) => {
                let response = await apiclient["GET:/actors/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.actor_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
        }
    }
    ;
    class ResultsMerger {
        providers;
        constructor(providers) {
            this.providers = providers;
        }
        async fetch(limit) {
            let entities = [];
            while (entities.length < limit) {
                let candidates = [];
                for (let provider of this.providers) {
                    let result = await provider.peek();
                    if (result == null) {
                        continue;
                    }
                    candidates.push({ result, provider });
                }
                this.providers = candidates.map((candidate) => candidate.provider);
                if (candidates.length === 0) {
                    break;
                }
                candidates.sort((one, two) => two.result.rank - one.result.rank);
                let candidate = candidates[0];
                await candidate.provider.read();
                entities.push(candidate.result);
            }
            return entities;
        }
    }
    ;
    class SearchResultsMerger extends ResultsMerger {
        constructor(token, query) {
            let actors = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/actors/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.actor_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let albums = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/albums/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.album_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let artists = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/artists/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.artist_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let discs = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/discs/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.disc_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let episodes = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/episodes/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.episode_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let genres = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/genres/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.genre_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let categories = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/categories/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.category_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let movies = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/movies/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.movie_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let seasons = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/seasons/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.season_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let playlists = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/playlists/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.playlist_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let shows = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/shows/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.show_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let tracks = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/tracks/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.track_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let users = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/users/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.user_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            let years = new ResultProvider(async (anchor) => {
                let response = await apiclient["GET:/years/<query>"]({
                    options: {
                        token,
                        query,
                        anchor: anchor?.year_id
                    }
                });
                let payload = await response.payload();
                return payload.results;
            });
            super([
                years,
                artists,
                albums,
                movies,
                shows,
                tracks,
                playlists,
                genres,
                categories,
                actors,
                users,
                episodes,
                seasons,
                discs
            ]);
        }
    }
    ;
    class DirectoryDirectoriesProvider extends ResultProvider {
        constructor(token, directory_id) {
            super(async (anchor) => {
                let response = await apiclient.getDirectoryDirectories({
                    options: {
                        directory_id,
                        token,
                        anchor: anchor?.directory_id
                    }
                });
                let payload = await response.payload();
                return payload.directories.map((directory) => ({
                    rank: 0,
                    entity: directory
                }));
            });
        }
    }
    ;
    class DirectoryFilesProvider extends ResultProvider {
        constructor(token, directory_id) {
            super(async (anchor) => {
                let response = await apiclient.getDirectoryFiles({
                    options: {
                        directory_id,
                        token,
                        anchor: anchor?.file_id
                    }
                });
                let payload = await response.payload();
                return payload.files.map((file) => ({
                    rank: 0,
                    entity: file
                }));
            });
        }
    }
    ;
    class DirectoryContentMerger extends ResultsMerger {
        constructor(token, directory_id) {
            let directories = new DirectoryDirectoriesProvider(token, directory_id);
            let files = new DirectoryFilesProvider(token, directory_id);
            super([
                directories,
                files
            ]);
        }
    }
    ;
});
function define(e,t,n){let l=define;function u(e){return require(e)}null==l.moduleStates&&(l.moduleStates=new Map),null==l.dependentsMap&&(l.dependentsMap=new Map);let i=l.moduleStates.get(e);if(null!=i)throw new Error("Duplicate module found with name "+e+"!");i={initializer:n,dependencies:t,module:null},l.moduleStates.set(e,i);for(let n of t){let t=l.dependentsMap.get(n);null==t&&(t=new Set,l.dependentsMap.set(n,t)),t.add(e)}!function e(t){let n=l.moduleStates.get(t);if(null==n||null!=n.module)return;let i=Array(),o={exports:{}};for(let e of n.dependencies){if("require"===e){i.push(u);continue}if("module"===e){i.push(o);continue}if("exports"===e){i.push(o.exports);continue}try{i.push(u(e));continue}catch(e){}let t=l.moduleStates.get(e);if(null==t||null==t.module)return;i.push(t.module.exports)}"function"==typeof n.initializer?n.initializer(...i):o.exports=n.initializer,n.module=o;let d=l.dependentsMap.get(t);if(null!=d)for(let t of d)e(t)}(e)}