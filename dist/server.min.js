var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageSerializer = exports.MessageGuardError = void 0;
    class MessageGuardError {
        constructor(guard, subject, path) {
            this.guard = guard;
            this.subject = subject;
            this.path = path;
        }
        getSubjectType() {
            if (this.subject === null) {
                return "null";
            }
            if (this.subject instanceof Array) {
                return "array";
            }
            return typeof this.subject;
        }
        toString() {
            return `The type ${this.getSubjectType()} at ${this.path} is type-incompatible with the expected type: ${this.guard.ts()}`;
        }
    }
    exports.MessageGuardError = MessageGuardError;
    ;
    class MessageSerializer {
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let json = JSON.parse(string);
            if ((json != null) && (json.constructor === Object)) {
                if ((json.type != null) && (json.type.constructor === String)) {
                    let type = json.type;
                    let data = json.data;
                    let guard = this.guards[type];
                    if (guard === undefined) {
                        throw "Unknown message type \"" + type + "\"!";
                    }
                    cb(type, guard.as(data));
                    return;
                }
            }
            throw "Invalid message envelope!";
        }
        serialize(type, data) {
            return JSON.stringify({
                type,
                data
            });
        }
    }
    exports.MessageSerializer = MessageSerializer;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/guards", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization"], function (require, exports, serialization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Union = exports.Undefined = exports.Tuple = exports.StringLiteral = exports.String = exports.Reference = exports.Record = exports.Object = exports.NumberLiteral = exports.Number = exports.Null = exports.Intersection = exports.Group = exports.BooleanLiteral = exports.Boolean = exports.Array = exports.Any = void 0;
    exports.Any = {
        as(subject, path = "") {
            return subject;
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `any`;
        }
    };
    exports.Array = {
        of(guard) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Array)) {
                        for (let i = 0; i < subject.length; i++) {
                            guard.as(subject[i], path + "[" + i + "]");
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `array<${guard.ts(eol)}>`;
                }
            };
        }
    };
    exports.Boolean = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Boolean)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `boolean`;
        }
    };
    exports.BooleanLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `${value}`;
                }
            };
        }
    };
    exports.Group = {
        of(guard, name) {
            return {
                as(subject, path = "") {
                    return guard.as(subject, path);
                },
                is(subject) {
                    return guard.is(subject);
                },
                ts(eol = "\n") {
                    return name !== null && name !== void 0 ? name : guard.ts(eol);
                }
            };
        }
    };
    exports.Intersection = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    for (let guard of guards) {
                        guard.as(subject, path);
                    }
                    return subject;
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let guard of guards) {
                        lines.push("\t" + guard.ts(eol + "\t"));
                    }
                    return "intersection<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
    exports.Null = {
        as(subject, path = "") {
            if (subject === null) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `null`;
        }
    };
    exports.Number = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Number)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `number`;
        }
    };
    exports.NumberLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `${value}`;
                }
            };
        }
    };
    exports.Object = {
        of(guards) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Object)) {
                        for (let key in guards) {
                            guards[key].as(subject[key], path + (/^([a-z][a-z0-9_]*)$/isu.test(key) ? "." + key : "[\"" + key + "\"]"));
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let [key, value] of globalThis.Object.entries(guards)) {
                        lines.push(`\t"${key}": ${value.ts(eol + "\t")}`);
                    }
                    return "object<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
    exports.Record = {
        of(guard) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Object)) {
                        let wrapped = exports.Union.of(exports.Undefined, guard);
                        for (let key of globalThis.Object.keys(subject)) {
                            wrapped.as(subject[key], path + "[\"" + key + "\"]");
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `record<${guard.ts(eol)}>`;
                }
            };
        }
    };
    exports.Reference = {
        of(guard) {
            return {
                as(subject, path = "") {
                    return guard().as(subject, path);
                },
                is(subject) {
                    return guard().is(subject);
                },
                ts(eol = "\n") {
                    return guard().ts(eol);
                }
            };
        }
    };
    exports.String = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.String)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return "string";
        }
    };
    exports.StringLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `"${value}"`;
                }
            };
        }
    };
    exports.Tuple = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Array)) {
                        for (let i = 0; i < guards.length; i++) {
                            guards[i].as(subject[i], path + "[" + i + "]");
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let guard of guards) {
                        lines.push(`\t${guard.ts(eol + "\t")}`);
                    }
                    return "tuple<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
    exports.Undefined = {
        as(subject, path = "") {
            if (subject === undefined) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return "undefined";
        }
    };
    exports.Union = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    for (let guard of guards) {
                        try {
                            return guard.as(subject, path);
                        }
                        catch (error) { }
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let guard of guards) {
                        lines.push("\t" + guard.ts(eol + "\t"));
                    }
                    return "union<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/api", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards"], function (require, exports, guards) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __asyncValues = (this && this.__asyncValues) || function (o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializePayload = exports.deserializeStringPayload = exports.compareArrays = exports.serializePayload = exports.serializeStringPayload = exports.collectPayload = exports.deserializeValue = exports.serializeValue = exports.Headers = exports.Options = exports.JSON = exports.Primitive = exports.Binary = exports.SyncBinary = exports.AsyncBinary = exports.decodeUndeclaredHeaders = exports.decodeHeaderValue = exports.decodeHeaderValues = exports.decodeUndeclaredParameters = exports.decodeParameterValue = exports.decodeParameterValues = exports.encodeUndeclaredParameterPairs = exports.encodeParameterPairs = exports.escapeParameterValue = exports.escapeParameterKey = exports.encodeComponents = exports.escapeComponent = exports.encodeUndeclaredHeaderPairs = exports.encodeHeaderPairs = exports.escapeHeaderValue = exports.escapeHeaderKey = exports.splitHeaders = exports.combineParameters = exports.splitParameters = exports.combineComponents = exports.splitComponents = exports.decodeURIComponent = void 0;
    function decodeURIComponent(string) {
        try {
            return globalThis.decodeURIComponent(string);
        }
        catch (error) { }
    }
    exports.decodeURIComponent = decodeURIComponent;
    ;
    function splitComponents(url) {
        let components = new Array();
        for (let part of url.split("?")[0].split("/").slice(1)) {
            components.push(part);
        }
        return components;
    }
    exports.splitComponents = splitComponents;
    ;
    function combineComponents(components) {
        return "/" + components.join("/");
    }
    exports.combineComponents = combineComponents;
    ;
    function splitParameters(url) {
        let parameters = new Array();
        let query = url.split("?").slice(1).join("?");
        if (query !== "") {
            for (let part of query.split("&")) {
                let parts = part.split("=");
                if (parts.length === 1) {
                    let key = parts[0];
                    let value = "";
                    parameters.push([key, value]);
                }
                else {
                    let key = parts[0];
                    let value = parts.slice(1).join("=");
                    parameters.push([key, value]);
                }
            }
        }
        return parameters;
    }
    exports.splitParameters = splitParameters;
    ;
    function combineParameters(parameters) {
        let parts = parameters.map((parameters) => {
            let key = parameters[0];
            let value = parameters[1];
            return `${key}=${value}`;
        });
        if (parts.length === 0) {
            return "";
        }
        return `?${parts.join("&")}`;
    }
    exports.combineParameters = combineParameters;
    ;
    function splitHeaders(lines) {
        return lines.map((part) => {
            let parts = part.split(":");
            if (parts.length === 1) {
                let key = parts[0].toLowerCase();
                let value = "";
                return [key, value];
            }
            else {
                let key = parts[0].toLowerCase();
                let value = parts.slice(1).join(":").trim();
                return [key, value];
            }
        });
    }
    exports.splitHeaders = splitHeaders;
    ;
    const RFC7320_DELIMITERS = "\"(),/:;<=>?@[\\]{}";
    const RFC7320_WHITESPACE = "\t ";
    // The specification (rfc7320) allows octets 33-126 and forbids delimiters. Octets 128-255 have been deprecated since rfc2616.
    function escapeHeaderKey(string, alwaysEncode = "") {
        return escapeHeaderValue(string, RFC7320_DELIMITERS + RFC7320_WHITESPACE + alwaysEncode);
    }
    exports.escapeHeaderKey = escapeHeaderKey;
    ;
    // The specification (rfc7320) allows octets 33-126 and whitespace. Octets 128-255 have been deprecated since rfc2616.
    function escapeHeaderValue(string, alwaysEncode = "") {
        return [...string]
            .map((codePointString) => {
            var _a;
            if (!alwaysEncode.includes(codePointString) && codePointString !== "%") {
                let codePoint = (_a = codePointString.codePointAt(0)) !== null && _a !== void 0 ? _a : 0;
                if (codePoint >= 33 && codePoint <= 126) {
                    return codePointString;
                }
                if (RFC7320_WHITESPACE.includes(codePointString)) {
                    return codePointString;
                }
            }
            return encodeURIComponent(codePointString);
        })
            .join("");
    }
    exports.escapeHeaderValue = escapeHeaderValue;
    ;
    function encodeHeaderPairs(key, values, plain) {
        let pairs = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                if (plain) {
                    pairs.push([
                        escapeHeaderKey(key),
                        escapeHeaderValue(serialized)
                    ]);
                }
                else {
                    pairs.push([
                        escapeHeaderKey(key),
                        escapeHeaderKey(serialized)
                    ]);
                }
            }
        }
        return pairs;
    }
    exports.encodeHeaderPairs = encodeHeaderPairs;
    ;
    function encodeUndeclaredHeaderPairs(record, exclude) {
        let pairs = new Array();
        for (let [key, value] of Object.entries(record)) {
            if (!exclude.includes(key) && value !== undefined) {
                if (guards.String.is(value)) {
                    pairs.push(...encodeHeaderPairs(key, [value], true));
                }
                else if (guards.Array.of(guards.String).is(value)) {
                    pairs.push(...encodeHeaderPairs(key, value, true));
                }
                else {
                    throw `Expected type of undeclared header "${key}" to be string or string[]!`;
                }
            }
        }
        return pairs;
    }
    exports.encodeUndeclaredHeaderPairs = encodeUndeclaredHeaderPairs;
    ;
    function escapeComponent(string) {
        return encodeURIComponent(string);
    }
    exports.escapeComponent = escapeComponent;
    ;
    function encodeComponents(values, plain) {
        let array = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                array.push(escapeComponent(serialized));
            }
        }
        return array;
    }
    exports.encodeComponents = encodeComponents;
    ;
    function escapeParameterKey(string) {
        return encodeURIComponent(string);
    }
    exports.escapeParameterKey = escapeParameterKey;
    ;
    function escapeParameterValue(string) {
        return encodeURIComponent(string);
    }
    exports.escapeParameterValue = escapeParameterValue;
    ;
    function encodeParameterPairs(key, values, plain) {
        let pairs = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                pairs.push([
                    escapeParameterKey(key),
                    escapeParameterValue(serialized)
                ]);
            }
        }
        return pairs;
    }
    exports.encodeParameterPairs = encodeParameterPairs;
    ;
    function encodeUndeclaredParameterPairs(record, exclude) {
        let pairs = new Array();
        for (let [key, value] of Object.entries(record)) {
            if (!exclude.includes(key) && value !== undefined) {
                if (guards.String.is(value)) {
                    pairs.push(...encodeParameterPairs(key, [value], true));
                }
                else if (guards.Array.of(guards.String).is(value)) {
                    pairs.push(...encodeParameterPairs(key, value, true));
                }
                else {
                    throw `Expected type of undeclared parameter "${key}" to be string or string[]!`;
                }
            }
        }
        return pairs;
    }
    exports.encodeUndeclaredParameterPairs = encodeUndeclaredParameterPairs;
    ;
    function decodeParameterValues(pairs, key, plain) {
        let values = new Array();
        for (let pair of pairs) {
            if (key === decodeURIComponent(pair[0])) {
                let parts = pair[1].split(",");
                for (let part of parts) {
                    let value = deserializeValue(decodeURIComponent(part), plain);
                    if (value === undefined) {
                        throw `Expected parameter "${key}" to be properly encoded!`;
                    }
                    values.push(value);
                }
            }
        }
        return values;
    }
    exports.decodeParameterValues = decodeParameterValues;
    ;
    function decodeParameterValue(pairs, key, plain) {
        let values = decodeParameterValues(pairs, key, plain);
        if (values.length > 1) {
            throw `Expected no more than one "${key}" parameter!`;
        }
        return values[0];
    }
    exports.decodeParameterValue = decodeParameterValue;
    ;
    function decodeUndeclaredParameters(pairs, exclude) {
        let map = {};
        for (let pair of pairs) {
            let key = decodeURIComponent(pair[0]);
            let value = decodeURIComponent(pair[1]);
            if (key === undefined || value === undefined) {
                throw `Expected undeclared parameter "${key}" to be properly encoded!`;
            }
            if (!exclude.includes(key)) {
                let values = map[key];
                if (values === undefined) {
                    values = new Array();
                    map[key] = values;
                }
                values.push(value);
            }
        }
        let record = {};
        for (let [key, value] of Object.entries(map)) {
            if (value.length === 1) {
                record[key] = value[0];
            }
            else {
                record[key] = value;
            }
        }
        return record;
    }
    exports.decodeUndeclaredParameters = decodeUndeclaredParameters;
    ;
    function decodeHeaderValues(pairs, key, plain) {
        let values = new Array();
        for (let pair of pairs) {
            if (key === decodeURIComponent(pair[0])) {
                let parts = pair[1].split(",");
                for (let part of parts) {
                    let value = deserializeValue(decodeURIComponent(part.trim()), plain);
                    if (value === undefined) {
                        throw `Expected header "${key}" to be properly encoded!`;
                    }
                    values.push(value);
                }
            }
        }
        return values;
    }
    exports.decodeHeaderValues = decodeHeaderValues;
    ;
    function decodeHeaderValue(pairs, key, plain) {
        let values = decodeHeaderValues(pairs, key, plain);
        if (values.length > 1) {
            throw `Expected no more than one "${key}" header!`;
        }
        return values[0];
    }
    exports.decodeHeaderValue = decodeHeaderValue;
    ;
    function decodeUndeclaredHeaders(pairs, exclude) {
        let map = {};
        for (let pair of pairs) {
            let key = decodeURIComponent(pair[0]);
            let value = decodeURIComponent(pair[1]);
            if (key === undefined || value === undefined) {
                throw `Expected undeclared header "${key}" to be properly encoded!`;
            }
            if (!exclude.includes(key)) {
                let values = map[key];
                if (values === undefined) {
                    values = new Array();
                    map[key] = values;
                }
                values.push(value);
            }
        }
        let record = {};
        for (let [key, value] of Object.entries(map)) {
            if (value.length === 1) {
                record[key] = value[0];
            }
            else {
                record[key] = value;
            }
        }
        return record;
    }
    exports.decodeUndeclaredHeaders = decodeUndeclaredHeaders;
    ;
    exports.AsyncBinary = {
        as(subject, path = "") {
            if (subject != null) {
                let member = subject[Symbol.asyncIterator];
                if (member != null && member.constructor === globalThis.Function) {
                    return subject;
                }
            }
            throw "Expected AsyncBinary at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `AsyncBinary`;
        }
    };
    exports.SyncBinary = {
        as(subject, path = "") {
            if (subject != null) {
                let member = subject[Symbol.iterator];
                if (member != null && member.constructor === globalThis.Function) {
                    return subject;
                }
            }
            throw "Expected SyncBinary at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `SyncBinary`;
        }
    };
    exports.Binary = guards.Union.of(exports.AsyncBinary, exports.SyncBinary);
    exports.Primitive = guards.Union.of(guards.Boolean, guards.Number, guards.String, guards.Undefined);
    exports.JSON = guards.Group.of(guards.Union.of(guards.Boolean, guards.Null, guards.Number, guards.String, guards.Array.of(guards.Reference.of(() => exports.JSON)), guards.Record.of(guards.Reference.of(() => exports.JSON)), guards.Undefined), "JSON");
    exports.Options = guards.Record.of(exports.JSON);
    exports.Headers = guards.Record.of(exports.JSON);
    function serializeValue(value, plain) {
        if (value === undefined) {
            return;
        }
        return plain ? String(value) : globalThis.JSON.stringify(value);
    }
    exports.serializeValue = serializeValue;
    ;
    function deserializeValue(value, plain) {
        if (value === undefined || plain) {
            return value;
        }
        try {
            return globalThis.JSON.parse(value);
        }
        catch (error) { }
    }
    exports.deserializeValue = deserializeValue;
    ;
    function collectPayload(binary) {
        var binary_1, binary_1_1;
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            let chunks = new Array();
            let length = 0;
            try {
                for (binary_1 = __asyncValues(binary); binary_1_1 = yield binary_1.next(), !binary_1_1.done;) {
                    let chunk = binary_1_1.value;
                    chunks.push(chunk);
                    length += chunk.length;
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (binary_1_1 && !binary_1_1.done && (_a = binary_1.return))
                        yield _a.call(binary_1);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            let payload = new Uint8Array(length);
            let offset = 0;
            for (let chunk of chunks) {
                payload.set(chunk, offset);
                offset += chunk.length;
            }
            return payload;
        });
    }
    exports.collectPayload = collectPayload;
    ;
    function serializeStringPayload(string) {
        // @ts-ignore
        let encoder = new TextEncoder();
        let array = encoder.encode(string);
        return [array];
    }
    exports.serializeStringPayload = serializeStringPayload;
    ;
    function serializePayload(payload) {
        let serialized = serializeValue(payload, false);
        if (serialized === undefined) {
            return [];
        }
        return serializeStringPayload(serialized);
    }
    exports.serializePayload = serializePayload;
    ;
    function compareArrays(one, two) {
        if (one.length !== two.length) {
            return false;
        }
        for (let i = 0; i < one.length; i++) {
            if (one[i] !== two[i]) {
                return false;
            }
        }
        return true;
    }
    exports.compareArrays = compareArrays;
    ;
    function deserializeStringPayload(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            let buffer = yield collectPayload(binary);
            // @ts-ignore
            let decoder = new TextDecoder();
            let string = decoder.decode(buffer);
            // @ts-ignore
            let encoder = new TextEncoder();
            let encoded = encoder.encode(string);
            if (!compareArrays(buffer, encoded)) {
                throw `Expected payload to be UTF-8 encoded!`;
            }
            return string;
        });
    }
    exports.deserializeStringPayload = deserializeStringPayload;
    ;
    function deserializePayload(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            let string = yield deserializeStringPayload(binary);
            if (string === "") {
                return;
            }
            let value = deserializeValue(string, false);
            if (value === undefined) {
                throw `Expected payload to be JSON encoded!`;
            }
            return value;
        });
    }
    exports.deserializePayload = deserializePayload;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/api", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards", "node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization"], function (require, exports, api, guards, serialization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialization = exports.guards = exports.api = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialization = exports.guards = exports.api = void 0;
    exports.api = api;
    exports.guards = guards;
    exports.serialization = serialization;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-server/api", ["require", "exports", "fs", "http", "https", "path", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-autoguard/dist/lib-shared/api"], function (require, exports, libfs, libhttp, libhttps, libpath, shared, api_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (this && this.__exportStar) || function (m, exports) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
                __createBinding(exports, m, p);
    };
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __asyncValues = (this && this.__asyncValues) || function (o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeReadStreamResponse = exports.makeDirectoryListing = exports.getContentTypeFromExtension = exports.parseRangeHeader = exports.route = exports.respond = exports.finalizeResponse = exports.acceptsMethod = exports.acceptsComponents = exports.makeNodeRequestHandler = exports.combineNodeRawHeaders = exports.DynamicRouteMatcher = exports.StaticRouteMatcher = exports.ClientRequest = exports.EndpointError = void 0;
    __exportStar(api_1, exports);
    class EndpointError {
        constructor(response) {
            this.response = response;
        }
        getResponse() {
            var _a, _b, _c;
            let status = (_a = this.response.status) !== null && _a !== void 0 ? _a : 500;
            let headers = (_b = this.response.headers) !== null && _b !== void 0 ? _b : [];
            let payload = (_c = this.response.payload) !== null && _c !== void 0 ? _c : [];
            return {
                status,
                headers,
                payload
            };
        }
    }
    exports.EndpointError = EndpointError;
    ;
    class ClientRequest {
        constructor(request, collect, auxillary) {
            this.request = request;
            this.collect = collect;
            this.auxillary = auxillary;
        }
        options() {
            let options = this.request.options;
            return Object.assign({}, options);
        }
        headers() {
            let headers = this.request.headers;
            return Object.assign({}, headers);
        }
        payload() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.collectedPayload !== undefined) {
                    return this.collectedPayload;
                }
                let payload = this.request.payload;
                let collectedPayload = (this.collect ? yield shared.api.collectPayload(payload) : payload);
                this.collectedPayload = collectedPayload;
                return collectedPayload;
            });
        }
        socket() {
            return this.auxillary.socket;
        }
    }
    exports.ClientRequest = ClientRequest;
    ;
    ;
    class StaticRouteMatcher {
        constructor(string) {
            this.string = string;
            this.accepted = false;
        }
        acceptComponent(component) {
            if (this.accepted) {
                return false;
            }
            this.accepted = component === this.string;
            return this.accepted;
        }
        getValue() {
            return this.string;
        }
        isSatisfied() {
            return this.accepted;
        }
    }
    exports.StaticRouteMatcher = StaticRouteMatcher;
    ;
    class DynamicRouteMatcher {
        constructor(minOccurences, maxOccurences, plain, guard) {
            this.minOccurences = minOccurences;
            this.maxOccurences = maxOccurences;
            this.plain = plain;
            this.guard = guard;
            this.values = new Array();
        }
        acceptComponent(component) {
            if (this.values.length >= this.maxOccurences) {
                return false;
            }
            try {
                let value = shared.api.deserializeValue(component, this.plain);
                if (this.guard.is(value)) {
                    this.values.push(value);
                    return true;
                }
            }
            catch (error) { }
            return false;
        }
        getValue() {
            if (this.maxOccurences === 1) {
                return this.values[0];
            }
            else {
                return this.values;
            }
        }
        isSatisfied() {
            return this.minOccurences <= this.values.length && this.values.length <= this.maxOccurences;
        }
    }
    exports.DynamicRouteMatcher = DynamicRouteMatcher;
    ;
    function combineNodeRawHeaders(raw) {
        let headers = new Array();
        for (let i = 0; i < raw.length; i += 2) {
            headers.push(`${raw[i + 0]}: ${raw[i + 1]}`);
        }
        return headers;
    }
    exports.combineNodeRawHeaders = combineNodeRawHeaders;
    ;
    function makeNodeRequestHandler(options) {
        return (raw, urlPrefix) => {
            let lib = (urlPrefix !== null && urlPrefix !== void 0 ? urlPrefix : "").startsWith("https:") ? libhttps : libhttp;
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let payload = yield shared.api.collectPayload(raw.payload);
                let headers = {
                    "Content-Length": [`${payload.length}`]
                };
                for (let header of raw.headers) {
                    let key = header[0];
                    let value = header[1];
                    let values = headers[key];
                    if (values === undefined) {
                        values = new Array();
                        headers[key] = values;
                    }
                    values.push(value);
                }
                let url = urlPrefix !== null && urlPrefix !== void 0 ? urlPrefix : "";
                url += shared.api.combineComponents(raw.components);
                url += shared.api.combineParameters(raw.parameters);
                let request = lib.request(url, Object.assign(Object.assign({}, options), { method: raw.method, headers: headers }), (response) => {
                    var _a;
                    let status = (_a = response.statusCode) !== null && _a !== void 0 ? _a : 200;
                    let headers = shared.api.splitHeaders(combineNodeRawHeaders(response.rawHeaders));
                    let payload = {
                        [Symbol.asyncIterator]: () => response[Symbol.asyncIterator]()
                    };
                    resolve({ status, headers, payload });
                });
                request.on("abort", reject);
                request.on("error", reject);
                request.write(payload);
                request.end();
            }));
        };
    }
    exports.makeNodeRequestHandler = makeNodeRequestHandler;
    ;
    function acceptsComponents(components, matchers) {
        let currentMatcher = 0;
        outer: for (let component of components) {
            let decoded = decodeURIComponent(component);
            if (decoded === undefined) {
                throw `Expected component to be properly encoded!`;
            }
            inner: for (let matcher of matchers.slice(currentMatcher)) {
                if (matcher.acceptComponent(decoded)) {
                    continue outer;
                }
                else {
                    if (matcher.isSatisfied()) {
                        currentMatcher += 1;
                        continue inner;
                    }
                    else {
                        break outer;
                    }
                }
            }
            break outer;
        }
        if (currentMatcher >= matchers.length) {
            return false;
        }
        for (let matcher of matchers.slice(currentMatcher)) {
            if (!matcher.isSatisfied()) {
                return false;
            }
        }
        return true;
    }
    exports.acceptsComponents = acceptsComponents;
    ;
    function acceptsMethod(one, two) {
        return one === two;
    }
    exports.acceptsMethod = acceptsMethod;
    ;
    function finalizeResponse(raw, defaultHeaders) {
        let headersToAppend = defaultHeaders.filter((defaultHeader) => {
            let found = raw.headers.find((header) => header[0].toLowerCase() === defaultHeader[0].toLowerCase());
            return found === undefined;
        });
        return Object.assign(Object.assign({}, raw), { headers: [
                ...raw.headers,
                ...headersToAppend
            ] });
    }
    exports.finalizeResponse = finalizeResponse;
    ;
    function respond(httpResponse, raw) {
        var e_1, _a;
        var _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let rawHeaders = new Array();
            for (let header of (_b = raw.headers) !== null && _b !== void 0 ? _b : []) {
                rawHeaders.push(...header);
            }
            httpResponse.writeHead((_c = raw.status) !== null && _c !== void 0 ? _c : 200, rawHeaders);
            try {
                for (var _e = __asyncValues((_d = raw.payload) !== null && _d !== void 0 ? _d : []), _f; _f = yield _e.next(), !_f.done;) {
                    let chunk = _f.value;
                    if (!httpResponse.write(chunk)) {
                        yield new Promise((resolve, reject) => {
                            httpResponse.once("drain", resolve);
                        });
                    }
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_f && !_f.done && (_a = _e.return))
                        yield _a.call(_e);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            httpResponse.end();
            yield new Promise((resolve, reject) => {
                httpResponse.once("finish", resolve);
            });
        });
    }
    exports.respond = respond;
    ;
    function route(endpoints, httpRequest, httpResponse, serverOptions) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            let urlPrefix = (_a = serverOptions === null || serverOptions === void 0 ? void 0 : serverOptions.urlPrefix) !== null && _a !== void 0 ? _a : "";
            let method = (_b = httpRequest.method) !== null && _b !== void 0 ? _b : "GET";
            let url = (_c = httpRequest.url) !== null && _c !== void 0 ? _c : "";
            if (!url.startsWith(urlPrefix)) {
                throw `Expected url "${url}" to have prefix "${urlPrefix}"!`;
            }
            url = url.slice(urlPrefix.length);
            try {
                let components = shared.api.splitComponents(url);
                let parameters = shared.api.splitParameters(url);
                let headers = shared.api.splitHeaders(combineNodeRawHeaders(httpRequest.rawHeaders));
                let payload = {
                    [Symbol.asyncIterator]: () => httpRequest[Symbol.asyncIterator]()
                };
                let socket = httpRequest.socket;
                let raw = {
                    method,
                    components,
                    parameters,
                    headers,
                    payload
                };
                let auxillary = {
                    socket
                };
                let filteredEndpoints = endpoints.map((endpoint) => endpoint(raw, auxillary));
                filteredEndpoints = filteredEndpoints.filter((endpoint) => endpoint.acceptsComponents());
                if (filteredEndpoints.length === 0) {
                    return respond(httpResponse, {
                        status: 404
                    });
                }
                filteredEndpoints = filteredEndpoints.filter((endpoint) => endpoint.acceptsMethod());
                if (filteredEndpoints.length === 0) {
                    return respond(httpResponse, {
                        status: 405
                    });
                }
                let endpoint = filteredEndpoints[0];
                let valid = yield endpoint.validateRequest();
                try {
                    let handled = yield valid.handleRequest();
                    try {
                        let raw = yield handled.validateResponse();
                        return yield respond(httpResponse, raw);
                    }
                    catch (error) {
                        return respond(httpResponse, {
                            status: 500,
                            payload: shared.api.serializeStringPayload(String(error))
                        });
                    }
                }
                catch (error) {
                    if (Number.isInteger(error) && error >= 100 && error <= 999) {
                        return respond(httpResponse, {
                            status: error
                        });
                    }
                    if (error instanceof EndpointError) {
                        let raw = error.getResponse();
                        return respond(httpResponse, raw);
                    }
                    return respond(httpResponse, {
                        status: 500
                    });
                }
            }
            catch (error) {
                return respond(httpResponse, {
                    status: 400,
                    payload: shared.api.serializeStringPayload(String(error))
                });
            }
        });
    }
    exports.route = route;
    ;
    // TODO: Move to Nexus in v6.
    function parseRangeHeader(value, size) {
        var _a, _b, _c;
        if (value === undefined) {
            return {
                status: 200,
                offset: 0,
                length: size,
                size: size
            };
        }
        let s416 = {
            status: 416,
            offset: 0,
            length: 0,
            size: size
        };
        let parts;
        parts = (_a = /^bytes[=]([0-9]+)[-]$/.exec(String(value))) !== null && _a !== void 0 ? _a : undefined;
        if (parts !== undefined) {
            let one = Number.parseInt(parts[1], 10);
            if (one >= size) {
                return s416;
            }
            return {
                status: 206,
                offset: one,
                length: size - one,
                size: size
            };
        }
        parts = (_b = /^bytes[=]([0-9]+)[-]([0-9]+)$/.exec(String(value))) !== null && _b !== void 0 ? _b : undefined;
        if (parts !== undefined) {
            let one = Number.parseInt(parts[1], 10);
            let two = Number.parseInt(parts[2], 10);
            if (two < one) {
                return s416;
            }
            if (one >= size) {
                return s416;
            }
            if (two >= size) {
                two = size - 1;
            }
            return {
                status: 206,
                offset: one,
                length: two - one + 1,
                size: size
            };
        }
        parts = (_c = /^bytes[=][-]([0-9]+)$/.exec(String(value))) !== null && _c !== void 0 ? _c : undefined;
        if (parts !== undefined) {
            let one = Number.parseInt(parts[1], 10);
            if (one < 1) {
                return s416;
            }
            if (size < 1) {
                return s416;
            }
            if (one > size) {
                one = size;
            }
            return {
                status: 206,
                offset: size - one,
                length: one,
                size: size
            };
        }
        return s416;
    }
    exports.parseRangeHeader = parseRangeHeader;
    ;
    // TODO: Move to Nexus in v6.
    function getContentTypeFromExtension(extension) {
        let extensions = {
            ".css": "text/css",
            ".htm": "text/html",
            ".html": "text/html",
            ".jpg": "image/jpeg",
            ".jpeg": "image/jpeg",
            ".js": "text/javascript",
            ".json": "application/json",
            ".png": "image/png",
            ".svg": "image/svg+xml"
        };
        return extensions[extension];
    }
    exports.getContentTypeFromExtension = getContentTypeFromExtension;
    ;
    // TODO: Move to Nexus in v6.
    function makeDirectoryListing(pathPrefix, pathSuffix, request) {
        let pathSuffixParts = libpath.normalize(pathSuffix).split(libpath.sep);
        if (pathSuffixParts[0] === "..") {
            throw 400;
        }
        if (pathSuffixParts[pathSuffixParts.length - 1] !== "") {
            pathSuffixParts.push("");
        }
        let fullPath = libpath.join(pathPrefix, ...pathSuffixParts);
        if (!libfs.existsSync(fullPath) || !libfs.statSync(fullPath).isDirectory()) {
            throw 404;
        }
        let entries = libfs.readdirSync(fullPath, { withFileTypes: true });
        let directories = entries
            .filter((entry) => entry.isDirectory())
            .map((entry) => {
            return {
                name: entry.name
            };
        })
            .sort((one, two) => one.name.localeCompare(two.name));
        let files = entries
            .filter((entry) => entry.isFile())
            .map((entry) => {
            let stat = libfs.statSync(libpath.join(fullPath, entry.name));
            return {
                name: entry.name,
                size: stat.size,
                timestamp: stat.mtime.valueOf()
            };
        })
            .sort((one, two) => one.name.localeCompare(two.name));
        let components = pathSuffixParts;
        return {
            components,
            directories,
            files
        };
    }
    exports.makeDirectoryListing = makeDirectoryListing;
    ;
    // TODO: Move to Nexus in v6.
    function makeReadStreamResponse(pathPrefix, pathSuffix, request) {
        if (libpath.normalize(pathSuffix).split(libpath.sep)[0] === "..") {
            throw 400;
        }
        let path = libpath.join(pathPrefix, pathSuffix);
        while (libfs.existsSync(path) && libfs.statSync(path).isDirectory()) {
            path = libpath.join(path, "index.html");
        }
        if (!libfs.existsSync(path)) {
            throw 404;
        }
        let stat = libfs.statSync(path);
        let range = parseRangeHeader(request.headers().range, stat.size);
        let stream = libfs.createReadStream(path, {
            start: range.offset,
            end: range.offset + range.length
        });
        return {
            status: range.status,
            headers: {
                "Accept-Ranges": "bytes",
                "Content-Length": `${range.length}`,
                "Content-Range": range.length > 0 ? `bytes ${range.offset}-${range.offset + range.length - 1}/${range.size}` : `bytes */${range.size}`,
                "Content-Type": getContentTypeFromExtension(libpath.extname(path)),
                "Last-Modified": stat.mtime.toUTCString()
            },
            payload: stream
        };
    }
    exports.makeReadStreamResponse = makeReadStreamResponse;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-server/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-autoguard/dist/lib-server/api"], function (require, exports, lib_shared_1, api) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.api = void 0;
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (this && this.__exportStar) || function (m, exports) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
                __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.api = void 0;
    __exportStar(lib_shared_1, exports);
    exports.api = api;
});
define("build/database/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Year = exports.PlaylistItem = exports.Playlist = exports.Stream = exports.Token = exports.Key = exports.User = exports.Cue = exports.Subtitle = exports.ShowGenre = exports.MovieGenre = exports.Genre = exports.ShowActor = exports.MovieActor = exports.Actor = exports.MovieFile = exports.Movie = exports.EpisodeFile = exports.Episode = exports.Season = exports.ShowFile = exports.Show = exports.TrackArtist = exports.AlbumArtist = exports.TrackFile = exports.Track = exports.Disc = exports.AlbumFile = exports.Album = exports.Artist = exports.VideoSubtitle = exports.VideoFile = exports.SubtitleFile = exports.MetadataFile = exports.ImageFile = exports.AudioFile = exports.File = exports.Directory = void 0;
    exports.Directory = autoguard.guards.Object.of({
        "directory_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "parent_directory_id": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.File = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "parent_directory_id": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "index_timestamp": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "size": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    });
    exports.AudioFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("audio/mp4"), autoguard.guards.StringLiteral.of("audio/mp3")),
        "duration_ms": autoguard.guards.Number
    });
    exports.ImageFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.StringLiteral.of("image/jpeg"),
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    });
    exports.MetadataFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.StringLiteral.of("application/json")
    });
    exports.SubtitleFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.StringLiteral.of("text/vtt"),
        "duration_ms": autoguard.guards.Number,
        "language": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.VideoFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.StringLiteral.of("video/mp4"),
        "duration_ms": autoguard.guards.Number,
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    });
    exports.VideoSubtitle = autoguard.guards.Object.of({
        "video_file_id": autoguard.guards.String,
        "subtitle_file_id": autoguard.guards.String
    });
    exports.Artist = autoguard.guards.Object.of({
        "artist_id": autoguard.guards.String,
        "name": autoguard.guards.String
    });
    exports.Album = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    });
    exports.AlbumFile = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.Disc = autoguard.guards.Object.of({
        "disc_id": autoguard.guards.String,
        "album_id": autoguard.guards.String,
        "number": autoguard.guards.Number
    });
    exports.Track = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "disc_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.TrackFile = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.AlbumArtist = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "artist_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.TrackArtist = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "artist_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.Show = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.ShowFile = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.Season = autoguard.guards.Object.of({
        "season_id": autoguard.guards.String,
        "show_id": autoguard.guards.String,
        "number": autoguard.guards.Number
    });
    exports.Episode = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "season_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.EpisodeFile = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.Movie = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.MovieFile = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.Actor = autoguard.guards.Object.of({
        "actor_id": autoguard.guards.String,
        "name": autoguard.guards.String
    });
    exports.MovieActor = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "actor_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.ShowActor = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "actor_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.Genre = autoguard.guards.Object.of({
        "genre_id": autoguard.guards.String,
        "name": autoguard.guards.String
    });
    exports.MovieGenre = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "genre_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.ShowGenre = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "genre_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    });
    exports.Subtitle = autoguard.guards.Object.of({
        "subtitle_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    });
    exports.Cue = autoguard.guards.Object.of({
        "cue_id": autoguard.guards.String,
        "subtitle_id": autoguard.guards.String,
        "start_ms": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number,
        "lines": autoguard.guards.String
    });
    exports.User = autoguard.guards.Object.of({
        "user_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "username": autoguard.guards.String,
        "password": autoguard.guards.String
    });
    exports.Key = autoguard.guards.Object.of({
        "key_id": autoguard.guards.String,
        "user_id": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.Token = autoguard.guards.Object.of({
        "token_id": autoguard.guards.String,
        "user_id": autoguard.guards.String,
        "hash": autoguard.guards.String,
        "expires_ms": autoguard.guards.Number
    });
    exports.Stream = autoguard.guards.Object.of({
        "stream_id": autoguard.guards.String,
        "user_id": autoguard.guards.String,
        "file_id": autoguard.guards.String,
        "timestamp_ms": autoguard.guards.Number
    });
    exports.Playlist = autoguard.guards.Object.of({
        "playlist_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "description": autoguard.guards.String,
        "user_id": autoguard.guards.String
    });
    exports.PlaylistItem = autoguard.guards.Object.of({
        "playlist_item_id": autoguard.guards.String,
        "playlist_id": autoguard.guards.String,
        "track_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "added_ms": autoguard.guards.Number
    });
    exports.Year = autoguard.guards.Object.of({
        "year_id": autoguard.guards.String,
        "year": autoguard.guards.Number
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Directory": autoguard.guards.Reference.of(() => exports.Directory),
            "File": autoguard.guards.Reference.of(() => exports.File),
            "AudioFile": autoguard.guards.Reference.of(() => exports.AudioFile),
            "ImageFile": autoguard.guards.Reference.of(() => exports.ImageFile),
            "MetadataFile": autoguard.guards.Reference.of(() => exports.MetadataFile),
            "SubtitleFile": autoguard.guards.Reference.of(() => exports.SubtitleFile),
            "VideoFile": autoguard.guards.Reference.of(() => exports.VideoFile),
            "VideoSubtitle": autoguard.guards.Reference.of(() => exports.VideoSubtitle),
            "Artist": autoguard.guards.Reference.of(() => exports.Artist),
            "Album": autoguard.guards.Reference.of(() => exports.Album),
            "AlbumFile": autoguard.guards.Reference.of(() => exports.AlbumFile),
            "Disc": autoguard.guards.Reference.of(() => exports.Disc),
            "Track": autoguard.guards.Reference.of(() => exports.Track),
            "TrackFile": autoguard.guards.Reference.of(() => exports.TrackFile),
            "AlbumArtist": autoguard.guards.Reference.of(() => exports.AlbumArtist),
            "TrackArtist": autoguard.guards.Reference.of(() => exports.TrackArtist),
            "Show": autoguard.guards.Reference.of(() => exports.Show),
            "ShowFile": autoguard.guards.Reference.of(() => exports.ShowFile),
            "Season": autoguard.guards.Reference.of(() => exports.Season),
            "Episode": autoguard.guards.Reference.of(() => exports.Episode),
            "EpisodeFile": autoguard.guards.Reference.of(() => exports.EpisodeFile),
            "Movie": autoguard.guards.Reference.of(() => exports.Movie),
            "MovieFile": autoguard.guards.Reference.of(() => exports.MovieFile),
            "Actor": autoguard.guards.Reference.of(() => exports.Actor),
            "MovieActor": autoguard.guards.Reference.of(() => exports.MovieActor),
            "ShowActor": autoguard.guards.Reference.of(() => exports.ShowActor),
            "Genre": autoguard.guards.Reference.of(() => exports.Genre),
            "MovieGenre": autoguard.guards.Reference.of(() => exports.MovieGenre),
            "ShowGenre": autoguard.guards.Reference.of(() => exports.ShowGenre),
            "Subtitle": autoguard.guards.Reference.of(() => exports.Subtitle),
            "Cue": autoguard.guards.Reference.of(() => exports.Cue),
            "User": autoguard.guards.Reference.of(() => exports.User),
            "Key": autoguard.guards.Reference.of(() => exports.Key),
            "Token": autoguard.guards.Reference.of(() => exports.Token),
            "Stream": autoguard.guards.Reference.of(() => exports.Stream),
            "Playlist": autoguard.guards.Reference.of(() => exports.Playlist),
            "PlaylistItem": autoguard.guards.Reference.of(() => exports.PlaylistItem),
            "Year": autoguard.guards.Reference.of(() => exports.Year)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/routing/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamespacedMessageRouter = exports.MessageRouter = void 0;
    class MessageRouter {
        constructor() {
            this.observers = Object.create(null);
        }
        addObserver(type, observer) {
            let observers = this.observers[type];
            if (observers === undefined) {
                observers = new Set();
                this.observers[type] = observers;
            }
            observers.add(observer);
        }
        removeObserver(type, observer) {
            let observers = this.observers[type];
            if (observers !== undefined) {
                observers.delete(observer);
                if (observers.size === 0) {
                    delete this.observers[type];
                }
            }
        }
        route(type, message) {
            let observers = this.observers[type];
            if (observers !== undefined) {
                for (let observer of observers) {
                    observer(message);
                }
            }
        }
        size() {
            return Object.keys(this.observers).length;
        }
    }
    exports.MessageRouter = MessageRouter;
    ;
    class NamespacedMessageRouter {
        constructor() {
            this.routers = Object.create(null);
        }
        addObserver(namespace, type, observer) {
            let router = this.routers[namespace];
            if (router === undefined) {
                router = new MessageRouter();
                this.routers[namespace] = router;
            }
            router.addObserver(type, observer);
        }
        removeObserver(namespace, type, observer) {
            let router = this.routers[namespace];
            if (router !== undefined) {
                router.removeObserver(type, observer);
                if (router.size() === 0) {
                    delete this.routers[namespace];
                }
            }
        }
        route(namespace, type, message) {
            let router = this.routers[namespace];
            if (router !== undefined) {
                router.route(type, message);
            }
        }
    }
    exports.NamespacedMessageRouter = NamespacedMessageRouter;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/index", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/routing/index"], function (require, exports, routing) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = void 0;
    exports.routing = routing;
});
define("build/is", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.present = exports.absent = void 0;
    function absent(subject) {
        return subject == null;
    }
    exports.absent = absent;
    ;
    function present(subject) {
        return subject != null;
    }
    exports.present = present;
    ;
});
define("build/jsondb/sorters", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = void 0;
    exports.CombinedSort = {
        of(...rankers) {
            return (one, two) => {
                for (let ranker of rankers) {
                    let rank = ranker(one, two);
                    if (rank !== 0) {
                        return rank;
                    }
                }
                return 0;
            };
        }
    };
    exports.CustomSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return (t ? 1 : 0) - (o ? 1 : 0);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return (o ? 1 : 0) - (t ? 1 : 0);
            };
        }
    };
    exports.LexicalSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t.localeCompare(o);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o.localeCompare(t);
            };
        }
    };
    exports.NumericSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t - o;
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o - t;
            };
        }
    };
});
define("build/jsondb/indices", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/is", "build/jsondb/sorters"], function (require, exports, stdlib, is, sorters) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SearchIndex = exports.getTokens = exports.RecordIndex = exports.CollectionIndex = void 0;
    class CollectionIndex {
        getPrimaryKeysFromIndexedValue;
        lookupRecord;
        getPrimaryKey;
        getIndexedValue;
        constructor(lookupRecord, getPrimaryKey, getIndexedValue) {
            this.getPrimaryKeysFromIndexedValue = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValue = getIndexedValue;
        }
        insert(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.absent(primaryKeys)) {
                primaryKeys = new Set();
                this.getPrimaryKeysFromIndexedValue.set(indexedValue, primaryKeys);
            }
            let primaryKey = this.getPrimaryKey(record);
            primaryKeys.add(primaryKey);
        }
        lookup(key) {
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(key);
            if (is.present(primaryKeys)) {
                return Array.from(primaryKeys).map(this.lookupRecord);
            }
            return new Array();
        }
        remove(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.present(primaryKeys)) {
                let primaryKey = this.getPrimaryKey(record);
                primaryKeys.delete(primaryKey);
                if (primaryKeys.size === 0) {
                    this.getPrimaryKeysFromIndexedValue.delete(indexedValue);
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
        static fromTable(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
    }
    exports.CollectionIndex = CollectionIndex;
    ;
    class RecordIndex {
        getRecordFromKey;
        getKey;
        router;
        insertOrUpdate(next, action = "replace") {
            let key = this.getKey(next);
            let last = this.getRecordFromKey.get(key);
            if (is.present(last)) {
                if (action === "combine") {
                    for (let key in last) {
                        let lastValue = last[key];
                        let nextValue = next[key];
                        if (is.present(lastValue) && is.absent(nextValue)) {
                            next[key] = last[key];
                        }
                    }
                }
                this.getRecordFromKey.set(key, next);
                this.router.route("update", { last, next });
                this.router.route("*", {});
            }
            else {
                this.getRecordFromKey.set(key, next);
                this.router.route("insert", { next });
                this.router.route("*", {});
            }
        }
        constructor(getKey) {
            this.getRecordFromKey = new Map();
            this.getKey = getKey;
            this.router = new stdlib.routing.MessageRouter();
        }
        [Symbol.iterator]() {
            return this.getRecordFromKey.values();
        }
        insert(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        keyof(record) {
            return this.getKey(record);
        }
        length() {
            return this.getRecordFromKey.size;
        }
        lookup(key) {
            let record = this.getRecordFromKey.get(key);
            if (is.absent(record)) {
                throw `Expected "${key}" to match a record!`;
            }
            return record;
        }
        on(type, listener) {
            this.router.addObserver(type, listener);
            if (type === "insert") {
                for (let record of this.getRecordFromKey.values()) {
                    listener({ next: record });
                }
            }
        }
        off(type, listener) {
            this.router.addObserver(type, listener);
        }
        remove(record) {
            let key = this.getKey(record);
            if (this.getRecordFromKey.has(key)) {
                this.getRecordFromKey.delete(key);
                this.router.route("remove", { last: record });
                this.router.route("*", {});
            }
        }
        update(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        static from(records, getKey) {
            let index = new RecordIndex(getKey);
            for (let record of records) {
                index.insert(record);
            }
            return index;
        }
    }
    exports.RecordIndex = RecordIndex;
    ;
    function getTokens(query) {
        let normalized = query;
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFKD");
        normalized = normalized.replace(/[\p{M}]/gu, "");
        return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
    }
    exports.getTokens = getTokens;
    ;
    class SearchIndex {
        getPrimaryKeysFromToken;
        lookupRecord;
        getPrimaryKey;
        getIndexedValues;
        minTokenLength;
        constructor(lookupRecord, getPrimaryKey, getIndexedValues, minTokenLength) {
            this.getPrimaryKeysFromToken = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValues = getIndexedValues;
            this.minTokenLength = minTokenLength;
        }
        insert(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value).filter((token) => token.length >= this.minTokenLength);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.absent(primaryKeys)) {
                        primaryKeys = new Set();
                        this.getPrimaryKeysFromToken.set(token, primaryKeys);
                    }
                    let primaryKey = this.getPrimaryKey(record);
                    primaryKeys.add(primaryKey);
                }
            }
        }
        lookup(query) {
            let tokens = getTokens(query).filter((token) => token.length >= this.minTokenLength);
            let primaryKeySets = tokens.map((token) => {
                return this.getPrimaryKeysFromToken.get(token);
            }).filter(is.present);
            let map = new Map();
            for (let primaryKeys of primaryKeySets) {
                for (let primaryKey of primaryKeys) {
                    let rank = map.get(primaryKey) ?? (0 - tokens.length);
                    map.set(primaryKey, rank + 2);
                }
            }
            return Array.from(map.entries())
                .filter((entry) => entry[1] >= 0)
                .sort(sorters.NumericSort.decreasing((entry) => entry[1]))
                .map((entry) => ({
                id: entry[0],
                rank: entry[1]
            }));
        }
        remove(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.present(primaryKeys)) {
                        let primaryKey = this.getPrimaryKey(record);
                        primaryKeys.delete(primaryKey);
                        if (primaryKeys.size === 0) {
                            this.getPrimaryKeysFromToken.delete(token);
                        }
                    }
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
        static fromTable(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            for (let record of records) {
                index.insert(record);
            }
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
    }
    exports.SearchIndex = SearchIndex;
    ;
});
define("build/jsondb/index", ["require", "exports", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters"], function (require, exports, indices, sorters, indices_1, indices_2, indices_3, sorters_1, sorters_2, sorters_3, sorters_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sorters = exports.indices = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = exports.SearchIndex = exports.RecordIndex = exports.CollectionIndex = exports.sorters = exports.indices = void 0;
    exports.indices = indices;
    exports.sorters = sorters;
    Object.defineProperty(exports, "CollectionIndex", { enumerable: true, get: function () { return indices_1.CollectionIndex; } });
    Object.defineProperty(exports, "RecordIndex", { enumerable: true, get: function () { return indices_2.RecordIndex; } });
    Object.defineProperty(exports, "SearchIndex", { enumerable: true, get: function () { return indices_3.SearchIndex; } });
    Object.defineProperty(exports, "CombinedSort", { enumerable: true, get: function () { return sorters_1.CombinedSort; } });
    Object.defineProperty(exports, "CustomSort", { enumerable: true, get: function () { return sorters_2.CustomSort; } });
    Object.defineProperty(exports, "LexicalSort", { enumerable: true, get: function () { return sorters_3.LexicalSort; } });
    Object.defineProperty(exports, "NumericSort", { enumerable: true, get: function () { return sorters_4.NumericSort; } });
});
define("build/database/probes/readers", ["require", "exports", "fs"], function (require, exports, libfs) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Binary = void 0;
    class Binary {
        fd;
        offset;
        read(buffer) {
            let bytes = libfs.readSync(this.fd, buffer, 0, buffer.length, this.offset);
            if (bytes !== buffer.length) {
                throw `Expected to read ${buffer.length} bytes but read ${bytes}!`;
            }
            this.offset += bytes;
            return buffer;
        }
        skip(length) {
            this.offset += length;
        }
        constructor(fd) {
            this.fd = fd;
            this.offset = 0;
        }
        newContext(context) {
            let offset = this.offset;
            try {
                return context((buffer) => this.read(buffer), (length) => this.skip(length));
            }
            catch (error) {
                this.offset = offset;
                throw error;
            }
        }
    }
    exports.Binary = Binary;
    ;
});
define("build/database/probes/jpeg", ["require", "exports", "build/database/probes/readers"], function (require, exports, readers) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    var Markers;
    (function (Markers) {
        Markers[Markers["START_OF_IMAGE"] = 65496] = "START_OF_IMAGE";
        Markers[Markers["END_OF_IMAGE"] = 65497] = "END_OF_IMAGE";
        Markers[Markers["APPLICATION_0"] = 65504] = "APPLICATION_0";
        Markers[Markers["START_OF_SCAN"] = 65498] = "START_OF_SCAN";
        Markers[Markers["START_OF_FRAME_0"] = 65472] = "START_OF_FRAME_0";
        Markers[Markers["DEFINE_QUANTIZATION_TABLE"] = 65499] = "DEFINE_QUANTIZATION_TABLE";
        Markers[Markers["DEFINE_HUFFMAN_TABLE"] = 65476] = "DEFINE_HUFFMAN_TABLE";
    })(Markers || (Markers = {}));
    function parseStartOfImage(data) {
        return {};
    }
    function parseApplication0(data) {
        let offset = 0;
        let identifier = data.slice(offset, 5);
        offset += 5;
        if (identifier.toString() !== "JFIF\0") {
            throw `Expected a JFIF tag!`;
        }
        let major = data.readUInt8(offset);
        offset += 1;
        let minor = data.readUInt8(offset);
        offset += 1;
        let units = data.readUInt8(offset);
        offset += 1;
        if ((units !== 0) && (units !== 1) && (units !== 2)) {
            throw `Expected a valid density unit!`;
        }
        let x = data.readUInt16BE(offset);
        offset += 2;
        if (x === 0) {
            throw `Expected a non-zero horisontal resolution!`;
        }
        let y = data.readUInt16BE(offset);
        offset += 2;
        if (y === 0) {
            throw `Expected a non-zero vertical resolution!`;
        }
        let w = data.readUInt8(offset);
        offset += 1;
        let h = data.readUInt8(offset);
        offset += 1;
        let preview = data.slice(offset, offset + w * h * 3);
        offset += w * h * 3;
        if (preview.length !== w * h * 3) {
            throw `Expected a valid thumbnail!`;
        }
        return {
            major,
            minor,
            units,
            x,
            y,
            w,
            h,
            preview
        };
    }
    function parseStartOfFrame0(data) {
        let offset = 0;
        let precision = data.readUInt8(offset);
        offset += 1;
        let height = data.readUInt16BE(offset);
        offset += 2;
        let width = data.readUInt16BE(offset);
        offset += 2;
        let component_count = data.readUInt8(offset);
        offset += 1;
        let components = [...Array(component_count).keys()].map(() => {
            let id = data.readUInt8(offset);
            offset += 1;
            let sampling_factors = data.readUInt8(offset);
            offset += 1;
            let quantization_table = data.readUInt8(offset);
            offset += 1;
            return {
                id,
                sampling_factors,
                quantization_table
            };
        });
        return {
            precision,
            height,
            width,
            component_count,
            components
        };
    }
    function probe(fd) {
        let reader = new readers.Binary(fd);
        return reader.newContext((read, skip) => {
            let marker = Buffer.alloc(2);
            let length = Buffer.alloc(2);
            read(marker);
            if (marker.readUInt16BE() !== Markers.START_OF_IMAGE) {
                throw `Expected SOI marker!`;
            }
            parseStartOfImage(Buffer.alloc(0));
            read(marker);
            if (marker.readUInt16BE() !== Markers.APPLICATION_0) {
                throw `Expected APP0 marker!`;
            }
            read(length);
            parseApplication0(read(Buffer.alloc(length.readUInt16BE() - 2)));
            while (true) {
                read(marker);
                read(length);
                if (marker.readUInt16BE() === Markers.START_OF_FRAME_0) {
                    let sof = parseStartOfFrame0(read(Buffer.alloc(length.readUInt16BE() - 2)));
                    let result = {
                        resources: [{
                                type: "image",
                                width: sof.width,
                                height: sof.height
                            }]
                    };
                    return result;
                }
                else {
                    skip(length.readUInt16BE() - 2);
                }
            }
        });
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Probe = exports.Resource = exports.VideoResource = exports.SubtitleResource = exports.MetadataResource = exports.ImageResource = exports.AudioResource = exports.Metadata = exports.AlbumMetadata = exports.TrackMetadata = exports.MovieMetadata = exports.EpisodeMetadata = void 0;
    exports.EpisodeMetadata = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("episode"),
        "title": autoguard.guards.String,
        "season": autoguard.guards.Number,
        "episode": autoguard.guards.Number,
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "show": autoguard.guards.Object.of({
            "title": autoguard.guards.String,
            "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "genres": autoguard.guards.Array.of(autoguard.guards.String),
            "actors": autoguard.guards.Array.of(autoguard.guards.String)
        }),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.MovieMetadata = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("movie"),
        "title": autoguard.guards.String,
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "genres": autoguard.guards.Array.of(autoguard.guards.String),
        "actors": autoguard.guards.Array.of(autoguard.guards.String),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.TrackMetadata = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("track"),
        "title": autoguard.guards.String,
        "disc": autoguard.guards.Number,
        "track": autoguard.guards.Number,
        "album": autoguard.guards.Object.of({
            "title": autoguard.guards.String,
            "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
            "artists": autoguard.guards.Array.of(autoguard.guards.String)
        }),
        "artists": autoguard.guards.Array.of(autoguard.guards.String),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.AlbumMetadata = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("album"),
        "title": autoguard.guards.String,
        "disc": autoguard.guards.Number,
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "artists": autoguard.guards.Array.of(autoguard.guards.String),
        "tracks": autoguard.guards.Array.of(autoguard.guards.Object.of({
            "title": autoguard.guards.String,
            "artists": autoguard.guards.Array.of(autoguard.guards.String),
            "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
        })),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.Metadata = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.EpisodeMetadata), autoguard.guards.Reference.of(() => exports.MovieMetadata), autoguard.guards.Reference.of(() => exports.TrackMetadata), autoguard.guards.Reference.of(() => exports.AlbumMetadata));
    exports.AudioResource = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("audio"),
        "duration_ms": autoguard.guards.Number
    });
    exports.ImageResource = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("image"),
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    });
    exports.MetadataResource = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("metadata")
    });
    exports.SubtitleResource = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("subtitle"),
        "duration_ms": autoguard.guards.Number,
        "language": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "cues": autoguard.guards.Array.of(autoguard.guards.Object.of({
            "start_ms": autoguard.guards.Number,
            "duration_ms": autoguard.guards.Number,
            "lines": autoguard.guards.Array.of(autoguard.guards.String)
        }))
    });
    exports.VideoResource = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("video"),
        "duration_ms": autoguard.guards.Number,
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    });
    exports.Resource = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.AudioResource), autoguard.guards.Reference.of(() => exports.ImageResource), autoguard.guards.Reference.of(() => exports.MetadataResource), autoguard.guards.Reference.of(() => exports.SubtitleResource), autoguard.guards.Reference.of(() => exports.VideoResource));
    exports.Probe = autoguard.guards.Object.of({
        "metadata": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Metadata), autoguard.guards.Undefined),
        "resources": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Resource))
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "EpisodeMetadata": autoguard.guards.Reference.of(() => exports.EpisodeMetadata),
            "MovieMetadata": autoguard.guards.Reference.of(() => exports.MovieMetadata),
            "TrackMetadata": autoguard.guards.Reference.of(() => exports.TrackMetadata),
            "AlbumMetadata": autoguard.guards.Reference.of(() => exports.AlbumMetadata),
            "Metadata": autoguard.guards.Reference.of(() => exports.Metadata),
            "AudioResource": autoguard.guards.Reference.of(() => exports.AudioResource),
            "ImageResource": autoguard.guards.Reference.of(() => exports.ImageResource),
            "MetadataResource": autoguard.guards.Reference.of(() => exports.MetadataResource),
            "SubtitleResource": autoguard.guards.Reference.of(() => exports.SubtitleResource),
            "VideoResource": autoguard.guards.Reference.of(() => exports.VideoResource),
            "Resource": autoguard.guards.Reference.of(() => exports.Resource),
            "Probe": autoguard.guards.Reference.of(() => exports.Probe)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/database/probes/json", ["require", "exports", "fs", "build/database/probes/schema/index"], function (require, exports, libfs, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    function probe(fd) {
        let result = {
            resources: [
                {
                    type: "metadata"
                }
            ]
        };
        let buffer = libfs.readFileSync(fd);
        let json = JSON.parse(buffer.toString());
        if (schema.Metadata.is(json)) {
            result.metadata = json;
        }
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/mp3", ["require", "exports", "build/is", "build/database/probes/readers"], function (require, exports, is, readers) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    function decodeSyncSafeInteger(buffer) {
        let a = buffer.readUInt8(0);
        let b = buffer.readUInt8(1);
        let c = buffer.readUInt8(2);
        let d = buffer.readUInt8(3);
        return ((a & 0x7F) << 21) | ((b & 0x7F) << 14) | ((c & 0x7F) << 7) | ((d & 0x7F) << 0);
    }
    function parseID3v2Header(reader) {
        return reader.newContext((read, skip) => {
            let buffer = Buffer.alloc(10);
            read(buffer);
            if (buffer.slice(0, 5).toString("binary") !== "ID3\x04\x00") {
                throw `Expected an ID3v2 tag!`;
            }
            let length = decodeSyncSafeInteger(buffer.slice(6, 6 + 4));
            let body = Buffer.alloc(length);
            read(body);
            let tags = {};
            let offset = 0;
            while (offset < body.length) {
                let type = body.slice(offset, offset + 4).toString("binary");
                let length = decodeSyncSafeInteger(body.slice(offset + 4, offset + 4 + 4));
                let flags = body.slice(offset + 8, offset + 8 + 2);
                let data = body.slice(offset + 10, offset + 10 + length);
                offset += 10 + length;
                if (type === "\0\0\0\0") {
                    break;
                }
                else if (type === "TCOP") {
                    tags.copyright = data.slice(1, -1).toString();
                }
                else if (type === "TIT2") {
                    tags.title = data.slice(1, -1).toString();
                }
                else if (type === "TALB") {
                    tags.album = data.slice(1, -1).toString();
                }
                else if (type === "TDRC") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^([0-9]+)$/.exec(string);
                    if (is.present(parts)) {
                        tags.year = parseInt(parts[1]);
                    }
                }
                else if (type === "TRCK") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^([0-9]+)(?:\/([0-9]+))?$/.exec(string);
                    if (is.present(parts)) {
                        tags.track_number = parseInt(parts[1]);
                    }
                }
                else if (type === "TPOS") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^([0-9]+)(?:\/([0-9]+))?$/.exec(string);
                    if (is.present(parts)) {
                        tags.disc_number = parseInt(parts[1]);
                    }
                }
                else if (type === "TPE1") {
                    tags.artist = data.slice(1, -1).toString();
                }
                else if (type === "TPE2") {
                    tags.album_artist = data.slice(1, -1).toString();
                }
                else if (type === "TXXX") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^ALBUM ARTIST\0(.+)$/.exec(string);
                    if (is.present(parts)) {
                        tags.album_artist = parts[1];
                    }
                }
            }
            return tags;
        });
    }
    var Version;
    (function (Version) {
        Version[Version["V2_5"] = 0] = "V2_5";
        Version[Version["RESERVED"] = 1] = "RESERVED";
        Version[Version["V2"] = 2] = "V2";
        Version[Version["V1"] = 3] = "V1";
    })(Version || (Version = {}));
    ;
    var Layer;
    (function (Layer) {
        Layer[Layer["RESERVED"] = 0] = "RESERVED";
        Layer[Layer["LAYER_3"] = 1] = "LAYER_3";
        Layer[Layer["LAYER_2"] = 2] = "LAYER_2";
        Layer[Layer["LAYER_1"] = 3] = "LAYER_1";
    })(Layer || (Layer = {}));
    ;
    const KILOBITS_PER_SECOND = [
        0,
        32,
        40,
        48,
        56,
        64,
        80,
        96,
        112,
        128,
        160,
        192,
        224,
        256,
        320,
        0
    ];
    const SAMPLES_PER_SECOND = [
        44100,
        48000,
        32000,
        0
    ];
    function parseXingHeader(reader) {
        return reader.newContext((read, skip) => {
            let buffer = Buffer.alloc(4);
            read(buffer);
            let sync = ((buffer[0] & 0xFF) << 3) | ((buffer[1] & 0xE0) >> 5);
            let version = ((buffer[1] & 0x18) >> 3);
            let layer = ((buffer[1] & 0x06) >> 1);
            let skip_crc = ((buffer[1] & 0x01) >> 0);
            let bitrate = ((buffer[2] & 0xF0) >> 4);
            let sample_rate = ((buffer[2] & 0x0C) >> 2);
            let padded = ((buffer[2] & 0x02) >> 1);
            let application_private = ((buffer[2] & 0x01) >> 0);
            let channels = ((buffer[3] & 0xC0) >> 6);
            let mode_extension = ((buffer[3] & 0x30) >> 4);
            let copyrighted = ((buffer[3] & 0x08) >> 3);
            let original = ((buffer[3] & 0x04) >> 2);
            let emphasis = ((buffer[3] & 0x03) >> 0);
            if (sync === 0x07FF && version === Version.V1 && layer === Layer.LAYER_3) {
                let samples_per_frame = 1152;
                let slots = Math.floor(samples_per_frame * KILOBITS_PER_SECOND[bitrate] * 1000 / 8 / SAMPLES_PER_SECOND[sample_rate]);
                if (padded) {
                    slots += 1;
                }
                let bytes = slots * 1;
                let body = Buffer.alloc(bytes - 4);
                read(body);
                let zeroes = body.slice(0, 0 + 32);
                let xing = body.slice(32, 32 + 4);
                if (xing.toString("binary") === "Xing" || xing.toString() === "Info") {
                    let flags = body.slice(36, 36 + 4);
                    let has_quality = ((flags[3] & 0x08) >> 3);
                    let has_toc = ((flags[3] & 0x04) >> 2);
                    let has_bytes = ((flags[3] & 0x02) >> 1);
                    let has_frames = ((flags[3] & 0x01) >> 0);
                    let offset = 40;
                    if (has_frames) {
                        let num_frames = body.readUInt32BE(offset);
                        offset += 4;
                        let duration_ms = Math.ceil((num_frames * samples_per_frame / SAMPLES_PER_SECOND[sample_rate]) * 1000);
                        return duration_ms;
                    }
                    if (has_bytes) {
                        let num_bytes = body.readUInt32BE(offset);
                        offset += 4;
                    }
                    if (has_toc) {
                        offset += 100;
                    }
                    if (has_quality) {
                        let quality = body.readUInt32BE(offset);
                        offset += 4;
                    }
                }
            }
            throw `Expected a Xing header!`;
        });
    }
    function probe(fd) {
        let reader = new readers.Binary(fd);
        let tags = parseID3v2Header(reader);
        console.log(tags);
        let duration_ms = parseXingHeader(reader);
        let result = {
            resources: [
                {
                    type: "audio",
                    duration_ms: duration_ms
                }
            ]
        };
        if (is.present(tags.title) && is.present(tags.disc_number) && is.present(tags.track_number) && is.present(tags.album)) {
            let metadata = {
                type: "track",
                title: tags.title,
                disc: tags.disc_number,
                track: tags.track_number,
                album: {
                    title: tags.album,
                    year: tags.year,
                    artists: is.absent(tags.album_artist) ? [] : tags.album_artist.split(";").map((artist) => artist.trim())
                },
                artists: is.absent(tags.artist) ? [] : tags.artist.split(";").map((artist) => artist.trim()),
                copyright: tags.copyright
            };
            result.metadata = metadata;
        }
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/mp4", ["require", "exports", "fs", "build/is"], function (require, exports, libfs, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    class Atom {
        fd;
        type;
        body;
        constructor(fd, type, body) {
            this.fd = fd;
            this.type = type;
            this.body = body;
        }
        getAllChildren() {
            let scope = {
                ...this.body
            };
            let atoms = new Array();
            while (scope.length > 0) {
                let atom = Atom.parse(this.fd, scope);
                // The "udta" atom begins with a mandatory zero-terminated list.
                if (this.type === "udta") {
                    atom.body.offset += 4;
                    atom.body.length -= 4;
                }
                atoms.push(atom);
                scope.offset = atom.body.offset + atom.body.length;
                scope.length = this.body.offset + this.body.length - scope.offset;
            }
            return atoms;
        }
        getChild(type) {
            let children = this.getChildren(type);
            if (children.length !== 1) {
                throw `Expected exactly one child!`;
            }
            return children[0];
        }
        getChildren(type) {
            return this.getAllChildren().filter((atom) => {
                return atom.type === type;
            });
        }
        readBody() {
            let buffer = Buffer.alloc(this.body.length);
            if (libfs.readSync(this.fd, buffer, 0, buffer.length, this.body.offset) !== buffer.length) {
                throw `Expected to read exactly ${buffer.length} bytes!`;
            }
            return buffer;
        }
        static parse(fd, scope) {
            let offset = scope.offset;
            let buffer = Buffer.alloc(8);
            if (libfs.readSync(fd, buffer, 0, buffer.length, offset) !== buffer.length) {
                throw `Expected to read exactly ${buffer.length} bytes!`;
            }
            offset += buffer.length;
            let length = buffer.readUInt32BE(0);
            let type = buffer.slice(4, 4 + 4).toString("binary");
            if (length === 0) {
                length = scope.length - offset;
            }
            else if (length === 1) {
                if (libfs.readSync(fd, buffer, 0, buffer.length, offset) !== buffer.length) {
                    throw `Expected to read exactly ${buffer.length} bytes!`;
                }
                offset += buffer.length;
                length = Number(buffer.readBigUInt64BE(0));
            }
            if (length < 8) {
                throw `Expected a length of at least 8 bytes, got ${length}!`;
            }
            else if (length > scope.length) {
                throw `Expected a length of at most ${scope.length} bytes, got ${length}!`;
            }
            length -= 8;
            return new Atom(fd, type, {
                offset,
                length
            });
        }
    }
    ;
    function probe(fd) {
        let atom = new Atom(fd, "root", {
            offset: 0,
            length: libfs.fstatSync(fd).size
        });
        let moov = atom.getChild("moov");
        let mvhd = moov.getChild("mvhd");
        let buffer = mvhd.readBody();
        let ts = buffer.readUInt32BE(12);
        let result = {
            resources: moov.getChildren("trak").map((trak) => {
                let tkhd = trak.getChild("tkhd");
                let buffer = tkhd.readBody();
                let duration_ts = buffer.readUInt32BE(20);
                let width = buffer.readUInt16BE(76);
                let height = buffer.readUInt16BE(80);
                let duration_ms = Math.ceil(duration_ts / ts * 1000);
                if (duration_ms > 0 && width > 0 && height > 0) {
                    return {
                        type: "video",
                        duration_ms,
                        width,
                        height
                    };
                }
                else if (duration_ms > 0) {
                    return {
                        type: "audio",
                        duration_ms
                    };
                }
                else {
                    return {
                        type: "metadata"
                    };
                }
            })
        };
        try {
            let udta = moov.getChild("udta");
            let meta = udta.getChild("meta");
            let ilst = meta.getChild("ilst");
            let tags = {};
            try {
                let buffer = ilst.getChild("tvsh").getChild("data").readBody();
                tags.show = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("tven").getChild("data").readBody();
                tags.episode = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("tves").getChild("data").readBody();
                tags.episode_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("tvsn").getChild("data").readBody();
                tags.season_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9nam").getChild("data").readBody();
                tags.title = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9day").getChild("data").readBody();
                tags.year = Number.parseInt(buffer.slice(8).toString());
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9cmt").getChild("data").readBody();
                tags.comment = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9cpy").getChild("data").readBody();
                tags.copyright = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9ART").getChild("data").readBody();
                tags.artist = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9alb").getChild("data").readBody();
                tags.album = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("aART").getChild("data").readBody();
                tags.album_artist = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("trkn").getChild("data").readBody();
                tags.track_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("disk").getChild("data").readBody();
                tags.disc_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            if (result.resources.find((resource) => resource.type === "video")) {
                if (is.present(tags.episode) && is.present(tags.season_number) && is.present(tags.episode_number) && is.present(tags.show)) {
                    let metadata = {
                        type: "episode",
                        title: tags.episode,
                        season: tags.season_number,
                        episode: tags.episode_number,
                        year: tags.year,
                        summary: tags.comment,
                        show: {
                            title: tags.show,
                            summary: undefined,
                            genres: [],
                            actors: []
                        }
                    };
                    result.metadata = metadata;
                }
                else if (is.present(tags.title)) {
                    let metadata = {
                        type: "movie",
                        title: tags.title,
                        year: tags.year,
                        summary: tags.comment,
                        genres: [],
                        actors: []
                    };
                    result.metadata = metadata;
                }
            }
            else if (result.resources.find((resource) => resource.type === "audio")) {
                if (is.present(tags.title) && is.present(tags.disc_number) && is.present(tags.track_number) && is.present(tags.album)) {
                    let metadata = {
                        type: "track",
                        title: tags.title,
                        disc: tags.disc_number,
                        track: tags.track_number,
                        album: {
                            title: tags.album,
                            year: tags.year,
                            artists: is.absent(tags.album_artist) ? [] : tags.album_artist.split(";").map((artist) => artist.trim())
                        },
                        artists: is.absent(tags.artist) ? [] : tags.artist.split(";").map((artist) => artist.trim()),
                        copyright: tags.copyright
                    };
                    result.metadata = metadata;
                }
            }
        }
        catch (error) { }
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/vtt/reader", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reader = void 0;
    function isString(value) {
        return value != null && value.constructor === String;
    }
    class Reader {
        string;
        offset;
        length;
        constructor(string) {
            this.string = string;
            this.offset = 0;
            this.length = string.length;
        }
        done() {
            return (this.offset === this.length);
        }
        line() {
            let string = "";
            while (!this.done()) {
                let one = this.string[this.offset];
                this.offset += 1;
                if (false) {
                }
                else if (one === "\r") {
                    if (!this.done()) {
                        let two = this.string[this.offset];
                        if (two === "\n") {
                            this.offset += 1;
                        }
                    }
                    break;
                }
                else if (one === "\n") {
                    if (!this.done()) {
                        let two = this.string[this.offset];
                        if (two === "\r") {
                            this.offset += 1;
                        }
                    }
                    break;
                }
                else {
                    string += one;
                }
            }
            return string;
        }
        keep(characters) {
            let string = "";
            while (!this.done()) {
                if (characters.indexOf(this.peek(1)) >= 0) {
                    break;
                }
                string += this.read(1);
            }
            return string;
        }
        peek(how) {
            let length = isString(how) ? how.length : how;
            let min = Math.min(this.offset, this.offset + length);
            let max = Math.max(this.offset, this.offset + length);
            if ((min < 0) || (min >= this.length) || (max < 0) || (max > this.length)) {
                throw "Unable to read between offsets " + min + " and " + max + " because length is " + this.length + "!";
            }
            let string = this.string.substring(min, max);
            if (isString(how)) {
                if (string !== how) {
                    throw "Expected \"" + how + "\" but read \"" + string + "\"!";
                }
            }
            return string;
        }
        read(how) {
            let string = this.peek(how);
            this.offset += string.length;
            return string;
        }
        seek(offset) {
            if ((offset < 0) || (offset >= this.length)) {
                throw "Unable to seek to offset " + offset + " because length is " + this.length + "!";
            }
            this.offset = offset;
        }
        skip(characters) {
            let string = "";
            while (!this.done()) {
                if (characters.indexOf(this.peek(1)) < 0) {
                    break;
                }
                string += this.read(1);
            }
            return string;
        }
        tell() {
            return this.offset;
        }
    }
    exports.Reader = Reader;
});
define("build/database/vtt/vtt", ["require", "exports", "build/database/vtt/reader"], function (require, exports, libreader) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    const DQ = "\"";
    function readString(reader, expected) {
        let string = reader.read(expected.length);
        if (string !== expected) {
            throw "Expected " + DQ + expected + DQ + " but read " + DQ + string + DQ + "!";
        }
    }
    function readBlank(reader) {
        let line = reader.line();
        if (line !== "") {
            throw "Expected a blank line but read " + DQ + line + DQ + "!";
        }
    }
    function readTimecode(reader) {
        let parts = null;
        if ((parts = /^([0-9][0-9])[:]([0-5][0-9])[:]([0-5][0-9])[.]([0-9][0-9][0-9])$/.exec(reader.peek(12))) != null) {
            reader.read(12);
            let hours = parseInt(parts[1], 10);
            let minutes = parseInt(parts[2], 10);
            let seconds = parseInt(parts[3], 10);
            let milliseconds = parseInt(parts[4], 10);
            return ((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds;
        }
        if ((parts = /^([0-5][0-9])[:]([0-5][0-9])[.]([0-9][0-9][0-9])$/.exec(reader.peek(9))) != null) {
            reader.read(9);
            let hours = 0;
            let minutes = parseInt(parts[1], 10);
            let seconds = parseInt(parts[2], 10);
            let milliseconds = parseInt(parts[3], 10);
            return ((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds;
        }
        console.log("Expected a valid timecode!");
        return 0;
    }
    function serializeTimecode(ms) {
        let s = Math.floor(ms / 1000);
        ms -= (s * 1000);
        let m = Math.floor(s / 60);
        s -= (m * 60);
        let h = Math.floor(m / 60);
        m -= (h * 60);
        let tch = `00${h}`.slice(-2);
        let tcm = `00${m}`.slice(-2);
        let tcs = `00${s}`.slice(-2);
        let tcms = `000${ms}`.slice(-3);
        return `${tch}:${tcm}:${tcs}.${tcms}`;
    }
    function readCue(reader) {
        let start_ms = readTimecode(reader);
        readString(reader, " --> ");
        let end_ms = readTimecode(reader);
        readBlank(reader);
        let duration_ms = end_ms - start_ms;
        if (duration_ms < 0) {
            console.log("Expected a positive duration but read " + start_ms + " and " + end_ms + "!");
        }
        let lines = new Array();
        while (true) {
            let line = reader.line();
            if (line === "") {
                break;
            }
            lines.push(line);
        }
        return {
            start_ms,
            duration_ms,
            lines
        };
    }
    function serializeCue(cue, options) {
        let lines = new Array();
        lines.push(serializeTimecode(cue.start_ms) + " --> " + serializeTimecode(cue.start_ms + cue.duration_ms));
        lines.push(...cue.lines);
        lines.push("");
        return lines.join(options.eol);
    }
    function readBody(reader) {
        let cues = new Array();
        while (!reader.done()) {
            let cue = readCue(reader);
            cues.push(cue);
        }
        cues = cues.sort((one, two) => one.start_ms - two.start_ms);
        return {
            cues
        };
    }
    function serializeBody(body, options) {
        let lines = new Array();
        for (let cue of body.cues) {
            lines.push(serializeCue(cue, options));
        }
        return lines.join(options.eol);
    }
    function readHead(reader) {
        readString(reader, "WEBVTT");
        let metadata = reader.line();
        readBlank(reader);
        return {
            metadata
        };
    }
    function serializeHead(head, options) {
        let lines = new Array();
        lines.push("WEBVTT " + head.metadata);
        lines.push("");
        return lines.join(options.eol);
    }
    function readTrack(reader) {
        let head = readHead(reader);
        let body = readBody(reader);
        return {
            head,
            body
        };
    }
    function serializeTrack(track, options) {
        let lines = new Array();
        lines.push(serializeHead(track.head, options));
        lines.push(serializeBody(track.body, options));
        return lines.join(options.eol);
    }
    function decode(string) {
        let reader = new libreader.Reader(string);
        return readTrack(reader);
    }
    exports.decode = decode;
    function encode(track) {
        return serializeTrack(track, {
            eol: "\r\n"
        });
    }
    exports.encode = encode;
});
define("build/database/probes/vtt", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "fs", "build/is", "build/database/vtt/vtt"], function (require, exports, autoguard, libfs, is, vtt) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    function probe(fd) {
        let result = {
            resources: []
        };
        let buffer = libfs.readFileSync(fd);
        let track = vtt.decode(buffer.toString());
        let cues = track.body.cues;
        let cue = cues.length > 0 ? cues[cues.length - 1] : undefined;
        let duration_ms = is.present(cue) ? cue.start_ms + cue.duration_ms : 0;
        let language;
        try {
            let json = JSON.parse(track.head.metadata);
            language = autoguard.guards.String.as(json.language);
        }
        catch (error) { }
        result.resources.push({
            type: "subtitle",
            duration_ms,
            language,
            cues
        });
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/index", ["require", "exports", "build/database/probes/jpeg", "build/database/probes/json", "build/database/probes/mp3", "build/database/probes/mp4", "build/database/probes/schema/index", "build/database/probes/vtt"], function (require, exports, jpeg, json, mp3, mp4, schema, vtt) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vtt = exports.schema = exports.mp4 = exports.mp3 = exports.json = exports.jpeg = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vtt = exports.schema = exports.mp4 = exports.mp3 = exports.json = exports.jpeg = void 0;
    exports.jpeg = jpeg;
    exports.json = json;
    exports.mp3 = mp3;
    exports.mp4 = mp4;
    exports.schema = schema;
    exports.vtt = vtt;
});
define("build/config/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "fs"], function (require, exports, ts_autoguard_1, libfs) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    const ROOT = [
        ".",
        "private",
        "config"
    ];
    const PATH = [...ROOT, "config.json"].join("/");
    let config = {
        certificate_path: [".", "private", "certs", "full_chain.pem"],
        certificate_key_path: [".", "private", "certs", "certificate_key.pem"],
        http_port: 80,
        https_port: 443,
        media_path: [".", "private", "media"],
        use_demo_mode: false,
        use_registration_keys: true
    };
    try {
        let string = libfs.readFileSync(PATH, "utf-8");
        let json = JSON.parse(string);
        if (ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any).is(json)) {
            if (ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String).is(json.certificate_key_path)) {
                config.certificate_key_path = json.certificate_key_path;
            }
            if (ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String).is(json.certificate_path)) {
                config.certificate_path = json.certificate_path;
            }
            if (ts_autoguard_1.guards.Number.is(json.http_port)) {
                config.http_port = json.http_port;
            }
            if (ts_autoguard_1.guards.Number.is(json.https_port)) {
                config.https_port = json.https_port;
            }
            if (ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String).is(json.media_path)) {
                config.media_path = json.media_path;
            }
            if (ts_autoguard_1.guards.Boolean.is(json.use_demo_mode)) {
                config.use_demo_mode = json.use_demo_mode;
            }
            if (ts_autoguard_1.guards.Boolean.is(json.use_registration_keys)) {
                config.use_registration_keys = json.use_registration_keys;
            }
        }
    }
    catch (error) { }
    if (!libfs.existsSync(ROOT.join("/"))) {
        libfs.mkdirSync(ROOT.join("/"));
    }
    libfs.writeFileSync(PATH, JSON.stringify(config, null, "\t"));
    exports.default = config;
});
define("build/jdb2/asserts/integer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntegerAssert = void 0;
    class IntegerAssert {
        constructor() { }
        static atLeast(min, value) {
            this.integer(min);
            this.integer(value);
            if (value < min) {
                throw `Expected ${value} to be at least ${min}!`;
            }
        }
        static atMost(max, value) {
            this.integer(value);
            this.integer(max);
            if (value > max) {
                throw `Expected ${value} to be at most ${max}!`;
            }
        }
        static between(min, value, max) {
            this.atLeast(min, value);
            this.atMost(max, value);
        }
        static exactly(value, expected) {
            this.integer(expected);
            this.integer(value);
            if (value !== expected) {
                throw `Expected ${value} to be exactly ${expected}!`;
            }
        }
        static integer(value) {
            if (!Number.isInteger(value)) {
                throw `Expected ${value} to be an integer!`;
            }
        }
    }
    exports.IntegerAssert = IntegerAssert;
    ;
});
define("build/jdb/index", ["require", "exports", "crypto", "fs", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/is", "build/jsondb/index"], function (require, exports, libcrypto, libfs, autoguard, stdlib, is, jsondb_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Index = exports.IndexRecord = exports.IndexEntry = exports.IndexHeader = exports.Table = exports.RecordIndexEntry = exports.RecordIndexHeader = exports.StreamIterable = exports.computeHash = void 0;
    function computeHash(value) {
        return libcrypto.createHash("sha256")
            .update(String(value))
            .digest("hex")
            .slice(0, 16);
    }
    exports.computeHash = computeHash;
    function* filter(iterable, predicate) {
        let index = 0;
        for (let value of iterable) {
            if (predicate(value, index++)) {
                yield value;
            }
        }
    }
    function* include(iterable, predicate) {
        let index = 0;
        for (let value of iterable) {
            if (predicate(value, index++)) {
                yield value;
            }
        }
    }
    function* map(iterable, transform) {
        let index = 0;
        for (let value of iterable) {
            yield transform(value, index++);
        }
    }
    class StreamIterable {
        values;
        constructor(values) {
            this.values = values;
        }
        *[Symbol.iterator]() {
            //yield* this.values;
            for (let value of this.values) {
                yield value;
            }
        }
        collect() {
            return Array.from(this.values);
        }
        filter(predicate) {
            return new StreamIterable(filter(this.values, predicate));
        }
        find(predicate) {
            let index = 0;
            for (let value of this.values) {
                if (predicate(value, index++)) {
                    return value;
                }
            }
        }
        include(predicate) {
            return new StreamIterable(include(this.values, predicate));
        }
        includes(predicate) {
            let index = 0;
            for (let value of this.values) {
                if (predicate(value, index++)) {
                    return true;
                }
            }
            return false;
        }
        map(transform) {
            return new StreamIterable(map(this.values, transform));
        }
        shift() {
            for (let value of this.values) {
                return value;
            }
        }
        slice(start, end) {
            let array = this.collect().slice(start, end);
            return new StreamIterable(array);
        }
        sort(comparator) {
            let array = this.collect().sort(comparator);
            return new StreamIterable(array);
        }
        unique() {
            return new StreamIterable(new Set(this.values));
        }
        static of(values) {
            return new StreamIterable(values ?? new Array());
        }
    }
    exports.StreamIterable = StreamIterable;
    ;
    function readBuffer(fd, buffer, position) {
        let bytes = libfs.readSync(fd, buffer, 0, buffer.length, position ?? null);
        if (bytes !== buffer.length) {
            throw `Expected to read ${buffer.length} bytes but read ${bytes}!`;
        }
        return buffer;
    }
    function writeBuffer(fd, buffer, position) {
        let bytes = libfs.writeSync(fd, buffer, 0, buffer.length, position ?? null);
        if (bytes !== buffer.length) {
            throw `Expected to write ${buffer.length} bytes but wrote ${bytes}!`;
        }
        return buffer;
    }
    class RecordIndexHeader {
        buffer;
        get identifier() {
            return this.buffer.slice(0, 8).toString("binary");
        }
        get chunk_size_minus_one() {
            return this.buffer.readUInt32BE(8);
        }
        set chunk_size_minus_one(value) {
            this.buffer.writeUInt32BE(value, 8);
        }
        get chunk_size() {
            return this.chunk_size_minus_one + 1;
        }
        set chunk_size(value) {
            this.chunk_size_minus_one = value - 1;
        }
        constructor() {
            let buffer = Buffer.alloc(16);
            buffer.write("\x23\x52\xDB\x07\xEC\x77\x30\x61", 0, "binary");
            buffer.writeUInt32BE(63, 8);
            this.buffer = buffer;
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
            let identifier = this.buffer.slice(0, 8).toString("binary");
            if (identifier !== this.identifier) {
                throw `Unsupported file format!`;
            }
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.RecordIndexHeader = RecordIndexHeader;
    ;
    class RecordIndexEntry {
        buffer;
        get key() {
            return this.buffer.slice(0, 8).toString("hex");
        }
        set key(value) {
            if (!/^[0-9a-f]{16}$/.test(value)) {
                throw `Invalid key, ${value}!`;
            }
            this.buffer.set(Buffer.from(value, "hex"), 0);
        }
        get chunk_offset() {
            return this.buffer.readUInt32BE(8);
        }
        set chunk_offset(value) {
            this.buffer.writeUInt32BE(value, 8);
        }
        get chunk_length_minus_one() {
            return this.buffer.readUInt32BE(12);
        }
        set chunk_length_minus_one(value) {
            this.buffer.writeUInt32BE(value, 12);
        }
        get chunk_length() {
            return this.chunk_length_minus_one + 1;
        }
        set chunk_length(value) {
            this.chunk_length_minus_one = value - 1;
        }
        constructor() {
            let buffer = Buffer.alloc(16);
            this.buffer = buffer;
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.RecordIndexEntry = RecordIndexEntry;
    ;
    class Table {
        toc;
        bin;
        header;
        indexFromKey; // 70k elements tar 5mb, 2195857 elements tar 170mb
        router;
        guard;
        key_provider;
        cache;
        free_entries;
        getNumberOfEntries() {
            let entry_count = libfs.fstatSync(this.toc).size / 16 - 1;
            if (!Number.isInteger(entry_count)) {
                throw `Expected a non-fractional number of entries!`;
            }
            return entry_count;
        }
        readEntry(index, entry) {
            entry.read(this.toc, 16 + index * 16);
            return entry;
        }
        getEntryFor(chunk_length, key) {
            let entry = new RecordIndexEntry();
            for (let entry_index of this.free_entries) {
                this.readEntry(entry_index, entry);
                if (entry.chunk_length >= chunk_length || entry_index === this.getNumberOfEntries() - 1) {
                    this.free_entries.delete(entry_index);
                    entry.key = key;
                    entry.chunk_length = Math.max(entry.chunk_length, chunk_length);
                    entry.write(this.toc, 16 + entry_index * 16);
                    return entry_index;
                }
            }
            let entry_index = this.getNumberOfEntries();
            entry.chunk_offset = Math.ceil(libfs.fstatSync(this.bin).size / this.header.chunk_size);
            entry.chunk_length = chunk_length;
            entry.key = key;
            entry.write(this.toc, 16 + entry_index * 16);
            return entry_index;
        }
        getRecord(index) {
            let record = this.cache.get(index);
            if (is.present(record)) {
                this.cache.delete(index);
                this.cache.set(index, record);
                return record;
            }
            let entry = new RecordIndexEntry();
            this.readEntry(index, entry);
            if (entry.key === "0000000000000000") {
                throw `Expected ${index} to match a record!`;
            }
            let position = entry.chunk_offset * this.header.chunk_size;
            let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
            readBuffer(this.bin, buffer, position);
            let end = buffer.length;
            while (end > 0) {
                if (buffer[end - 1] !== 0) {
                    break;
                }
                end -= 1;
            }
            let string = buffer.toString("utf8", 0, end);
            let json = JSON.parse(string);
            record = this.guard.as(json);
            this.cache.set(index, record);
            if (this.cache.size > 10000) {
                for (let idx of this.cache.keys()) {
                    this.cache.delete(idx);
                    break;
                }
            }
            return record;
        }
        insertOrUpdate(next) {
            let key = this.key_provider(next);
            let string = JSON.stringify(next);
            let binary = new TextEncoder().encode(string);
            let chunks = Math.max(1, Math.ceil(binary.length / this.header.chunk_size));
            let index = this.indexFromKey[key];
            if (is.present(index)) {
                let last = this.getRecord(index);
                let entry = this.readEntry(index, new RecordIndexEntry());
                if (chunks <= entry.chunk_length) {
                    let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    buffer.set(binary, 0);
                    writeBuffer(this.bin, buffer, entry.chunk_offset * this.header.chunk_size);
                }
                else {
                    let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    writeBuffer(this.bin, buffer, entry.chunk_offset * this.header.chunk_size);
                    delete this.indexFromKey[key];
                    entry.key = "0000000000000000";
                    entry.write(this.toc, 16 + index * 16);
                    this.free_entries.add(index);
                    index = this.getEntryFor(chunks * 2, key);
                    entry = this.readEntry(index, new RecordIndexEntry());
                    let buffer2 = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    buffer2.set(binary, 0);
                    writeBuffer(this.bin, buffer2, entry.chunk_offset * this.header.chunk_size);
                    this.indexFromKey[key] = index;
                }
                this.cache.delete(index);
                this.cache.set(index, next);
                this.router.route("update", {
                    last: last,
                    next: next
                });
                return;
            }
            index = this.getEntryFor(chunks, key);
            let entry = this.readEntry(index, new RecordIndexEntry());
            let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
            buffer.set(binary, 0);
            writeBuffer(this.bin, buffer, entry.chunk_offset * this.header.chunk_size);
            this.indexFromKey[key] = index;
            this.cache.set(index, next);
            this.router.route("insert", {
                next: next
            });
        }
        constructor(root, table_name, guard, key_provider) {
            let directory = [...root, table_name];
            if (!libfs.existsSync(directory.join("/"))) {
                libfs.mkdirSync(directory.join("/"), { recursive: true });
            }
            let toc_filename = [...directory, "toc"];
            let toc_exists = libfs.existsSync(toc_filename.join("/"));
            let toc = libfs.openSync(toc_filename.join("/"), toc_exists ? "r+" : "w+");
            let bin_filename = [...directory, "bin"];
            let bin_exists = libfs.existsSync(bin_filename.join("/"));
            let bin = libfs.openSync(bin_filename.join("/"), bin_exists ? "r+" : "w+");
            let indexFromKey = {};
            let header = new RecordIndexHeader();
            let free_entries = new Set();
            if (toc_exists) {
                header.read(toc, 0);
                let entry_count = libfs.fstatSync(toc).size / 16 - 1;
                if (!Number.isInteger(entry_count)) {
                    throw `Expected a non-fractional number of entries!`;
                }
                let entry = new RecordIndexEntry();
                for (let index = 0; index < entry_count; index++) {
                    entry.read(toc, 16 + index * 16);
                    if (entry.key !== "0000000000000000") {
                        indexFromKey[entry.key] = index;
                    }
                    else {
                        free_entries.add(index);
                    }
                }
            }
            else {
                header.write(toc, 0);
            }
            this.toc = toc;
            this.bin = bin;
            this.header = header;
            this.indexFromKey = indexFromKey;
            this.router = new stdlib.routing.MessageRouter();
            this.guard = guard;
            this.key_provider = key_provider;
            this.cache = new Map();
            this.free_entries = free_entries;
        }
        destroy() {
            libfs.closeSync(this.toc);
            libfs.closeSync(this.bin);
        }
        *[Symbol.iterator]() {
            for (let index = 0; index < this.getNumberOfEntries(); index++) {
                try {
                    yield this.getRecord(index);
                }
                catch (error) { }
            }
        }
        insert(record) {
            this.insertOrUpdate(record);
        }
        keyof(record) {
            return this.key_provider(record);
        }
        length() {
            return this.getNumberOfEntries();
        }
        lookup(key) {
            let index = this.indexFromKey[key ?? "0000000000000000"];
            if (is.present(index)) {
                let record = this.getRecord(index);
                if (this.key_provider(record) === key) {
                    return record;
                }
            }
            throw `Expected ${key} to match a record!`;
        }
        on(type, listener) {
            this.router.addObserver(type, listener);
        }
        off(type, listener) {
            this.router.addObserver(type, listener);
        }
        remove(record) {
            let key = this.key_provider(record);
            let index = this.indexFromKey[key];
            if (is.present(index)) {
                let last = this.getRecord(index);
                if (this.key_provider(last) === key) {
                    let entry = this.readEntry(index, new RecordIndexEntry());
                    let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    let position = entry.chunk_offset * this.header.chunk_size;
                    writeBuffer(this.bin, buffer, position);
                    this.cache.delete(index);
                    delete this.indexFromKey[key];
                    entry.key = Buffer.alloc(8).toString("hex");
                    entry.write(this.toc, 16 + index * 16);
                    this.free_entries.add(index);
                    this.router.route("remove", {
                        last: last
                    });
                }
            }
        }
        update(record) {
            this.insertOrUpdate(record);
        }
    }
    exports.Table = Table;
    ;
    class IndexHeader {
        buffer;
        get identifier() {
            return this.buffer.slice(0, 8).toString("binary");
        }
        constructor() {
            let buffer = Buffer.alloc(16);
            buffer.write("\x01\xfb\x2e\x28\x8a\xa7\x98\x76", 0, "binary");
            this.buffer = buffer;
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
            let identifier = this.buffer.slice(0, 8).toString("binary");
            if (identifier !== this.identifier) {
                throw `Unsupported file format!`;
            }
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.IndexHeader = IndexHeader;
    ;
    class IndexEntry {
        buffer;
        get hash() {
            return this.buffer.slice(0, 8).toString("hex");
        }
        set hash(value) {
            if (!/^[0-9a-f]{16}$/.test(value)) {
                throw `Invalid group key, ${value}!`;
            }
            this.buffer.set(Buffer.from(value, "hex"), 0);
        }
        get key() {
            return this.buffer.slice(8, 8 + 8).toString("hex");
        }
        set key(value) {
            if (!/^[0-9a-f]{16}$/.test(value)) {
                throw `Invalid key, ${value}!`;
            }
            this.buffer.set(Buffer.from(value, "hex"), 8);
        }
        get is_free() {
            return /^[0]{16}$/.test(this.buffer.toString("hex"));
        }
        set is_free(value) {
            if (value) {
                this.buffer.fill(0);
            }
        }
        constructor() {
            let buffer = Buffer.alloc(16);
            this.buffer = buffer;
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.IndexEntry = IndexEntry;
    ;
    exports.IndexRecord = autoguard.guards.Object.of({
        id: autoguard.guards.String,
        keys: autoguard.guards.Array.of(autoguard.guards.String)
    });
    function computePosition(key, keys, lower = 0, upper = keys.length - 1) {
        let length = upper - lower + 1;
        let index = lower + Math.floor(length / 2);
        if (length > 0) {
            let compareKey = keys[index];
            if (key < compareKey) {
                return computePosition(key, keys, lower, index - 1);
            }
            if (key > compareKey) {
                return computePosition(key, keys, index + 1, upper);
            }
        }
        return index;
    }
    function insert(key, keys) {
        let position = computePosition(key, keys);
        if (keys[position] !== key) {
            keys.splice(position, 0, key);
        }
    }
    function remove(key, keys) {
        let position = computePosition(key, keys);
        if (keys[position] === key) {
            keys.splice(position, 1);
        }
    }
    class Index {
        table;
        getRecordFromKey;
        getValues;
        getKey;
        getTokensFromValue;
        maxGroupSize;
        constructor(root, index_name, getRecordFromKey, getValues, getRecordKey, getQueryTokens, maxGroupSize) {
            this.table = new Table(root, index_name, exports.IndexRecord, (record) => record.id);
            this.getRecordFromKey = getRecordFromKey;
            this.getValues = getValues;
            this.getKey = getRecordKey;
            this.getTokensFromValue = getQueryTokens;
            this.maxGroupSize = maxGroupSize;
        }
        insert(record) {
            let key = this.getKey(record);
            for (let value of this.getValues(record)) {
                for (let token of this.getTokensFromValue(value)) {
                    let hash = computeHash(token);
                    let record;
                    try {
                        record = this.table.lookup(hash);
                    }
                    catch (error) { }
                    if (is.absent(record)) {
                        record = {
                            id: hash,
                            keys: []
                        };
                    }
                    let keys = record.keys;
                    if (is.present(this.maxGroupSize) && keys.length >= this.maxGroupSize) {
                        continue;
                    }
                    let position = computePosition(key, keys);
                    if (keys[position] !== key) {
                        keys.splice(position, 0, key);
                        this.table.update(record);
                    }
                }
            }
        }
        length() {
            return this.table.length();
        }
        lookup(value) {
            return this.search(value).map((result) => this.getRecordFromKey(result.id));
        }
        remove(record) {
            let key = this.getKey(record);
            for (let value of this.getValues(record)) {
                for (let token of this.getTokensFromValue(value)) {
                    let hash = computeHash(token);
                    let keys = new Array();
                    try {
                        let record = this.table.lookup(hash);
                        keys = record.keys;
                    }
                    catch (error) { }
                    let position = computePosition(key, keys);
                    if (keys[position] === key) {
                        keys.splice(position, 1);
                        if (keys.length > 0) {
                            this.table.update({
                                id: hash,
                                keys: keys
                            });
                        }
                        else {
                            this.table.remove({
                                id: hash,
                                keys: keys
                            });
                        }
                    }
                }
            }
        }
        search(value) {
            let tokens = this.getTokensFromValue(value);
            let records = tokens
                .map((token) => computeHash(token))
                .map((hash) => {
                try {
                    return this.table.lookup(hash);
                }
                catch (error) { }
            })
                .filter(is.present);
            let map = new Map();
            for (let record of records) {
                for (let key of record.keys) {
                    let rank = map.get(key) ?? (0 - tokens.length);
                    map.set(key, rank + 2);
                }
            }
            return StreamIterable.of(map.entries())
                .filter((entry) => entry[1] >= 0)
                .sort(jsondb_1.sorters.NumericSort.decreasing((entry) => entry[1]))
                .map((entry) => ({
                id: entry[0],
                rank: entry[1]
            }));
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static NUMBER_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            return Array.from(normalized.match(/(\p{N}+)/gu) ?? []);
        };
        static QUERY_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
        };
        static VALUE_TOKENIZER = (value) => {
            return [value];
        };
        static WORD_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            return Array.from(normalized.match(/(\p{L}+)/gu) ?? []);
        };
    }
    exports.Index = Index;
    ;
});
define("build/jdb2/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.IndexRecord = void 0;
    exports.IndexRecord = autoguard.guards.Object.of({
        "token": autoguard.guards.Union.of(autoguard.guards.Union.of(autoguard.guards.Boolean, autoguard.guards.Null, autoguard.guards.Number, autoguard.guards.String, autoguard.guards.Undefined), autoguard.guards.Undefined),
        "index": autoguard.guards.Number
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "IndexRecord": autoguard.guards.Reference.of(() => exports.IndexRecord)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/jdb2/index", ["require", "exports", "crypto", "fs", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/is", "build/jdb2/asserts/integer", "build/jdb/index", "build/jsondb/index", "build/jdb2/schema/index"], function (require, exports, libcrypto, libfs, stdlib, is, integer_1, jdb_1, jsondb_1, schema_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /*
    [v1]
        latency shows: 160 ms
        files table: 6191 kB + 431 kB
        indices: 9 MB
        tables: 15 MB
    
    [8bit branch, 32bit pointers]
        latency shows: 290 ms
        files table: 10272 kB + 747 kB
        indices: 178 MB
        tables: 35 MB
    
    [4bit branch, 32bit pointers]
        latency shows: 240 ms
        files table: 6482 kB + 807 kB
        indices: 23 MB
        tables: 20 MB
    
    [4bit branch, 32bit pointers + rhh]
        latency shows: 230 ms
        files table: 6482 kB + 807 kB
        indices: 14 MB
        tables: 20 MB
    
    [rhh + rhh]
        latency shows: 230 ms
        files table: 5823 kB + 431 kB
        indices: 11 MB
        tables: 16 MB
    */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Index = exports.RobinHoodHash = exports.Table = exports.deserializeKey = exports.serializeKey = exports.bytesFromNibbles = exports.nibblesFromBytes = exports.computeCommonPrefixLength = exports.NodeTable = exports.Node = exports.BlockHandler = exports.Cache = exports.Entry = exports.Pointer = exports.Counter = exports.Chunk = exports.write = exports.size = exports.read = exports.open = void 0;
    const DEBUG = false;
    function open(path) {
        let filename = path.join("/");
        let exists = libfs.existsSync(filename);
        libfs.mkdirSync(path.slice(0, -1).join("/"), { recursive: true });
        let fd = libfs.openSync(filename, exists ? "r+" : "w+");
        return fd;
    }
    exports.open = open;
    ;
    function read(fd, buffer, offset) {
        let length = buffer.length;
        let bytes = libfs.readSync(fd, buffer, {
            position: offset
        });
        if (bytes !== length) {
            throw `Expected to read ${length} bytes but read ${bytes}!`;
        }
        return buffer;
    }
    exports.read = read;
    ;
    function size(fd) {
        return libfs.fstatSync(fd).size;
    }
    exports.size = size;
    ;
    function write(fd, buffer, offset) {
        let length = buffer.length;
        let bytes = libfs.writeSync(fd, buffer, 0, length, offset);
        if (bytes !== length) {
            throw `Expected to write ${length} bytes but wrote ${bytes}!`;
        }
        return buffer;
    }
    exports.write = write;
    ;
    class Chunk {
        buffer;
        constructor(buffer) {
            this.buffer = buffer;
        }
        load(fd, offset) {
            read(fd, this.buffer, offset);
        }
        save(fd, offset) {
            write(fd, this.buffer, offset);
        }
    }
    exports.Chunk = Chunk;
    ;
    class Counter extends Chunk {
        static SIZE = 4;
        get count() {
            return this.buffer.readUInt32BE(0);
        }
        set count(value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
            this.buffer.writeUInt32BE(value, 0);
        }
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Counter.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Counter.SIZE);
            super(buffer);
        }
    }
    exports.Counter = Counter;
    ;
    class Pointer extends Chunk {
        static SIZE = 4;
        get index() {
            return this.buffer.readUInt32BE(0);
        }
        set index(value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
            this.buffer.writeUInt32BE(value, 0);
        }
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Pointer.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Pointer.SIZE);
            super(buffer);
        }
    }
    exports.Pointer = Pointer;
    ;
    class Entry extends Chunk {
        static SIZE = 16;
        get offset() {
            return Number(this.buffer.readBigUInt64BE(0));
        }
        set offset(value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFFFFFF);
            this.buffer.writeBigUInt64BE(BigInt(value), 0);
        }
        get deleted() {
            return this.buffer.readUInt8(8) === 0x80;
        }
        set deleted(value) {
            this.buffer.writeUInt8(value ? 0x80 : 0x00, 8);
        }
        get length() {
            return Number(this.buffer.readBigUInt64BE(8) & BigInt(0xFFFFFFFFFFFF)) + 1;
        }
        set length(value) {
            value = value - 1;
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFFFFFF);
            let deleted = this.deleted;
            this.buffer.writeBigUInt64BE(BigInt(value), 8);
            this.deleted = deleted;
        }
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Entry.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Entry.SIZE);
            super(buffer);
        }
    }
    exports.Entry = Entry;
    ;
    class Cache {
        map;
        weightProvider;
        maxWeight;
        weight;
        purge() {
            if (is.present(this.maxWeight)) {
                for (let [key, last] of this.map.entries()) {
                    if (this.weight <= this.maxWeight) {
                        break;
                    }
                    this.weight -= this.weightProvider(last);
                    this.map.delete(key);
                }
            }
        }
        constructor(weightProvider, maxWeight) {
            this.map = new Map();
            this.weightProvider = weightProvider;
            this.maxWeight = maxWeight;
            this.weight = 0;
        }
        insert(key, value) {
            this.remove(key);
            if (is.present(value)) {
                this.weight += this.weightProvider(value);
                this.map.set(key, value);
                this.purge();
            }
        }
        lookup(key) {
            return this.map.get(key);
        }
        remove(key) {
            let value = this.map.get(key);
            if (is.present(value)) {
                this.weight -= this.weightProvider(value);
                this.map.delete(key);
            }
            return value;
        }
    }
    exports.Cache = Cache;
    ;
    class BlockHandler {
        static FIRST_APPLICATION_BLOCK = 64;
        bin;
        toc;
        blockCache;
        entryCache;
        inBatchOperation;
        computePool(minLength) {
            if (DEBUG)
                integer_1.IntegerAssert.atLeast(0, minLength);
            let lengthLog2 = Math.ceil(Math.log2(Math.max(1, minLength)));
            return lengthLog2;
        }
        createNewBlock(minLength) {
            let entry = new Entry();
            entry.offset = size(this.bin);
            entry.length = Math.pow(2, this.computePool(minLength));
            write(this.bin, Buffer.alloc(entry.length), entry.offset);
            write(this.toc, entry.buffer, size(this.toc));
            return this.getCount() - 1;
        }
        createOldBlock(minLength) {
            let pool = this.computePool(minLength);
            let counter = new Counter();
            this.readBlock(pool, counter.buffer, 0);
            if (counter.count === 0) {
                throw ``;
            }
            let pointer = new Pointer();
            this.readBlock(pool, pointer.buffer, Counter.SIZE + (counter.count - 1) * Pointer.SIZE);
            let index = pointer.index;
            pointer.index = 0;
            this.writeBlock(pool, pointer.buffer, Counter.SIZE + (counter.count - 1) * Pointer.SIZE);
            counter.count -= 1;
            this.writeBlock(pool, counter.buffer, 0);
            let entry = new Entry();
            this.readEntry(index, entry);
            entry.deleted = false;
            this.writeEntry(index, entry);
            return index;
        }
        readEntry(index, entry) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, index, this.getCount() - 1);
            let cached = this.entryCache.lookup(index);
            if (is.absent(cached)) {
                cached = new Entry();
                read(this.toc, cached.buffer, index * Entry.SIZE);
                this.entryCache.insert(index, cached);
            }
            cached.buffer.copy(entry.buffer, 0, 0);
            return entry;
        }
        writeEntry(index, entry) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, index, this.getCount() - 1);
            write(this.toc, entry.buffer, index * Entry.SIZE);
            let cached = new Entry();
            entry.buffer.copy(cached.buffer, 0, 0);
            this.entryCache.insert(index, cached);
            return entry;
        }
        constructor(path) {
            this.bin = open([...path, "bin"]);
            this.toc = open([...path, "toc"]);
            this.blockCache = new Cache((value) => value.length, 512 * 1024 * 1024);
            this.entryCache = new Cache((value) => 1, 1 * 1000 * 1000);
            this.inBatchOperation = new Set();
            if (this.getCount() === 0) {
                for (let i = 0; i < BlockHandler.FIRST_APPLICATION_BLOCK; i++) {
                    this.createNewBlock(16);
                }
            }
        }
        batchOperation(index, operation) {
            if (this.inBatchOperation.has(index)) {
                throw `Expected block ${index} to be in normal operation!`;
            }
            this.inBatchOperation.add(index);
            try {
                operation();
            }
            catch (error) {
                this.inBatchOperation.delete(index);
                throw error;
            }
            this.inBatchOperation.delete(index);
            let buffer = this.readBlock(index);
            this.writeBlock(index, buffer);
        }
        clearBlock(index) {
            this.writeBlock(index, Buffer.alloc(0));
        }
        createBlock(minLength) {
            if (minLength === 0) {
                return 0xFFFFFFFF;
            }
            try {
                return this.createOldBlock(minLength);
            }
            catch (error) { }
            try {
                return this.createNewBlock(minLength);
            }
            catch (error) { }
            throw `Unable to create block with length ${minLength}!`;
        }
        deleteBlock(index) {
            if (index === 0xFFFFFFFF) {
                return;
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            if (entry.deleted) {
                return;
            }
            let pool = this.computePool(entry.length);
            let counter = new Counter();
            this.readBlock(pool, counter.buffer, 0);
            let minLength = Counter.SIZE + (counter.count + 1) * Pointer.SIZE;
            let length = this.readEntry(pool, new Entry()).length;
            if (minLength > length) {
                this.resizeBlock(pool, minLength);
                this.readBlock(pool, counter.buffer, 0); // Resize can in theory consume one block.
            }
            let pointer = new Pointer();
            pointer.index = index;
            this.writeBlock(pool, pointer.buffer, Counter.SIZE + (counter.count * Pointer.SIZE));
            counter.count += 1;
            this.writeBlock(pool, counter.buffer, 0);
            let buffer = Buffer.alloc(entry.length);
            this.writeBlock(index, buffer, 0);
            entry.deleted = true;
            this.writeEntry(index, entry);
            this.blockCache.remove(index);
            this.inBatchOperation.delete(index);
        }
        getBlockSize(index) {
            if (index === 0xFFFFFFFF) {
                return 0;
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            return entry.length;
        }
        getCount() {
            let count = size(this.toc) / Entry.SIZE;
            if (DEBUG)
                integer_1.IntegerAssert.atLeast(0, count);
            return count;
        }
        readBlock(index, buffer, skipLength) {
            if (index === 0xFFFFFFFF) {
                return Buffer.alloc(0);
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            buffer = buffer ?? Buffer.alloc(entry.length);
            let offset = skipLength ?? 0;
            let length = buffer.length;
            if (DEBUG)
                integer_1.IntegerAssert.between(0, offset, entry.length - 1);
            if (DEBUG)
                integer_1.IntegerAssert.between(0, length, entry.length - offset);
            let cached = this.blockCache.lookup(index);
            if (is.absent(cached)) {
                cached = Buffer.alloc(entry.length);
                read(this.bin, cached, entry.offset);
                this.blockCache.insert(index, cached);
            }
            cached.copy(buffer, 0, offset);
            return buffer;
        }
        resizeBlock(index, minLength) {
            if (index === 0xFFFFFFFF) {
                return;
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            if (this.computePool(minLength) === this.computePool(entry.length)) {
                return;
            }
            let indexTwo = this.createBlock(minLength);
            let entryTwo = new Entry();
            this.readEntry(indexTwo, entryTwo);
            let length = Math.min(entry.length, entryTwo.length);
            let buffer = Buffer.alloc(length);
            this.readBlock(index, buffer);
            this.writeBlock(indexTwo, buffer, 0);
            this.swapBlocks(index, indexTwo);
            this.deleteBlock(indexTwo);
        }
        swapBlocks(indexOne, indexTwo) {
            let entryOne = new Entry();
            this.readEntry(indexOne, entryOne);
            let entryTwo = new Entry();
            this.readEntry(indexTwo, entryTwo);
            this.writeEntry(indexOne, entryTwo);
            this.writeEntry(indexTwo, entryOne);
            let blockOne = this.blockCache.remove(indexOne);
            let blockTwo = this.blockCache.remove(indexTwo);
            this.blockCache.insert(indexOne, blockTwo);
            this.blockCache.insert(indexTwo, blockOne);
        }
        writeBlock(index, buffer, skipLength) {
            if (index === 0xFFFFFFFF) {
                return Buffer.alloc(0);
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            buffer = buffer ?? Buffer.alloc(entry.length);
            let offset = skipLength ?? 0;
            let length = buffer.length;
            if (DEBUG)
                integer_1.IntegerAssert.between(0, offset, entry.length - 1);
            if (DEBUG)
                integer_1.IntegerAssert.between(0, length, entry.length - offset);
            let cached = this.blockCache.lookup(index);
            if (is.absent(cached)) {
                cached = this.readBlock(index);
                this.blockCache.insert(index, cached);
            }
            cached.set(buffer, offset);
            if (is.absent(skipLength)) {
                cached.set(Buffer.alloc(entry.length - buffer.length), buffer.length);
            }
            if (!this.inBatchOperation.has(index)) {
                write(this.bin, buffer, entry.offset + offset);
                if (is.absent(skipLength)) {
                    write(this.bin, Buffer.alloc(entry.length - buffer.length), entry.offset + buffer.length);
                }
            }
            return buffer;
        }
    }
    exports.BlockHandler = BlockHandler;
    ;
    class Node extends Chunk {
        static MAX_NIBBLES = 15;
        static SIZE = 8 + 8;
        prefix(value) {
            if (is.present(value)) {
                let length = value.length;
                if (DEBUG)
                    integer_1.IntegerAssert.between(0, length, Node.MAX_NIBBLES);
                let bytes = bytesFromNibbles(Buffer.of(length, ...value));
                this.buffer.set(bytes, 0);
                this.buffer.fill(0, bytes.length, 8);
                return this.buffer;
            }
            else {
                let bytes = this.buffer.slice(0, 8);
                let nibbles = nibblesFromBytes(bytes);
                let length = nibbles[0];
                return nibbles.slice(1, 1 + length);
            }
        }
        resident(value) {
            let offset = 8;
            if (is.present(value)) {
                if (DEBUG)
                    integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
                this.buffer.writeUInt32BE(value, offset);
                return value;
            }
            else {
                return this.buffer.readUInt32BE(offset);
            }
        }
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Node.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Node.SIZE);
            super(buffer);
        }
    }
    exports.Node = Node;
    ;
    class NodeTable extends Chunk {
        static LENGTH = 16;
        static SIZE = NodeTable.LENGTH * 4;
        subtree(index, value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, index, NodeTable.LENGTH - 1);
            let offset = index * 4;
            if (is.present(value)) {
                if (DEBUG)
                    integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
                this.buffer.writeUInt32BE(value, offset);
                return value;
            }
            else {
                return this.buffer.readUInt32BE(offset);
            }
        }
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(NodeTable.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, NodeTable.SIZE);
            super(buffer);
        }
    }
    exports.NodeTable = NodeTable;
    ;
    function computeCommonPrefixLength(prefixBytes, keyBytes, keyByteIndex) {
        let length = Math.min(prefixBytes.length, keyBytes.length - keyByteIndex);
        for (let i = 0; i < length; i++) {
            let prefixByte = prefixBytes[i];
            let keyByte = keyBytes[keyByteIndex + i];
            if (prefixByte !== keyByte) {
                return i;
            }
        }
        return length;
    }
    exports.computeCommonPrefixLength = computeCommonPrefixLength;
    ;
    function nibblesFromBytes(bytes) {
        let nibbles = new Array();
        for (let byte of bytes) {
            nibbles.push((byte >> 4) & 0x0F, (byte >> 0) & 0x0F);
        }
        return Buffer.from(nibbles);
    }
    exports.nibblesFromBytes = nibblesFromBytes;
    ;
    function bytesFromNibbles(nibbles) {
        let bytes = new Array();
        for (let i = 0; i < nibbles.length; i += 2) {
            bytes.push((nibbles[i + 0] << 4) | (nibbles[i + 1] << 0));
        }
        return Buffer.from(bytes);
    }
    exports.bytesFromNibbles = bytesFromNibbles;
    ;
    function serializeKey(key) {
        if (typeof key === "boolean") {
            return Buffer.of(key ? 1 : 0);
        }
        if (typeof key === "number") {
            return Buffer.from(`${key}`);
        }
        if (typeof key === "string") {
            if (/^[0-9a-f]{8,}$/i.test(key)) {
                return Buffer.from(key, "hex");
            }
            else {
                return Buffer.from(key, "binary");
            }
        }
        return Buffer.alloc(0);
    }
    exports.serializeKey = serializeKey;
    ;
    function deserializeKey(bytes) {
        return bytes.toString("binary");
    }
    exports.deserializeKey = deserializeKey;
    ;
    class Table extends stdlib.routing.MessageRouter {
        recordCache;
        blockHandler;
        recordParser;
        keyProvider;
        hashTable;
        debug() {
            this.hashTable.debug();
        }
        constructor(blockHandler, recordParser, keyProvider) {
            super();
            if (blockHandler.getCount() === BlockHandler.FIRST_APPLICATION_BLOCK) {
                blockHandler.createBlock(RobinHoodHash.INITIAL_SIZE);
            }
            this.recordCache = new Cache((record) => 1, 1 * 1000 * 1000);
            this.blockHandler = blockHandler;
            this.recordParser = recordParser;
            this.keyProvider = keyProvider;
            this.hashTable = new RobinHoodHash(blockHandler, BlockHandler.FIRST_APPLICATION_BLOCK, (index) => {
                let record = this.getRecord(index);
                return this.keyProvider(record);
            });
        }
        *[Symbol.iterator]() {
            yield* jdb_1.StreamIterable.of(this.hashTable)
                .map((value) => this.getRecord(value));
        }
        getRecord(index) {
            let record = this.recordCache.lookup(index);
            if (is.present(record)) {
                return record;
            }
            let block = this.blockHandler.readBlock(index);
            let string = block.toString().replace(/[\0]*$/, "");
            let json = JSON.parse(string);
            record = this.recordParser(json);
            this.recordCache.insert(index, record);
            return record;
        }
        entries() {
            return jdb_1.StreamIterable.of(this.hashTable)
                .map((index) => {
                let record = this.getRecord(index);
                let key = this.keyProvider(record);
                return [key, index, record];
            })
                .slice();
        }
        insert(next) {
            let bytes = Buffer.from(JSON.stringify(next));
            let key = this.keyProvider(next);
            let index = this.hashTable.lookup(key);
            if (is.absent(index)) {
                index = this.blockHandler.createBlock(bytes.length);
                this.blockHandler.writeBlock(index, bytes);
                this.hashTable.insert(key, index);
                this.recordCache.insert(index, next);
                this.route("insert", {
                    key: key,
                    index: index,
                    record: next
                });
            }
            else {
                let last = this.getRecord(index);
                this.blockHandler.resizeBlock(index, bytes.length);
                this.blockHandler.writeBlock(index, bytes);
                this.recordCache.insert(index, next);
                this.route("update", {
                    key: key,
                    index: index,
                    last: last,
                    next: next
                });
            }
        }
        lookup(key) {
            let index = this.hashTable.lookup(key);
            if (is.absent(index)) {
                throw `Expected a record for ${key}!`;
            }
            let record = this.getRecord(index);
            return record;
        }
        remove(next) {
            let key = this.keyProvider(next);
            let index = this.hashTable.lookup(key);
            if (is.absent(index)) {
                return;
            }
            this.route("remove", {
                key: key,
                index: index,
                record: next
            });
            this.hashTable.remove(key, index);
            this.blockHandler.deleteBlock(index);
            this.recordCache.remove(index);
        }
        update(next) {
            this.insert(next);
        }
    }
    exports.Table = Table;
    ;
    class RobinHoodHash {
        static INITIAL_SIZE = 16 + 2 * 8;
        blockHandler;
        blockIndex;
        keyFromIndexProvider;
        constructor(blockHandler, blockIndex, keyFromIndexProvider) {
            this.blockHandler = blockHandler;
            this.blockIndex = blockIndex;
            this.keyFromIndexProvider = keyFromIndexProvider;
        }
        readHeader() {
            let buffer = Buffer.alloc(16);
            this.blockHandler.readBlock(this.blockIndex, buffer, 0);
            let occupiedSlots = Number(buffer.readBigUInt64BE(0));
            return {
                occupiedSlots
            };
        }
        writeHeader(header) {
            let buffer = Buffer.alloc(16);
            buffer.writeBigUInt64BE(BigInt(header.occupiedSlots), 0);
            this.blockHandler.writeBlock(this.blockIndex, buffer, 0);
        }
        getSlotCount() {
            let blockSize = this.blockHandler.getBlockSize(this.blockIndex);
            return (blockSize - 16) / 8;
        }
        computeOptimalSlot(serializedKey) {
            let hash = libcrypto.createHash("sha256")
                .update(serializedKey)
                .digest();
            let slotCount = this.getSlotCount();
            let optimalSlot = Number(hash.readBigUInt64BE(0) % BigInt(slotCount));
            return optimalSlot;
        }
        loadSlot(slotIndex) {
            let buffer = Buffer.alloc(8);
            this.blockHandler.readBlock(this.blockIndex, buffer, 16 + slotIndex * 8);
            let probeDistance = buffer.readUInt8(0);
            let isOccupied = buffer.readUInt8(1) === 0x01;
            let index = Number(buffer.readBigUInt64BE(0) & 0x0000ffffffffffffn);
            return {
                probeDistance,
                isOccupied,
                index
            };
        }
        saveSlot(slotIndex, slot) {
            let buffer = Buffer.alloc(8);
            buffer.writeBigUInt64BE(BigInt(slot.index), 0);
            buffer.writeUInt8(slot.probeDistance, 0);
            buffer.writeUInt8(slot.isOccupied ? 0x01 : 0x00, 1);
            this.blockHandler.writeBlock(this.blockIndex, buffer, 16 + slotIndex * 8);
        }
        resizeIfNeccessary() {
            let slotCount = this.getSlotCount();
            let header = this.readHeader();
            let currentLoadFactor = header.occupiedSlots / slotCount;
            let desiredSlotCount = slotCount;
            if (currentLoadFactor <= 0.25) {
                desiredSlotCount = Math.max(Math.ceil(slotCount / 2), 2);
            }
            if (currentLoadFactor >= 0.75) {
                desiredSlotCount = slotCount * 2;
            }
            if (desiredSlotCount === slotCount) {
                return;
            }
            let values = jdb_1.StreamIterable.of(this).collect();
            let minLength = 16 + desiredSlotCount * 8;
            this.blockHandler.resizeBlock(this.blockIndex, minLength);
            let newSlotCount = this.getSlotCount();
            if (newSlotCount === slotCount) {
                return;
            }
            this.blockHandler.batchOperation(this.blockIndex, () => {
                this.blockHandler.clearBlock(this.blockIndex);
                for (let value of values) {
                    let key = this.keyFromIndexProvider(value);
                    this.doInsert(key, value);
                }
                this.writeHeader(header);
            });
        }
        doInsert(key, index) {
            let serializedKey = serializeKey(key);
            let optimalSlot = this.computeOptimalSlot(serializedKey);
            let slotCount = this.getSlotCount();
            let slotIndex = optimalSlot;
            let probeDistance = 0;
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot(slotIndex);
                if (!slot.isOccupied) {
                    this.saveSlot(slotIndex, {
                        index: index,
                        probeDistance: probeDistance,
                        isOccupied: true
                    });
                    return slotIndex;
                }
                if (slot.index === index) {
                    return;
                }
                if (probeDistance > slot.probeDistance) {
                    this.saveSlot(slotIndex, {
                        index: index,
                        probeDistance: probeDistance,
                        isOccupied: true
                    });
                    index = slot.index;
                    probeDistance = slot.probeDistance;
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
            throw `Expected code to be unreachable!`;
        }
        propagateBackwards(slotIndex) {
            let slotCount = this.getSlotCount();
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot((slotIndex + 1) % slotCount);
                if (slot.probeDistance === 0) {
                    this.saveSlot(slotIndex, {
                        index: 0,
                        probeDistance: 0,
                        isOccupied: false
                    });
                    break;
                }
                this.saveSlot(slotIndex, {
                    index: slot.index,
                    probeDistance: slot.probeDistance - 1,
                    isOccupied: true
                });
                slotIndex = (slotIndex + 1) % slotCount;
            }
        }
        doRemove(key, index) {
            let serializedKey = serializeKey(key);
            let optimalSlot = this.computeOptimalSlot(serializedKey);
            let slotCount = this.getSlotCount();
            let slotIndex = optimalSlot;
            let probeDistance = 0;
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot(slotIndex);
                if (!slot.isOccupied || probeDistance > slot.probeDistance) {
                    return;
                }
                if (slot.index === index) {
                    this.saveSlot(slotIndex, {
                        index: 0,
                        probeDistance: 0,
                        isOccupied: false
                    });
                    return slotIndex;
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
            throw `Expected code to be unreachable!`;
        }
        *[Symbol.iterator]() {
            let slotCount = this.getSlotCount();
            for (let slotIndex = 0; slotIndex < slotCount; slotIndex++) {
                let slot = this.loadSlot(slotIndex);
                if (slot.isOccupied) {
                    yield slot.index;
                }
            }
        }
        entries() {
            return jdb_1.StreamIterable.of(this)
                .map((index) => {
                let key = this.keyFromIndexProvider(index);
                return {
                    key,
                    index
                };
            })
                .slice();
        }
        insert(key, index) {
            let slotIndex = this.doInsert(key, index);
            if (is.present(slotIndex)) {
                let header = this.readHeader();
                header.occupiedSlots += 1;
                this.writeHeader(header);
                this.resizeIfNeccessary();
            }
        }
        lookup(key) {
            let serializedKey = serializeKey(key);
            let optimalSlot = this.computeOptimalSlot(serializedKey);
            let slotCount = this.getSlotCount();
            let slotIndex = optimalSlot;
            let probeDistance = 0;
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot(slotIndex);
                if (!slot.isOccupied || probeDistance > slot.probeDistance) {
                    return;
                }
                if (this.keyFromIndexProvider(slot.index) === key) {
                    return slot.index;
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
            throw `Expected code to be unreachable!`;
        }
        remove(key, index) {
            let slotIndex = this.doRemove(key, index);
            if (is.present(slotIndex)) {
                let header = this.readHeader();
                header.occupiedSlots -= 1;
                this.writeHeader(header);
                this.propagateBackwards(slotIndex);
                this.resizeIfNeccessary();
            }
        }
        debug() {
            let header = this.readHeader();
            console.log(header);
            let slotCount = this.getSlotCount();
            for (let slotIndex = 0; slotIndex < slotCount; slotIndex++) {
                let slot = this.loadSlot(slotIndex);
                let key = slot.isOccupied ? this.keyFromIndexProvider(slot.index) : undefined;
                console.log({
                    ...slot,
                    key
                });
            }
        }
    }
    exports.RobinHoodHash = RobinHoodHash;
    ;
    class Index {
        static NUMBER_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            normalized = normalized.replace(/['"`]+/g, "");
            return Array.from(normalized.match(/(\p{N}+)/gu) ?? []);
        };
        static QUERY_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            normalized = normalized.replace(/['"`]+/g, "");
            return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
        };
        static VALUE_TOKENIZER = (value) => {
            return [value];
        };
        static WORD_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            normalized = normalized.replace(/['"`]+/g, "");
            return Array.from(normalized.match(/(\p{L}+)/gu) ?? []);
        };
        tokenTable;
        parentTable;
        childTable;
        getIndexedValues;
        getTokens;
        blockHandler;
        debug() {
            this.tokenTable.debug();
        }
        constructor(blockHandler, parentTable, childTable, getIndexedValues, getTokens = Index.VALUE_TOKENIZER) {
            let tokenTable = new Table(blockHandler, schema_1.IndexRecord.as, (record) => record.token);
            function insert(key, index, record) {
                let values = is.present(record) ? getIndexedValues(record) : [];
                for (let value of values) {
                    let tokens = getTokens(value);
                    for (let token of tokens) {
                        let indexRecord;
                        try {
                            indexRecord = tokenTable.lookup(token);
                        }
                        catch (error) { }
                        if (is.absent(indexRecord)) {
                            let index = blockHandler.createBlock(RobinHoodHash.INITIAL_SIZE);
                            indexRecord = {
                                token,
                                index
                            };
                            tokenTable.insert(indexRecord);
                        }
                        let rhh = new RobinHoodHash(blockHandler, indexRecord.index, (index) => index);
                        rhh.insert(index, index);
                    }
                }
            }
            function remove(key, index, record) {
                let values = is.present(record) ? getIndexedValues(record) : [];
                for (let value of values) {
                    let tokens = getTokens(value);
                    for (let token of tokens) {
                        let indexRecord;
                        try {
                            indexRecord = tokenTable.lookup(token);
                        }
                        catch (error) { }
                        if (is.absent(indexRecord)) {
                            continue;
                        }
                        let rhh = new RobinHoodHash(blockHandler, indexRecord.index, (index) => index);
                        rhh.remove(index, index);
                    }
                }
            }
            childTable.addObserver("insert", (event) => {
                insert(event.key, event.index, event.record);
            });
            childTable.addObserver("remove", (event) => {
                remove(event.key, event.index, event.record);
            });
            childTable.addObserver("update", (event) => {
                remove(event.key, event.index, event.last);
                insert(event.key, event.index, event.next);
            });
            parentTable.addObserver("remove", (event) => {
                // Deletion is already performed when parent and child reference the same table.
                try {
                    let token = event.key;
                    let indexRecord = tokenTable.lookup(token);
                    let rhh = new RobinHoodHash(this.blockHandler, indexRecord.index, (index) => index);
                    for (let entry of rhh.entries()) {
                        let record = childTable.getRecord(entry.index);
                        childTable.remove(record);
                    }
                }
                catch (error) { }
            });
            if (blockHandler.getCount() === BlockHandler.FIRST_APPLICATION_BLOCK + 1) {
                for (let [key, index, record] of childTable.entries()) {
                    insert(key, index, record);
                }
            }
            this.blockHandler = blockHandler;
            this.tokenTable = tokenTable;
            this.parentTable = parentTable;
            this.childTable = childTable;
            this.getIndexedValues = getIndexedValues;
            this.getTokens = getTokens;
        }
        lookup(query) {
            return this.search(query)
                .map((result) => result.lookup())
                .slice();
        }
        search(query) {
            let tokens = this.getTokens(query);
            let map = new Map();
            for (let token of tokens) {
                try {
                    let indexRecord = this.tokenTable.lookup(token);
                    let rhh = new RobinHoodHash(this.blockHandler, indexRecord.index, (index) => index);
                    for (let index of rhh) {
                        let key = index;
                        let rank = map.get(key) ?? (0 - tokens.length);
                        map.set(key, rank + 2);
                    }
                }
                catch (error) { }
            }
            return jdb_1.StreamIterable.of(map.entries())
                .filter((result) => result[1] >= 0)
                .sort(jsondb_1.sorters.NumericSort.decreasing((result) => result[1]))
                .map((entry) => ({
                index: entry[0],
                rank: entry[1],
                lookup: () => this.childTable.getRecord(entry[0])
            }));
        }
    }
    exports.Index = Index;
    ;
});
define("build/database/indexer", ["require", "exports", "crypto", "fs", "build/database/schema/index", "build/jsondb/index", "build/is", "build/database/probes/index", "build/config/index", "build/jdb2/index"], function (require, exports, libcrypto, libfs, schema, indices, is, probes, config_1, jdb2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFilesFromMovie = exports.getMoviesFromFile = exports.movie_files = exports.movies = exports.getFilesFromEpisode = exports.getEpisodesFromFile = exports.episode_files = exports.getEpisodesFromSeason = exports.episodes = exports.getSeasonsFromShow = exports.seasons = exports.getFilesFromShow = exports.getShowsFromFile = exports.show_files = exports.shows = exports.getTracksFromArtist = exports.getArtistsFromTrack = exports.track_artists = exports.getAlbumsFromArtist = exports.getArtistsFromAlbum = exports.album_artists = exports.getFilesFromTrack = exports.getTracksFromFile = exports.track_files = exports.getTracksFromDisc = exports.tracks = exports.getDiscsFromAlbum = exports.discs = exports.getFilesFromAlbum = exports.getAlbumsFromFile = exports.album_files = exports.albums = exports.artists = exports.getVideoFilesFromSubtitleFile = exports.getSubtitleFilesFromVideoFile = exports.video_subtitles = exports.getVideoFilesFromFile = exports.video_files = exports.getSubtitleFilesFromFile = exports.subtitle_files = exports.getMetadataFilesFromFile = exports.metadata_files = exports.getImageFilesFromFile = exports.image_files = exports.getAudioFiles = exports.audio_files = exports.getFilesFromDirectory = exports.files = exports.getDirectoriesFromDirectory = exports.directories = void 0;
    exports.runIndexer = exports.getPath = exports.year_search = exports.user_search = exports.track_search = exports.shows_search = exports.playlist_search = exports.actor_search = exports.movie_search = exports.genre_search = exports.episode_search = exports.cue_search = exports.artist_search = exports.album_search = exports.getAlbumsFromYear = exports.getMoviesFromYear = exports.years = exports.getPlaylistItemsFromTrack = exports.getPlaylistsItemsFromPlaylist = exports.playlist_items = exports.getPlaylistsFromUser = exports.playlists = exports.getStreamsFromFile = exports.getStreamsFromUser = exports.streams = exports.getTokensFromUser = exports.tokens = exports.getKeysFromUser = exports.keys = exports.getUsersFromUsername = exports.users = exports.getCuesFromSubtitle = exports.cues = exports.subtitles = exports.getGenresFromShow = exports.getShowsFromGenre = exports.show_genres = exports.getGenresFromMovie = exports.getMoviesFromGenre = exports.movie_genres = exports.genres = exports.getActorsFromShow = exports.getShowsFromActor = exports.show_actors = exports.getActorsFromMovie = exports.getMoviesFromActor = exports.movie_actors = exports.actors = void 0;
    function wordify(string) {
        return String(string)
            .toLowerCase()
            .normalize("NFKD")
            .replace(/[\|\/\\\_\-]/g, " ")
            .replace(/[^a-z0-9 ]/g, "")
            .trim()
            .split(/[ ]+/g);
    }
    function makeId(...components) {
        components = components
            .map((component) => wordify(component ?? ""))
            .map((words) => {
            return words.join(" ");
        });
        return libcrypto.createHash("sha256")
            .update(components.join("\0"))
            .digest("hex")
            .slice(0, 16);
    }
    if (!libfs.existsSync(config_1.default.media_path.join("/"))) {
        libfs.mkdirSync(config_1.default.media_path.join("/"));
    }
    const TABLES_ROOT = [
        ".",
        "private",
        "tables"
    ];
    if (!libfs.existsSync(TABLES_ROOT.join("/"))) {
        libfs.mkdirSync(TABLES_ROOT.join("/"));
    }
    const INDICES_ROOT = [
        ".",
        "private",
        "indices"
    ];
    if (!libfs.existsSync(INDICES_ROOT.join("/"))) {
        libfs.mkdirSync(INDICES_ROOT.join("/"));
    }
    function loadTable(name, guard, getKey) {
        let blockHandler = new jdb2.BlockHandler([".", "private", "tables", name]);
        let table = new jdb2.Table(blockHandler, (json) => guard.as(json), getKey);
        return table;
    }
    function loadIndex(name, parent, child, getGroupKey, tokenizer = jdb2.Index.VALUE_TOKENIZER) {
        let blockHandler = new jdb2.BlockHandler([".", "private", "indices", name]);
        let index = new jdb2.Index(blockHandler, parent, child, getGroupKey, tokenizer);
        return index;
    }
    exports.directories = loadTable("directories", schema.Directory, (record) => record.directory_id);
    exports.getDirectoriesFromDirectory = loadIndex("directory_directories", exports.directories, exports.directories, (record) => [record.parent_directory_id]);
    exports.files = loadTable("files", schema.File, (record) => record.file_id);
    exports.getFilesFromDirectory = loadIndex("directory_files", exports.directories, exports.files, (record) => [record.parent_directory_id]);
    exports.audio_files = loadTable("audio_files", schema.AudioFile, (record) => record.file_id);
    exports.getAudioFiles = loadIndex("file_audio_files", exports.files, exports.audio_files, (record) => [record.file_id]);
    exports.image_files = loadTable("image_files", schema.ImageFile, (record) => record.file_id);
    exports.getImageFilesFromFile = loadIndex("file_image_files", exports.files, exports.image_files, (record) => [record.file_id]);
    exports.metadata_files = loadTable("metadata_files", schema.MetadataFile, (record) => record.file_id);
    exports.getMetadataFilesFromFile = loadIndex("file_metadata_files", exports.files, exports.metadata_files, (record) => [record.file_id]);
    exports.subtitle_files = loadTable("subtitle_files", schema.SubtitleFile, (record) => record.file_id);
    exports.getSubtitleFilesFromFile = loadIndex("file_subtitle_files", exports.files, exports.subtitle_files, (record) => [record.file_id]);
    exports.video_files = loadTable("video_files", schema.VideoFile, (record) => record.file_id);
    exports.getVideoFilesFromFile = loadIndex("file_video_files", exports.files, exports.video_files, (record) => [record.file_id]);
    exports.video_subtitles = loadTable("video_subtitles", schema.VideoSubtitle, (record) => makeId(record.video_file_id, record.subtitle_file_id));
    exports.getSubtitleFilesFromVideoFile = loadIndex("video_file_video_subtitles", exports.video_files, exports.video_subtitles, (record) => [record.video_file_id]);
    exports.getVideoFilesFromSubtitleFile = loadIndex("subtitle_file_video_subtitles", exports.subtitle_files, exports.video_subtitles, (record) => [record.subtitle_file_id]);
    exports.artists = loadTable("artists", schema.Artist, (record) => record.artist_id);
    exports.albums = loadTable("albums", schema.Album, (record) => record.album_id);
    exports.album_files = loadTable("album_files", schema.AlbumFile, (record) => makeId(record.album_id, record.file_id));
    exports.getAlbumsFromFile = loadIndex("file_album_files", exports.files, exports.album_files, (record) => [record.file_id]);
    exports.getFilesFromAlbum = loadIndex("album_album_files", exports.albums, exports.album_files, (record) => [record.album_id]);
    exports.discs = loadTable("discs", schema.Disc, (record) => record.disc_id);
    exports.getDiscsFromAlbum = loadIndex("album_discs", exports.albums, exports.discs, (record) => [record.album_id]);
    exports.tracks = loadTable("tracks", schema.Track, (record) => record.track_id);
    exports.getTracksFromDisc = loadIndex("disc_tracks", exports.discs, exports.tracks, (record) => [record.disc_id]);
    exports.track_files = loadTable("track_files", schema.TrackFile, (record) => makeId(record.track_id, record.file_id));
    exports.getTracksFromFile = loadIndex("file_track_files", exports.files, exports.track_files, (record) => [record.file_id]);
    exports.getFilesFromTrack = loadIndex("track_track_files", exports.tracks, exports.track_files, (record) => [record.track_id]);
    exports.album_artists = loadTable("album_artists", schema.AlbumArtist, (record) => makeId(record.album_id, record.artist_id));
    exports.getArtistsFromAlbum = loadIndex("album_album_artists", exports.albums, exports.album_artists, (record) => [record.album_id]);
    exports.getAlbumsFromArtist = loadIndex("artist_album_artists", exports.artists, exports.album_artists, (record) => [record.artist_id]);
    exports.track_artists = loadTable("track_artists", schema.TrackArtist, (record) => makeId(record.track_id, record.artist_id));
    exports.getArtistsFromTrack = loadIndex("track_track_artists", exports.tracks, exports.track_artists, (record) => [record.track_id]);
    exports.getTracksFromArtist = loadIndex("artist_track_artists", exports.artists, exports.track_artists, (record) => [record.artist_id]);
    exports.shows = loadTable("shows", schema.Show, (record) => record.show_id);
    exports.show_files = loadTable("show_files", schema.ShowFile, (record) => makeId(record.show_id, record.file_id));
    exports.getShowsFromFile = loadIndex("file_show_files", exports.files, exports.show_files, (record) => [record.file_id]);
    exports.getFilesFromShow = loadIndex("show_show_files", exports.shows, exports.show_files, (record) => [record.show_id]);
    exports.seasons = loadTable("seasons", schema.Season, (record) => record.season_id);
    exports.getSeasonsFromShow = loadIndex("show_seasons", exports.shows, exports.seasons, (record) => [record.show_id]);
    exports.episodes = loadTable("episodes", schema.Episode, (record) => record.episode_id);
    exports.getEpisodesFromSeason = loadIndex("season_episodes", exports.seasons, exports.episodes, (record) => [record.season_id]);
    exports.episode_files = loadTable("episode_files", schema.EpisodeFile, (record) => makeId(record.episode_id, record.file_id));
    exports.getEpisodesFromFile = loadIndex("file_episode_files", exports.files, exports.episode_files, (record) => [record.file_id]);
    exports.getFilesFromEpisode = loadIndex("episode_episode_files", exports.episodes, exports.episode_files, (record) => [record.episode_id]);
    exports.movies = loadTable("movies", schema.Movie, (record) => record.movie_id);
    exports.movie_files = loadTable("movie_files", schema.MovieFile, (record) => makeId(record.movie_id, record.file_id));
    exports.getMoviesFromFile = loadIndex("file_movie_files", exports.files, exports.movie_files, (record) => [record.file_id]);
    exports.getFilesFromMovie = loadIndex("movie_movie_files", exports.movies, exports.movie_files, (record) => [record.movie_id]);
    exports.actors = loadTable("actors", schema.Actor, (record) => record.actor_id);
    exports.movie_actors = loadTable("movie_actors", schema.MovieActor, (record) => makeId(record.movie_id, record.actor_id));
    exports.getMoviesFromActor = loadIndex("actor_movie_actors", exports.actors, exports.movie_actors, (record) => [record.actor_id]);
    exports.getActorsFromMovie = loadIndex("movie_movie_actors", exports.movies, exports.movie_actors, (record) => [record.movie_id]);
    exports.show_actors = loadTable("show_actors", schema.ShowActor, (record) => makeId(record.show_id, record.actor_id));
    exports.getShowsFromActor = loadIndex("actor_show_actors", exports.actors, exports.show_actors, (record) => [record.actor_id]);
    exports.getActorsFromShow = loadIndex("show_show_actors", exports.shows, exports.show_actors, (record) => [record.show_id]);
    exports.genres = loadTable("genres", schema.Genre, (record) => record.genre_id);
    exports.movie_genres = loadTable("movie_genres", schema.MovieGenre, (record) => makeId(record.movie_id, record.genre_id));
    exports.getMoviesFromGenre = loadIndex("genre_movie_genres", exports.genres, exports.movie_genres, (record) => [record.genre_id]);
    exports.getGenresFromMovie = loadIndex("movie_movie_genres", exports.movies, exports.movie_genres, (record) => [record.movie_id]);
    exports.show_genres = loadTable("show_genres", schema.ShowGenre, (record) => makeId(record.show_id, record.genre_id));
    exports.getShowsFromGenre = loadIndex("genre_show_genres", exports.genres, exports.show_genres, (record) => [record.genre_id]);
    exports.getGenresFromShow = loadIndex("show_show_genres", exports.shows, exports.show_genres, (record) => [record.show_id]);
    exports.subtitles = loadTable("subtitles", schema.Subtitle, (record) => record.subtitle_id);
    exports.cues = loadTable("cues", schema.Cue, (record) => record.cue_id);
    exports.getCuesFromSubtitle = loadIndex("subtitle_cues", exports.subtitles, exports.cues, (record) => [record.subtitle_id]);
    exports.users = loadTable("users", schema.User, (record) => record.user_id);
    exports.getUsersFromUsername = loadIndex("user_users", exports.users, exports.users, (record) => [record.username]);
    exports.keys = loadTable("keys", schema.Key, (record) => record.key_id);
    exports.getKeysFromUser = loadIndex("user_keys", exports.users, exports.keys, (record) => [record.user_id]);
    exports.tokens = loadTable("tokens", schema.Token, (record) => record.token_id);
    exports.getTokensFromUser = loadIndex("user_tokens", exports.users, exports.tokens, (record) => [record.user_id]);
    exports.streams = loadTable("streams", schema.Stream, (record) => record.stream_id);
    exports.getStreamsFromUser = loadIndex("user_streams", exports.users, exports.streams, (record) => [record.user_id]);
    exports.getStreamsFromFile = loadIndex("file_streams", exports.files, exports.streams, (record) => [record.file_id]);
    exports.playlists = loadTable("playlists", schema.Playlist, (record) => record.playlist_id);
    exports.getPlaylistsFromUser = loadIndex("user_playlists", exports.users, exports.playlists, (record) => [record.user_id]);
    exports.playlist_items = loadTable("playlist_items", schema.PlaylistItem, (record) => record.playlist_item_id);
    exports.getPlaylistsItemsFromPlaylist = loadIndex("playlist_playlist_items", exports.playlists, exports.playlist_items, (record) => [record.playlist_id]);
    exports.getPlaylistItemsFromTrack = loadIndex("track_playlist_items", exports.tracks, exports.playlist_items, (record) => [record.track_id]);
    exports.years = loadTable("years", schema.Year, (record) => record.year_id);
    exports.getMoviesFromYear = loadIndex("year_movies", exports.years, exports.movies, (record) => [record.year]);
    exports.getAlbumsFromYear = loadIndex("year_albums", exports.years, exports.albums, (record) => [record.year]);
    if (exports.getKeysFromUser.lookup(undefined).collect().length === 0) {
        exports.keys.insert({
            key_id: makeId("key", libcrypto.randomBytes(8).toString("hex"))
        });
    }
    exports.album_search = loadIndex("search_albums", exports.albums, exports.albums, (entry) => [entry.title, entry.year].filter(is.present), jdb2.Index.QUERY_TOKENIZER);
    exports.artist_search = loadIndex("search_artists", exports.artists, exports.artists, (entry) => [entry.name], jdb2.Index.QUERY_TOKENIZER);
    exports.cue_search = loadIndex("search_cues", exports.cues, exports.cues, (entry) => [entry.lines], jdb2.Index.QUERY_TOKENIZER);
    exports.episode_search = loadIndex("search_episodes", exports.episodes, exports.episodes, (entry) => [entry.title, entry.year].filter(is.present), jdb2.Index.QUERY_TOKENIZER);
    exports.genre_search = loadIndex("search_genres", exports.genres, exports.genres, (entry) => [entry.name], jdb2.Index.QUERY_TOKENIZER);
    exports.movie_search = loadIndex("search_movies", exports.movies, exports.movies, (entry) => [entry.title, entry.year].filter(is.present), jdb2.Index.QUERY_TOKENIZER);
    exports.actor_search = loadIndex("search_actors", exports.actors, exports.actors, (entry) => [entry.name], jdb2.Index.QUERY_TOKENIZER);
    exports.playlist_search = loadIndex("search_playlists", exports.playlists, exports.playlists, (entry) => [entry.title], jdb2.Index.QUERY_TOKENIZER);
    exports.shows_search = loadIndex("search_shows", exports.shows, exports.shows, (entry) => [entry.name], jdb2.Index.QUERY_TOKENIZER);
    exports.track_search = loadIndex("search_tracks", exports.tracks, exports.tracks, (entry) => [entry.title], jdb2.Index.QUERY_TOKENIZER);
    exports.user_search = loadIndex("search_users", exports.users, exports.users, (entry) => [entry.name, entry.username], jdb2.Index.QUERY_TOKENIZER);
    exports.year_search = loadIndex("search_years", exports.years, exports.years, (entry) => [entry.year], jdb2.Index.QUERY_TOKENIZER);
    function getPath(entry) {
        let path = new Array();
        while (true) {
            path.unshift(entry.name);
            let parent_directory_id = entry.parent_directory_id;
            if (is.absent(parent_directory_id)) {
                break;
            }
            entry = exports.directories.lookup(parent_directory_id);
        }
        return [...config_1.default.media_path, ...path];
    }
    exports.getPath = getPath;
    ;
    function getDirectoryPath(directory) {
        return getPath(directory);
    }
    function getFilePath(file) {
        return getPath(file);
    }
    function checkFile(root) {
        let path = getFilePath(root).join("/");
        if (libfs.existsSync(path)) {
            let stats = libfs.statSync(path);
            if (stats.isFile()) {
                if (stats.mtime.valueOf() === root.index_timestamp) {
                    exports.files.update({
                        ...root,
                        size: stats.size
                    });
                    return;
                }
            }
        }
        exports.files.remove(root);
    }
    function checkDirectory(root) {
        let path = getDirectoryPath(root).join("/");
        if (libfs.existsSync(path)) {
            let stats = libfs.statSync(path);
            if (stats.isDirectory()) {
                for (let directory of exports.getDirectoriesFromDirectory.lookup(root.directory_id)) {
                    checkDirectory(directory);
                }
                for (let file of exports.getFilesFromDirectory.lookup(root.directory_id)) {
                    checkFile(file);
                }
                return;
            }
        }
        exports.directories.remove(root);
    }
    function visitDirectory(path, parent_directory_id) {
        let dirents = libfs.readdirSync(path.join("/"), { withFileTypes: true });
        for (let dirent of dirents) {
            let name = dirent.name;
            if (dirent.isDirectory()) {
                let directory_id = makeId("directory", parent_directory_id, name);
                try {
                    exports.directories.lookup(directory_id);
                }
                catch (error) {
                    exports.directories.insert({
                        directory_id,
                        name,
                        parent_directory_id
                    });
                }
                visitDirectory([...path, dirent.name], directory_id);
            }
            else if (dirent.isFile()) {
                let file_id = makeId("file", parent_directory_id, name);
                try {
                    exports.files.lookup(file_id);
                }
                catch (error) {
                    exports.files.insert({
                        file_id,
                        name,
                        parent_directory_id
                    });
                }
            }
        }
    }
    function indexMetadata(probe, ...file_ids) {
        let metadata = probe.metadata;
        if (probes.schema.EpisodeMetadata.is(metadata)) {
            let show_id = makeId("show", metadata.show.title);
            exports.shows.insert({
                show_id: show_id,
                name: metadata.show.title,
                summary: metadata.show.summary
            });
            let season_id = makeId("season", show_id, `${metadata.season}`);
            exports.seasons.insert({
                season_id: season_id,
                show_id: show_id,
                number: metadata.season
            });
            let episode_id = makeId("episode", season_id, `${metadata.episode}`);
            exports.episodes.insert({
                episode_id: episode_id,
                season_id: season_id,
                title: metadata.title,
                number: metadata.episode,
                year: metadata.year,
                summary: metadata.summary,
                copyright: metadata.copyright
            });
            for (let file_id of file_ids) {
                exports.episode_files.insert({
                    episode_id: episode_id,
                    file_id: file_id
                });
            }
            for (let [index, actor] of metadata.show.actors.entries()) {
                let actor_id = makeId("actor", actor);
                exports.actors.insert({
                    actor_id: actor_id,
                    name: actor
                });
                exports.show_actors.insert({
                    actor_id: actor_id,
                    show_id: show_id,
                    order: index
                });
            }
            for (let [index, genre] of metadata.show.genres.entries()) {
                let genre_id = makeId("genre", genre);
                exports.genres.insert({
                    genre_id: genre_id,
                    name: genre
                });
                exports.show_genres.insert({
                    genre_id: genre_id,
                    show_id: show_id,
                    order: index
                });
            }
        }
        else if (probes.schema.MovieMetadata.is(metadata)) {
            let movie_id = makeId("movie", metadata.title, metadata.year);
            exports.movies.insert({
                movie_id: movie_id,
                title: metadata.title,
                year: metadata.year,
                summary: metadata.summary,
                copyright: metadata.copyright
            });
            if (is.present(metadata.year)) {
                let year_id = makeId("year", metadata.year);
                exports.years.insert({
                    year_id: year_id,
                    year: metadata.year
                });
            }
            for (let file_id of file_ids) {
                exports.movie_files.insert({
                    movie_id: movie_id,
                    file_id: file_id
                });
            }
            for (let [index, actor] of metadata.actors.entries()) {
                let actor_id = makeId("actor", actor);
                exports.actors.insert({
                    actor_id: actor_id,
                    name: actor
                });
                exports.movie_actors.insert({
                    actor_id: actor_id,
                    movie_id: movie_id,
                    order: index
                });
            }
            for (let [index, genre] of metadata.genres.entries()) {
                let genre_id = makeId("genre", genre);
                exports.genres.insert({
                    genre_id: genre_id,
                    name: genre
                });
                exports.movie_genres.insert({
                    genre_id: genre_id,
                    movie_id: movie_id,
                    order: index
                });
            }
        }
        else if (probes.schema.TrackMetadata.is(metadata)) {
            let album_id = makeId("album", metadata.album.title, metadata.album.year);
            exports.albums.insert({
                album_id: album_id,
                title: metadata.album.title,
                year: metadata.album.year
            });
            if (is.present(metadata.album.year)) {
                let year_id = makeId("year", metadata.album.year);
                exports.years.insert({
                    year_id: year_id,
                    year: metadata.album.year
                });
            }
            for (let [index, artist] of metadata.album.artists.entries()) {
                let artist_id = makeId("artist", artist);
                exports.artists.insert({
                    artist_id: artist_id,
                    name: artist
                });
                exports.album_artists.insert({
                    album_id: album_id,
                    artist_id: artist_id,
                    order: index
                });
            }
            let disc_id = makeId("disc", album_id, `${metadata.disc}`);
            exports.discs.insert({
                disc_id: disc_id,
                album_id: album_id,
                number: metadata.disc
            });
            let track_id = makeId("track", disc_id, `${metadata.track}`);
            exports.tracks.insert({
                track_id: track_id,
                disc_id: disc_id,
                title: metadata.title,
                number: metadata.track,
                copyright: metadata.copyright
            });
            for (let file_id of file_ids) {
                exports.track_files.insert({
                    track_id: track_id,
                    file_id: file_id
                });
            }
            for (let [index, artist] of metadata.artists.entries()) {
                let artist_id = makeId("artist", artist);
                exports.artists.insert({
                    artist_id: artist_id,
                    name: artist
                });
                exports.track_artists.insert({
                    track_id: track_id,
                    artist_id: artist_id,
                    order: index
                });
            }
        }
        else if (probes.schema.AlbumMetadata.is(metadata)) {
            let album_id = makeId("album", metadata.title, metadata.year);
            exports.albums.insert({
                album_id: album_id,
                title: metadata.title,
                year: metadata.year
            });
            if (is.present(metadata.year)) {
                let year_id = makeId("year", metadata.year);
                exports.years.insert({
                    year_id: year_id,
                    year: metadata.year
                });
            }
            for (let [index, artist] of metadata.artists.entries()) {
                let artist_id = makeId("artist", artist);
                exports.artists.insert({
                    artist_id: artist_id,
                    name: artist
                });
                exports.album_artists.insert({
                    album_id: album_id,
                    artist_id: artist_id,
                    order: index
                });
            }
            let disc_id = makeId("disc", album_id, `${metadata.disc}`);
            exports.discs.insert({
                disc_id: disc_id,
                album_id: album_id,
                number: metadata.disc
            });
            if (metadata.tracks.length === file_ids.length) {
                for (let [index, file_id] of file_ids.entries()) {
                    let track = metadata.tracks[index];
                    let track_id = makeId("track", disc_id, `${index}`);
                    exports.tracks.insert({
                        track_id: track_id,
                        disc_id: disc_id,
                        title: track.title,
                        number: index + 1,
                        copyright: track.copyright ?? metadata.copyright
                    });
                    exports.track_files.insert({
                        track_id: track_id,
                        file_id: file_id
                    });
                    for (let [index, artist] of track.artists.entries()) {
                        let artist_id = makeId("artist", artist);
                        exports.artists.insert({
                            artist_id: artist_id,
                            name: artist
                        });
                        exports.track_artists.insert({
                            track_id: track_id,
                            artist_id: artist_id,
                            order: index
                        });
                    }
                }
            }
        }
    }
    function indexFile(file) {
        let file_id = file.file_id;
        let path = getFilePath(file);
        let fd = libfs.openSync(path.join("/"), "r");
        try {
            let probe = {
                resources: []
            };
            if (file.name.endsWith(".vtt")) {
                probe = probes.vtt.probe(fd);
                let subtitle_resources = probe.resources.filter((resource) => resource.type === "subtitle");
                let subtitle_resource = subtitle_resources.shift();
                if (is.present(subtitle_resource)) {
                    exports.subtitle_files.insert({
                        file_id: file_id,
                        mime: "text/vtt",
                        duration_ms: subtitle_resource.duration_ms,
                        language: subtitle_resource.language
                    });
                    let subtitle_id = makeId("subtitle", file.file_id);
                    exports.subtitles.insert({
                        subtitle_id: subtitle_id,
                        file_id: file.file_id
                    });
                    /* 				for (let cue of subtitle_resource.cues) {
                                        let cue_id = makeId("cue", subtitle_id, `${cue.start_ms}`);
                                        cues.insert({
                                            cue_id: cue_id,
                                            subtitle_id: subtitle_id,
                                            start_ms: cue.start_ms,
                                            duration_ms: cue.duration_ms,
                                            lines: cue.lines.join("\n")
                                        });
                                    } */
                }
            }
            else if (file.name.endsWith(".json")) {
                probe = probes.json.probe(fd);
                let metadata_resources = probe.resources.filter((resource) => resource.type === "metadata");
                let metadata_resource = metadata_resources.shift();
                if (is.present(metadata_resource)) {
                    exports.metadata_files.insert({
                        file_id: file_id,
                        mime: "application/json"
                    });
                }
            }
            else if (file.name.endsWith(".mp3")) {
                probe = probes.mp3.probe(fd);
                let audio_resources = probe.resources.filter((resource) => resource.type === "audio");
                let audio_resource = audio_resources.shift();
                if (is.present(audio_resource)) {
                    exports.audio_files.insert({
                        file_id: file_id,
                        mime: "audio/mp3",
                        duration_ms: audio_resource.duration_ms
                    });
                }
            }
            else if (file.name.endsWith(".mp4")) {
                probe = probes.mp4.probe(fd);
                let audio_resources = probe.resources.filter((resource) => resource.type === "audio");
                let video_resources = probe.resources.filter((resource) => resource.type === "video");
                let audio_resource = audio_resources.shift();
                let video_resource = video_resources.shift();
                if (is.present(video_resource)) {
                    exports.video_files.insert({
                        file_id: file_id,
                        mime: "video/mp4",
                        duration_ms: video_resource.duration_ms,
                        width: video_resource.width,
                        height: video_resource.height
                    });
                }
                else if (is.present(audio_resource)) {
                    exports.audio_files.insert({
                        file_id: file_id,
                        mime: "audio/mp4",
                        duration_ms: audio_resource.duration_ms
                    });
                }
            }
            else if (file.name.endsWith(".jpg") || file.name.endsWith(".jpeg")) {
                probe = probes.jpeg.probe(fd);
                let image_resources = probe.resources.filter((resource) => resource.type === "image");
                let image_resource = image_resources.shift();
                if (is.present(image_resource)) {
                    exports.image_files.insert({
                        file_id: file_id,
                        mime: "image/jpeg",
                        width: image_resource.width,
                        height: image_resource.height
                    });
                }
            }
            // TODO: Only index actual media files and not the metadata files themselves.
            indexMetadata(probe, file_id);
        }
        catch (error) {
            console.log(`Indexing failed for "${path.join("/")}"!`);
        }
        libfs.closeSync(fd);
        let stats = libfs.statSync(path.join("/"));
        file.index_timestamp = stats.mtime.valueOf();
        file.size = stats.size;
        exports.files.update(file);
    }
    function indexFiles() {
        for (let file of exports.files) {
            if (is.absent(file.index_timestamp)) {
                console.log(`Indexing ${file.name}...`);
                indexFile(file);
            }
        }
    }
    function getSiblingFiles(subject) {
        let candidates_in_directory = exports.getFilesFromDirectory.lookup(subject.parent_directory_id)
            .sort(indices.LexicalSort.increasing((file) => file.name))
            .map((file) => {
            try {
                exports.audio_files.lookup(file.file_id);
                return file;
            }
            catch (error) { }
            try {
                exports.video_files.lookup(file.file_id);
                return file;
            }
            catch (error) { }
        })
            .include(is.present)
            .collect();
        let basename = subject.name.split(".")[0];
        let candidates_sharing_basename = candidates_in_directory
            .filter((file) => file.name.split(".")[0] === basename);
        if (candidates_sharing_basename.length > 0) {
            return candidates_sharing_basename;
        }
        else {
            return candidates_in_directory;
        }
    }
    function associateMetadata() {
        for (let metadata_file of exports.metadata_files) {
            let file = exports.files.lookup(metadata_file.file_id);
            let path = getFilePath(file);
            let fd = libfs.openSync(path.join("/"), "r");
            let probe = probes.json.probe(fd);
            libfs.closeSync(fd);
            let siblings = getSiblingFiles(file);
            indexMetadata(probe, ...siblings.map((file) => file.file_id));
        }
    }
    function associateImages() {
        for (let image_file of exports.image_files) {
            let file = exports.files.lookup(image_file.file_id);
            let siblings = getSiblingFiles(file);
            for (let sibling of siblings) {
                let track_files = exports.getTracksFromFile.lookup(sibling.file_id)
                    .filter((track_file) => track_file.file_id !== image_file.file_id);
                for (let track_file of track_files) {
                    try {
                        let track = exports.tracks.lookup(track_file.track_id);
                        let disc = exports.discs.lookup(track.disc_id);
                        let album = exports.albums.lookup(disc.album_id);
                        exports.album_files.insert({
                            album_id: album.album_id,
                            file_id: image_file.file_id
                        });
                    }
                    catch (error) { }
                }
                let movies = exports.getMoviesFromFile.lookup(sibling.file_id)
                    .filter((movie_file) => movie_file.file_id !== image_file.file_id);
                for (let movie of movies) {
                    exports.movie_files.insert({
                        movie_id: movie.movie_id,
                        file_id: image_file.file_id
                    });
                }
                let episode_files = exports.getEpisodesFromFile.lookup(sibling.file_id)
                    .filter((episode_file) => episode_file.file_id !== image_file.file_id);
                for (let episode_file of episode_files) {
                    try {
                        let episode = exports.episodes.lookup(episode_file.episode_id);
                        let season = exports.seasons.lookup(episode.season_id);
                        let show = exports.shows.lookup(season.show_id);
                        exports.show_files.insert({
                            show_id: show.show_id,
                            file_id: image_file.file_id
                        });
                    }
                    catch (error) { }
                }
            }
        }
    }
    function associateSubtitles() {
        for (let subtitle_file of exports.subtitle_files) {
            let file = exports.files.lookup(subtitle_file.file_id);
            let basename = file.name.split(".")[0];
            let siblings = getSiblingFiles(file)
                .filter((file) => file.name.split(".")[0] === basename);
            for (let sibling of siblings) {
                exports.video_subtitles.insert({
                    video_file_id: sibling.file_id,
                    subtitle_file_id: file.file_id
                });
            }
        }
    }
    function removeBrokenEntities() {
        for (let track of exports.tracks) {
            let track_files = exports.getFilesFromTrack.lookup(track.track_id);
            if (track_files.collect().length === 0) {
                exports.tracks.remove(track);
            }
        }
        for (let movie of exports.movies) {
            let movie_files = exports.getFilesFromMovie.lookup(movie.movie_id);
            if (movie_files.collect().length === 0) {
                exports.movies.remove(movie);
            }
        }
        for (let episode of exports.episodes) {
            let episode_files = exports.getFilesFromEpisode.lookup(episode.episode_id);
            if (episode_files.collect().length === 0) {
                exports.episodes.remove(episode);
            }
        }
    }
    function runIndexer() {
        console.log(`Running indexer...`);
        for (let directory of exports.getDirectoriesFromDirectory.lookup(undefined)) {
            checkDirectory(directory);
        }
        for (let file of exports.getFilesFromDirectory.lookup(undefined)) {
            checkFile(file);
        }
        visitDirectory(config_1.default.media_path);
        indexFiles();
        associateMetadata();
        associateImages();
        associateSubtitles();
        removeBrokenEntities();
        for (let token of exports.tokens) {
            if (token.expires_ms <= Date.now()) {
                exports.tokens.remove(token);
            }
        }
        console.log(`Indexing finished.`);
        if (global.gc) {
            global.gc();
            let mbs = process.memoryUsage().heapUsed / 1024 / 1024;
            console.log(`Memory usage: ${mbs.toFixed()} MB`);
        }
    }
    exports.runIndexer = runIndexer;
    ;
    runIndexer();
    process.on("SIGTERM", () => {
        console.log("SIGTERM");
        process.exit(0);
    });
    process.on("SIGINT", () => {
        console.log("SIGINT");
        process.exit(0);
    });
});
define("build/server/passwords", ["require", "exports", "crypto"], function (require, exports, libcrypto) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verify = exports.generate = void 0;
    function generate(password) {
        let cost = 14;
        let blockSize = 8;
        let paralellization = 1;
        let salt = libcrypto.randomBytes(16);
        let password_hash = libcrypto.scryptSync(password, salt, 32, {
            N: (1 << cost),
            r: blockSize,
            p: paralellization,
            maxmem: (256 << cost) * blockSize
        });
        let params = Buffer.alloc(4);
        params[0] = (cost >> 8);
        params[1] = (cost >> 0);
        params[2] = (blockSize >> 0);
        params[3] = (paralellization >> 0);
        return `$s0$${params.toString("hex")}$${salt.toString("base64")}$${password_hash.toString("base64")}`;
    }
    exports.generate = generate;
    function verify(password, chunk) {
        let parts = /^\$s0\$([0-9a-fA-F]{8})\$([A-Za-z0-9+/]{22}==)\$([A-Za-z0-9+/]{43}=)$/.exec(chunk);
        if (parts == null) {
            throw `Expected a valid scrypt chunk!`;
        }
        let parameters = Buffer.from(parts[1], "hex");
        let salt = Buffer.from(parts[2], "base64");
        let hash = Buffer.from(parts[3], "base64");
        let cost = (parameters[0] << 8) | (parameters[1] << 0);
        let blockSize = (parameters[2] << 0);
        let paralellization = (parameters[3] << 0);
        let password_hash = libcrypto.scryptSync(password, salt, 32, {
            N: (1 << cost),
            r: blockSize,
            p: paralellization,
            maxmem: (256 << cost) * blockSize
        });
        return libcrypto.timingSafeEqual(hash, password_hash);
    }
    exports.verify = verify;
});
define("build/server/auth", ["require", "exports", "crypto", "build/database/indexer", "build/server/passwords"], function (require, exports, libcrypto, indexer, passwords) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUserId = exports.createToken = void 0;
    function generate_token(user_id) {
        let selector = libcrypto.randomBytes(8);
        let validator = libcrypto.randomBytes(8);
        let hash = libcrypto.createHash('sha256');
        hash.update(validator);
        let validator_hash = hash.digest('hex');
        indexer.tokens.insert({
            token_id: selector.toString('hex'),
            user_id: user_id,
            hash: validator_hash,
            expires_ms: Date.now() + (7 * 24 * 60 * 60 * 1000)
        });
        return `${selector.toString('hex')}${validator.toString('hex')}`;
    }
    function createToken(username, password) {
        let users = indexer.getUsersFromUsername.lookup(username).collect();
        let user = users.shift();
        if (!user) {
            throw 401;
        }
        if (!passwords.verify(password, user.password)) {
            throw 401;
        }
        return generate_token(user.user_id);
    }
    exports.createToken = createToken;
    function getUserId(chunk) {
        let parts = /^([0-9a-f]{16})([0-9a-f]{16})$/.exec(chunk);
        if (!parts) {
            throw new Error();
        }
        let selector = parts[1];
        let validator = parts[2];
        let token = indexer.tokens.lookup(selector);
        if (token.expires_ms < Date.now()) {
            throw 401;
        }
        let hash = libcrypto.createHash('sha256');
        hash.update(Buffer.from(validator, 'hex'));
        let validator_hash = hash.digest();
        if (!libcrypto.timingSafeEqual(Buffer.from(token.hash, 'hex'), validator_hash)) {
            throw 401;
        }
        let expires_ms = Date.now() + (7 * 24 * 60 * 60 * 1000);
        indexer.tokens.update({
            ...token,
            expires_ms
        });
        return token.user_id;
    }
    exports.getUserId = getUserId;
});
define("build/api/handler", ["require", "exports", "crypto", "build/server/auth", "build/server/passwords", "build/database/indexer", "build/jsondb/index", "build/is", "build/config/index"], function (require, exports, libcrypto, auth, passwords, database, jsondb, is, config_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.searchForTracks = exports.searchForShows = exports.searchForSeasons = exports.searchForPlaylists = exports.searchForActors = exports.searchForMovies = exports.searchForGenres = exports.searchForEpisodes = exports.searchForDiscs = exports.searchForCues = exports.searchForArtists = exports.searchForAlbums = exports.getNewMovies = exports.getNewAlbums = exports.lookupYear = exports.lookupYearBase = exports.lookupUser = exports.lookupUserBase = exports.lookupTrack = exports.lookupTrackBase = exports.lookupSubtitle = exports.lookupSubtitleBase = exports.lookupShow = exports.lookupShowBase = exports.lookupSeason = exports.lookupSeasonBase = exports.lookupPlaylistItem = exports.lookupPlaylistItemBase = exports.lookupPlaylist = exports.lookupPlaylistBase = exports.lookupActor = exports.lookupActorBase = exports.lookupMovie = exports.lookupMovieBase = exports.lookupGenre = exports.lookupGenreBase = exports.lookupEpisode = exports.lookupEpisodeBase = exports.lookupDisc = exports.lookupDiscBase = exports.lookupCue = exports.lookupCueBase = exports.lookupArtist = exports.lookupArtistBase = exports.lookupAlbum = exports.lookupAlbumBase = exports.createUser = exports.createStream = exports.lookupFile = exports.getStreamWeight = void 0;
    exports.getAlbumsFromYear = exports.getMoviesFromYear = exports.getUserShows = exports.getUserAlbums = exports.getUserPlaylists = exports.getShowsFromActor = exports.getShowsFromGenre = exports.getMoviesFromActor = exports.getMoviesFromGenre = exports.getMovieSuggestions = exports.getPlaylistAppearances = exports.getArtistTracks = exports.getArtistAppearances = exports.searchForEntities = exports.searchForYears = exports.searchForUsers = void 0;
    function getStreamWeight(timestamp_ms) {
        let ms = Date.now() - timestamp_ms;
        let weeks = ms / (1000 * 60 * 60 * 24 * 7);
        return Math.pow(0.5, weeks);
    }
    exports.getStreamWeight = getStreamWeight;
    ;
    function lookupFile(file_id, user_id) {
        let file = database.files.lookup(file_id);
        let mime = "application/octet-stream";
        try {
            mime = database.audio_files.lookup(file.file_id).mime;
        }
        catch (error) { }
        try {
            mime = database.image_files.lookup(file.file_id).mime;
        }
        catch (error) { }
        try {
            mime = database.metadata_files.lookup(file.file_id).mime;
        }
        catch (error) { }
        try {
            mime = database.subtitle_files.lookup(file.file_id).mime;
        }
        catch (error) { }
        try {
            mime = database.video_files.lookup(file.file_id).mime;
        }
        catch (error) { }
        return {
            ...file,
            mime
        };
    }
    exports.lookupFile = lookupFile;
    ;
    function createStream(stream) {
        database.streams.insert(stream);
    }
    exports.createStream = createStream;
    ;
    function createUser(request) {
        let { username, password, name, key_id } = { ...request };
        let errors = new Array();
        if (database.getUsersFromUsername.lookup(username).collect().length > 0) {
            errors.push(`The requested username is not available.`);
        }
        if (config_1.default.use_registration_keys) {
            try {
                let key = database.keys.lookup(key_id);
                if (is.present(key.user_id)) {
                    errors.push(`The registration key has already been used.`);
                }
            }
            catch (error) {
                errors.push(`The registration key is not valid.`);
            }
        }
        if (Buffer.from(username).length >= 256) {
            errors.push(`The username is too long!`);
        }
        if (Buffer.from(name).length >= 256) {
            errors.push(`The name is too long!`);
        }
        if (errors.length > 0) {
            return {
                errors
            };
        }
        let user_id = libcrypto.randomBytes(8).toString("hex");
        database.users.insert({
            user_id,
            username,
            name,
            password: passwords.generate(password)
        });
        if (config_1.default.use_registration_keys) {
            let key = database.keys.lookup(key_id);
            database.keys.update({
                ...key,
                user_id
            });
        }
        let token = auth.createToken(username, password);
        return {
            token
        };
    }
    exports.createUser = createUser;
    ;
    function lookupAlbumBase(album_id, user_id) {
        let album = database.albums.lookup(album_id);
        return {
            album_id: album.album_id,
            title: config_1.default.use_demo_mode ? "Album title" : album.title,
            artwork: database.getFilesFromAlbum.lookup(album_id)
                .map((record) => {
                try {
                    return database.image_files.lookup(record.file_id);
                }
                catch (error) { }
            })
                .include(is.present)
                .collect()
        };
    }
    exports.lookupAlbumBase = lookupAlbumBase;
    ;
    function lookupAlbum(album_id, user_id) {
        let record = database.albums.lookup(album_id);
        let album = lookupAlbumBase(album_id, user_id);
        return {
            ...album,
            artists: database.getArtistsFromAlbum.lookup(album_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupArtistBase(record.artist_id, user_id))
                .collect(),
            year: record.year,
            discs: database.getDiscsFromAlbum.lookup(album_id)
                .sort(jsondb.NumericSort.increasing((record) => record.number))
                .map((record) => lookupDisc(record.disc_id, user_id, album))
                .collect()
        };
    }
    exports.lookupAlbum = lookupAlbum;
    ;
    function lookupArtistBase(artist_id, user_id) {
        let artist = database.artists.lookup(artist_id);
        return {
            artist_id: artist.artist_id,
            title: config_1.default.use_demo_mode ? "Artist name" : artist.name
        };
    }
    exports.lookupArtistBase = lookupArtistBase;
    ;
    function lookupArtist(artist_id, user_id) {
        let artist = lookupArtistBase(artist_id, user_id);
        return {
            ...artist,
            albums: database.getAlbumsFromArtist.lookup(artist_id)
                .map((record) => database.albums.lookup(record.album_id))
                .sort(jsondb.NumericSort.decreasing((record) => record.year))
                .map((record) => lookupAlbum(record.album_id, user_id))
                .collect()
        };
    }
    exports.lookupArtist = lookupArtist;
    ;
    function lookupCueBase(cue_id, user_id, subtitle) {
        let cue = database.cues.lookup(cue_id);
        return {
            cue_id: cue.cue_id,
            subtitle: is.present(subtitle) ? subtitle : lookupSubtitleBase(cue.subtitle_id, user_id),
            start_ms: cue.start_ms,
            duration_ms: cue.duration_ms,
            lines: cue.lines.split("\n")
        };
    }
    exports.lookupCueBase = lookupCueBase;
    ;
    function lookupCue(cue_id, user_id, subtitle) {
        let cue = lookupCueBase(cue_id, user_id, subtitle);
        let medias = database.getVideoFilesFromSubtitleFile.lookup(cue.subtitle.subtitle.file_id)
            .map((video_subtitle) => {
            try {
                let episode_files = database.getEpisodesFromFile.lookup(video_subtitle.video_file_id);
                for (let episode_file of episode_files) {
                    return lookupEpisode(episode_file.episode_id, user_id);
                }
            }
            catch (error) { }
            try {
                let movie_files = database.getMoviesFromFile.lookup(video_subtitle.video_file_id);
                for (let movie_file of movie_files) {
                    return lookupMovie(movie_file.movie_id, user_id);
                }
            }
            catch (error) { }
        })
            .include(is.present)
            .collect();
        let media = medias.shift();
        if (is.absent(media)) {
            throw `Expected a media entity!`;
        }
        return {
            ...cue,
            media
        };
    }
    exports.lookupCue = lookupCue;
    ;
    function lookupDiscBase(disc_id, user_id, album) {
        let disc = database.discs.lookup(disc_id);
        return {
            disc_id: disc.disc_id,
            album: is.present(album) ? album : lookupAlbumBase(disc.album_id, user_id),
            number: disc.number
        };
    }
    exports.lookupDiscBase = lookupDiscBase;
    ;
    function lookupDisc(disc_id, user_id, album) {
        let disc = lookupDiscBase(disc_id, user_id, album);
        return {
            ...disc,
            tracks: database.getTracksFromDisc.lookup(disc_id)
                .sort(jsondb.NumericSort.increasing((record) => record.number))
                .map((record) => lookupTrack(record.track_id, user_id, disc))
                .collect()
        };
    }
    exports.lookupDisc = lookupDisc;
    ;
    function lookupEpisodeBase(episode_id, user_id, season) {
        let episode = database.episodes.lookup(episode_id);
        return {
            episode_id: episode.episode_id,
            title: config_1.default.use_demo_mode ? "Episode title" : episode.title,
            number: episode.number,
            season: is.present(season) ? season : lookupSeasonBase(episode.season_id, user_id)
        };
    }
    exports.lookupEpisodeBase = lookupEpisodeBase;
    ;
    function lookupEpisode(episode_id, user_id, season) {
        let episode = lookupEpisodeBase(episode_id, user_id, season);
        let record = database.episodes.lookup(episode_id);
        let files = database.getFilesFromEpisode.lookup(episode_id)
            .map((record) => {
            try {
                return database.video_files.lookup(record.file_id);
            }
            catch (error) { }
        })
            .include(is.present)
            .sort(jsondb.NumericSort.decreasing((record) => record.height))
            .collect();
        let media = files.shift();
        if (is.absent(media)) {
            throw `Expected a valid video file!`;
        }
        let subtitles = database.getSubtitleFilesFromVideoFile.lookup(media.file_id)
            .map((record) => database.subtitle_files.lookup(record.subtitle_file_id))
            .collect();
        let streams = database.getStreamsFromFile.lookup(media.file_id)
            .filter((stream) => stream.user_id === user_id)
            .sort((jsondb.NumericSort.increasing((stream) => stream.timestamp_ms)))
            .collect();
        return {
            ...episode,
            year: record.year,
            summary: config_1.default.use_demo_mode ? "Episode summary." : record.summary,
            last_stream_date: streams.pop()?.timestamp_ms,
            media: media,
            subtitles: subtitles,
            copyright: record.copyright
        };
    }
    exports.lookupEpisode = lookupEpisode;
    ;
    function lookupGenreBase(genre_id, user_id) {
        let genre = database.genres.lookup(genre_id);
        return {
            genre_id: genre.genre_id,
            title: genre.name
        };
    }
    exports.lookupGenreBase = lookupGenreBase;
    ;
    function lookupGenre(genre_id, user_id) {
        let genre = lookupGenreBase(genre_id, user_id);
        return {
            ...genre
        };
    }
    exports.lookupGenre = lookupGenre;
    ;
    function lookupMovieBase(movie_id, user_id) {
        let movie = database.movies.lookup(movie_id);
        return {
            movie_id: movie.movie_id,
            title: config_1.default.use_demo_mode ? "Movie title" : movie.title,
            artwork: database.getFilesFromMovie.lookup(movie_id)
                .map((record) => {
                try {
                    return database.image_files.lookup(record.file_id);
                }
                catch (error) { }
            })
                .include(is.present)
                .collect()
        };
    }
    exports.lookupMovieBase = lookupMovieBase;
    ;
    function lookupMovie(movie_id, user_id) {
        let movie = lookupMovieBase(movie_id, user_id);
        let record = database.movies.lookup(movie_id);
        let files = database.getFilesFromMovie.lookup(movie_id)
            .map((record) => {
            try {
                return database.video_files.lookup(record.file_id);
            }
            catch (error) { }
        })
            .include(is.present)
            .sort(jsondb.NumericSort.decreasing((record) => record.height))
            .collect();
        let media = files.shift();
        if (is.absent(media)) {
            throw `Expected a valid video file!`;
        }
        let subtitles = database.getSubtitleFilesFromVideoFile.lookup(media.file_id)
            .map((record) => database.subtitle_files.lookup(record.subtitle_file_id))
            .collect();
        let streams = database.getStreamsFromFile.lookup(media.file_id)
            .filter((stream) => stream.user_id === user_id)
            .sort((jsondb.NumericSort.increasing((stream) => stream.timestamp_ms)))
            .collect();
        return {
            ...movie,
            year: record.year,
            summary: config_1.default.use_demo_mode ? "Movie summary." : record.summary,
            genres: database.getGenresFromMovie.lookup(movie_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupGenreBase(record.genre_id, user_id))
                .collect(),
            actors: database.getActorsFromMovie.lookup(movie_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupActor(record.actor_id, user_id))
                .collect(),
            last_stream_date: streams.pop()?.timestamp_ms,
            media: media,
            subtitles: subtitles,
            copyright: record.copyright
        };
    }
    exports.lookupMovie = lookupMovie;
    ;
    function lookupActorBase(actor_id, user_id) {
        let actor = database.actors.lookup(actor_id);
        return {
            actor_id: actor.actor_id,
            name: config_1.default.use_demo_mode ? "Actor name" : actor.name
        };
    }
    exports.lookupActorBase = lookupActorBase;
    ;
    function lookupActor(actor_id, user_id) {
        let actor = lookupActorBase(actor_id, user_id);
        return {
            ...actor
        };
    }
    exports.lookupActor = lookupActor;
    ;
    function lookupPlaylistBase(playlist_id, user_id, user) {
        let playlist = database.playlists.lookup(playlist_id);
        return {
            playlist_id: playlist.playlist_id,
            title: playlist.title,
            description: playlist.description,
            user: is.present(user) ? user : lookupUserBase(playlist.user_id, user_id)
        };
    }
    exports.lookupPlaylistBase = lookupPlaylistBase;
    ;
    function lookupPlaylist(playlist_id, user_id, user) {
        let playlist = lookupPlaylistBase(playlist_id, user_id, user);
        return {
            ...playlist,
            items: database.getPlaylistsItemsFromPlaylist.lookup(playlist_id)
                .sort(jsondb.NumericSort.increasing((record) => record.number))
                .map((record) => lookupPlaylistItem(record.playlist_item_id, user_id, playlist))
                .collect()
        };
    }
    exports.lookupPlaylist = lookupPlaylist;
    ;
    function lookupPlaylistItemBase(playlist_item_id, user_id, playlist) {
        let playlist_item = database.playlist_items.lookup(playlist_item_id);
        return {
            playlist_item_id: playlist_item.playlist_item_id,
            number: playlist_item.number,
            playlist: is.present(playlist) ? playlist : lookupPlaylistBase(playlist_item.playlist_id, user_id),
            track: lookupTrack(playlist_item.track_id, user_id)
        };
    }
    exports.lookupPlaylistItemBase = lookupPlaylistItemBase;
    ;
    function lookupPlaylistItem(playlist_item_id, user_id, playlist) {
        let playlist_item = lookupPlaylistItemBase(playlist_item_id, user_id, playlist);
        return {
            ...playlist_item
        };
    }
    exports.lookupPlaylistItem = lookupPlaylistItem;
    ;
    function lookupSeasonBase(season_id, user_id, show) {
        let season = database.seasons.lookup(season_id);
        return {
            season_id: season.season_id,
            number: season.number,
            show: is.present(show) ? show : lookupShowBase(season.show_id, user_id)
        };
    }
    exports.lookupSeasonBase = lookupSeasonBase;
    ;
    function lookupSeason(season_id, user_id, show) {
        let season = lookupSeasonBase(season_id, user_id, show);
        return {
            ...season,
            episodes: database.getEpisodesFromSeason.lookup(season_id)
                .sort(jsondb.NumericSort.increasing((record) => record.number))
                .map((record) => lookupEpisode(record.episode_id, user_id, season))
                .collect()
        };
    }
    exports.lookupSeason = lookupSeason;
    ;
    function lookupShowBase(show_id, user_id) {
        let show = database.shows.lookup(show_id);
        return {
            show_id: show.show_id,
            title: config_1.default.use_demo_mode ? "Show title" : show.name,
            artwork: database.getFilesFromShow.lookup(show_id)
                .map((record) => {
                try {
                    return database.image_files.lookup(record.file_id);
                }
                catch (error) { }
            })
                .include(is.present)
                .slice(0, 1)
                .collect()
        };
    }
    exports.lookupShowBase = lookupShowBase;
    ;
    function lookupShow(show_id, user_id) {
        let show = lookupShowBase(show_id, user_id);
        let record = database.shows.lookup(show_id);
        return {
            ...show,
            summary: config_1.default.use_demo_mode ? "Show summary." : record.summary,
            genres: database.getGenresFromShow.lookup(show_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupGenreBase(record.genre_id, user_id))
                .collect(),
            actors: database.getActorsFromShow.lookup(show_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupActorBase(record.actor_id, user_id))
                .collect(),
            seasons: database.getSeasonsFromShow.lookup(show_id)
                .sort(jsondb.NumericSort.increasing((record) => record.number))
                .map((record) => lookupSeason(record.season_id, user_id, show))
                .collect()
        };
    }
    exports.lookupShow = lookupShow;
    ;
    function lookupSubtitleBase(subtitle_id, user_id) {
        let subtitle = database.subtitles.lookup(subtitle_id);
        return {
            subtitle_id: subtitle.subtitle_id,
            subtitle: database.subtitle_files.lookup(subtitle.file_id)
        };
    }
    exports.lookupSubtitleBase = lookupSubtitleBase;
    ;
    function lookupSubtitle(subtitle_id, user_id) {
        let subtitle = lookupSubtitleBase(subtitle_id, user_id);
        return {
            ...subtitle,
            cues: database.getCuesFromSubtitle.lookup(subtitle_id)
                .map((record) => lookupCue(record.cue_id, user_id))
                .sort(jsondb.NumericSort.increasing((record) => record.start_ms))
                .collect()
        };
    }
    exports.lookupSubtitle = lookupSubtitle;
    ;
    function lookupTrackBase(track_id, user_id, disc) {
        let track = database.tracks.lookup(track_id);
        return {
            track_id: track.track_id,
            title: config_1.default.use_demo_mode ? "Track title" : track.title,
            disc: is.present(disc) ? disc : lookupDiscBase(track.disc_id, user_id),
            number: track.number
        };
    }
    exports.lookupTrackBase = lookupTrackBase;
    ;
    function lookupTrack(track_id, user_id, disc) {
        let track = lookupTrackBase(track_id, user_id, disc);
        let record = database.tracks.lookup(track_id);
        let files = database.getFilesFromTrack.lookup(track_id)
            .map((record) => {
            try {
                return database.audio_files.lookup(record.file_id);
            }
            catch (error) { }
        })
            .include(is.present)
            .collect();
        let media = files.shift();
        if (is.absent(media)) {
            throw `Expected a valid audio file!`;
        }
        let streams = database.getStreamsFromFile.lookup(media.file_id)
            .filter((stream) => stream.user_id === user_id)
            .sort((jsondb.NumericSort.increasing((stream) => stream.timestamp_ms)))
            .collect();
        return {
            ...track,
            artists: database.getArtistsFromTrack.lookup(track_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupArtistBase(record.artist_id, user_id))
                .collect(),
            last_stream_date: streams.pop()?.timestamp_ms,
            media: media,
            copyright: record.copyright
        };
    }
    exports.lookupTrack = lookupTrack;
    ;
    function lookupUserBase(user_id, api_user_id) {
        let user = database.users.lookup(user_id);
        return {
            user_id: user.user_id,
            name: user.name,
            username: user.username
        };
    }
    exports.lookupUserBase = lookupUserBase;
    ;
    function lookupUser(user_id, api_user_id) {
        let user = lookupUserBase(user_id, api_user_id);
        return {
            ...user
        };
    }
    exports.lookupUser = lookupUser;
    ;
    function lookupYearBase(year_id, user_id) {
        let year = database.years.lookup(year_id);
        return {
            year_id: year.year_id,
            year: year.year
        };
    }
    exports.lookupYearBase = lookupYearBase;
    ;
    function lookupYear(year_id, user_id) {
        let year = lookupYearBase(year_id, user_id);
        return {
            ...year
        };
    }
    exports.lookupYear = lookupYear;
    ;
    function getNewAlbums(user_id, offset, length) {
        let albums = new Map();
        for (let album of database.albums) {
            for (let disc of database.getDiscsFromAlbum.lookup(album.album_id)) {
                for (let track of database.getTracksFromDisc.lookup(disc.disc_id)) {
                    for (let track_file of database.getFilesFromTrack.lookup(track.track_id)) {
                        let file = database.files.lookup(track_file.file_id);
                        if (is.present(file.index_timestamp)) {
                            let index_timestamp = albums.get(album.album_id);
                            if (is.absent(index_timestamp)) {
                                index_timestamp = file.index_timestamp;
                            }
                            else {
                                index_timestamp = Math.max(index_timestamp, file.index_timestamp);
                            }
                            albums.set(album.album_id, index_timestamp);
                        }
                    }
                }
            }
        }
        return Array.from(albums.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => lookupAlbum(entry[0], user_id));
    }
    exports.getNewAlbums = getNewAlbums;
    ;
    function getNewMovies(user_id, offset, length) {
        let movies = new Map();
        for (let movie of database.movies) {
            for (let movie_file of database.getFilesFromMovie.lookup(movie.movie_id)) {
                let file = database.files.lookup(movie_file.file_id);
                if (is.present(file.index_timestamp)) {
                    let index_timestamp = movies.get(movie.movie_id);
                    if (is.absent(index_timestamp)) {
                        index_timestamp = file.index_timestamp;
                    }
                    else {
                        index_timestamp = Math.max(index_timestamp, file.index_timestamp);
                    }
                    movies.set(movie.movie_id, index_timestamp);
                }
            }
        }
        return Array.from(movies.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => lookupMovie(entry[0], user_id));
    }
    exports.getNewMovies = getNewMovies;
    ;
    function searchForAlbums(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.albums)
                .sort(jsondb.LexicalSort.increasing((record) => record.title))
                .slice(offset, offset + length)
                .map((record) => lookupAlbum(record.album_id, user_id));
        }
        else {
            return database.album_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().album_id)
                .map((id) => lookupAlbum(id, user_id))
                .collect();
        }
    }
    exports.searchForAlbums = searchForAlbums;
    ;
    function searchForArtists(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.artists)
                .map((artist) => ({
                artist,
                albums: database.getAlbumsFromArtist.lookup(artist.artist_id).collect()
            }))
                .sort(jsondb.CombinedSort.of(jsondb.CustomSort.increasing((entry) => entry.albums.length === 0), jsondb.LexicalSort.increasing((entry) => entry.artist.name)))
                .map((entry) => entry.artist)
                .slice(offset, offset + length)
                .map((record) => lookupArtist(record.artist_id, user_id));
        }
        else {
            return database.artist_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().artist_id)
                .map((id) => lookupArtist(id, user_id))
                .collect();
        }
    }
    exports.searchForArtists = searchForArtists;
    ;
    function searchForCues(query, offset, limit, user_id) {
        return is.absent(database.cue_search) ? [] : database.cue_search.search(query)
            .slice(offset, offset + limit)
            .map((record) => lookupCue(record.lookup().cue_id, user_id))
            .map((cue) => {
            let video_files = database.getVideoFilesFromSubtitleFile.lookup(cue.subtitle.subtitle.file_id);
            for (let video_file of video_files) {
                try {
                    let episode_files = database.getEpisodesFromFile.lookup(video_file.video_file_id);
                    for (let episode_file of episode_files) {
                        return {
                            ...cue,
                            media: lookupEpisode(episode_file.episode_id, user_id)
                        };
                    }
                }
                catch (error) { }
                try {
                    let movie_files = database.getMoviesFromFile.lookup(video_file.video_file_id);
                    for (let movie_file of movie_files) {
                        return {
                            ...cue,
                            media: lookupMovie(movie_file.movie_id, user_id)
                        };
                    }
                }
                catch (error) { }
            }
        })
            .include(is.present)
            .collect();
    }
    exports.searchForCues = searchForCues;
    ;
    function searchForDiscs(query, offset, length, user_id) {
        return Array.from(database.discs)
            .sort(jsondb.LexicalSort.increasing((record) => record.disc_id))
            .slice(offset, offset + length)
            .map((record) => lookupDisc(record.disc_id, user_id));
    }
    exports.searchForDiscs = searchForDiscs;
    ;
    function searchForEpisodes(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.episodes)
                .sort(jsondb.LexicalSort.increasing((record) => record.title))
                .slice(offset, offset + length)
                .map((record) => lookupEpisode(record.episode_id, user_id));
        }
        else {
            return database.episode_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().episode_id)
                .map((id) => lookupEpisode(id, user_id))
                .collect();
        }
    }
    exports.searchForEpisodes = searchForEpisodes;
    ;
    function searchForGenres(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.genres)
                .sort(jsondb.LexicalSort.increasing((record) => record.name))
                .map((record) => lookupGenre(record.genre_id, user_id));
        }
        else {
            return database.genre_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().genre_id)
                .map((id) => lookupGenre(id, user_id))
                .collect();
        }
    }
    exports.searchForGenres = searchForGenres;
    ;
    function searchForMovies(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.movies)
                .sort(jsondb.LexicalSort.increasing((record) => record.title))
                .slice(offset, offset + length)
                .map((record) => lookupMovie(record.movie_id, user_id));
        }
        else {
            return database.movie_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().movie_id)
                .map((id) => lookupMovie(id, user_id))
                .collect();
        }
    }
    exports.searchForMovies = searchForMovies;
    ;
    function searchForActors(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.actors)
                .sort(jsondb.LexicalSort.increasing((record) => record.name))
                .slice(offset, offset + length)
                .map((record) => lookupActor(record.actor_id, user_id));
        }
        else {
            return database.actor_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().actor_id)
                .map((id) => lookupActor(id, user_id))
                .collect();
        }
    }
    exports.searchForActors = searchForActors;
    ;
    function searchForPlaylists(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.playlists)
                .sort(jsondb.LexicalSort.increasing((record) => record.title))
                .slice(offset, offset + length)
                .map((record) => lookupPlaylist(record.playlist_id, user_id));
        }
        else {
            return database.playlist_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().playlist_id)
                .map((id) => lookupPlaylist(id, user_id))
                .collect();
        }
    }
    exports.searchForPlaylists = searchForPlaylists;
    ;
    function searchForSeasons(query, offset, length, user_id) {
        return Array.from(database.seasons)
            .sort(jsondb.LexicalSort.increasing((record) => record.season_id))
            .slice(offset, offset + length)
            .map((record) => lookupSeason(record.season_id, user_id));
    }
    exports.searchForSeasons = searchForSeasons;
    ;
    function searchForShows(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.shows)
                .sort(jsondb.LexicalSort.increasing((record) => record.name))
                .slice(offset, offset + length)
                .map((record) => lookupShow(record.show_id, user_id));
        }
        else {
            return database.shows_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().show_id)
                .map((id) => lookupShow(id, user_id))
                .collect();
        }
    }
    exports.searchForShows = searchForShows;
    ;
    function searchForTracks(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.tracks)
                .sort(jsondb.LexicalSort.increasing((record) => record.title))
                .slice(offset, offset + length)
                .map((record) => lookupTrack(record.track_id, user_id));
        }
        else {
            return database.track_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().track_id)
                .map((id) => lookupTrack(id, user_id))
                .collect();
        }
    }
    exports.searchForTracks = searchForTracks;
    ;
    function searchForUsers(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.users)
                .sort(jsondb.LexicalSort.increasing((record) => record.name))
                .slice(offset, offset + length)
                .map((record) => lookupUser(record.user_id, user_id));
        }
        else {
            return database.user_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().user_id)
                .map((id) => lookupUser(id, user_id))
                .collect();
        }
    }
    exports.searchForUsers = searchForUsers;
    ;
    function searchForYears(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.years)
                .sort(jsondb.NumericSort.decreasing((record) => record.year))
                .slice(offset, offset + length)
                .map((record) => lookupYear(record.year_id, user_id));
        }
        else {
            return database.year_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().year_id)
                .map((id) => lookupYear(id, user_id))
                .collect();
        }
    }
    exports.searchForYears = searchForYears;
    ;
    function searchForEntities(query, user_id, offset, limit, options) {
        let results = [
            ...database.actor_search.search(query).map((result) => ({ ...result, type: "ACTOR", type_rank: 1 })),
            ...database.album_search.search(query).map((result) => ({ ...result, type: "ALBUM", type_rank: 9 })),
            ...database.artist_search.search(query).map((result) => ({ ...result, type: "ARTIST", type_rank: 6 })),
            ...database.episode_search.search(query).map((result) => ({ ...result, type: "EPISODE", type_rank: 4 })),
            ...database.genre_search.search(query).map((result) => ({ ...result, type: "GENRE", type_rank: 2 })),
            ...database.movie_search.search(query).map((result) => ({ ...result, type: "MOVIE", type_rank: 8 })),
            ...database.playlist_search.search(query).map((result) => ({ ...result, type: "PLAYLIST", type_rank: 3 })),
            ...database.shows_search.search(query).map((result) => ({ ...result, type: "SHOW", type_rank: 7 })),
            ...database.track_search.search(query).map((result) => ({ ...result, type: "TRACK", type_rank: 5 })),
            ...database.user_search.search(query).map((result) => ({ ...result, type: "USER", type_rank: 0 })),
            ...database.year_search.search(query).map((result) => ({ ...result, type: "YEAR", type_rank: 10 })),
            ...new Array()
        ].sort(jsondb.CombinedSort.of(jsondb.NumericSort.decreasing((value) => value.rank), jsondb.NumericSort.decreasing((value) => value.type_rank)));
        if (options?.cues) {
            let cue = database.cue_search.search(query).shift();
            if (is.present(cue)) {
                let result = results[0];
                if (is.absent(result) || cue.rank > result.rank) {
                    results.unshift({ ...cue, type: "CUE", type_rank: 11 });
                }
            }
        }
        let entities = results.slice(offset, offset + limit).map((result) => {
            let type = result.type;
            if (false) {
            }
            else if (type === "ACTOR") {
                return lookupActor(result.lookup().actor_id, user_id);
            }
            else if (type === "ALBUM") {
                return lookupAlbum(result.lookup().album_id, user_id);
            }
            else if (type === "ARTIST") {
                return lookupArtist(result.lookup().artist_id, user_id);
            }
            else if (type === "CUE") {
                return lookupCue(result.lookup().cue_id, user_id);
            }
            else if (type === "EPISODE") {
                return lookupEpisode(result.lookup().episode_id, user_id);
            }
            else if (type === "GENRE") {
                return lookupGenre(result.lookup().genre_id, user_id);
            }
            else if (type === "MOVIE") {
                return lookupMovie(result.lookup().movie_id, user_id);
            }
            else if (type === "PLAYLIST") {
                return lookupPlaylist(result.lookup().playlist_id, user_id);
            }
            else if (type === "SHOW") {
                return lookupShow(result.lookup().show_id, user_id);
            }
            else if (type === "TRACK") {
                return lookupTrack(result.lookup().track_id, user_id);
            }
            else if (type === "USER") {
                return lookupUser(result.lookup().user_id, user_id);
            }
            else if (type === "YEAR") {
                return lookupYear(result.lookup().year_id, user_id);
            }
            throw `Expected code to be unreachable!`;
        });
        return entities;
    }
    exports.searchForEntities = searchForEntities;
    ;
    function getArtistAppearances(artist_id, user_id) {
        let track_artists = database.getTracksFromArtist.lookup(artist_id);
        let tracks = track_artists.map((track_artist) => {
            return database.tracks.lookup(track_artist.track_id);
        });
        let disc_ids = tracks.map((track) => {
            return track.disc_id;
        })
            .collect();
        disc_ids = Array.from(new Set(disc_ids));
        let discs = disc_ids.map((disc_id) => {
            return database.discs.lookup(disc_id);
        });
        let album_ids = discs.map((disc) => {
            return disc.album_id;
        });
        album_ids = Array.from(new Set(album_ids));
        let result = new Array();
        for (let album_id of album_ids) {
            let album_artists = database.getArtistsFromAlbum.lookup(album_id);
            if (album_artists.find((album_artist) => album_artist.artist_id === artist_id) == null) {
                result.push(album_id);
            }
        }
        return result
            .map((entry) => database.albums.lookup(entry))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.title))
            .map((entry) => {
            return lookupAlbum(entry.album_id, user_id);
        });
    }
    exports.getArtistAppearances = getArtistAppearances;
    ;
    function getArtistTracks(artist_id, offset, length, user_id) {
        let track_weights = new Map();
        for (let track_artist of database.getTracksFromArtist.lookup(artist_id)) {
            let track_id = track_artist.track_id;
            for (let file of database.getFilesFromTrack.lookup(track_id)) {
                let streams = database.getStreamsFromFile.lookup(file.file_id);
                for (let stream of streams) {
                    let weight = track_weights.get(track_id) ?? 0;
                    weight += getStreamWeight(stream.timestamp_ms);
                    track_weights.set(track_id, weight);
                }
            }
        }
        return Array.from(track_weights.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => entry[0])
            .map((track_id) => lookupTrack(track_id, user_id));
    }
    exports.getArtistTracks = getArtistTracks;
    function getPlaylistAppearances(track_id, offset, length, user_id) {
        let playlist_ids = new Set();
        for (let playlist_item of database.getPlaylistItemsFromTrack.lookup(track_id)) {
            playlist_ids.add(playlist_item.playlist_id);
        }
        return Array.from(playlist_ids)
            .map((playlist_id) => database.playlists.lookup(playlist_id))
            .sort(jsondb.LexicalSort.increasing((playlist) => playlist.title))
            .slice(offset, offset + length)
            .map((playlist) => lookupPlaylist(playlist.playlist_id, user_id));
    }
    exports.getPlaylistAppearances = getPlaylistAppearances;
    ;
    function getMovieSuggestions(movie_id, offset, length, user_id) {
        let genres = database.getGenresFromMovie.lookup(movie_id);
        let map = new Map();
        for (let genre of genres) {
            let movie_genres = database.getMoviesFromGenre.lookup(genre.genre_id);
            for (let movie_genre of movie_genres) {
                let value = map.get(movie_genre.movie_id) ?? 0;
                map.set(movie_genre.movie_id, value + 2);
            }
        }
        for (let entry of map) {
            let video_genres = database.getGenresFromMovie.lookup(entry[0]).collect();
            map.set(entry[0], entry[1] - video_genres.length);
        }
        map.delete(movie_id);
        return Array.from(map.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => entry[0])
            .map((movie_id) => lookupMovie(movie_id, user_id));
    }
    exports.getMovieSuggestions = getMovieSuggestions;
    ;
    function getMoviesFromGenre(video_genre_id, user_id, offset, length) {
        return database.getMoviesFromGenre.lookup(video_genre_id)
            .map((entry) => database.movies.lookup(entry.movie_id))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.title))
            .slice(offset, offset + length)
            .map((entry) => lookupMovie(entry.movie_id, user_id))
            .collect();
    }
    exports.getMoviesFromGenre = getMoviesFromGenre;
    ;
    function getMoviesFromActor(actor_id, user_id, offset, length) {
        return database.getMoviesFromActor.lookup(actor_id)
            .map((entry) => database.movies.lookup(entry.movie_id))
            .sort(jsondb.LexicalSort.increasing((movie) => movie.title))
            .slice(offset, offset + length)
            .map((entry) => lookupMovie(entry.movie_id, user_id))
            .collect();
    }
    exports.getMoviesFromActor = getMoviesFromActor;
    ;
    function getShowsFromGenre(video_genre_id, user_id, offset, length) {
        return database.getShowsFromGenre.lookup(video_genre_id)
            .map((entry) => database.shows.lookup(entry.show_id))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.name))
            .slice(offset, offset + length)
            .map((entry) => lookupShow(entry.show_id, user_id))
            .collect();
    }
    exports.getShowsFromGenre = getShowsFromGenre;
    ;
    function getShowsFromActor(actor_id, user_id, offset, length) {
        return database.getShowsFromActor.lookup(actor_id)
            .map((entry) => database.shows.lookup(entry.show_id))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.name))
            .slice(offset, offset + length)
            .map((entry) => lookupShow(entry.show_id, user_id))
            .collect();
    }
    exports.getShowsFromActor = getShowsFromActor;
    ;
    function getUserPlaylists(subject_user_id, user_id, offset, length) {
        return database.getPlaylistsFromUser.lookup(subject_user_id)
            .sort(jsondb.LexicalSort.increasing((entry) => entry.title))
            .slice(offset, offset + length)
            .map((entry) => lookupPlaylist(entry.playlist_id, user_id))
            .collect();
    }
    exports.getUserPlaylists = getUserPlaylists;
    ;
    function getUserAlbums(subject_user_id, offset, length, user_id) {
        let album_weights = new Map();
        let streams = database.getStreamsFromUser.lookup(subject_user_id);
        for (let stream of streams) {
            let track_files = database.getTracksFromFile.lookup(stream.file_id);
            for (let track_file of track_files) {
                let track = database.tracks.lookup(track_file.track_id);
                let disc = database.discs.lookup(track.disc_id);
                let album = database.albums.lookup(disc.album_id);
                let album_id = album.album_id;
                let weight = album_weights.get(album_id) ?? 0;
                weight += getStreamWeight(stream.timestamp_ms);
                album_weights.set(album_id, weight);
            }
        }
        return Array.from(album_weights.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => entry[0])
            .map((album_id) => lookupAlbum(album_id, user_id));
    }
    exports.getUserAlbums = getUserAlbums;
    ;
    function getUserShows(subject_user_id, offset, length, user_id) {
        let show_weights = new Map();
        let streams = database.getStreamsFromUser.lookup(subject_user_id);
        for (let stream of streams) {
            let episode_files = database.getEpisodesFromFile.lookup(stream.file_id);
            for (let episode_file of episode_files) {
                let episode = database.episodes.lookup(episode_file.episode_id);
                let season = database.seasons.lookup(episode.season_id);
                let show = database.shows.lookup(season.show_id);
                let show_id = show.show_id;
                let weight = show_weights.get(show_id) ?? 0;
                weight += getStreamWeight(stream.timestamp_ms);
                show_weights.set(show_id, weight);
            }
        }
        return Array.from(show_weights.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => entry[0])
            .map((artist_id) => lookupShow(artist_id, user_id));
    }
    exports.getUserShows = getUserShows;
    ;
    function getMoviesFromYear(year_id, user_id, offset, length) {
        return database.getMoviesFromYear.lookup(lookupYearBase(year_id, user_id).year)
            .map((entry) => database.movies.lookup(entry.movie_id))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.title))
            .slice(offset, offset + length)
            .map((entry) => lookupMovie(entry.movie_id, user_id))
            .collect();
    }
    exports.getMoviesFromYear = getMoviesFromYear;
    ;
    function getAlbumsFromYear(year_id, user_id, offset, length) {
        return database.getAlbumsFromYear.lookup(lookupYearBase(year_id, user_id).year)
            .map((entry) => database.albums.lookup(entry.album_id))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.title))
            .slice(offset, offset + length)
            .map((entry) => lookupAlbum(entry.album_id, user_id))
            .collect();
    }
    exports.getAlbumsFromYear = getAlbumsFromYear;
    ;
});
define("build/api/schema/objects/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/database/schema/index", "build/database/schema/index", "build/database/schema/index", "build/database/schema/index"], function (require, exports, autoguard, schema_1, schema_2, schema_3, schema_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Entity = exports.EntityBase = exports.Year = exports.YearBase = exports.Cue = exports.CueBase = exports.Subtitle = exports.SubtitleBase = exports.Episode = exports.EpisodeBase = exports.Season = exports.SeasonBase = exports.Show = exports.ShowBase = exports.Movie = exports.MovieBase = exports.Genre = exports.GenreBase = exports.PlaylistItem = exports.PlaylistItemBase = exports.Playlist = exports.PlaylistBase = exports.User = exports.UserBase = exports.Track = exports.TrackBase = exports.Disc = exports.DiscBase = exports.Album = exports.AlbumBase = exports.Artist = exports.ArtistBase = exports.Actor = exports.ActorBase = void 0;
    exports.ActorBase = autoguard.guards.Object.of({
        "actor_id": autoguard.guards.String,
        "name": autoguard.guards.String
    });
    exports.Actor = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ActorBase), autoguard.guards.Object.of({}));
    exports.ArtistBase = autoguard.guards.Object.of({
        "artist_id": autoguard.guards.String,
        "title": autoguard.guards.String
    });
    exports.Artist = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ArtistBase), autoguard.guards.Object.of({
        "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Album))
    }));
    exports.AlbumBase = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Album = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.AlbumBase), autoguard.guards.Object.of({
        "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ArtistBase)),
        "discs": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Disc)),
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    }));
    exports.DiscBase = autoguard.guards.Object.of({
        "disc_id": autoguard.guards.String,
        "album": autoguard.guards.Reference.of(() => exports.AlbumBase),
        "number": autoguard.guards.Number
    });
    exports.Disc = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.DiscBase), autoguard.guards.Object.of({
        "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Track))
    }));
    exports.TrackBase = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "disc": autoguard.guards.Reference.of(() => exports.DiscBase),
        "number": autoguard.guards.Number
    });
    exports.Track = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.TrackBase), autoguard.guards.Object.of({
        "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ArtistBase)),
        "last_stream_date": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "media": autoguard.guards.Reference.of(() => schema_1.AudioFile),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    }));
    exports.UserBase = autoguard.guards.Object.of({
        "user_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "username": autoguard.guards.String
    });
    exports.User = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.UserBase), autoguard.guards.Object.of({}));
    exports.PlaylistBase = autoguard.guards.Object.of({
        "playlist_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "description": autoguard.guards.String,
        "user": autoguard.guards.Reference.of(() => exports.UserBase)
    });
    exports.Playlist = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.PlaylistBase), autoguard.guards.Object.of({
        "items": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.PlaylistItem))
    }));
    exports.PlaylistItemBase = autoguard.guards.Object.of({
        "playlist_item_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "playlist": autoguard.guards.Reference.of(() => exports.PlaylistBase),
        "track": autoguard.guards.Reference.of(() => exports.Track)
    });
    exports.PlaylistItem = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.PlaylistItemBase), autoguard.guards.Object.of({}));
    exports.GenreBase = autoguard.guards.Object.of({
        "genre_id": autoguard.guards.String,
        "title": autoguard.guards.String
    });
    exports.Genre = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.GenreBase), autoguard.guards.Object.of({}));
    exports.MovieBase = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Movie = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.MovieBase), autoguard.guards.Object.of({
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "genres": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Genre)),
        "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Actor)),
        "last_stream_date": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "media": autoguard.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_3.SubtitleFile)),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    }));
    exports.ShowBase = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Show = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ShowBase), autoguard.guards.Object.of({
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "genres": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Genre)),
        "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Actor)),
        "seasons": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Season))
    }));
    exports.SeasonBase = autoguard.guards.Object.of({
        "season_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "show": autoguard.guards.Reference.of(() => exports.ShowBase)
    });
    exports.Season = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.SeasonBase), autoguard.guards.Object.of({
        "episodes": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Episode))
    }));
    exports.EpisodeBase = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "season": autoguard.guards.Reference.of(() => exports.SeasonBase)
    });
    exports.Episode = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.EpisodeBase), autoguard.guards.Object.of({
        "year": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "summary": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "last_stream_date": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "media": autoguard.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_3.SubtitleFile)),
        "copyright": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    }));
    exports.SubtitleBase = autoguard.guards.Object.of({
        "subtitle_id": autoguard.guards.String,
        "subtitle": autoguard.guards.Reference.of(() => schema_3.SubtitleFile)
    });
    exports.Subtitle = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.SubtitleBase), autoguard.guards.Object.of({
        "cues": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Cue))
    }));
    exports.CueBase = autoguard.guards.Object.of({
        "cue_id": autoguard.guards.String,
        "subtitle": autoguard.guards.Reference.of(() => exports.SubtitleBase),
        "start_ms": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number,
        "lines": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.Cue = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.CueBase), autoguard.guards.Object.of({
        "media": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Episode), autoguard.guards.Reference.of(() => exports.Movie))
    }));
    exports.YearBase = autoguard.guards.Object.of({
        "year_id": autoguard.guards.String,
        "year": autoguard.guards.Number
    });
    exports.Year = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.YearBase), autoguard.guards.Object.of({}));
    exports.EntityBase = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ActorBase), autoguard.guards.Reference.of(() => exports.AlbumBase), autoguard.guards.Reference.of(() => exports.ArtistBase), autoguard.guards.Reference.of(() => exports.CueBase), autoguard.guards.Reference.of(() => exports.DiscBase), autoguard.guards.Reference.of(() => exports.EpisodeBase), autoguard.guards.Reference.of(() => exports.GenreBase), autoguard.guards.Reference.of(() => exports.MovieBase), autoguard.guards.Reference.of(() => exports.PlaylistBase), autoguard.guards.Reference.of(() => exports.SeasonBase), autoguard.guards.Reference.of(() => exports.ShowBase), autoguard.guards.Reference.of(() => exports.TrackBase), autoguard.guards.Reference.of(() => exports.UserBase), autoguard.guards.Reference.of(() => exports.YearBase));
    exports.Entity = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Actor), autoguard.guards.Reference.of(() => exports.Album), autoguard.guards.Reference.of(() => exports.Artist), autoguard.guards.Reference.of(() => exports.Cue), autoguard.guards.Reference.of(() => exports.Disc), autoguard.guards.Reference.of(() => exports.Episode), autoguard.guards.Reference.of(() => exports.Genre), autoguard.guards.Reference.of(() => exports.Movie), autoguard.guards.Reference.of(() => exports.Playlist), autoguard.guards.Reference.of(() => exports.Season), autoguard.guards.Reference.of(() => exports.Show), autoguard.guards.Reference.of(() => exports.Track), autoguard.guards.Reference.of(() => exports.User), autoguard.guards.Reference.of(() => exports.Year));
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ActorBase": autoguard.guards.Reference.of(() => exports.ActorBase),
            "Actor": autoguard.guards.Reference.of(() => exports.Actor),
            "ArtistBase": autoguard.guards.Reference.of(() => exports.ArtistBase),
            "Artist": autoguard.guards.Reference.of(() => exports.Artist),
            "AlbumBase": autoguard.guards.Reference.of(() => exports.AlbumBase),
            "Album": autoguard.guards.Reference.of(() => exports.Album),
            "DiscBase": autoguard.guards.Reference.of(() => exports.DiscBase),
            "Disc": autoguard.guards.Reference.of(() => exports.Disc),
            "TrackBase": autoguard.guards.Reference.of(() => exports.TrackBase),
            "Track": autoguard.guards.Reference.of(() => exports.Track),
            "UserBase": autoguard.guards.Reference.of(() => exports.UserBase),
            "User": autoguard.guards.Reference.of(() => exports.User),
            "PlaylistBase": autoguard.guards.Reference.of(() => exports.PlaylistBase),
            "Playlist": autoguard.guards.Reference.of(() => exports.Playlist),
            "PlaylistItemBase": autoguard.guards.Reference.of(() => exports.PlaylistItemBase),
            "PlaylistItem": autoguard.guards.Reference.of(() => exports.PlaylistItem),
            "GenreBase": autoguard.guards.Reference.of(() => exports.GenreBase),
            "Genre": autoguard.guards.Reference.of(() => exports.Genre),
            "MovieBase": autoguard.guards.Reference.of(() => exports.MovieBase),
            "Movie": autoguard.guards.Reference.of(() => exports.Movie),
            "ShowBase": autoguard.guards.Reference.of(() => exports.ShowBase),
            "Show": autoguard.guards.Reference.of(() => exports.Show),
            "SeasonBase": autoguard.guards.Reference.of(() => exports.SeasonBase),
            "Season": autoguard.guards.Reference.of(() => exports.Season),
            "EpisodeBase": autoguard.guards.Reference.of(() => exports.EpisodeBase),
            "Episode": autoguard.guards.Reference.of(() => exports.Episode),
            "SubtitleBase": autoguard.guards.Reference.of(() => exports.SubtitleBase),
            "Subtitle": autoguard.guards.Reference.of(() => exports.Subtitle),
            "CueBase": autoguard.guards.Reference.of(() => exports.CueBase),
            "Cue": autoguard.guards.Reference.of(() => exports.Cue),
            "YearBase": autoguard.guards.Reference.of(() => exports.YearBase),
            "Year": autoguard.guards.Reference.of(() => exports.Year),
            "EntityBase": autoguard.guards.Reference.of(() => exports.EntityBase),
            "Entity": autoguard.guards.Reference.of(() => exports.Entity)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.RegisterResponse = exports.RegisterRequest = exports.ErrorMessage = void 0;
    exports.ErrorMessage = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.RegisterRequest = autoguard.guards.Object.of({
        "username": autoguard.guards.String,
        "password": autoguard.guards.String,
        "name": autoguard.guards.String,
        "key_id": autoguard.guards.String
    });
    exports.RegisterResponse = autoguard.guards.Object.of({
        "token": autoguard.guards.String
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ErrorMessage": autoguard.guards.Reference.of(() => exports.ErrorMessage),
            "RegisterRequest": autoguard.guards.Reference.of(() => exports.RegisterRequest),
            "RegisterResponse": autoguard.guards.Reference.of(() => exports.RegisterResponse)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/api/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/messages/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/messages/index", "build/api/schema/messages/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2, objects_3, objects_4, objects_5, objects_6, messages_1, objects_7, objects_8, objects_9, messages_2, messages_3, objects_10, objects_11, objects_12, objects_13, objects_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = void 0;
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {};
        Autoguard.Requests = {
            "POST:/auth/": autoguard.guards.Object.of({
                "options": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Options), autoguard.guards.Undefined),
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "x-circus-username": autoguard.guards.String,
                    "x-circus-password": autoguard.guards.String
                }), autoguard.api.Headers),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "POST:/users/": autoguard.guards.Object.of({
                "options": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Options), autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Reference.of(() => messages_2.RegisterRequest)
            }),
            "GET:/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "cues": autoguard.guards.Union.of(autoguard.guards.Boolean, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/actors/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/actors/<actor_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/actors/<actor_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/actors/<actor_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/albums/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "getNewAlbums": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/albums/<album_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "album_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/artists/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/artists/<artist_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "artist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/discs/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/discs/<disc_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "disc_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/episodes/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/episodes/<episode_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "episode_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/genres/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/genres/<genre_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/genres/<genre_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/genres/<genre_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/movies/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "getNewMovies": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/movies/<movie_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "movie_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/movies/<movie_id>/suggestions/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "movie_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/playlists/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/playlists/<playlist_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "playlist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/seasons/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/seasons/<season_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "season_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/shows/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/shows/<show_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "show_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/tracks/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/tracks/<track_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "track_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/tracks/<track_id>/playlists/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "track_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/users/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/users/<user_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/users/<user_id>/albums/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/users/<user_id>/playlists/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/users/<user_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/years/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/years/<year_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/years/<year_id>/albums/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/years/<year_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String,
                    "offset": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                    "limit": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/files/<file_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "file_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/statistics/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String
                }), autoguard.api.Options),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            })
        };
        Autoguard.Responses = {
            "POST:/auth/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "x-circus-token": autoguard.guards.String
                }), autoguard.api.Headers),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "POST:/users/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => messages_3.RegisterResponse), autoguard.guards.Reference.of(() => messages_1.ErrorMessage))
            }),
            "GET:/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "entities": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_5.Entity))
                })
            }),
            "GET:/actors/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_1.Actor))
                })
            }),
            "GET:/actors/<actor_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "actor": autoguard.guards.Reference.of(() => objects_1.Actor)
                })
            }),
            "GET:/actors/<actor_id>/movies/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "GET:/actors/<actor_id>/shows/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                })
            }),
            "GET:/albums/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                })
            }),
            "getNewAlbums": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                })
            }),
            "GET:/albums/<album_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "album": autoguard.guards.Reference.of(() => objects_2.Album)
                })
            }),
            "GET:/artists/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_3.Artist))
                })
            }),
            "GET:/artists/<artist_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "artist": autoguard.guards.Reference.of(() => objects_3.Artist),
                    "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_12.Track)),
                    "appearances": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                })
            }),
            "GET:/discs/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "discs": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_4.Disc))
                })
            }),
            "GET:/discs/<disc_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "disc": autoguard.guards.Reference.of(() => objects_4.Disc),
                    "last": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_4.Disc), autoguard.guards.Undefined),
                    "next": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_4.Disc), autoguard.guards.Undefined)
                })
            }),
            "GET:/episodes/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "episodes": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_6.Episode))
                })
            }),
            "GET:/episodes/<episode_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "episode": autoguard.guards.Reference.of(() => objects_6.Episode),
                    "last": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_6.Episode), autoguard.guards.Undefined),
                    "next": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_6.Episode), autoguard.guards.Undefined)
                })
            }),
            "GET:/genres/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "genres": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_7.Genre))
                })
            }),
            "GET:/genres/<genre_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "genre": autoguard.guards.Reference.of(() => objects_7.Genre)
                })
            }),
            "GET:/genres/<genre_id>/movies/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "GET:/genres/<genre_id>/shows/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                })
            }),
            "GET:/movies/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "getNewMovies": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "GET:/movies/<movie_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movie": autoguard.guards.Reference.of(() => objects_8.Movie)
                })
            }),
            "GET:/movies/<movie_id>/suggestions/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "GET:/playlists/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "playlists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_9.Playlist))
                })
            }),
            "GET:/playlists/<playlist_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "playlist": autoguard.guards.Reference.of(() => objects_9.Playlist)
                })
            }),
            "GET:/seasons/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "seasons": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_10.Season))
                })
            }),
            "GET:/seasons/<season_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "season": autoguard.guards.Reference.of(() => objects_10.Season),
                    "last": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_10.Season), autoguard.guards.Undefined),
                    "next": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_10.Season), autoguard.guards.Undefined)
                })
            }),
            "GET:/shows/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                })
            }),
            "GET:/shows/<show_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "show": autoguard.guards.Reference.of(() => objects_11.Show)
                })
            }),
            "GET:/tracks/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_12.Track))
                })
            }),
            "GET:/tracks/<track_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "track": autoguard.guards.Reference.of(() => objects_12.Track),
                    "last": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_12.Track), autoguard.guards.Undefined),
                    "next": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_12.Track), autoguard.guards.Undefined)
                })
            }),
            "GET:/tracks/<track_id>/playlists/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "playlists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_9.Playlist))
                })
            }),
            "GET:/users/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "users": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_13.User))
                })
            }),
            "GET:/users/<user_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "user": autoguard.guards.Reference.of(() => objects_13.User)
                })
            }),
            "GET:/users/<user_id>/albums/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                })
            }),
            "GET:/users/<user_id>/playlists/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "playlists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_9.Playlist))
                })
            }),
            "GET:/users/<user_id>/shows/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                })
            }),
            "GET:/years/<query>": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "years": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_14.Year))
                })
            }),
            "GET:/years/<year_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "year": autoguard.guards.Reference.of(() => objects_14.Year)
                })
            }),
            "GET:/years/<year_id>/albums/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                })
            }),
            "GET:/years/<year_id>/movies/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                })
            }),
            "GET:/files/<file_id>/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Union.of(autoguard.api.Binary, autoguard.guards.Undefined)
            }),
            "GET:/statistics/": autoguard.guards.Object.of({
                "status": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
                "headers": autoguard.guards.Union.of(autoguard.guards.Intersection.of(autoguard.guards.Object.of({}), autoguard.api.Headers), autoguard.guards.Undefined),
                "payload": autoguard.guards.Object.of({
                    "statistics": autoguard.guards.Array.of(autoguard.guards.Object.of({
                        "title": autoguard.guards.String,
                        "value": autoguard.guards.Number,
                        "unit": autoguard.guards.Union.of(autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("BYTES"), autoguard.guards.StringLiteral.of("MILLISECONDS")), autoguard.guards.Undefined)
                    }))
                })
            })
        };
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/api/server", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-server/index", "build/api/schema/api/index"], function (require, exports, autoguard, shared) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeServer = void 0;
    const makeServer = (routes, serverOptions) => {
        let endpoints = new Array();
        endpoints.push((raw, auxillary) => {
            let method = "POST";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("auth")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers["x-circus-username"] = autoguard.api.decodeHeaderValue(raw.headers, "x-circus-username", true);
                    headers["x-circus-password"] = autoguard.api.decodeHeaderValue(raw.headers, "x-circus-password", true);
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["POST:/auth/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["POST:/auth/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["POST:/auth/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeHeaderPairs("x-circus-token", [response.headers?.["x-circus-token"]], true));
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = response.payload ?? [];
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/octet-stream"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "POST";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = await autoguard.api.deserializePayload(raw.payload);
                    let guard = shared.Autoguard.Requests["POST:/users/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["POST:/users/"](new autoguard.api.ClientRequest(request, false, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["POST:/users/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[0].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options["cues"] = autoguard.api.decodeParameterValue(raw.parameters, "cues", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/actors/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/actors/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/actors/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["actor_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/actors/<actor_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/actors/<actor_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/actors/<actor_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["actor_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/actors/<actor_id>/movies/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/actors/<actor_id>/movies/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/actors/<actor_id>/movies/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["actor_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/actors/<actor_id>/shows/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/actors/<actor_id>/shows/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/actors/<actor_id>/shows/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/albums/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/albums/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/albums/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("new")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["getNewAlbums"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["getNewAlbums"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["getNewAlbums"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["album_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/albums/<album_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/albums/<album_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/albums/<album_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("artists")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/artists/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/artists/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/artists/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("artists")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["artist_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/artists/<artist_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/artists/<artist_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/artists/<artist_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("discs")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/discs/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/discs/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/discs/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("discs")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["disc_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/discs/<disc_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/discs/<disc_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/discs/<disc_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("episodes")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/episodes/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/episodes/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/episodes/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("episodes")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["episode_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/episodes/<episode_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/episodes/<episode_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/episodes/<episode_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/genres/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/genres/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/genres/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["genre_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/genres/<genre_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/genres/<genre_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/genres/<genre_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["genre_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/genres/<genre_id>/movies/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/genres/<genre_id>/movies/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/genres/<genre_id>/movies/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["genre_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/genres/<genre_id>/shows/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/genres/<genre_id>/shows/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/genres/<genre_id>/shows/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/movies/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/movies/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/movies/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("new")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["getNewMovies"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["getNewMovies"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["getNewMovies"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["movie_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/movies/<movie_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/movies/<movie_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/movies/<movie_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("suggestions")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["movie_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/movies/<movie_id>/suggestions/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/movies/<movie_id>/suggestions/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/movies/<movie_id>/suggestions/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/playlists/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/playlists/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/playlists/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["playlist_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/playlists/<playlist_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/playlists/<playlist_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/playlists/<playlist_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("seasons")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/seasons/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/seasons/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/seasons/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("seasons")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["season_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/seasons/<season_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/seasons/<season_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/seasons/<season_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/shows/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/shows/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/shows/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["show_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/shows/<show_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/shows/<show_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/shows/<show_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("tracks")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/tracks/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/tracks/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/tracks/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("tracks")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["track_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/tracks/<track_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/tracks/<track_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/tracks/<track_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("tracks")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["track_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/tracks/<track_id>/playlists/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/tracks/<track_id>/playlists/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/tracks/<track_id>/playlists/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/users/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/users/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/users/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["user_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/users/<user_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/users/<user_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/users/<user_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["user_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/users/<user_id>/albums/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/users/<user_id>/albums/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/users/<user_id>/albums/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["user_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/users/<user_id>/playlists/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/users/<user_id>/playlists/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/users/<user_id>/playlists/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["user_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/users/<user_id>/shows/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/users/<user_id>/shows/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/users/<user_id>/shows/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/years/<query>"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/years/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/years/<query>"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["year_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/years/<year_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/years/<year_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/years/<year_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["year_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/years/<year_id>/albums/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/years/<year_id>/albums/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/years/<year_id>/albums/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["year_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/years/<year_id>/movies/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/years/<year_id>/movies/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/years/<year_id>/movies/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("files")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["file_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/files/<file_id>/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/files/<file_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/files/<file_id>/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = response.payload ?? [];
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/octet-stream"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("statistics")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters ?? {}, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers ?? {}, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = shared.Autoguard.Requests["GET:/statistics/"];
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/statistics/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = shared.Autoguard.Responses["GET:/statistics/"];
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        return (request, response) => autoguard.api.route(endpoints, request, response, serverOptions);
    };
    exports.makeServer = makeServer;
});
define("build/api/api", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-server/index", "crypto", "fs", "build/server/auth", "build/server/auth", "build/api/handler", "build/database/indexer", "build/api/schema/api/server"], function (require, exports, autoguard, libcrypto, libfs, libauth, auth, handler, database, apiv2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.server = void 0;
    function getVersion() {
        try {
            let pack = libfs.readFileSync("./package.json", "utf8");
            let json = JSON.parse(pack);
            let parts = /^([0-9]+)[.]([0-9]+)[.]([0-9]+)$/.exec(String(json?.version));
            if (parts != null) {
                let major = Number.parseInt(parts[1], 10);
                let minor = Number.parseInt(parts[2], 10);
                let patch = Number.parseInt(parts[3], 10);
                return {
                    major,
                    minor,
                    patch
                };
            }
        }
        catch (error) { }
    }
    exports.server = apiv2.makeServer({
        "POST:/auth/": async (request) => {
            let headers = request.headers();
            let token = libauth.createToken(headers["x-circus-username"], headers["x-circus-password"]);
            return {
                headers: {
                    "x-circus-token": token
                }
            };
        },
        "POST:/users/": async (request) => {
            let payload = handler.createUser(await request.payload());
            return {
                payload
            };
        },
        "GET:/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let entities = options.cues
                ? handler.searchForCues(options.query, options.offset ?? 0, options.limit ?? 24, user_id)
                : handler.searchForEntities(options.query, user_id, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    entities
                }
            };
        },
        "GET:/actors/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let actors = handler.searchForActors(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    actors
                }
            };
        },
        "GET:/actors/<actor_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let actor = handler.lookupActor(options.actor_id, user_id);
            return {
                payload: {
                    actor
                }
            };
        },
        "GET:/actors/<actor_id>/movies/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let movies = handler.getMoviesFromActor(options.actor_id, user_id, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    movies
                }
            };
        },
        "GET:/actors/<actor_id>/shows/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let shows = handler.getShowsFromActor(options.actor_id, user_id, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    shows
                }
            };
        },
        "GET:/albums/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let albums = handler.searchForAlbums(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    albums
                }
            };
        },
        getNewAlbums: async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let albums = handler.getNewAlbums(user_id, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    albums
                }
            };
        },
        "GET:/albums/<album_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let album = handler.lookupAlbum(options.album_id, user_id);
            return {
                payload: {
                    album
                }
            };
        },
        "GET:/artists/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let artists = handler.searchForArtists(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    artists
                }
            };
        },
        "GET:/artists/<artist_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let artist = handler.lookupArtist(options.artist_id, user_id);
            let tracks = handler.getArtistTracks(options.artist_id, 0, 3, user_id);
            let appearances = handler.getArtistAppearances(options.artist_id, user_id);
            return {
                payload: {
                    artist,
                    tracks,
                    appearances
                }
            };
        },
        "GET:/discs/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let discs = handler.searchForDiscs(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    discs
                }
            };
        },
        "GET:/discs/<disc_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let disc = handler.lookupDisc(options.disc_id, user_id);
            let discs = handler.lookupAlbum(disc.album.album_id, user_id).discs;
            let index = discs.findIndex((other) => other.disc_id === disc.disc_id);
            let last = discs[index - 1];
            let next = discs[index + 1];
            return {
                payload: {
                    disc,
                    last,
                    next
                }
            };
        },
        "GET:/episodes/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let episodes = handler.searchForEpisodes(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    episodes
                }
            };
        },
        "GET:/episodes/<episode_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let episode = handler.lookupEpisode(options.episode_id, user_id);
            let episodes = handler.lookupSeason(episode.season.season_id, user_id).episodes;
            let index = episodes.findIndex((other) => other.episode_id === episode.episode_id);
            let last = episodes[index - 1];
            let next = episodes[index + 1];
            return {
                payload: {
                    episode,
                    last,
                    next
                }
            };
        },
        "GET:/genres/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let genres = handler.searchForGenres(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    genres
                }
            };
        },
        "GET:/genres/<genre_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let genre = handler.lookupGenre(options.genre_id, user_id);
            return {
                payload: {
                    genre
                }
            };
        },
        "GET:/genres/<genre_id>/movies/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let movies = handler.getMoviesFromGenre(options.genre_id, user_id, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    movies
                }
            };
        },
        "GET:/genres/<genre_id>/shows/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let shows = handler.getShowsFromGenre(options.genre_id, user_id, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    shows
                }
            };
        },
        "GET:/movies/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let movies = handler.searchForMovies(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    movies
                }
            };
        },
        getNewMovies: async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let movies = handler.getNewMovies(user_id, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    movies
                }
            };
        },
        "GET:/movies/<movie_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let movie = handler.lookupMovie(options.movie_id, user_id);
            return {
                payload: {
                    movie
                }
            };
        },
        "GET:/movies/<movie_id>/suggestions/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let movies = handler.getMovieSuggestions(options.movie_id, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    movies
                }
            };
        },
        "GET:/playlists/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let playlists = handler.searchForPlaylists(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    playlists
                }
            };
        },
        "GET:/playlists/<playlist_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let playlist = handler.lookupPlaylist(options.playlist_id, user_id);
            return {
                payload: {
                    playlist
                }
            };
        },
        "GET:/seasons/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let seasons = handler.searchForSeasons(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    seasons
                }
            };
        },
        "GET:/seasons/<season_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let season = handler.lookupSeason(options.season_id, user_id);
            let seasons = handler.lookupShow(season.show.show_id, user_id).seasons;
            let index = seasons.findIndex((other) => other.season_id === season.season_id);
            let last = seasons[index - 1];
            let next = seasons[index + 1];
            return {
                payload: {
                    season,
                    last,
                    next
                }
            };
        },
        "GET:/shows/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let shows = handler.searchForShows(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    shows
                }
            };
        },
        "GET:/shows/<show_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let show = handler.lookupShow(options.show_id, user_id);
            return {
                payload: {
                    show
                }
            };
        },
        "GET:/tracks/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let tracks = handler.searchForTracks(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    tracks
                }
            };
        },
        "GET:/tracks/<track_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let track = handler.lookupTrack(options.track_id, user_id);
            let tracks = handler.lookupDisc(track.disc.disc_id, user_id).tracks;
            let index = tracks.findIndex((other) => other.track_id === track.track_id);
            let last = tracks[index - 1];
            let next = tracks[index + 1];
            return {
                payload: {
                    track,
                    last,
                    next
                }
            };
        },
        "GET:/tracks/<track_id>/playlists/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let playlists = handler.getPlaylistAppearances(options.track_id, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    playlists
                }
            };
        },
        "GET:/users/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let users = handler.searchForUsers(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    users
                }
            };
        },
        "GET:/users/<user_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let user = handler.lookupUser(options.user_id || user_id, user_id);
            return {
                payload: {
                    user
                }
            };
        },
        "GET:/users/<user_id>/albums/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let albums = handler.getUserAlbums(options.user_id || user_id, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    albums
                }
            };
        },
        "GET:/users/<user_id>/playlists/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let playlists = handler.getUserPlaylists(options.user_id || user_id, user_id, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    playlists
                }
            };
        },
        "GET:/users/<user_id>/shows/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let shows = handler.getUserShows(options.user_id || user_id, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    shows
                }
            };
        },
        "GET:/years/<query>": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let years = handler.searchForYears(options.query, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    years
                }
            };
        },
        "GET:/years/<year_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let year = handler.lookupYear(options.year_id, user_id);
            return {
                payload: {
                    year
                }
            };
        },
        "GET:/years/<year_id>/albums/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let albums = handler.getAlbumsFromYear(options.year_id, user_id, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    albums
                }
            };
        },
        "GET:/years/<year_id>/movies/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let movies = handler.getMoviesFromYear(options.year_id, user_id, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    movies
                }
            };
        },
        "GET:/files/<file_id>/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let file = handler.lookupFile(options.file_id, user_id);
            let path = database.getPath(file).join("/");
            let range = autoguard.api.parseRangeHeader(request.headers().range, libfs.statSync(path).size);
            let stream = libfs.createReadStream(path, {
                start: range.offset,
                end: range.offset + range.length
            });
            stream.addListener("close", () => {
                if (range.offset + stream.bytesRead === range.size) {
                    handler.createStream({
                        stream_id: libcrypto.randomBytes(8).toString("hex"),
                        user_id: user_id,
                        file_id: options.file_id,
                        timestamp_ms: Date.now()
                    });
                }
            });
            return {
                status: range.status,
                headers: {
                    "Access-Control-Allow-Origin": "*",
                    "Accept-Ranges": "bytes",
                    "Cache-Control": "private,max-age=86400",
                    "Content-Length": `${range.length}`,
                    "Content-Range": range.length > 0 ? `bytes ${range.offset}-${range.offset + range.length - 1}/${range.size}` : `bytes */${range.size}`,
                    "Content-Type": file.mime
                },
                payload: stream
            };
        },
        "GET:/statistics/": async (request) => {
            let options = request.options();
            let user_id = auth.getUserId(options.token);
            let files = Array.from(database.files);
            let audio_files = Array.from(database.audio_files);
            let image_files = Array.from(database.image_files);
            let metadata_files = Array.from(database.metadata_files);
            let subtitle_files = Array.from(database.subtitle_files);
            let video_files = Array.from(database.video_files);
            let version = getVersion();
            return {
                payload: {
                    statistics: [
                        {
                            title: "Major version",
                            value: version?.major ?? 0
                        },
                        {
                            title: "Minor version",
                            value: version?.minor ?? 0
                        },
                        {
                            title: "Patch version",
                            value: version?.patch ?? 0
                        },
                        {
                            title: "Library Size",
                            value: files.reduce((sum, item) => sum + (item?.size ?? 0), 0),
                            unit: "BYTES"
                        },
                        {
                            title: "Audio Content",
                            value: audio_files.reduce((sum, item) => sum + item.duration_ms, 0),
                            unit: "MILLISECONDS"
                        },
                        {
                            title: "Video Content",
                            value: video_files.reduce((sum, item) => sum + item.duration_ms, 0),
                            unit: "MILLISECONDS"
                        },
                        {
                            title: "Files",
                            value: files.length
                        },
                        {
                            title: "Audio Files",
                            value: audio_files.length
                        },
                        {
                            title: "Image Files",
                            value: image_files.length
                        },
                        {
                            title: "Metadata Files",
                            value: metadata_files.length
                        },
                        {
                            title: "Subtitle Files",
                            value: subtitle_files.length
                        },
                        {
                            title: "Video Files",
                            value: video_files.length
                        }
                    ]
                }
            };
        }
    }, { urlPrefix: "/api" });
});
define("build/utils", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNextEpisode = exports.formatTimestamp = exports.join = void 0;
    function join(...parameters) {
        return parameters.map((parameter) => {
            return String(parameter);
        }).join("");
    }
    exports.join = join;
    function formatTimestamp(ms) {
        let s = Math.floor(ms / 1000);
        ms -= (s * 1000);
        let m = Math.floor(s / 60);
        s -= (m * 60);
        let h = Math.floor(m / 60);
        m -= (h * 60);
        let fh = join("00", h).slice(-2);
        let fm = join("00", m).slice(-2);
        let fs = join("00", s).slice(-2);
        let fms = join("000", ms).slice(-3);
        return join(fh, ":", fm, ":", fs, ".", fms);
    }
    exports.formatTimestamp = formatTimestamp;
    function getNextEpisode(show) {
        let indices;
        show.seasons.forEach((season, seasonIndex) => {
            season.episodes.forEach((episode, episodeIndex) => {
                if (is.present(episode.last_stream_date)) {
                    if (is.present(indices)) {
                        if (episode.last_stream_date < (show.seasons[indices.seasonIndex].episodes[indices.episodeIndex].last_stream_date ?? 0)) {
                            return;
                        }
                    }
                    indices = {
                        seasonIndex,
                        episodeIndex
                    };
                }
            });
        });
        if (is.present(indices)) {
            indices.episodeIndex += 1;
            if (indices.episodeIndex === show.seasons[indices.seasonIndex].episodes.length) {
                indices.episodeIndex = 0;
                indices.seasonIndex += 1;
                if (indices.seasonIndex === show.seasons.length) {
                    indices.seasonIndex = 0;
                }
            }
        }
        else {
            if (show.seasons.length > 0 && show.seasons[0].episodes.length > 0) {
                indices = {
                    seasonIndex: 0,
                    episodeIndex: 0
                };
            }
        }
        return indices;
    }
    exports.getNextEpisode = getNextEpisode;
});
define("build/server/ffprobe/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.FormatResult = exports.Format = exports.StreamsResult = exports.Stream = exports.VideoStream = exports.SubtitleStream = exports.ImageStream = exports.AudioStream = exports.StreamCommon = exports.FramesResult = exports.VideoFrame = void 0;
    exports.VideoFrame = autoguard.guards.Object.of({
        "pkt_pts_time": autoguard.guards.String
    });
    exports.FramesResult = autoguard.guards.Object.of({
        "frames": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.VideoFrame))
    });
    exports.StreamCommon = autoguard.guards.Object.of({
        "codec_name": autoguard.guards.String
    });
    exports.AudioStream = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.StreamCommon), autoguard.guards.Object.of({
        "codec_type": autoguard.guards.StringLiteral.of("audio"),
        "start_time": autoguard.guards.String,
        "duration": autoguard.guards.String
    }));
    exports.ImageStream = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.StreamCommon), autoguard.guards.Object.of({
        "codec_type": autoguard.guards.StringLiteral.of("video"),
        "codec_time_base": autoguard.guards.StringLiteral.of("0/1"),
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    }));
    exports.SubtitleStream = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.StreamCommon), autoguard.guards.Object.of({
        "codec_type": autoguard.guards.StringLiteral.of("subtitle")
    }));
    exports.VideoStream = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.StreamCommon), autoguard.guards.Object.of({
        "codec_type": autoguard.guards.StringLiteral.of("video"),
        "start_time": autoguard.guards.String,
        "duration": autoguard.guards.String,
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    }));
    exports.Stream = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.AudioStream), autoguard.guards.Reference.of(() => exports.ImageStream), autoguard.guards.Reference.of(() => exports.SubtitleStream), autoguard.guards.Reference.of(() => exports.VideoStream));
    exports.StreamsResult = autoguard.guards.Object.of({
        "streams": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Stream))
    });
    exports.Format = autoguard.guards.Object.of({
        "format_name": autoguard.guards.String,
        "tags": autoguard.guards.Union.of(autoguard.guards.Object.of({
            "title": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "date": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "comment": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "show": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "episode_id": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "episode_sort": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "season_number": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "track": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "artist": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "album_artist": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "album": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "disc": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
        }), autoguard.guards.Undefined)
    });
    exports.FormatResult = autoguard.guards.Object.of({
        "format": autoguard.guards.Reference.of(() => exports.Format)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "VideoFrame": autoguard.guards.Reference.of(() => exports.VideoFrame),
            "FramesResult": autoguard.guards.Reference.of(() => exports.FramesResult),
            "StreamCommon": autoguard.guards.Reference.of(() => exports.StreamCommon),
            "AudioStream": autoguard.guards.Reference.of(() => exports.AudioStream),
            "ImageStream": autoguard.guards.Reference.of(() => exports.ImageStream),
            "SubtitleStream": autoguard.guards.Reference.of(() => exports.SubtitleStream),
            "VideoStream": autoguard.guards.Reference.of(() => exports.VideoStream),
            "Stream": autoguard.guards.Reference.of(() => exports.Stream),
            "StreamsResult": autoguard.guards.Reference.of(() => exports.StreamsResult),
            "Format": autoguard.guards.Reference.of(() => exports.Format),
            "FormatResult": autoguard.guards.Reference.of(() => exports.FormatResult)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/server/keyframes", ["require", "exports", "child_process", "build/server/ffprobe/index"], function (require, exports, libcp, libffprobe) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getKeyframeSegments = exports.getKeyframeOffsets = exports.getStreams = exports.combineOffsets = exports.makeSegments = void 0;
    function makeSegments(offsets_ms) {
        let segments = new Array();
        for (let i = 0; i + 1 < offsets_ms.length; i++) {
            segments.push({
                offset_ms: offsets_ms[i],
                duration_ms: offsets_ms[i + 1] - offsets_ms[i]
            });
        }
        return segments;
    }
    exports.makeSegments = makeSegments;
    function combineOffsets(offsets_ms, target_duration_ms) {
        let last_offset_ms = 0 - Infinity;
        let combined_offsets_ms = new Array();
        for (let i = 1; i < offsets_ms.length; i++) {
            if (offsets_ms[i] - last_offset_ms > target_duration_ms) {
                last_offset_ms = offsets_ms[i - 1];
                combined_offsets_ms.push(last_offset_ms);
            }
        }
        return combined_offsets_ms;
    }
    exports.combineOffsets = combineOffsets;
    async function getStreams(paths) {
        return new Promise((resolve, reject) => {
            let ffprobe = libcp.spawn("ffprobe", [
                "-hide_banner",
                "-i", paths.join("/"),
                "-show_streams",
                "-show_entries", "stream=start_time,duration",
                "-of", "json"
            ]);
            let chunks = new Array();
            ffprobe.stdout.on("data", (chunk) => {
                chunks.push(chunk);
            });
            ffprobe.on("exit", () => {
                let string = Buffer.concat(chunks).toString();
                let json = libffprobe.StreamsResult.as(JSON.parse(string));
                let streams = json.streams.filter((stream) => libffprobe.VideoStream.is(stream)).map((stream) => {
                    let offset_ms = Math.round(Number.parseFloat(stream.start_time) * 1000);
                    let duration_ms = Math.round(Number.parseFloat(stream.duration) * 1000);
                    return {
                        offset_ms,
                        duration_ms
                    };
                });
                resolve(streams);
            });
        });
    }
    exports.getStreams = getStreams;
    async function getKeyframeOffsets(paths, streamIndex) {
        return new Promise((resolve, reject) => {
            let ffprobe = libcp.spawn("ffprobe", [
                "-hide_banner",
                "-i", paths.join("/"),
                "-select_streams", `${streamIndex}`,
                "-skip_frame", "nokey",
                "-show_frames",
                "-show_entries", "frame=pkt_pts_time",
                "-of", "json"
            ]);
            let chunks = new Array();
            ffprobe.stdout.on("data", (chunk) => {
                chunks.push(chunk);
            });
            ffprobe.on("error", (error) => {
                reject(error);
            });
            ffprobe.on("exit", () => {
                let string = Buffer.concat(chunks).toString();
                try {
                    let json = libffprobe.FramesResult.as(JSON.parse(string));
                    let frames = json.frames.map((frame) => {
                        return Math.round(Number.parseFloat(frame.pkt_pts_time) * 1000);
                    });
                    resolve(frames);
                }
                catch (error) {
                    //console.log(`Keyframes failed for ${paths.join("/")}!`);
                    reject(error);
                }
            });
        });
    }
    exports.getKeyframeOffsets = getKeyframeOffsets;
    async function getKeyframeSegments(paths, streamIndex, targetDurationMs) {
        let streams = await getStreams(paths);
        let keyframeOffsets = await getKeyframeOffsets(paths, streamIndex);
        let stream = streams[streamIndex];
        let combinedOffsets = combineOffsets([...keyframeOffsets, stream.duration_ms], targetDurationMs);
        let segments = makeSegments([...combinedOffsets, stream.duration_ms]);
        return segments;
    }
    exports.getKeyframeSegments = getKeyframeSegments;
});
define("build/server/subsearch", ["require", "exports", "fs", "child_process", "crypto", "build/database/indexer", "build/is", "build/utils", "build/server/keyframes"], function (require, exports, libfs, libcp, libcrypto, indexer, is, utils, keyframes) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateMeme = exports.generateStill = void 0;
    function getMediaFile(subtitle) {
        let video_files = indexer.getVideoFilesFromSubtitleFile.lookup(subtitle.file_id).collect();
        return indexer.files.lookup(video_files[0].video_file_id);
    }
    function createWorkingDirectory(cb) {
        let id = libcrypto.randomBytes(8).toString("hex");
        let wd = [".", "private", "jobs", id];
        libfs.mkdirSync(wd.join("/"), { recursive: true });
        return cb(wd, id);
    }
    function renameFile(source, target) {
        libfs.mkdirSync(target.slice(0, -1).join("/"), { recursive: true });
        libfs.renameSync(source.join("/"), target.join("/"));
    }
    function deleteTree(root) {
        let stats = libfs.statSync(root);
        if (stats.isDirectory()) {
            let nodes = libfs.readdirSync(root).map((node) => {
                return root + "/" + node;
            });
            nodes.forEach(deleteTree);
            libfs.rmdirSync(root);
        }
        else if (stats.isFile()) {
            libfs.unlinkSync(root);
        }
    }
    async function generateStill(target, file) {
        let path = indexer.getPath(file);
        let offsets = await keyframes.getKeyframeOffsets(path, 0);
        let offset = offsets[Math.floor(offsets.length / 2)];
        return new Promise((resolve, reject) => {
            createWorkingDirectory((wd, id) => {
                let still = [...wd, "still.jpeg"];
                let cp = libcp.spawn("ffmpeg", [
                    "-ss", utils.formatTimestamp(offset),
                    "-i", path.join("/"),
                    "-q:v", "1",
                    "-frames:v", "1",
                    "-f", "singlejpeg",
                    "-fflags", "+bitexact",
                    "-map_metadata", "-1",
                    still.join("/"),
                    "-y"
                ]);
                cp.on("error", () => {
                    deleteTree(wd.join("/"));
                    return reject();
                });
                cp.on("exit", () => {
                    renameFile(still, target);
                    deleteTree(wd.join("/"));
                    return resolve();
                });
            });
        });
    }
    exports.generateStill = generateStill;
    function generateMeme(target, cue, cb) {
        let subtitle = indexer.subtitles.lookup(cue.subtitle_id);
        let file_subtitle = indexer.files.lookup(subtitle.file_id);
        const file_media = getMediaFile(subtitle);
        if (file_media == null) {
            return cb();
        }
        else {
            createWorkingDirectory((wd, id) => {
                let subtitle = [...wd, "subtitle.vtt"];
                let palette = [...wd, "palette.png"];
                let meme = [...wd, "meme.gif"];
                let cp = libcp.spawn("ffmpeg", [
                    "-ss", utils.formatTimestamp(cue.start_ms),
                    "-t", utils.formatTimestamp(Math.min(cue.duration_ms, 5000)),
                    "-i", indexer.getPath(file_subtitle).join("/"),
                    subtitle.join("/"),
                    "-y"
                ]);
                cp.on("error", () => {
                    console.log("ffmpeg command failed!");
                    deleteTree(wd.join("/"));
                    return cb();
                });
                cp.on("exit", () => {
                    let cp = libcp.spawn("ffmpeg", [
                        "-ss", utils.formatTimestamp(cue.start_ms),
                        "-t", utils.formatTimestamp(Math.min(cue.duration_ms, 5000)),
                        "-i", indexer.getPath(file_media).join("/"),
                        "-vf", "fps=15,scale=w=384:h=216:force_original_aspect_ratio=decrease,pad=384:216:-1:-1,subtitles=" + subtitle.join("/") + ":force_style='Bold=1,Fontsize=24,Outline=2',palettegen",
                        palette.join("/"),
                        "-y"
                    ]);
                    cp.on("exit", () => {
                        let cp = libcp.spawn("ffmpeg", [
                            "-ss", utils.formatTimestamp(cue.start_ms),
                            "-t", utils.formatTimestamp(Math.min(cue.duration_ms, 5000)),
                            "-i", indexer.getPath(file_media).join("/"),
                            "-i", palette.join("/"),
                            "-filter_complex", "fps=15,scale=w=384:h=216:force_original_aspect_ratio=decrease,pad=384:216:-1:-1,subtitles=" + subtitle.join("/") + ":force_style='Bold=1,Fontsize=24,Outline=2'[x];[x][1:v]paletteuse",
                            "-map_metadata", "-1",
                            meme.join("/"),
                            "-y"
                        ]);
                        cp.on("exit", () => {
                            renameFile(meme, target);
                            deleteTree(wd.join("/"));
                            return cb();
                        });
                    });
                });
            });
        }
    }
    exports.generateMeme = generateMeme;
    const queue = [];
    async function processQueue() {
        let job = queue.pop();
        if (is.absent(job)) {
            return;
        }
        try {
            await generateStill(job.target, job.file);
        }
        catch (error) { }
        setTimeout(processQueue, 10 * 1000);
    }
    for (let episode of indexer.video_files) {
        let target = [".", "private", "stills", episode.file_id];
        if (!libfs.existsSync(target.join("/"))) {
            let file = indexer.files.lookup(episode.file_id);
            queue.push({ target, file });
        }
    }
    setTimeout(processQueue);
});
define("build/observers/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayObservable = exports.computed = exports.ObservableClass = void 0;
    class ObservableClass {
        state;
        observers;
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer, alwaysNotify) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push({
                observer: (state) => {
                    observable.updateState(observer(state));
                },
                alwaysNotify
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return this.state;
        }
        updateState(state) {
            let didChange = state !== this.state;
            this.state = state;
            for (let observer of this.observers) {
                if (didChange || observer.alwaysNotify) {
                    observer.observer(this.state);
                }
            }
        }
    }
    exports.ObservableClass = ObservableClass;
    function computed(computer, ...observables) {
        let observable = new ObservableClass(computer(...observables.map((observable) => observable.getState())));
        let updater = () => {
            observable.updateState(computer(...observables.map((observable) => observable.getState())));
        };
        for (let observable of observables) {
            observable.addObserver(updater);
        }
        return observable;
    }
    exports.computed = computed;
    class ArrayObservable {
        state;
        observers;
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer) {
            this.observers.push(observer);
            for (let value of this.state) {
                observer.onappend?.(value);
            }
        }
        compute(observer) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push({
                onappend: (state) => {
                    observable.updateState(observer(this.state));
                },
                onsplice: (state, index) => {
                    observable.updateState(observer(this.state));
                }
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return this.state;
        }
        append(state) {
            this.state.push(state);
            for (let observer of this.observers) {
                observer.onappend?.(state);
            }
        }
        splice(index) {
            if (index < 0 || index >= this.state.length) {
                throw `Expected an index of at most ${this.state.length}, got ${index}!`;
            }
            let state = this.state[index];
            this.state.splice(index, 1);
            for (let observer of this.observers) {
                observer.onsplice?.(state, index);
            }
        }
        update(state) {
            for (let i = this.state.length - 1; i >= 0; i--) {
                this.splice(i);
            }
            for (let v of state) {
                this.append(v);
            }
        }
    }
    exports.ArrayObservable = ArrayObservable;
});
define("build/player/schema/objects/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2, objects_3, objects_4, objects_5, objects_6, objects_7, objects_8, objects_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Session = exports.Device = exports.ContextItem = exports.Context = exports.ContextEpisode = exports.ContextSeason = exports.ContextShow = exports.ContextMovie = exports.ContextPlaylist = exports.ContextTrack = exports.ContextDisc = exports.ContextArtist = exports.ContextAlbum = void 0;
    exports.ContextAlbum = autoguard.guards.Reference.of(() => objects_1.Album);
    exports.ContextArtist = autoguard.guards.Reference.of(() => objects_2.Artist);
    exports.ContextDisc = autoguard.guards.Reference.of(() => objects_3.Disc);
    exports.ContextTrack = autoguard.guards.Reference.of(() => objects_9.Track);
    exports.ContextPlaylist = autoguard.guards.Reference.of(() => objects_6.Playlist);
    exports.ContextMovie = autoguard.guards.Reference.of(() => objects_5.Movie);
    exports.ContextShow = autoguard.guards.Reference.of(() => objects_8.Show);
    exports.ContextSeason = autoguard.guards.Reference.of(() => objects_7.Season);
    exports.ContextEpisode = autoguard.guards.Reference.of(() => objects_4.Episode);
    exports.Context = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ContextAlbum), autoguard.guards.Reference.of(() => exports.ContextArtist), autoguard.guards.Reference.of(() => exports.ContextDisc), autoguard.guards.Reference.of(() => exports.ContextTrack), autoguard.guards.Reference.of(() => exports.ContextPlaylist), autoguard.guards.Reference.of(() => exports.ContextMovie), autoguard.guards.Reference.of(() => exports.ContextShow), autoguard.guards.Reference.of(() => exports.ContextSeason), autoguard.guards.Reference.of(() => exports.ContextEpisode));
    exports.ContextItem = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ContextTrack), autoguard.guards.Reference.of(() => exports.ContextMovie), autoguard.guards.Reference.of(() => exports.ContextEpisode));
    exports.Device = autoguard.guards.Object.of({
        "id": autoguard.guards.String,
        "protocol": autoguard.guards.String,
        "name": autoguard.guards.String,
        "type": autoguard.guards.String
    });
    exports.Session = autoguard.guards.Object.of({
        "context": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Context), autoguard.guards.Undefined),
        "device": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Device), autoguard.guards.Undefined),
        "index": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "playback": autoguard.guards.Boolean,
        "progress": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ContextAlbum": autoguard.guards.Reference.of(() => exports.ContextAlbum),
            "ContextArtist": autoguard.guards.Reference.of(() => exports.ContextArtist),
            "ContextDisc": autoguard.guards.Reference.of(() => exports.ContextDisc),
            "ContextTrack": autoguard.guards.Reference.of(() => exports.ContextTrack),
            "ContextPlaylist": autoguard.guards.Reference.of(() => exports.ContextPlaylist),
            "ContextMovie": autoguard.guards.Reference.of(() => exports.ContextMovie),
            "ContextShow": autoguard.guards.Reference.of(() => exports.ContextShow),
            "ContextSeason": autoguard.guards.Reference.of(() => exports.ContextSeason),
            "ContextEpisode": autoguard.guards.Reference.of(() => exports.ContextEpisode),
            "Context": autoguard.guards.Reference.of(() => exports.Context),
            "ContextItem": autoguard.guards.Reference.of(() => exports.ContextItem),
            "Device": autoguard.guards.Reference.of(() => exports.Device),
            "Session": autoguard.guards.Reference.of(() => exports.Session)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/player/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/player/schema/objects/index", "build/player/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.SetToken = exports.SetProgress = exports.SetPlayback = exports.SetLocalDevice = exports.SetIndex = exports.SetDevices = exports.SetDevice = exports.SetContext = void 0;
    exports.SetContext = autoguard.guards.Object.of({
        "context": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_1.Context), autoguard.guards.Undefined)
    });
    exports.SetDevice = autoguard.guards.Object.of({
        "device": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => objects_2.Device), autoguard.guards.Undefined)
    });
    exports.SetDevices = autoguard.guards.Object.of({
        "devices": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Device))
    });
    exports.SetIndex = autoguard.guards.Object.of({
        "index": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    });
    exports.SetLocalDevice = autoguard.guards.Object.of({
        "device": autoguard.guards.Reference.of(() => objects_2.Device)
    });
    exports.SetPlayback = autoguard.guards.Object.of({
        "playback": autoguard.guards.Boolean
    });
    exports.SetProgress = autoguard.guards.Object.of({
        "progress": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    });
    exports.SetToken = autoguard.guards.Object.of({
        "token": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "SetContext": autoguard.guards.Reference.of(() => exports.SetContext),
            "SetDevice": autoguard.guards.Reference.of(() => exports.SetDevice),
            "SetDevices": autoguard.guards.Reference.of(() => exports.SetDevices),
            "SetIndex": autoguard.guards.Reference.of(() => exports.SetIndex),
            "SetLocalDevice": autoguard.guards.Reference.of(() => exports.SetLocalDevice),
            "SetPlayback": autoguard.guards.Reference.of(() => exports.SetPlayback),
            "SetProgress": autoguard.guards.Reference.of(() => exports.SetProgress),
            "SetToken": autoguard.guards.Reference.of(() => exports.SetToken)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/player/schema/index", ["require", "exports", "build/player/schema/messages/index", "build/player/schema/objects/index"], function (require, exports, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    exports.messages = messages;
    exports.objects = objects;
});
define("node_modules/@joelek/ts-sockets/dist/lib/shared", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusCode = exports.ReadyState = void 0;
    var ReadyState;
    (function (ReadyState) {
        ReadyState[ReadyState["CONNECTING"] = 0] = "CONNECTING";
        ReadyState[ReadyState["OPEN"] = 1] = "OPEN";
        ReadyState[ReadyState["CLOSING"] = 2] = "CLOSING";
        ReadyState[ReadyState["CLOSED"] = 3] = "CLOSED";
    })(ReadyState = exports.ReadyState || (exports.ReadyState = {}));
    ;
    var StatusCode;
    (function (StatusCode) {
        StatusCode[StatusCode["NORMAL"] = 1000] = "NORMAL";
        StatusCode[StatusCode["GOING_AWAY"] = 1001] = "GOING_AWAY";
        StatusCode[StatusCode["PROTOCOL_ERROR"] = 1002] = "PROTOCOL_ERROR";
        StatusCode[StatusCode["DATA_TYPE_NOT_ACCEPTED"] = 1003] = "DATA_TYPE_NOT_ACCEPTED";
        StatusCode[StatusCode["RESERVED_1004"] = 1004] = "RESERVED_1004";
        StatusCode[StatusCode["RESERVED_1005"] = 1005] = "RESERVED_1005";
        StatusCode[StatusCode["RESERVED_1006"] = 1006] = "RESERVED_1006";
        StatusCode[StatusCode["BAD_DATA_TYPE"] = 1007] = "BAD_DATA_TYPE";
        StatusCode[StatusCode["POLICY_VIOLATION"] = 1008] = "POLICY_VIOLATION";
        StatusCode[StatusCode["MESSAGE_TOO_BIG"] = 1009] = "MESSAGE_TOO_BIG";
        StatusCode[StatusCode["CLIENT_EXPECTED_EXTENSION"] = 1010] = "CLIENT_EXPECTED_EXTENSION";
        StatusCode[StatusCode["SERVER_UNEXPECTED_CONDITION"] = 1011] = "SERVER_UNEXPECTED_CONDITION";
        StatusCode[StatusCode["RESERVED_1015"] = 1015] = "RESERVED_1015";
    })(StatusCode = exports.StatusCode || (exports.StatusCode = {}));
    ;
    ;
});
define("build/typesockets/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Envelope = void 0;
    exports.Envelope = autoguard.guards.Object.of({
        "type": autoguard.guards.String,
        "data": autoguard.guards.Any,
        "id": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Envelope": autoguard.guards.Reference.of(() => exports.Envelope)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/typesockets/shared", ["require", "exports", "build/typesockets/schema/index", "build/is"], function (require, exports, schema, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Serializer = void 0;
    class Serializer {
        guards;
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let envelope = schema.Envelope.as(JSON.parse(string));
            let id = envelope.id;
            let type = envelope.type;
            let data = envelope.data;
            let guard = this.guards[type];
            if (is.absent(guard)) {
                throw `Unknown message type "${type}"!`;
            }
            cb(type, guard.as(data), id);
        }
        serialize(type, data, id) {
            return JSON.stringify({
                type,
                data,
                id
            });
        }
    }
    exports.Serializer = Serializer;
    ;
});
define("build/typesockets/client", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/index", "node_modules/@joelek/ts-sockets/dist/lib/shared", "build/typesockets/shared", "build/is"], function (require, exports, stdlib, sockets, shared, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketClient = void 0;
    class TypeSocketClient {
        nextConnectionAttemptDelayFactor;
        nextConnectionAttemptDelay;
        router;
        serializer;
        url;
        factory;
        socket;
        requests;
        makeId() {
            let string = "";
            for (let i = 0; i < 32; i++) {
                let number = Math.floor(Math.random() * 16);
                string += number.toString(16);
            }
            return string;
        }
        makeSocket() {
            let socket = this.factory(this.url);
            socket.addEventListener("close", this.onClose.bind(this));
            socket.addEventListener("error", this.onError.bind(this));
            socket.addEventListener("message", this.onMessage.bind(this));
            socket.addEventListener("open", this.onOpen.bind(this));
            return socket;
        }
        onClose(event) {
            this.router.route("sys", "disconnect", {});
        }
        onError(event) {
            setTimeout(() => {
                this.socket = this.makeSocket();
            }, this.nextConnectionAttemptDelay);
            this.nextConnectionAttemptDelay = Math.round(this.nextConnectionAttemptDelay * this.nextConnectionAttemptDelayFactor);
        }
        onMessage(event) {
            try {
                this.serializer.deserialize(event.data, (type, data, id) => {
                    this.router.route("sys", "message", {
                        type,
                        data
                    });
                    if (is.present(id)) {
                        let callback = this.requests.get(id);
                        if (is.present(callback)) {
                            this.requests.delete(id);
                            callback(type, data);
                        }
                    }
                    this.router.route("app", type, data);
                });
            }
            catch (error) {
                this.socket.close();
            }
        }
        onOpen(event) {
            this.nextConnectionAttemptDelay = 2000;
            this.router.route("sys", "connect", {});
        }
        queue(payload) {
            if (this.socket.readyState === sockets.ReadyState.OPEN) {
                this.socket.send(payload);
            }
            else {
                let onopen = () => {
                    this.socket.removeEventListener("open", onopen);
                    this.socket.send(payload);
                };
                this.socket.addEventListener("open", onopen);
            }
        }
        constructor(url, factory, guards) {
            this.nextConnectionAttemptDelayFactor = 2.0 + Math.random();
            this.nextConnectionAttemptDelay = 2000;
            this.router = new stdlib.routing.NamespacedMessageRouter();
            this.serializer = new shared.Serializer(guards);
            this.url = url;
            this.factory = factory;
            this.socket = this.makeSocket();
            this.requests = new Map();
        }
        addEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        close() {
            this.socket.close();
        }
        reconnect() {
            if (this.socket.readyState === sockets.ReadyState.CLOSED) {
                this.socket = this.makeSocket();
            }
        }
        removeEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        request(type, response_type, data) {
            return new Promise((resolve, reject) => {
                let id = this.makeId();
                let payload = this.serializer.serialize(type, data, id);
                this.requests.set(id, (type, data) => {
                    if (type !== response_type) {
                        reject(`Received response with type "${type}" when expecting "${response_type}"!`);
                    }
                    else {
                        resolve(data);
                    }
                });
                this.queue(payload);
            });
        }
        send(type, data) {
            let payload = this.serializer.serialize(type, data);
            this.queue(payload);
        }
    }
    exports.TypeSocketClient = TypeSocketClient;
    ;
});
define("build/player/client", ["require", "exports", "build/is", "build/observers/index", "build/player/schema/index", "build/typesockets/client"], function (require, exports, is, observers, schema, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextClient = void 0;
    class ContextClient {
        tsc;
        estimatedProgress = new observers.ObservableClass(undefined);
        estimatedProgressTimestamp = new observers.ObservableClass(undefined);
        token = new observers.ObservableClass(undefined);
        localDevice = new observers.ObservableClass(undefined);
        devices = new observers.ArrayObservable(new Array());
        device = new observers.ObservableClass(undefined);
        isDeviceLocal = new observers.ObservableClass(false);
        isDeviceRemote = new observers.ObservableClass(false);
        context = new observers.ObservableClass(undefined);
        contextPath = new observers.ObservableClass(undefined);
        flattenedContext = new observers.ObservableClass(undefined);
        lastIndex = new observers.ObservableClass(undefined);
        lastEntry = new observers.ObservableClass(undefined);
        lastLocalEntry = new observers.ObservableClass(undefined);
        currentIndex = new observers.ObservableClass(undefined);
        currentEntry = new observers.ObservableClass(undefined);
        currentLocalEntry = new observers.ObservableClass(undefined);
        nextIndex = new observers.ObservableClass(undefined);
        nextEntry = new observers.ObservableClass(undefined);
        nextLocalEntry = new observers.ObservableClass(undefined);
        playback = new observers.ObservableClass(false);
        progress = new observers.ObservableClass(undefined);
        localPlayback = new observers.ObservableClass(false);
        canPlayLast = new observers.ObservableClass(false);
        canPlayCurrent = new observers.ObservableClass(false);
        canPlayNext = new observers.ObservableClass(false);
        isCurrentEntryVideo = new observers.ObservableClass(false);
        isOnline = new observers.ObservableClass(false);
        sendPlay(context, index) {
            this.isCurrentEntryVideo.updateState(false);
            this.tsc.send("SetContext", {
                context
            });
            this.tsc.send("SetIndex", {
                index
            });
            this.tsc.send("SetPlayback", {
                playback: true
            });
        }
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.tsc = new typesockets.TypeSocketClient(url, factory, schema.messages.Autoguard.Guards);
            this.tsc.addEventListener("sys", "connect", () => {
                this.isOnline.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.isOnline.updateState(false);
            });
            this.context.addObserver((context) => {
                if (is.present(context)) {
                    if (schema.objects.ContextAlbum.is(context)) {
                        let files = [];
                        let album = context;
                        for (let disc of album.discs) {
                            files.push(...disc.tracks);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextArtist.is(context)) {
                        let files = [];
                        let artist = context;
                        for (let album of artist.albums) {
                            for (let disc of album.discs) {
                                files.push(...disc.tracks);
                            }
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextEpisode.is(context)) {
                        let files = [];
                        let episode = context;
                        files.push(episode);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextMovie.is(context)) {
                        let files = [];
                        let movie = context;
                        files.push(movie);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextPlaylist.is(context)) {
                        let files = [];
                        let playlist = context;
                        for (let item of playlist.items) {
                            files.push(item.track);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextSeason.is(context)) {
                        let files = [];
                        let season = context;
                        files.push(...season.episodes);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextShow.is(context)) {
                        let files = [];
                        let show = context;
                        for (let season of show.seasons) {
                            files.push(...season.episodes);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextTrack.is(context)) {
                        let files = [];
                        let track = context;
                        files.push(track);
                        this.flattenedContext.updateState(files);
                    }
                    else {
                        throw `Expected code to be unreachable!`;
                    }
                }
            });
            {
                let computer = () => {
                    let context = this.context.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(context) && is.present(currentIndex)) {
                        if (schema.objects.ContextAlbum.is(context)) {
                            let discIndex = 0;
                            let trackIndex = currentIndex;
                            let album = context;
                            let discs = album.discs;
                            for (let d = 0; d < discs.length; d++) {
                                let length = discs[d].tracks.length;
                                if (trackIndex >= length) {
                                    discIndex += 1;
                                    trackIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.album_id,
                                context.discs[discIndex]?.disc_id,
                                context.discs[discIndex]?.tracks[trackIndex]?.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextArtist.is(context)) {
                            let albumIndex = 0;
                            let discIndex = 0;
                            let trackIndex = currentIndex;
                            let artist = context;
                            let albums = artist.albums;
                            outer: for (let a = 0; a < albums.length; a++) {
                                let discs = albums[a].discs;
                                for (let d = 0; d < discs.length; d++) {
                                    let length = discs[d].tracks.length;
                                    if (trackIndex >= length) {
                                        discIndex += 1;
                                        trackIndex -= length;
                                    }
                                    else {
                                        break outer;
                                    }
                                }
                                albumIndex += 1;
                                discIndex = 0;
                            }
                            return this.contextPath.updateState([
                                context.artist_id,
                                context.albums[albumIndex]?.album_id,
                                context.albums[albumIndex]?.discs[discIndex]?.disc_id,
                                context.albums[albumIndex]?.discs[discIndex]?.tracks[trackIndex]?.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextEpisode.is(context)) {
                            return this.contextPath.updateState([
                                context.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextMovie.is(context)) {
                            return this.contextPath.updateState([
                                context.movie_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextPlaylist.is(context)) {
                            let itemIndex = currentIndex;
                            return this.contextPath.updateState([
                                context.playlist_id,
                                context.items[itemIndex]?.track.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextShow.is(context)) {
                            let seasonIndex = 0;
                            let episodeIndex = currentIndex;
                            let show = context;
                            let seasons = show.seasons;
                            for (let d = 0; d < seasons.length; d++) {
                                let length = seasons[d].episodes.length;
                                if (episodeIndex >= length) {
                                    seasonIndex += 1;
                                    episodeIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.show_id,
                                context.seasons[seasonIndex]?.season_id,
                                context.seasons[seasonIndex]?.episodes[episodeIndex]?.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextSeason.is(context)) {
                            let episodeIndex = currentIndex;
                            return this.contextPath.updateState([
                                context.season_id,
                                context.episodes[episodeIndex]?.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextTrack.is(context)) {
                            return this.contextPath.updateState([
                                context.track_id
                            ].filter(is.present));
                        }
                        else {
                            throw `Expected code to be unreachable!`;
                        }
                    }
                    this.contextPath.updateState(undefined);
                };
                this.context.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            this.lastEntry.addObserver((lastEntry) => {
                this.canPlayLast.updateState(is.present(lastEntry));
            });
            this.currentEntry.addObserver((currentEntry) => {
                this.canPlayCurrent.updateState(is.present(currentEntry));
            });
            this.nextEntry.addObserver((nextEntry) => {
                this.canPlayNext.updateState(is.present(nextEntry));
            });
            this.progress.addObserver((progress) => {
                this.estimatedProgress.updateState(progress);
                this.estimatedProgressTimestamp.updateState(Date.now());
            }, true);
            this.playback.addObserver((playback) => {
                let estimatedProgress = this.estimatedProgress.getState();
                let estimatedProgressTimestamp = this.estimatedProgressTimestamp.getState();
                let now = Date.now();
                if (!playback) {
                    if (is.present(estimatedProgress) && is.present(estimatedProgressTimestamp)) {
                        this.estimatedProgress.updateState(estimatedProgress + (now - estimatedProgressTimestamp) / 1000);
                    }
                }
                this.estimatedProgressTimestamp.updateState(now);
            });
            this.progress.addObserver((progress) => {
                console.log(`Progress: ${progress}`);
            });
            this.estimatedProgress.addObserver((estimatedProgress) => {
                console.log(`Estimated progress: ${estimatedProgress}`);
            });
            {
                let computer = () => {
                    let playback = this.playback.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.localPlayback.updateState(isDeviceLocal && playback);
                };
                this.playback.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let lastEntry = this.lastEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.lastLocalEntry.updateState(isDeviceLocal ? lastEntry : undefined);
                };
                this.lastEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let currentEntry = this.currentEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.currentLocalEntry.updateState(isDeviceLocal ? currentEntry : undefined);
                };
                this.currentEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let nextEntry = this.nextEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.nextLocalEntry.updateState(isDeviceLocal ? nextEntry : undefined);
                };
                this.nextEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id === device.id) {
                            return this.isDeviceLocal.updateState(true);
                        }
                    }
                    return this.isDeviceLocal.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id !== device.id) {
                            return this.isDeviceRemote.updateState(true);
                        }
                    }
                    return this.isDeviceRemote.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(currentIndex)) {
                        let index = currentIndex - 1;
                        if (index >= 0 && index < flattenedContext.length) {
                            return this.lastIndex.updateState(index);
                        }
                    }
                    return this.lastIndex.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(currentIndex)) {
                        let index = currentIndex + 1;
                        if (index >= 0 && index < flattenedContext.length) {
                            return this.nextIndex.updateState(index);
                        }
                    }
                    return this.nextIndex.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let lastIndex = this.lastIndex.getState();
                    if (is.present(flattenedContext) && is.present(lastIndex)) {
                        return this.lastEntry.updateState(flattenedContext[lastIndex]);
                    }
                    return this.lastEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.lastIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let contextIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(contextIndex)) {
                        if (contextIndex >= 0 && contextIndex + 0 < flattenedContext.length) {
                            return this.currentEntry.updateState(flattenedContext[contextIndex + 0]);
                        }
                    }
                    return this.currentEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let nextIndex = this.nextIndex.getState();
                    if (is.present(flattenedContext) && is.present(nextIndex)) {
                        return this.nextEntry.updateState(flattenedContext[nextIndex]);
                    }
                    return this.nextEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.nextIndex.addObserver(computer);
            }
            this.tsc.addEventListener("app", "SetLocalDevice", (message) => {
                this.localDevice.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetDevices", (message) => {
                this.devices.update(message.devices);
            });
            this.tsc.addEventListener("app", "SetContext", (message) => {
                this.context.updateState(message.context);
            });
            this.tsc.addEventListener("app", "SetDevice", (message) => {
                this.device.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetIndex", (message) => {
                this.currentIndex.updateState(message.index);
            });
            this.tsc.addEventListener("app", "SetPlayback", (message) => {
                this.playback.updateState(message.playback);
            });
            this.tsc.addEventListener("app", "SetProgress", (message) => {
                this.progress.updateState(message.progress);
            });
            this.tsc.addEventListener("app", "SetToken", (message) => {
                this.token.updateState(message.token);
            });
            this.isOnline.addObserver((isOnline) => {
                if (!isOnline) {
                    this.context.updateState(undefined);
                    this.currentIndex.updateState(undefined);
                    this.playback.updateState(false);
                    this.progress.updateState(undefined);
                }
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.isOnline, this.token);
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        close() {
            this.tsc.close();
        }
        last() {
            let lastIndex = this.lastIndex.getState();
            if (is.present(lastIndex)) {
                this.currentIndex.updateState(lastIndex);
                this.tsc.send("SetIndex", {
                    index: lastIndex
                });
            }
            else {
                this.pause();
            }
        }
        next() {
            let nextIndex = this.nextIndex.getState();
            if (is.present(nextIndex)) {
                this.currentIndex.updateState(nextIndex);
                this.tsc.send("SetIndex", {
                    index: nextIndex
                });
            }
            else {
                this.pause();
            }
        }
        pause() {
            this.playback.updateState(false);
            this.tsc.send("SetPlayback", {
                playback: false
            });
        }
        play() {
            this.resume();
        }
        playAlbum(album, discIndex, trackIndex) {
            let index = 0;
            if (is.present(discIndex)) {
                let discs = album.discs;
                if (discIndex < 0 || discIndex >= discs.length) {
                    throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                }
                index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                if (is.present(trackIndex)) {
                    let tracks = discs[discIndex].tracks;
                    if (trackIndex < 0 || trackIndex >= tracks.length) {
                        throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                    }
                    index += trackIndex;
                }
            }
            return this.sendPlay(album, index);
        }
        playArtist(artist, albumIndex, discIndex, trackIndex) {
            let index = 0;
            if (is.present(albumIndex)) {
                let albums = artist.albums;
                if (albumIndex < 0 || albumIndex >= albums.length) {
                    throw `Expected ${albumIndex} to be a number between 0 and ${albums.length}!`;
                }
                index += albums.slice(0, albumIndex).reduce((sum, album) => sum + album.discs.reduce((sum, disc) => sum + disc.tracks.length, 0), 0);
                if (is.present(discIndex)) {
                    let discs = albums[albumIndex].discs;
                    if (discIndex < 0 || discIndex >= discs.length) {
                        throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                    }
                    index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                    if (is.present(trackIndex)) {
                        let tracks = discs[discIndex].tracks;
                        if (trackIndex < 0 || trackIndex >= tracks.length) {
                            throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                        }
                        index += trackIndex;
                    }
                }
            }
            return this.sendPlay(artist, index);
        }
        playDisc(disc, trackIndex) {
            let index = 0;
            if (is.present(trackIndex)) {
                let tracks = disc.tracks;
                if (trackIndex < 0 || trackIndex >= tracks.length) {
                    throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                }
                index += trackIndex;
            }
            return this.sendPlay(disc, index);
        }
        playEpisode(episode) {
            this.sendPlay(episode, 0);
        }
        playMovie(movie) {
            this.sendPlay(movie, 0);
        }
        playPlaylist(playlist, itemIndex) {
            let index = 0;
            if (is.present(itemIndex)) {
                let items = playlist.items;
                if (itemIndex < 0 || itemIndex >= items.length) {
                    throw `Expected ${itemIndex} to be a number between 0 and ${items.length}!`;
                }
                index += itemIndex;
            }
            return this.sendPlay(playlist, index);
        }
        playSeason(season, episodeIndex) {
            let index = 0;
            if (is.present(episodeIndex)) {
                let episodes = season.episodes;
                if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                    throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                }
                index += episodeIndex;
            }
            return this.sendPlay(season, index);
        }
        playShow(show, seasonIndex, episodeIndex) {
            let index = 0;
            if (is.present(seasonIndex)) {
                let seasons = show.seasons;
                if (seasonIndex < 0 || seasonIndex >= seasons.length) {
                    throw `Expected ${seasonIndex} to be a number between 0 and ${seasons.length}!`;
                }
                index += seasons.slice(0, seasonIndex).reduce((sum, season) => sum + season.episodes.length, 0);
                if (is.present(episodeIndex)) {
                    let episodes = seasons[seasonIndex].episodes;
                    if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                        throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                    }
                    index += episodeIndex;
                }
            }
            return this.sendPlay(show, index);
        }
        playTrack(track) {
            this.sendPlay(track, 0);
        }
        reconnect() {
            this.tsc.reconnect();
        }
        resume() {
            if (this.canPlayCurrent.getState()) {
                this.playback.updateState(true);
                this.tsc.send("SetPlayback", {
                    playback: true
                });
            }
        }
        seek(progress) {
            this.progress.updateState(progress);
            this.tsc.send("SetProgress", {
                progress: progress
            });
        }
        toggle() {
            if (this.playback.getState()) {
                this.pause();
            }
            else {
                this.resume();
            }
        }
        transfer(device) {
            this.tsc.send("SetDevice", {
                device: device
            });
        }
    }
    exports.ContextClient = ContextClient;
});
define("node_modules/@joelek/ts-sockets/dist/lib/frames", ["require", "exports", "crypto"], function (require, exports, libcrypto) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeFrame = exports.decodeFrame = exports.WebSocketFrameType = void 0;
    var WebSocketFrameType;
    (function (WebSocketFrameType) {
        WebSocketFrameType[WebSocketFrameType["CONTINUATION"] = 0] = "CONTINUATION";
        WebSocketFrameType[WebSocketFrameType["TEXT"] = 1] = "TEXT";
        WebSocketFrameType[WebSocketFrameType["BINARY"] = 2] = "BINARY";
        WebSocketFrameType[WebSocketFrameType["UNUSED_3"] = 3] = "UNUSED_3";
        WebSocketFrameType[WebSocketFrameType["UNUSED_4"] = 4] = "UNUSED_4";
        WebSocketFrameType[WebSocketFrameType["UNUSED_5"] = 5] = "UNUSED_5";
        WebSocketFrameType[WebSocketFrameType["UNUSED_6"] = 6] = "UNUSED_6";
        WebSocketFrameType[WebSocketFrameType["UNUSED_7"] = 7] = "UNUSED_7";
        WebSocketFrameType[WebSocketFrameType["CLOSE"] = 8] = "CLOSE";
        WebSocketFrameType[WebSocketFrameType["PING"] = 9] = "PING";
        WebSocketFrameType[WebSocketFrameType["PONG"] = 10] = "PONG";
        WebSocketFrameType[WebSocketFrameType["UNUSED_B"] = 11] = "UNUSED_B";
        WebSocketFrameType[WebSocketFrameType["UNUSED_C"] = 12] = "UNUSED_C";
        WebSocketFrameType[WebSocketFrameType["UNUSED_D"] = 13] = "UNUSED_D";
        WebSocketFrameType[WebSocketFrameType["UNUSED_E"] = 14] = "UNUSED_E";
        WebSocketFrameType[WebSocketFrameType["UNUSED_F"] = 15] = "UNUSED_F";
    })(WebSocketFrameType = exports.WebSocketFrameType || (exports.WebSocketFrameType = {}));
    ;
    function decodeFrame(state) {
        let final = ((state.buffer.readUInt8(state.offset) >> 7) & 0x01);
        let reserved1 = ((state.buffer.readUInt8(state.offset) >> 6) & 0x01);
        let reserved2 = ((state.buffer.readUInt8(state.offset) >> 5) & 0x01);
        let reserved3 = ((state.buffer.readUInt8(state.offset) >> 4) & 0x01);
        let opcode = ((state.buffer.readUInt8(state.offset) >> 0) & 0x0F);
        state.offset += 1;
        let masked = ((state.buffer.readUInt8(state.offset) >> 7) & 0x01);
        let payload_length = ((state.buffer.readUInt8(state.offset) >> 0) & 0x7F);
        state.offset += 1;
        if (payload_length === 126) {
            payload_length = state.buffer.readUInt16BE(state.offset);
            state.offset += 2;
            if (payload_length <= 125) {
                throw "Invalid frame encoding!";
            }
        }
        else if (payload_length === 127) {
            if (state.buffer.readUInt32BE(state.offset) !== 0) {
                throw "Invalid frame encoding!";
            }
            state.offset += 4;
            payload_length = state.buffer.readUInt32BE(state.offset);
            state.offset += 4;
            if (payload_length <= 65535) {
                throw "Invalid frame encoding!";
            }
        }
        let key = Buffer.alloc(4);
        if (masked === 1) {
            key = state.buffer.slice(state.offset, state.offset + 4);
            state.offset += 4;
        }
        if (state.offset + payload_length > state.buffer.length) {
            throw "Invalid frame encoding!";
        }
        let payload = state.buffer.slice(state.offset, state.offset + payload_length);
        state.offset += payload_length;
        if (masked === 1) {
            for (let i = 0; i < payload.length; i++) {
                payload[i] = payload[i] ^ key[i & 0x03];
            }
        }
        return {
            final,
            reserved1,
            reserved2,
            reserved3,
            opcode,
            masked,
            payload
        };
    }
    exports.decodeFrame = decodeFrame;
    ;
    function encodeFrame(frame) {
        let chunks = new Array();
        let payload_length = frame.payload.length;
        let header = Buffer.alloc(2);
        chunks.push(header);
        let byte0 = 0;
        byte0 |= ((frame.final & 0x01) << 7);
        byte0 |= ((frame.reserved1 & 0x01) << 6);
        byte0 |= ((frame.reserved2 & 0x01) << 5);
        byte0 |= ((frame.reserved3 & 0x01) << 4);
        byte0 |= ((frame.opcode & 0x0F) << 0);
        header.writeUInt8(byte0, 0);
        if (payload_length <= 125) {
            let byte1 = 0;
            byte1 |= ((frame.masked & 0x01) << 7);
            byte1 |= ((payload_length & 0x7F) << 0);
            header.writeUInt8(byte1, 1);
        }
        else if (payload_length <= 65535) {
            let byte1 = 0;
            byte1 |= ((frame.masked & 0x01) << 7);
            byte1 |= ((126 & 0x7F) << 0);
            header.writeUInt8(byte1, 1);
            let length = Buffer.alloc(2);
            length.writeUInt16BE(payload_length, 0);
            chunks.push(length);
        }
        else if (payload_length <= 4294967295) {
            let byte1 = 0;
            byte1 |= ((frame.masked & 0x01) << 7);
            byte1 |= ((127 & 0x7F) << 0);
            header.writeUInt8(byte1, 1);
            let length = Buffer.alloc(8);
            length.writeUInt32BE(payload_length, 4);
            chunks.push(length);
        }
        else {
            throw "Invalid frame size!";
        }
        if (frame.masked === 1) {
            let key = libcrypto.randomBytes(4);
            let payload = Buffer.concat([frame.payload]);
            for (let i = 0; i < payload.length; i++) {
                payload[i] = payload[i] ^ key[i & 0x03];
            }
            chunks.push(key, payload);
        }
        else {
            chunks.push(frame.payload);
        }
        return Buffer.concat(chunks);
    }
    exports.encodeFrame = encodeFrame;
    ;
});
define("node_modules/@joelek/ts-sockets/dist/lib/is", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.present = exports.absent = void 0;
    function absent(subject) {
        return subject == null;
    }
    exports.absent = absent;
    ;
    function present(subject) {
        return subject != null;
    }
    exports.present = present;
    ;
});
define("node_modules/@joelek/ts-sockets/dist/lib/utils", ["require", "exports", "node_modules/@joelek/ts-sockets/dist/lib/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BiMap = exports.getHeader = void 0;
    function getHeader(request, key) {
        let values = request.headers[key.toLowerCase()];
        if (is.present(values)) {
            if (values.constructor === String) {
                return values;
            }
            if (values.constructor === Array && values.length === 1) {
                return values[0];
            }
        }
        return null;
    }
    exports.getHeader = getHeader;
    ;
    class BiMap {
        constructor() {
            this.value_to_key = new Map();
            this.key_to_value = new Map();
        }
        [Symbol.iterator]() {
            return this.key_to_value[Symbol.iterator]();
        }
        add(key, value) {
            this.value_to_key.set(value, key);
            this.key_to_value.set(key, value);
        }
        key(value) {
            return this.value_to_key.get(value) || null;
        }
        remove(key) {
            let value = this.key_to_value.get(key);
            if (is.present(value)) {
                this.value_to_key.delete(value);
            }
            this.key_to_value.delete(key);
        }
        value(key) {
            return this.key_to_value.get(key) || null;
        }
    }
    exports.BiMap = BiMap;
    ;
});
define("node_modules/@joelek/ts-sockets/dist/lib/client", ["require", "exports", "crypto", "http", "https", "url", "node_modules/@joelek/ts-stdlib/dist/lib/index", "node_modules/@joelek/ts-sockets/dist/lib/frames", "node_modules/@joelek/ts-sockets/dist/lib/is", "node_modules/@joelek/ts-sockets/dist/lib/shared", "node_modules/@joelek/ts-sockets/dist/lib/utils"], function (require, exports, libcrypto, libhttp, libhttps, liburl, stdlib, frames, is, shared, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketClient = void 0;
    function makeHttpPromise(url, options) {
        return new Promise((resolve, reject) => {
            libhttp.get(url, options)
                .on("upgrade", (response, socket, buffer) => {
                resolve({ response, socket, buffer });
            })
                .on("error", reject);
        });
    }
    function makeHttpsPromise(url, options) {
        return new Promise((resolve, reject) => {
            libhttps.get(url, options)
                .on("upgrade", (response, socket, buffer) => {
                resolve({ response, socket, buffer });
            })
                .on("error", reject);
        });
    }
    class WebSocketClient {
        constructor(url) {
            var _a;
            this.state = shared.ReadyState.CONNECTING;
            this.listeners = new stdlib.routing.MessageRouter();
            this.pending = new Array();
            this.socket = undefined;
            let key = libcrypto.randomBytes(16).toString("base64");
            let headers = {
                "Connection": "upgrade",
                "Host": (_a = liburl.parse(url).host) !== null && _a !== void 0 ? _a : "",
                "Sec-WebSocket-Key": key,
                "Sec-WebSocket-Version": "13",
                "Upgrade": "websocket"
            };
            (() => {
                if (url.startsWith("wss:")) {
                    return makeHttpsPromise("https:" + url.substring(4), { headers, rejectUnauthorized: false });
                }
                else if (url.startsWith("ws:")) {
                    return makeHttpPromise("http:" + url.substring(3), { headers });
                }
                else {
                    throw `Expected ${url} to be a WebSocket URL!`;
                }
            })().then((upgraded) => {
                var _a, _b;
                let response = upgraded.response;
                let socket = upgraded.socket;
                let buffer = upgraded.buffer;
                socket.on("close", () => {
                    this.state = shared.ReadyState.CLOSED;
                    this.listeners.route("close", {});
                });
                socket.on("error", () => {
                    this.state = shared.ReadyState.CLOSING;
                    this.listeners.route("error", {});
                    socket.end();
                });
                if (response.statusCode !== 101) {
                    return socket.emit("error");
                }
                if (((_a = utils.getHeader(response, "Connection")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== "upgrade") {
                    return socket.emit("error");
                }
                if (((_b = utils.getHeader(response, "Upgrade")) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== "websocket") {
                    return socket.emit("error");
                }
                let accept = libcrypto.createHash("sha1")
                    .update(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")
                    .digest("base64");
                if (utils.getHeader(response, "Sec-WebSocket-Accept") !== accept) {
                    return socket.emit("error");
                }
                this.socket = socket;
                let processBuffer = () => {
                    while (true) {
                        try {
                            let state = {
                                buffer,
                                offset: 0
                            };
                            let frame = frames.decodeFrame(state);
                            this.onFrame(socket, frame);
                            buffer = buffer.slice(state.offset);
                        }
                        catch (error) {
                            break;
                        }
                    }
                };
                this.socket.on("data", (chunk) => {
                    buffer = Buffer.concat([buffer, chunk]);
                    processBuffer();
                });
                this.state = shared.ReadyState.OPEN;
                this.listeners.route("open", {});
                processBuffer();
            });
        }
        onFrame(socket, frame) {
            if (frame.reserved1 !== 0 || frame.reserved2 !== 0 || frame.reserved3 !== 0) {
                return this.close(shared.StatusCode.PROTOCOL_ERROR);
            }
            if (frame.opcode < 8) {
                if (frame.opcode === frames.WebSocketFrameType.CONTINUATION || frame.opcode === frames.WebSocketFrameType.TEXT || frame.opcode == frames.WebSocketFrameType.BINARY) {
                    if (this.pending.length === 0) {
                        if (frame.opcode === frames.WebSocketFrameType.CONTINUATION) {
                            return this.close(shared.StatusCode.PROTOCOL_ERROR);
                        }
                    }
                    else {
                        if (frame.opcode !== frames.WebSocketFrameType.CONTINUATION) {
                            return this.close(shared.StatusCode.PROTOCOL_ERROR);
                        }
                    }
                    this.pending.push(frame.payload);
                    if (frame.final === 1) {
                        let buffer = Buffer.concat(this.pending);
                        this.pending.splice(0);
                        this.listeners.route("message", {
                            data: buffer.toString()
                        });
                    }
                }
                else {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
            }
            else {
                if (frame.final !== 1) {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.payload.length > 125) {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.opcode === frames.WebSocketFrameType.CLOSE) {
                    if (this.readyState === shared.ReadyState.CLOSING) {
                        return socket.end();
                    }
                    else {
                        socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { masked: 1 })), () => {
                            return socket.end();
                        });
                    }
                }
                else if (frame.opcode === frames.WebSocketFrameType.PING) {
                    socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { opcode: 0x0A, masked: 1 })));
                }
                else if (frame.opcode === frames.WebSocketFrameType.PONG) {
                }
                else {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
            }
        }
        addEventListener(type, listener) {
            this.listeners.addObserver(type, listener);
        }
        close(status) {
            if (this.state !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            const socket = this.socket;
            if (is.absent(socket)) {
                throw `Expected socket to be open!`;
            }
            let payload = Buffer.alloc(0);
            if (is.present(status)) {
                payload = Buffer.concat([Buffer.alloc(2), Buffer.from("Connection closed by client.")]);
                payload.writeUInt16BE(status, 0);
            }
            let frame = frames.encodeFrame({
                final: 1,
                reserved1: 0,
                reserved2: 0,
                reserved3: 0,
                opcode: frames.WebSocketFrameType.CLOSE,
                masked: 1,
                payload: payload
            });
            socket.write(frame);
            this.state = shared.ReadyState.CLOSING;
        }
        removeEventListener(type, listener) {
            this.listeners.removeObserver(type, listener);
        }
        send(payload) {
            if (this.state !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            let socket = this.socket;
            if (is.absent(socket)) {
                throw `Expected socket to be open!`;
            }
            let final = 1;
            let reserved1 = 0;
            let reserved2 = 0;
            let reserved3 = 0;
            let opcode = frames.WebSocketFrameType.BINARY;
            let masked = 1;
            if (!(payload instanceof Buffer)) {
                payload = Buffer.from(payload, "utf8");
                opcode = frames.WebSocketFrameType.TEXT;
            }
            let frame = frames.encodeFrame({
                final,
                reserved1,
                reserved2,
                reserved3,
                opcode,
                masked,
                payload
            });
            socket.write(frame);
        }
        get readyState() {
            return this.state;
        }
    }
    exports.WebSocketClient = WebSocketClient;
    ;
});
define("node_modules/@joelek/ts-sockets/dist/lib/server", ["require", "exports", "crypto", "tls", "node_modules/@joelek/ts-stdlib/dist/lib/index", "node_modules/@joelek/ts-sockets/dist/lib/frames", "node_modules/@joelek/ts-sockets/dist/lib/is", "node_modules/@joelek/ts-sockets/dist/lib/shared", "node_modules/@joelek/ts-sockets/dist/lib/utils"], function (require, exports, libcrypto, libtls, stdlib, frames, is, shared, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketServer = void 0;
    function makeConnectionUrl(request) {
        let host = request.headers.host || "";
        let path = request.url || "/";
        let protocol = request.socket instanceof libtls.TLSSocket ? "wss:" : "ws:";
        return `${protocol}//${host}${path}`;
    }
    class WebSocketServer {
        constructor() {
            this.pending_chunks = new Map();
            this.states = new Map();
            this.connections = new utils.BiMap();
            this.router = new stdlib.routing.MessageRouter();
        }
        onFrame(connection_id, connection_url, socket, frame) {
            if (frame.reserved1 !== 0 || frame.reserved2 !== 0 || frame.reserved3 !== 0) {
                return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
            }
            if (frame.masked !== 1) {
                return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
            }
            if (frame.opcode < 8) {
                if (frame.opcode === frames.WebSocketFrameType.CONTINUATION || frame.opcode === frames.WebSocketFrameType.TEXT || frame.opcode == frames.WebSocketFrameType.BINARY) {
                    let pending_chunks = this.pending_chunks.get(connection_id);
                    if (is.absent(pending_chunks)) {
                        pending_chunks = new Array();
                        this.pending_chunks.set(connection_id, pending_chunks);
                    }
                    else {
                        if (frame.opcode !== frames.WebSocketFrameType.CONTINUATION) {
                            return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                        }
                    }
                    pending_chunks.push(frame.payload);
                    if (frame.final === 1) {
                        let buffer = Buffer.concat(pending_chunks);
                        this.pending_chunks.delete(connection_id);
                        this.router.route("message", {
                            connection_id,
                            connection_url,
                            buffer
                        });
                    }
                }
                else {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
            }
            else {
                if (frame.final !== 1) {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.payload.length > 125) {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.opcode === frames.WebSocketFrameType.CLOSE) {
                    if (this.states.get(connection_id) === shared.ReadyState.CLOSING) {
                        return socket.end();
                    }
                    else {
                        socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { masked: 0 })), () => {
                            return socket.end();
                        });
                    }
                }
                else if (frame.opcode === frames.WebSocketFrameType.PING) {
                    socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { opcode: 0x0A, masked: 0 })));
                }
                else if (frame.opcode === frames.WebSocketFrameType.PONG) {
                }
                else {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
            }
        }
        addEventListener(type, listener) {
            return this.router.addObserver(type, listener);
        }
        broadcast(payload) {
            for (let [connection_id, socket] of this.connections) {
                if (this.states.get(connection_id) === shared.ReadyState.OPEN) {
                    this.send(connection_id, payload);
                }
            }
        }
        close(connection_id, status) {
            if (this.states.get(connection_id) !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            const socket = this.connections.value(connection_id);
            if (is.absent(socket)) {
                throw "Connection with id \"" + connection_id + "\" has no socket!";
            }
            let payload = Buffer.alloc(0);
            if (is.present(status)) {
                payload = Buffer.concat([Buffer.alloc(2), Buffer.from("Connection closed by server.")]);
                payload.writeUInt16BE(status, 0);
            }
            let frame = frames.encodeFrame({
                final: 1,
                reserved1: 0,
                reserved2: 0,
                reserved3: 0,
                opcode: frames.WebSocketFrameType.CLOSE,
                masked: 0,
                payload: payload
            });
            socket.write(frame);
            this.states.set(connection_id, shared.ReadyState.CLOSING);
        }
        getRequestHandler() {
            return (request, response) => {
                let socket = request.socket;
                let connection_id = this.connections.key(socket);
                if (is.present(connection_id)) {
                    response.writeHead(400);
                    return response.end();
                }
                let major = request.httpVersionMajor;
                let minor = request.httpVersionMinor;
                if (major < 1 || (major === 1 && minor < 1)) {
                    response.writeHead(400);
                    return response.end();
                }
                let method = request.method;
                if (method !== "GET") {
                    response.writeHead(400);
                    return response.end();
                }
                let host = utils.getHeader(request, "Host");
                if (is.absent(host)) {
                    response.writeHead(400);
                    return response.end();
                }
                let upgrade = utils.getHeader(request, "Upgrade");
                if (is.absent(upgrade) || upgrade.toLowerCase() !== "websocket") {
                    response.writeHead(400);
                    return response.end();
                }
                let connection = utils.getHeader(request, "Connection");
                if (is.absent(connection) || connection.toLowerCase() !== "upgrade") {
                    response.writeHead(400);
                    return response.end();
                }
                let key = utils.getHeader(request, "Sec-WebSocket-Key");
                if (is.absent(key) || Buffer.from(key, "base64").length !== 16) {
                    response.writeHead(400);
                    return response.end();
                }
                let version = utils.getHeader(request, "Sec-WebSocket-Version");
                if (version !== "13") {
                    response.writeHead(426, {
                        "Sec-WebSocket-Version": "13"
                    });
                    return response.end();
                }
                let accept = libcrypto.createHash("sha1")
                    .update(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")
                    .digest("base64");
                response.writeHead(101, {
                    "Upgrade": "websocket",
                    "Connection": "Upgrade",
                    "Sec-WebSocket-Accept": accept
                });
                return response.end(() => {
                    let connection_id = libcrypto.randomBytes(16).toString("hex");
                    let connection_url = makeConnectionUrl(request);
                    let buffer = Buffer.alloc(0);
                    socket.on("data", (chunk) => {
                        buffer = Buffer.concat([buffer, chunk]);
                        while (true) {
                            try {
                                let state = {
                                    buffer,
                                    offset: 0
                                };
                                let frame = frames.decodeFrame(state);
                                this.onFrame(connection_id, connection_url, socket, frame);
                                buffer = buffer.slice(state.offset);
                            }
                            catch (error) {
                                break;
                            }
                        }
                    });
                    socket.on("close", () => {
                        this.connections.remove(connection_id);
                        this.states.delete(connection_id);
                        this.router.route("disconnect", {
                            connection_id,
                            connection_url
                        });
                    });
                    socket.setTimeout(0);
                    this.connections.add(connection_id, socket);
                    this.states.set(connection_id, shared.ReadyState.OPEN);
                    this.router.route("connect", {
                        connection_id,
                        connection_url
                    });
                });
            };
        }
        removeEventListener(type, listener) {
            return this.router.removeObserver(type, listener);
        }
        send(connection_id, payload) {
            if (this.states.get(connection_id) !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            let socket = this.connections.value(connection_id);
            if (is.absent(socket)) {
                throw "Connection with id \"" + connection_id + "\" has no socket!";
            }
            let final = 1;
            let reserved1 = 0;
            let reserved2 = 0;
            let reserved3 = 0;
            let opcode = frames.WebSocketFrameType.BINARY;
            let masked = 0;
            if (!(payload instanceof Buffer)) {
                payload = Buffer.from(payload, "utf8");
                opcode = frames.WebSocketFrameType.TEXT;
            }
            let frame = frames.encodeFrame({
                final,
                reserved1,
                reserved2,
                reserved3,
                opcode,
                masked,
                payload
            });
            socket.write(frame);
        }
    }
    exports.WebSocketServer = WebSocketServer;
});
define("node_modules/@joelek/ts-sockets/dist/lib/index", ["require", "exports", "node_modules/@joelek/ts-sockets/dist/lib/client", "node_modules/@joelek/ts-sockets/dist/lib/frames", "node_modules/@joelek/ts-sockets/dist/lib/server", "node_modules/@joelek/ts-sockets/dist/lib/shared", "node_modules/@joelek/ts-sockets/dist/lib/client", "node_modules/@joelek/ts-sockets/dist/lib/server"], function (require, exports, client, frames, server, shared, client_1, server_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shared = exports.server = exports.frames = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketServer = exports.WebSocketClient = exports.shared = exports.server = exports.frames = exports.client = void 0;
    exports.client = client;
    exports.frames = frames;
    exports.server = server;
    exports.shared = shared;
    Object.defineProperty(exports, "WebSocketClient", { enumerable: true, get: function () { return client_1.WebSocketClient; } });
    Object.defineProperty(exports, "WebSocketServer", { enumerable: true, get: function () { return server_1.WebSocketServer; } });
});
define("build/typesockets/server", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/index", "node_modules/@joelek/ts-sockets/dist/lib/index", "build/typesockets/shared"], function (require, exports, stdlib, sockets, shared) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketServer = void 0;
    class TypeSocketServer {
        router;
        serializer;
        socket;
        debug;
        constructor(guards, debug = false) {
            this.router = new stdlib.routing.NamespacedMessageRouter();
            this.serializer = new shared.Serializer(guards);
            this.socket = new sockets.WebSocketServer();
            this.debug = debug;
            this.socket.addEventListener("connect", (message) => {
                let connection_id = message.connection_id;
                let connection_url = message.connection_url;
                this.router.route("sys", "connect", {
                    connection_id,
                    connection_url
                });
            });
            this.socket.addEventListener("disconnect", (message) => {
                let connection_id = message.connection_id;
                let connection_url = message.connection_url;
                this.router.route("sys", "disconnect", {
                    connection_id,
                    connection_url
                });
            });
            this.socket.addEventListener("message", (message) => {
                let connection_id = message.connection_id;
                let connection_url = message.connection_url;
                let payload = message.buffer.toString();
                try {
                    this.serializer.deserialize(payload, (type, data, id) => {
                        if (this.debug) {
                            console.log(`${connection_id} -> ${type}`);
                        }
                        this.router.route("sys", "message", {
                            connection_id,
                            connection_url,
                            id,
                            type,
                            data
                        });
                        this.router.route("app", type, {
                            connection_id,
                            connection_url,
                            id,
                            data
                        });
                    });
                }
                catch (error) {
                    if (this.debug) {
                        console.log(error);
                    }
                }
            });
        }
        addEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        broadcast(type, data) {
            let payload = this.serializer.serialize(type, data);
            this.socket.broadcast(payload);
        }
        close(connection_id) {
            this.socket.close(connection_id);
        }
        getRequestHandler() {
            return this.socket.getRequestHandler();
        }
        removeEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        respond(message, type, data) {
            let payload = this.serializer.serialize(type, data, message.id);
            if (this.debug) {
                console.log(`${message.connection_id} <- ${type}`);
            }
            try {
                this.socket.send(message.connection_id, payload);
            }
            catch (error) {
                if (this.debug) {
                    console.log(error);
                }
            }
        }
        send(type, connection_ids, data) {
            let payload = this.serializer.serialize(type, data);
            for (let connection_id of Array.isArray(connection_ids) ? connection_ids : [connection_ids]) {
                if (this.debug) {
                    console.log(`${connection_id} <- ${type}`);
                }
                try {
                    this.socket.send(connection_id, payload);
                }
                catch (error) {
                    if (this.debug) {
                        console.log(error);
                    }
                }
            }
        }
    }
    exports.TypeSocketServer = TypeSocketServer;
    ;
});
define("build/typesockets/index", ["require", "exports", "build/typesockets/client", "build/typesockets/server", "build/typesockets/shared", "build/typesockets/client", "build/typesockets/server"], function (require, exports, client, server, shared, client_1, server_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shared = exports.server = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketServer = exports.TypeSocketClient = exports.shared = exports.server = exports.client = void 0;
    exports.client = client;
    exports.server = server;
    exports.shared = shared;
    Object.defineProperty(exports, "TypeSocketClient", { enumerable: true, get: function () { return client_1.TypeSocketClient; } });
    Object.defineProperty(exports, "TypeSocketServer", { enumerable: true, get: function () { return server_1.TypeSocketServer; } });
});
define("build/player/server", ["require", "exports", "url", "build/server/auth", "build/is", "build/observers/index", "build/player/schema/index", "build/typesockets/index"], function (require, exports, liburl, auth, is, observers, schema, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextServer = void 0;
    function getQuery(url, key) {
        let values = url.query[key] ?? [];
        if (Array.isArray(values)) {
            return values;
        }
        else {
            return [values];
        }
    }
    function makeDevice(connection_id, connection_url) {
        let url = liburl.parse(connection_url, true);
        let protocol = getQuery(url, "protocol").pop() ?? "";
        let name = getQuery(url, "name").pop() ?? "";
        let type = getQuery(url, "type").pop() ?? "";
        return {
            id: connection_id,
            protocol: protocol,
            name: name,
            type: type
        };
    }
    class ContextServer {
        chromecasts;
        tss;
        tokens = new Map();
        sessions = new Map();
        getExistingSession(connection_id, callback) {
            let token = this.tokens.get(connection_id);
            if (is.present(token)) {
                let user_id = auth.getUserId(token);
                let session = this.sessions.get(user_id);
                if (is.present(session)) {
                    callback(session);
                }
            }
        }
        getSession(user_id) {
            let existingSession = this.sessions.get(user_id);
            if (is.present(existingSession)) {
                return existingSession;
            }
            const session = {
                playback: false,
                devices: new observers.ObservableClass(new Array())
            };
            let allDevices = new observers.ObservableClass([]);
            {
                let computer = () => {
                    let devices = session.devices.getState();
                    let chromecasts = this.chromecasts.getState().filter((chromecast) => {
                        return is.absent(devices.find((device) => {
                            return device.id === chromecast.id;
                        }));
                    });
                    allDevices.updateState([...devices, ...chromecasts]);
                };
                session.devices.addObserver(computer);
                this.chromecasts.addObserver(computer);
            }
            allDevices.addObserver((allDevices) => {
                this.tss.send("SetDevices", session.devices.getState().map((device) => {
                    return device.id;
                }), {
                    devices: allDevices
                });
            });
            session.devices.addObserver((devices) => {
                this.updateProgress(session);
            });
            session.devices.addObserver((devices) => {
                let deviceWasLost = is.absent(devices.find((device) => {
                    return device.id === session.device?.id;
                }));
                if (deviceWasLost) {
                    this.updateProgress(session);
                    session.playback = false;
                    this.tss.send("SetPlayback", devices.map((device) => {
                        return device.id;
                    }), {
                        playback: session.playback
                    });
                    session.device = undefined;
                    this.tss.send("SetDevice", devices.map((device) => {
                        return device.id;
                    }), {
                        device: session.device
                    });
                }
            });
            this.sessions.set(user_id, session);
            return session;
        }
        revokeAuthentication(connection_id) {
            let token = this.tokens.get(connection_id);
            this.tokens.delete(connection_id);
            if (is.present(token)) {
                let user_id = auth.getUserId(token);
                let session = this.sessions.get(user_id);
                if (is.present(session)) {
                    let devices = session.devices;
                    devices.updateState(devices.getState().filter((device) => {
                        return device.id !== connection_id;
                    }));
                }
            }
        }
        updateProgress(session) {
            let now = Date.now();
            if (session.playback) {
                if (is.present(session.progress) && is.present(session.progressTimestamp)) {
                    session.progress += (now - session.progressTimestamp) / 1000;
                }
            }
            session.progressTimestamp = now;
        }
        constructor() {
            this.chromecasts = new observers.ObservableClass([]);
            this.tss = new typesockets.TypeSocketServer(schema.messages.Autoguard.Guards);
            this.tss.addEventListener("sys", "connect", (message) => {
                console.log("connect: " + message.connection_url);
                let device = makeDevice(message.connection_id, message.connection_url);
                this.tss.send("SetLocalDevice", message.connection_id, {
                    device
                });
                if (device.protocol === "cast" || device.protocol === "airplay") {
                    this.chromecasts.updateState([...this.chromecasts.getState(), device]);
                }
            });
            this.tss.addEventListener("sys", "disconnect", (message) => {
                console.log("disconnect: " + message.connection_url);
                let device = makeDevice(message.connection_id, message.connection_url);
                this.revokeAuthentication(message.connection_id);
                if (device.protocol === "cast" || device.protocol === "airplay") {
                    this.chromecasts.updateState(this.chromecasts.getState().filter((chromecast) => {
                        return chromecast.id !== device.id;
                    }));
                }
            });
            this.tss.addEventListener("app", "SetToken", (message) => {
                this.revokeAuthentication(message.connection_id);
                let token = message.data.token;
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    this.tokens.set(message.connection_id, token);
                    let session = this.getSession(user_id);
                    let device = makeDevice(message.connection_id, message.connection_url);
                    session.devices.updateState([...session.devices.getState(), device]);
                    this.tss.send("SetContext", message.connection_id, {
                        context: session.context
                    });
                    this.tss.send("SetDevice", message.connection_id, {
                        device: session.device
                    });
                    this.tss.send("SetIndex", message.connection_id, {
                        index: session.index
                    });
                    this.tss.send("SetPlayback", message.connection_id, {
                        playback: session.playback
                    });
                    this.tss.send("SetProgress", message.connection_id, {
                        progress: session.progress
                    });
                    this.tss.send("SetToken", message.connection_id, {
                        token: token
                    });
                }
            });
            this.tss.addEventListener("app", "SetContext", (message) => {
                this.getExistingSession(message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    session.index = undefined;
                    this.tss.send("SetIndex", session.devices.getState().map((device) => {
                        return device.id;
                    }), {
                        index: session.index
                    });
                    session.context = message.data.context;
                    this.tss.send("SetContext", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            });
            this.tss.addEventListener("app", "SetDevice", (message) => {
                this.getExistingSession(message.connection_id, (session) => {
                    this.updateProgress(session);
                    this.tss.send("SetProgress", session.devices.getState().map((device) => {
                        return device.id;
                    }), {
                        progress: session.progress
                    });
                    session.device = message.data.device;
                    this.tss.send("SetDevice", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                    if (is.present(session.device)) {
                        this.tss.send("SetToken", session.device.id, {
                            token: this.tokens.get(message.connection_id)
                        });
                    }
                });
            });
            this.tss.addEventListener("app", "SetIndex", (message) => {
                this.getExistingSession(message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    session.progress = is.present(message.data.index) ? 0 : undefined;
                    session.progressTimestamp = Date.now();
                    this.tss.send("SetProgress", session.devices.getState().map((device) => {
                        return device.id;
                    }), {
                        progress: session.progress
                    });
                    session.index = message.data.index;
                    this.tss.send("SetIndex", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            });
            this.tss.addEventListener("app", "SetPlayback", (message) => {
                this.getExistingSession(message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    this.updateProgress(session);
                    session.playback = message.data.playback;
                    this.tss.send("SetPlayback", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            });
            this.tss.addEventListener("app", "SetProgress", (message) => {
                this.getExistingSession(message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    session.progress = message.data.progress;
                    session.progressTimestamp = Date.now();
                    this.tss.send("SetProgress", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            });
        }
        getRequestHandler() {
            return this.tss.getRequestHandler();
        }
    }
    exports.ContextServer = ContextServer;
});
define("build/player/index", ["require", "exports", "build/player/client", "build/player/server", "build/player/schema/index"], function (require, exports, client, server, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    exports.client = client;
    exports.server = server;
    exports.schema = schema;
});
define("build/playlists/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.UpdatePlaylistItem = exports.UpdatePlaylistItemResponse = exports.UpdatePlaylistItemRequest = exports.DeletePlaylistItem = exports.DeletePlaylistItemResponse = exports.DeletePlaylistItemRequest = exports.CreatePlaylistItem = exports.CreatePlaylistItemResponse = exports.CreatePlaylistItemRequest = exports.UpdatePlaylist = exports.UpdatePlaylistResponse = exports.UpdatePlaylistRequest = exports.DeletePlaylist = exports.DeletePlaylistResponse = exports.DeletePlaylistRequest = exports.CreatePlaylist = exports.CreatePlaylistResponse = exports.CreatePlaylistRequest = exports.PermissionsResponse = exports.PermissionsRequest = exports.SetToken = void 0;
    exports.SetToken = autoguard.guards.Object.of({
        "token": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.PermissionsRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String
        })
    });
    exports.PermissionsResponse = autoguard.guards.Object.of({
        "permissions": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("read"), autoguard.guards.StringLiteral.of("write"))
    });
    exports.CreatePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "title": autoguard.guards.String,
            "description": autoguard.guards.String
        })
    });
    exports.CreatePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String),
        "playlist_id": autoguard.guards.String
    });
    exports.CreatePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    });
    exports.DeletePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String
        })
    });
    exports.DeletePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.DeletePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    });
    exports.UpdatePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String,
            "title": autoguard.guards.String,
            "description": autoguard.guards.String
        })
    });
    exports.UpdatePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.UpdatePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    });
    exports.CreatePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String,
            "track_id": autoguard.guards.String
        })
    });
    exports.CreatePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String),
        "playlist_item_id": autoguard.guards.String
    });
    exports.CreatePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    });
    exports.DeletePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_item_id": autoguard.guards.String
        })
    });
    exports.DeletePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.DeletePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    });
    exports.UpdatePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_item_id": autoguard.guards.String,
            "number": autoguard.guards.Number
        })
    });
    exports.UpdatePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.UpdatePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "SetToken": autoguard.guards.Reference.of(() => exports.SetToken),
            "PermissionsRequest": autoguard.guards.Reference.of(() => exports.PermissionsRequest),
            "PermissionsResponse": autoguard.guards.Reference.of(() => exports.PermissionsResponse),
            "CreatePlaylistRequest": autoguard.guards.Reference.of(() => exports.CreatePlaylistRequest),
            "CreatePlaylistResponse": autoguard.guards.Reference.of(() => exports.CreatePlaylistResponse),
            "CreatePlaylist": autoguard.guards.Reference.of(() => exports.CreatePlaylist),
            "DeletePlaylistRequest": autoguard.guards.Reference.of(() => exports.DeletePlaylistRequest),
            "DeletePlaylistResponse": autoguard.guards.Reference.of(() => exports.DeletePlaylistResponse),
            "DeletePlaylist": autoguard.guards.Reference.of(() => exports.DeletePlaylist),
            "UpdatePlaylistRequest": autoguard.guards.Reference.of(() => exports.UpdatePlaylistRequest),
            "UpdatePlaylistResponse": autoguard.guards.Reference.of(() => exports.UpdatePlaylistResponse),
            "UpdatePlaylist": autoguard.guards.Reference.of(() => exports.UpdatePlaylist),
            "CreatePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.CreatePlaylistItemRequest),
            "CreatePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.CreatePlaylistItemResponse),
            "CreatePlaylistItem": autoguard.guards.Reference.of(() => exports.CreatePlaylistItem),
            "DeletePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.DeletePlaylistItemRequest),
            "DeletePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.DeletePlaylistItemResponse),
            "DeletePlaylistItem": autoguard.guards.Reference.of(() => exports.DeletePlaylistItem),
            "UpdatePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItemRequest),
            "UpdatePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItemResponse),
            "UpdatePlaylistItem": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItem)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/playlists/client", ["require", "exports", "build/observers/index", "build/jsondb/index", "build/playlists/schema/messages/index", "build/typesockets/client"], function (require, exports, observers, jsondb, messages, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaylistsClient = void 0;
    class PlaylistsClient {
        tsc;
        token = new observers.ObservableClass(undefined);
        online = new observers.ObservableClass(false);
        playlists = new observers.ArrayObservable(new Array());
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.tsc = new typesockets.TypeSocketClient(url, factory, messages.Autoguard.Guards);
            this.tsc.addEventListener("sys", "connect", () => {
                this.online.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.online.updateState(false);
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.online, this.token);
            this.tsc.addEventListener("app", "CreatePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
                let playlist = {
                    ...message.playlist,
                    items: new Array()
                };
                this.playlists.append(new observers.ObservableClass(playlist));
            });
            this.tsc.addEventListener("app", "DeletePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylist", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        playlist.updateState({
                            ...state,
                            ...message.playlist
                        });
                    }
                }
            });
            this.tsc.addEventListener("app", "CreatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        items.push(message.playlist_item);
                        let additions = 1;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "DeletePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        let additions = 0;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let old_index = state.items.findIndex((item) => item.playlist_item_id === message.playlist_item.playlist_item_id);
                        if (old_index >= 0) {
                            let new_index = message.playlist_item.number - 1;
                            if (new_index > old_index) {
                                for (let i = old_index + 1; i < new_index; i++) {
                                    state.items[i].number -= 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            else if (new_index < old_index) {
                                for (let i = new_index; i < old_index; i++) {
                                    state.items[i].number += 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            state.items[new_index] = {
                                ...state.items[new_index],
                                ...message.playlist_item
                            };
                            playlist.updateState({
                                ...state
                            });
                        }
                    }
                }
            });
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        isOnline() {
            return this.online.getState();
        }
        getPermissions(request) {
            return this.tsc.request("PermissionsRequest", "PermissionsResponse", request);
        }
        createPlaylist(request) {
            return this.tsc.request("CreatePlaylistRequest", "CreatePlaylistResponse", request);
        }
        deletePlaylist(request) {
            return this.tsc.request("DeletePlaylistRequest", "DeletePlaylistResponse", request);
        }
        updatePlaylist(request) {
            return this.tsc.request("UpdatePlaylistRequest", "UpdatePlaylistResponse", request);
        }
        createPlaylistItem(request) {
            return this.tsc.request("CreatePlaylistItemRequest", "CreatePlaylistItemResponse", request);
        }
        deletePlaylistItem(request) {
            return this.tsc.request("DeletePlaylistItemRequest", "DeletePlaylistItemResponse", request);
        }
        updatePlaylistItem(request) {
            return this.tsc.request("UpdatePlaylistItemRequest", "UpdatePlaylistItemResponse", request);
        }
        close() {
            this.tsc.close();
        }
        reconnect() {
            this.tsc.reconnect();
        }
    }
    exports.PlaylistsClient = PlaylistsClient;
    ;
});
define("build/playlists/schema/objects/index", ["require", "exports"], function (require, exports) {
    "use strict";
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = void 0;
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {};
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/playlists/schema/index", ["require", "exports", "build/playlists/schema/messages/index", "build/playlists/schema/objects/index"], function (require, exports, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    exports.messages = messages;
    exports.objects = objects;
});
define("build/api/schema/index", ["require", "exports", "build/api/schema/api/index", "build/api/schema/messages/index", "build/api/schema/objects/index"], function (require, exports, api, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = exports.api = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = exports.api = void 0;
    exports.api = api;
    exports.messages = messages;
    exports.objects = objects;
});
define("build/api/index", ["require", "exports", "build/api/handler", "build/api/schema/index"], function (require, exports, handler, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.handler = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.handler = void 0;
    exports.handler = handler;
    exports.schema = schema;
});
define("build/playlists/server", ["require", "exports", "crypto", "build/server/auth", "build/is", "build/playlists/schema/index", "build/database/indexer", "build/typesockets/index", "build/jsondb/index", "build/api/index"], function (require, exports, libcrypto, auth, is, schema, database, typesockets, jsondb, api) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaylistsServer = void 0;
    class PlaylistsServer {
        tss;
        tokens = new Map();
        sessions = new Map();
        getOrCreateSession(user_id) {
            let session = this.sessions.get(user_id);
            if (is.present(session)) {
                return session;
            }
            session = {
                connections: new Set()
            };
            this.sessions.set(user_id, session);
            return session;
        }
        revokeAuthentication(connection_id) {
            let token = this.tokens.get(connection_id);
            this.tokens.delete(connection_id);
            if (is.present(token)) {
                let user_id = auth.getUserId(token);
                let session = this.sessions.get(user_id);
                if (is.present(session)) {
                    let connections = session.connections;
                    connections.delete(connection_id);
                }
            }
        }
        constructor() {
            this.tss = new typesockets.TypeSocketServer(schema.messages.Autoguard.Guards);
            this.tss.addEventListener("sys", "connect", (message) => {
            });
            this.tss.addEventListener("sys", "disconnect", (message) => {
                this.revokeAuthentication(message.connection_id);
            });
            this.tss.addEventListener("app", "SetToken", (message) => {
                this.revokeAuthentication(message.connection_id);
                let token = message.data.token;
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    this.tokens.set(message.connection_id, token);
                    let session = this.getOrCreateSession(user_id);
                    session.connections.add(message.connection_id);
                    for (let playlist of database.getPlaylistsFromUser.lookup(user_id)) {
                        this.tss.send("CreatePlaylist", message.connection_id, {
                            playlist: api.handler.lookupPlaylistBase(playlist.playlist_id, user_id)
                        });
                        for (let playlist_item of database.getPlaylistsItemsFromPlaylist.lookup(playlist.playlist_id)) {
                            this.tss.send("CreatePlaylistItem", message.connection_id, {
                                playlist_item: api.handler.lookupPlaylistItemBase(playlist_item.playlist_item_id, user_id)
                            });
                        }
                    }
                }
            });
            this.tss.addEventListener("app", "PermissionsRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let playlist = database.playlists.lookup(message.data.playlist.playlist_id);
                    if (playlist.user_id === user_id) {
                        this.tss.respond(message, "PermissionsResponse", {
                            permissions: "write"
                        });
                    }
                    else {
                        this.tss.respond(message, "PermissionsResponse", {
                            permissions: "read"
                        });
                    }
                }
            });
            this.tss.addEventListener("app", "CreatePlaylistRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let title = message.data.playlist.title;
                    if (Buffer.from(title).length >= 256) {
                        errors.push(`The playlist title is too long!`);
                    }
                    let description = message.data.playlist.description;
                    if (Buffer.from(description).length >= 256) {
                        errors.push(`The playlist description is too long!`);
                    }
                    let playlist_id = libcrypto.randomBytes(8).toString("hex");
                    this.tss.respond(message, "CreatePlaylistResponse", {
                        errors,
                        playlist_id
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let playlist = {
                        playlist_id: playlist_id,
                        title: title,
                        description: description,
                        user_id: user_id
                    };
                    database.playlists.insert(playlist);
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("CreatePlaylist", Array.from(session.connections), {
                        playlist: api.handler.lookupPlaylistBase(playlist.playlist_id, user_id)
                    });
                }
            });
            this.tss.addEventListener("app", "DeletePlaylistRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let playlist_id = message.data.playlist.playlist_id;
                    let playlist = database.playlists.lookup(playlist_id);
                    if (playlist.user_id !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    this.tss.respond(message, "DeletePlaylistResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("DeletePlaylist", Array.from(session.connections), {
                        playlist: api.handler.lookupPlaylistBase(playlist.playlist_id, user_id)
                    });
                    database.playlists.remove(playlist);
                }
            });
            this.tss.addEventListener("app", "UpdatePlaylistRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let playlist_id = message.data.playlist.playlist_id;
                    let playlist = database.playlists.lookup(playlist_id);
                    if (playlist.user_id !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    let title = message.data.playlist.title;
                    if (Buffer.from(title).length >= 256) {
                        errors.push(`The playlist title is too long!`);
                    }
                    let description = message.data.playlist.description;
                    if (Buffer.from(description).length >= 256) {
                        errors.push(`The playlist description is too long!`);
                    }
                    this.tss.respond(message, "UpdatePlaylistResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    database.playlists.update({
                        ...playlist,
                        ...message.data.playlist
                    });
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("UpdatePlaylist", Array.from(session.connections), {
                        playlist: api.handler.lookupPlaylistBase(playlist.playlist_id, user_id)
                    });
                }
            });
            this.tss.addEventListener("app", "CreatePlaylistItemRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let playlist_id = message.data.playlist_item.playlist_id;
                    let playlist = database.playlists.lookup(playlist_id);
                    if (playlist.user_id !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    let track_id = message.data.playlist_item.track_id;
                    let track = database.tracks.lookup(track_id);
                    let playlist_item_id = libcrypto.randomBytes(8).toString("hex");
                    this.tss.respond(message, "CreatePlaylistItemResponse", {
                        errors,
                        playlist_item_id
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let playlist_items = database.getPlaylistsItemsFromPlaylist.lookup(playlist_id)
                        .sort(jsondb.NumericSort.increasing((record) => record.number))
                        .collect();
                    let playlist_item = {
                        playlist_item_id: playlist_item_id,
                        playlist_id: playlist_id,
                        track_id: track_id,
                        number: (playlist_items.pop()?.number ?? 0) + 1,
                        added_ms: Date.now()
                    };
                    database.playlist_items.insert(playlist_item);
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("CreatePlaylistItem", Array.from(session.connections), {
                        playlist_item: api.handler.lookupPlaylistItemBase(playlist_item.playlist_item_id, user_id)
                    });
                }
            });
            this.tss.addEventListener("app", "DeletePlaylistItemRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let playlist_item_id = message.data.playlist_item.playlist_item_id;
                    let playlist_item = database.playlist_items.lookup(playlist_item_id);
                    let playlist = database.playlists.lookup(playlist_item.playlist_id);
                    if (playlist.user_id !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    this.tss.respond(message, "DeletePlaylistItemResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let number = playlist_item.number;
                    let playlist_items = database.getPlaylistsItemsFromPlaylist.lookup(playlist.playlist_id)
                        .sort(jsondb.NumericSort.increasing((record) => record.number));
                    for (let playlist_item of playlist_items) {
                        if (playlist_item.number > number) {
                            playlist_item.number -= 1;
                            database.playlist_items.update(playlist_item);
                        }
                    }
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("DeletePlaylistItem", Array.from(session.connections), {
                        playlist_item: api.handler.lookupPlaylistItemBase(playlist_item.playlist_item_id, user_id)
                    });
                    database.playlist_items.remove(playlist_item);
                }
            });
            this.tss.addEventListener("app", "UpdatePlaylistItemRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let playlist_item_id = message.data.playlist_item.playlist_item_id;
                    let playlist_item = database.playlist_items.lookup(playlist_item_id);
                    let playlist = database.playlists.lookup(playlist_item.playlist_id);
                    if (playlist.user_id !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    let number = message.data.playlist_item.number;
                    let playlist_items = database.getPlaylistsItemsFromPlaylist.lookup(playlist.playlist_id)
                        .sort(jsondb.NumericSort.increasing((record) => record.number))
                        .collect();
                    if (number < 1 || number > playlist_items.length) {
                        errors.push(`Expected a position between ${1} and ${playlist_items.length} (${number})!`);
                    }
                    this.tss.respond(message, "UpdatePlaylistItemResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let old_index = number - 1;
                    let new_index = message.data.playlist_item.number - 1;
                    if (new_index > old_index) {
                        for (let i = old_index + 1; i < new_index; i++) {
                            let playlist_item = playlist_items[i];
                            playlist_item.number -= 1;
                            database.playlist_items.update(playlist_item);
                        }
                    }
                    else if (new_index < old_index) {
                        for (let i = new_index; i < old_index; i++) {
                            let playlist_item = playlist_items[i];
                            playlist_item.number += 1;
                            database.playlist_items.update(playlist_item);
                        }
                    }
                    playlist_item.number = number;
                    database.playlist_items.update({
                        ...playlist_item,
                        ...message.data.playlist_item
                    });
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("UpdatePlaylistItem", Array.from(session.connections), {
                        playlist_item: api.handler.lookupPlaylistItemBase(playlist_item.playlist_item_id, user_id)
                    });
                }
            });
        }
        getRequestHandler() {
            return this.tss.getRequestHandler();
        }
    }
    exports.PlaylistsServer = PlaylistsServer;
    ;
});
define("build/playlists/index", ["require", "exports", "build/playlists/client", "build/playlists/server", "build/playlists/schema/index"], function (require, exports, client, server, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    exports.client = client;
    exports.server = server;
    exports.schema = schema;
});
define("build/chromecast/protobuf", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeOptionalBuffer = exports.parseOptionalBuffer = exports.serializeRequiredBuffer = exports.parseRequiredBuffer = exports.serializeOptionalString = exports.parseOptionalString = exports.serializeRequiredString = exports.parseRequiredString = exports.serializeRequiredEnum = exports.parseRequiredEnum = exports.parseFields = exports.serializeField = exports.parseField = exports.serializeKey = exports.parseKey = exports.makeUInt64LE = exports.serializeVarint = exports.parseVarint = exports.WireType = exports.readBytes = exports.numberFromBigInt = void 0;
    function numberFromBigInt(bigint) {
        if (bigint > Number.MAX_SAFE_INTEGER || bigint < Number.MIN_SAFE_INTEGER) {
            throw `Expected a safe integer but got ${bigint}!`;
        }
        return Number(bigint);
    }
    exports.numberFromBigInt = numberFromBigInt;
    ;
    function readBytes(state, length) {
        let remaining = state.buffer.length - state.offset;
        if (length > remaining) {
            throw `Expected to read at most ${remaining} bytes but attempted to read ${length} bytes!`;
        }
        let buffer = state.buffer.slice(state.offset, state.offset + length);
        state.offset += length;
        return buffer;
    }
    exports.readBytes = readBytes;
    ;
    var WireType;
    (function (WireType) {
        WireType[WireType["VARINT"] = 0] = "VARINT";
        WireType[WireType["FIXED_64_BIT"] = 1] = "FIXED_64_BIT";
        WireType[WireType["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
        WireType[WireType["START_GROUP"] = 3] = "START_GROUP";
        WireType[WireType["END_GROUP"] = 4] = "END_GROUP";
        WireType[WireType["FIXED_32_BIT"] = 5] = "FIXED_32_BIT";
    })(WireType = exports.WireType || (exports.WireType = {}));
    ;
    function parseVarint(state) {
        let bytes = Buffer.alloc(10);
        for (let i = 0; i < 10; i++) {
            let byte = state.buffer.readUInt8(state.offset);
            state.offset += 1;
            bytes[i] = byte;
            if ((byte & 0x80) === 0) {
                if (i + 1 === 10) {
                    if ((byte & 0x7E) !== 0) {
                        throw "Expected a varint of at most 64 bits!";
                    }
                }
                let value = BigInt(0);
                for (let j = i; j >= 0; j--) {
                    value = (value << BigInt(7)) | BigInt(bytes[j] & 0x7F);
                }
                let buffer = Buffer.alloc(8);
                buffer.writeBigUInt64LE(value, 0);
                return buffer;
            }
        }
        throw "Expected a varint of at most 10 bytes!";
    }
    exports.parseVarint = parseVarint;
    ;
    function serializeVarint(buffer) {
        let bigint = buffer.readBigUInt64LE(0);
        let result = Buffer.alloc(10);
        for (let i = 0; i < 10; i++) {
            let byte = (bigint & BigInt(0x7F));
            bigint = (bigint >> BigInt(7));
            if (bigint > 0) {
                result.writeUInt8(numberFromBigInt(byte) | 0x80, i);
            }
            else {
                result.writeUInt8(numberFromBigInt(byte) | 0x00, i);
                return result.slice(0, i + 1);
            }
        }
        throw "Expected to serialize at most 10 bytes!";
    }
    exports.serializeVarint = serializeVarint;
    ;
    function makeUInt64LE(number) {
        let buffer = Buffer.alloc(8);
        buffer.writeBigUInt64LE(BigInt(number));
        return buffer;
    }
    exports.makeUInt64LE = makeUInt64LE;
    ;
    function parseKey(state) {
        let bigint = parseVarint(state).readBigUInt64LE(0);
        let field_number = numberFromBigInt(bigint >> BigInt(3));
        let wire_type = numberFromBigInt(bigint & BigInt(0x07));
        return {
            field_number,
            wire_type
        };
    }
    exports.parseKey = parseKey;
    ;
    function serializeKey(key) {
        let bigint = (BigInt(key.field_number) << BigInt(3)) | (BigInt(key.wire_type) & BigInt(0x07));
        let buffer = Buffer.alloc(8);
        buffer.writeBigUInt64LE(bigint, 0);
        return serializeVarint(buffer);
    }
    exports.serializeKey = serializeKey;
    ;
    function parseField(state) {
        let key = parseKey(state);
        if (key.wire_type === WireType.VARINT) {
            let data = parseVarint(state);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.FIXED_64_BIT) {
            let data = readBytes(state, 8);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.LENGTH_DELIMITED) {
            let bigint = parseVarint(state).readBigUInt64LE(0);
            let length = numberFromBigInt(bigint);
            let data = readBytes(state, length);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.START_GROUP) {
            let data = Buffer.alloc(0);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.END_GROUP) {
            let data = Buffer.alloc(0);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.FIXED_32_BIT) {
            let data = readBytes(state, 4);
            return {
                key,
                data
            };
        }
        throw "Expected a recognized wire type!";
    }
    exports.parseField = parseField;
    ;
    function serializeField(field) {
        if (field.key.wire_type === WireType.VARINT) {
            return Buffer.concat([
                serializeKey(field.key),
                serializeVarint(field.data)
            ]);
        }
        if (field.key.wire_type === WireType.FIXED_64_BIT) {
            if (field.data.length !== 8) {
                throw `Expected to serialize exactly 8 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.LENGTH_DELIMITED) {
            let length = Buffer.alloc(8);
            length.writeBigUInt64LE(BigInt(field.data.length));
            return Buffer.concat([
                serializeKey(field.key),
                serializeVarint(length),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.START_GROUP) {
            if (field.data.length !== 0) {
                throw `Expected to serialize exactly 0 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.END_GROUP) {
            if (field.data.length !== 0) {
                throw `Expected to serialize exactly 0 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.FIXED_32_BIT) {
            if (field.data.length !== 4) {
                throw `Expected to serialize exactly 4 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        throw "Expected a recognized wire type!";
    }
    exports.serializeField = serializeField;
    ;
    function parseFields(state) {
        let fields = new Array();
        while (state.offset < state.buffer.length) {
            let field = parseField(state);
            fields.push(field);
        }
        return fields;
    }
    exports.parseFields = parseFields;
    ;
    function parseRequiredEnum(field_number, fields) {
        let candidates = fields.filter((field) => field.key.field_number === field_number);
        if (candidates.length === 0) {
            throw `Expected required field to be present!`;
        }
        let field = candidates[candidates.length - 1];
        let value = numberFromBigInt(field.data.readBigUInt64LE(0));
        return value;
    }
    exports.parseRequiredEnum = parseRequiredEnum;
    ;
    function serializeRequiredEnum(field_number, value) {
        let key = {
            field_number,
            wire_type: WireType.VARINT
        };
        let data = makeUInt64LE(value);
        return serializeField({
            key,
            data
        });
    }
    exports.serializeRequiredEnum = serializeRequiredEnum;
    ;
    function parseRequiredString(field_number, fields) {
        let candidates = fields.filter((field) => field.key.field_number === field_number);
        if (candidates.length === 0) {
            throw `Expected required field to be present!`;
        }
        let field = candidates[candidates.length - 1];
        let value = field.data.toString();
        return value;
    }
    exports.parseRequiredString = parseRequiredString;
    ;
    function serializeRequiredString(field_number, value) {
        let key = {
            field_number,
            wire_type: WireType.LENGTH_DELIMITED
        };
        let data = Buffer.from(value);
        return serializeField({
            key,
            data
        });
    }
    exports.serializeRequiredString = serializeRequiredString;
    ;
    function parseOptionalString(field_number, fields) {
        try {
            return parseRequiredString(field_number, fields);
        }
        catch (error) {
            return undefined;
        }
    }
    exports.parseOptionalString = parseOptionalString;
    ;
    function serializeOptionalString(field_number, value) {
        if (value == null) {
            return Buffer.alloc(0);
        }
        return serializeRequiredString(field_number, value);
    }
    exports.serializeOptionalString = serializeOptionalString;
    ;
    function parseRequiredBuffer(field_number, fields) {
        let candidates = fields.filter((field) => field.key.field_number === field_number);
        if (candidates.length === 0) {
            throw `Expected required field to be present!`;
        }
        let field = candidates[candidates.length - 1];
        let value = field.data;
        return value;
    }
    exports.parseRequiredBuffer = parseRequiredBuffer;
    ;
    function serializeRequiredBuffer(field_number, value) {
        let key = {
            field_number,
            wire_type: WireType.LENGTH_DELIMITED
        };
        let data = value;
        return serializeField({
            key,
            data
        });
    }
    exports.serializeRequiredBuffer = serializeRequiredBuffer;
    ;
    function parseOptionalBuffer(field_number, fields) {
        try {
            return parseRequiredBuffer(field_number, fields);
        }
        catch (error) {
            return undefined;
        }
    }
    exports.parseOptionalBuffer = parseOptionalBuffer;
    ;
    function serializeOptionalBuffer(field_number, value) {
        if (value == null) {
            return Buffer.alloc(0);
        }
        return serializeRequiredBuffer(field_number, value);
    }
    exports.serializeOptionalBuffer = serializeOptionalBuffer;
    ;
});
define("build/chromecast/cast_message", ["require", "exports", "build/chromecast/protobuf"], function (require, exports, protobuf) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeCastMessage = exports.parseCastMessage = exports.PayloadType = exports.ProtocolVersion = void 0;
    var ProtocolVersion;
    (function (ProtocolVersion) {
        ProtocolVersion[ProtocolVersion["CASTV2_1_0"] = 0] = "CASTV2_1_0";
    })(ProtocolVersion = exports.ProtocolVersion || (exports.ProtocolVersion = {}));
    ;
    var PayloadType;
    (function (PayloadType) {
        PayloadType[PayloadType["STRING"] = 0] = "STRING";
        PayloadType[PayloadType["BINARY"] = 1] = "BINARY";
    })(PayloadType = exports.PayloadType || (exports.PayloadType = {}));
    ;
    function parseCastMessage(buffer) {
        let fields = protobuf.parseFields({
            buffer: buffer,
            offset: 0
        });
        let protocol_version = protobuf.parseRequiredEnum(1, fields);
        let source_id = protobuf.parseRequiredString(2, fields);
        let destination_id = protobuf.parseRequiredString(3, fields);
        let namespace = protobuf.parseRequiredString(4, fields);
        let payload_type = protobuf.parseRequiredEnum(5, fields);
        let payload_utf8 = protobuf.parseOptionalString(6, fields);
        let payload_binary = protobuf.parseOptionalBuffer(7, fields);
        return {
            protocol_version,
            source_id,
            destination_id,
            namespace,
            payload_type,
            payload_utf8,
            payload_binary
        };
    }
    exports.parseCastMessage = parseCastMessage;
    ;
    function serializeCastMessage(message) {
        return Buffer.concat([
            protobuf.serializeRequiredEnum(1, message.protocol_version),
            protobuf.serializeRequiredString(2, message.source_id),
            protobuf.serializeRequiredString(3, message.destination_id),
            protobuf.serializeRequiredString(4, message.namespace),
            protobuf.serializeRequiredEnum(5, message.payload_type),
            protobuf.serializeOptionalString(6, message.payload_utf8),
            protobuf.serializeOptionalBuffer(7, message.payload_binary),
        ]);
    }
    exports.serializeCastMessage = serializeCastMessage;
    ;
});
define("build/mdns/index", ["require", "exports", "dgram", "build/is"], function (require, exports, libdgram, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observe = exports.sendDiscoveryPacket = void 0;
    const MDNS_ADDRESS = "224.0.0.251";
    const MDNS_PORT = 5353;
    let map = new Map();
    function parseName(buffer, offset) {
        let labels = new Array();
        while (true) {
            let length = buffer.readUInt8(offset);
            if (length === 0) {
                offset += 1;
                break;
            }
            if (length < 192) {
                offset += 1;
                let label = buffer.slice(offset, offset + length);
                offset += length;
                labels.push(label.toString());
                continue;
            }
            let name = parseName(buffer, buffer.readUInt16BE(offset) & 0x3FFF);
            labels.push(name.labels.join("."));
            offset += 2;
            break;
        }
        return {
            labels: labels,
            offset: offset
        };
    }
    ;
    var Type;
    (function (Type) {
        Type[Type["A"] = 1] = "A";
        Type[Type["PTR"] = 12] = "PTR";
        Type[Type["TXT"] = 16] = "TXT";
        Type[Type["SRV"] = 33] = "SRV";
    })(Type || (Type = {}));
    ;
    async function parseQuestion(packet, offset) {
        let name = await parseName(packet, offset);
        offset = name.offset;
        let type = packet.readUInt16BE(offset);
        offset += 2;
        let kind = packet.readUInt16BE(offset);
        offset += 2;
        return {
            value: name.labels.join("."),
            type,
            kind,
            offset
        };
    }
    ;
    function parseA(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let a = buffer.readUInt8(data_offset);
        data_offset += 1;
        let b = buffer.readUInt8(data_offset);
        data_offset += 1;
        let c = buffer.readUInt8(data_offset);
        data_offset += 1;
        let d = buffer.readUInt8(data_offset);
        data_offset += 1;
        let ipv4 = `${a}.${b}.${c}.${d}`;
        return {
            ipv4
        };
    }
    function parsePTR(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let to = parseName(buffer, data_offset);
        data_offset = to.offset;
        return {
            to: to.labels.join(".")
        };
    }
    function parseTXT(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let content = parseName(buffer, data_offset);
        return {
            content: content.labels
        };
    }
    function parseSRV(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let priority = buffer.readUInt16BE(data_offset);
        data_offset += 2;
        let weight = buffer.readUInt16BE(data_offset);
        data_offset += 2;
        let port = buffer.readUInt16BE(data_offset);
        data_offset += 2;
        let to = parseName(buffer, data_offset);
        data_offset = to.offset;
        return {
            priority,
            weight,
            port,
            to: to.labels.join(".")
        };
    }
    function parseAnswer(packet, offset) {
        let name = parseName(packet, offset);
        offset = name.offset;
        let type = packet.readUInt16BE(offset);
        offset += 2;
        let kind = packet.readUInt16BE(offset);
        offset += 2;
        let ttl = packet.readUInt32BE(offset);
        offset += 4;
        let data_length = packet.readUInt16BE(offset);
        offset += 2;
        let data_offset = offset;
        if (data_offset + data_length > packet.length) {
            throw `Invalid buffer length!`;
        }
        offset += data_length;
        return {
            name: name.labels.join("."),
            type,
            kind,
            ttl,
            packet,
            data_offset,
            data_length
        };
    }
    ;
    async function parsePacket(buffer) {
        let offset = 0;
        let header = buffer.slice(offset, offset + 12);
        offset += 12;
        let id = header.readUInt16BE(0);
        let flags = header.readUInt16BE(2);
        let qdcount = header.readUInt16BE(4);
        let ancount = header.readUInt16BE(6);
        let nscount = header.readUInt16BE(8);
        let arcount = header.readUInt16BE(10);
        let questions = new Array();
        for (let i = 0; i < qdcount; i++) {
            let result = await parseQuestion(buffer, offset);
            questions.push(result);
            offset = result.offset;
        }
        let answers = new Array();
        for (let i = 0; i < ancount; i++) {
            let result = await parseAnswer(buffer, offset);
            answers.push(result);
            offset = result.data_offset + result.data_length;
        }
        let authorities = new Array();
        for (let i = 0; i < nscount; i++) {
            let result = await parseAnswer(buffer, offset);
            authorities.push(result);
            offset = result.data_offset + result.data_length;
        }
        let additionals = new Array();
        for (let i = 0; i < arcount; i++) {
            let result = await parseAnswer(buffer, offset);
            additionals.push(result);
            offset = result.data_offset + result.data_length;
        }
        return {
            buffer,
            questions,
            answers,
            authorities,
            additionals
        };
    }
    ;
    function lookupDevice(device, packet) {
        for (let answer of [...packet.answers, ...packet.authorities, ...packet.additionals]) {
            if (answer.name === device.hostname) {
                if (answer.type === Type.TXT) {
                    try {
                        let record = parseTXT(answer);
                        device = {
                            ...device,
                            service_info: record.content
                        };
                    }
                    catch (error) { }
                }
            }
        }
        for (let answer of [...packet.answers, ...packet.authorities, ...packet.additionals]) {
            if (answer.name === device.hostname) {
                if (answer.type === Type.A) {
                    let record = parseA(answer);
                    device = {
                        ...device,
                        hostname: record.ipv4
                    };
                    return device;
                }
                else if (answer.type === Type.PTR) {
                    let record = parsePTR(answer);
                    device = {
                        ...device,
                        hostname: record.to
                    };
                    return lookupDevice(device, packet);
                }
                else if (answer.type === Type.SRV) {
                    let record = parseSRV(answer);
                    device = {
                        ...device,
                        hostname: record.to
                    };
                    return lookupDevice(device, packet);
                }
            }
        }
    }
    function notifyObservers(packet) {
        for (let answer of packet.answers) {
            let hostname = answer.name;
            let observers = map.get(hostname);
            if (is.present(observers)) {
                let device = lookupDevice({ hostname }, packet);
                if (is.present(device)) {
                    for (let observer of observers) {
                        observer(device);
                    }
                }
            }
        }
    }
    ;
    const socket = libdgram.createSocket({ type: "udp4", reuseAddr: true });
    socket.on("listening", () => {
        socket.setMulticastLoopback(false);
        socket.addMembership(MDNS_ADDRESS, "0.0.0.0");
    });
    socket.on("message", async (buffer) => {
        try {
            let packet = await parsePacket(buffer);
            notifyObservers(packet);
        }
        catch (error) {
            console.log(`Expected a valid DNS packet!`);
            console.log(error);
        }
    });
    socket.bind(MDNS_PORT);
    // TODO: Encode labels properly.
    function sendDiscoveryPacket(host) {
        let buffers = Array();
        let head = Buffer.alloc(12);
        head.writeUInt16BE(1, 4);
        buffers.push(head);
        for (let label of host.split(".")) {
            if (label.length >= 64) {
                throw `Expected a label with a length less than 64!`;
            }
            let buffer = Buffer.alloc(1 + label.length);
            buffer.writeUInt8(label.length, 0);
            buffer.write(label, 1);
            buffers.push(buffer);
        }
        let tail = Buffer.alloc(5);
        tail.writeUInt8(0, 0);
        tail.writeUInt16BE(12, 1);
        tail.writeUInt16BE(1, 3);
        buffers.push(tail);
        socket.send(Buffer.concat(buffers), MDNS_PORT, MDNS_ADDRESS);
    }
    exports.sendDiscoveryPacket = sendDiscoveryPacket;
    ;
    ;
    function observe(host, observer) {
        let observers = map.get(host);
        if (is.absent(observers)) {
            observers = new Set();
            map.set(host, observers);
        }
        observers.add(observer);
        sendDiscoveryPacket(host);
        return {
            cancel() {
                let observers = map.get(host);
                if (is.present(observers)) {
                    observers.delete(observer);
                    if (observers.size === 0) {
                        map.delete(host);
                    }
                }
            }
        };
    }
    exports.observe = observe;
    ;
});
define("build/chromecast/schema/connection/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.CLOSE = exports.CONNECT = void 0;
    exports.CONNECT = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("CONNECT")
    });
    exports.CLOSE = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("CLOSE")
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "CONNECT": autoguard.guards.Reference.of(() => exports.CONNECT),
            "CLOSE": autoguard.guards.Reference.of(() => exports.CLOSE)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/chromecast/schema/heartbeat/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.PONG = exports.PING = void 0;
    exports.PING = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("PING")
    });
    exports.PONG = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("PONG")
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "PING": autoguard.guards.Reference.of(() => exports.PING),
            "PONG": autoguard.guards.Reference.of(() => exports.PONG)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/chromecast/schema/objects/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.MediaStatus = exports.PhotoMediaMetadata = exports.MusicTrackMediaMetadata = exports.TvShowMediaMetadata = exports.MovieMediaMetadata = exports.GenericMediaMetadata = exports.MediaInformation = exports.Volume = exports.Image = void 0;
    exports.Image = autoguard.guards.Object.of({
        "url": autoguard.guards.String,
        "height": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "width": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined)
    });
    exports.Volume = autoguard.guards.Object.of({
        "level": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "muted": autoguard.guards.Union.of(autoguard.guards.Boolean, autoguard.guards.Undefined)
    });
    exports.MediaInformation = autoguard.guards.Object.of({
        "contentId": autoguard.guards.String,
        "streamType": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("NONE"), autoguard.guards.StringLiteral.of("BUFFERED"), autoguard.guards.StringLiteral.of("LIVE")),
        "contentType": autoguard.guards.String,
        "metadata": autoguard.guards.Union.of(autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.GenericMediaMetadata), autoguard.guards.Reference.of(() => exports.MovieMediaMetadata), autoguard.guards.Reference.of(() => exports.TvShowMediaMetadata), autoguard.guards.Reference.of(() => exports.MusicTrackMediaMetadata), autoguard.guards.Reference.of(() => exports.PhotoMediaMetadata)), autoguard.guards.Undefined),
        "duration": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined),
        "tracks": autoguard.guards.Union.of(autoguard.guards.Array.of(autoguard.guards.Group.of(autoguard.guards.Union.of(autoguard.guards.Object.of({
            "trackId": autoguard.guards.Number,
            "type": autoguard.guards.String
        }), autoguard.guards.Object.of({
            "trackId": autoguard.guards.Number,
            "type": autoguard.guards.StringLiteral.of("TEXT"),
            "trackType": autoguard.guards.StringLiteral.of("TEXT"),
            "trackContentId": autoguard.guards.String,
            "trackContentType": autoguard.guards.String,
            "subtype": autoguard.guards.StringLiteral.of("SUBTITLES"),
            "language": autoguard.guards.String,
            "name": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
            "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
        })))), autoguard.guards.Undefined)
    });
    exports.GenericMediaMetadata = autoguard.guards.Object.of({
        "metadataType": autoguard.guards.NumberLiteral.of(0),
        "title": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "subtitle": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "images": autoguard.guards.Union.of(autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Image)), autoguard.guards.Undefined),
        "releaseDate": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.MovieMediaMetadata = autoguard.guards.Object.of({
        "metadataType": autoguard.guards.NumberLiteral.of(1),
        "title": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "subtitle": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "studio": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "images": autoguard.guards.Union.of(autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Image)), autoguard.guards.Undefined),
        "releaseDate": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.TvShowMediaMetadata = autoguard.guards.Object.of({
        "metadataType": autoguard.guards.NumberLiteral.of(2),
        "seriesTitle": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "subtitle": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "season": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "episode": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "images": autoguard.guards.Union.of(autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Image)), autoguard.guards.Undefined),
        "originalAirDate": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.MusicTrackMediaMetadata = autoguard.guards.Object.of({
        "metadataType": autoguard.guards.NumberLiteral.of(3),
        "albumName": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "title": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "albumArtist": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "artist": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "composer": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "trackNumber": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "discNumber": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "images": autoguard.guards.Union.of(autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Image)), autoguard.guards.Undefined),
        "releaseDate": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.PhotoMediaMetadata = autoguard.guards.Object.of({
        "metadataType": autoguard.guards.NumberLiteral.of(4),
        "title": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "artist": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "location": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined),
        "latitude": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "longitude": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "width": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "height": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "creationDateTime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.Undefined)
    });
    exports.MediaStatus = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "media": autoguard.guards.Union.of(autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.MediaInformation), autoguard.guards.Object.of({})), autoguard.guards.Undefined),
        "playbackRate": autoguard.guards.Number,
        "playerState": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("IDLE"), autoguard.guards.StringLiteral.of("PLAYING"), autoguard.guards.StringLiteral.of("BUFFERING"), autoguard.guards.StringLiteral.of("PAUSED")),
        "idleReason": autoguard.guards.Union.of(autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("CANCELLED"), autoguard.guards.StringLiteral.of("INTERRUPTED"), autoguard.guards.StringLiteral.of("FINISHED"), autoguard.guards.StringLiteral.of("ERROR")), autoguard.guards.Undefined),
        "currentTime": autoguard.guards.Number,
        "supportedMediaCommands": autoguard.guards.Number,
        "volume": autoguard.guards.Reference.of(() => exports.Volume),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Image": autoguard.guards.Reference.of(() => exports.Image),
            "Volume": autoguard.guards.Reference.of(() => exports.Volume),
            "MediaInformation": autoguard.guards.Reference.of(() => exports.MediaInformation),
            "GenericMediaMetadata": autoguard.guards.Reference.of(() => exports.GenericMediaMetadata),
            "MovieMediaMetadata": autoguard.guards.Reference.of(() => exports.MovieMediaMetadata),
            "TvShowMediaMetadata": autoguard.guards.Reference.of(() => exports.TvShowMediaMetadata),
            "MusicTrackMediaMetadata": autoguard.guards.Reference.of(() => exports.MusicTrackMediaMetadata),
            "PhotoMediaMetadata": autoguard.guards.Reference.of(() => exports.PhotoMediaMetadata),
            "MediaStatus": autoguard.guards.Reference.of(() => exports.MediaStatus)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/chromecast/schema/media/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/chromecast/schema/objects/index", "build/chromecast/schema/objects/index", "build/chromecast/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2, objects_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.MEDIA_STATUS = exports.INVALID_REQUEST = exports.LOAD_CANCELLED = exports.LOAD_FAILED = exports.INVALID_PLAYER_STATE = exports.VOLUME = exports.GET_STATUS = exports.PLAY = exports.STOP = exports.SEEK = exports.PAUSE = exports.LOAD = void 0;
    exports.LOAD = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("LOAD"),
        "media": autoguard.guards.Reference.of(() => objects_1.MediaInformation),
        "autoplay": autoguard.guards.Union.of(autoguard.guards.Boolean, autoguard.guards.Undefined),
        "currentTime": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined),
        "activeTrackIds": autoguard.guards.Union.of(autoguard.guards.Array.of(autoguard.guards.Number), autoguard.guards.Undefined)
    });
    exports.PAUSE = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("PAUSE"),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    exports.SEEK = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("SEEK"),
        "resumeState": autoguard.guards.Union.of(autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("PLAYBACK_START"), autoguard.guards.StringLiteral.of("PLAYBACK_PAUSE")), autoguard.guards.Undefined),
        "currentTime": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    exports.STOP = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("STOP"),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    exports.PLAY = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("PLAY"),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    exports.GET_STATUS = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Union.of(autoguard.guards.Number, autoguard.guards.Undefined),
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("GET_STATUS"),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    exports.VOLUME = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("VOLUME"),
        "volume": autoguard.guards.Reference.of(() => objects_3.Volume),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    exports.INVALID_PLAYER_STATE = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("INVALID_PLAYER_STATE"),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    exports.LOAD_FAILED = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("LOAD_FAILED"),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    exports.LOAD_CANCELLED = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("LOAD_CANCELLED"),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    exports.INVALID_REQUEST = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("INVALID_REQUEST"),
        "reason": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("INVALID_COMMAND"), autoguard.guards.StringLiteral.of("DUPLICATE_REQUESTID")),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    exports.MEDIA_STATUS = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("MEDIA_STATUS"),
        "status": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.MediaStatus)),
        "customData": autoguard.guards.Union.of(autoguard.guards.Record.of(autoguard.guards.Any), autoguard.guards.Undefined)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "LOAD": autoguard.guards.Reference.of(() => exports.LOAD),
            "PAUSE": autoguard.guards.Reference.of(() => exports.PAUSE),
            "SEEK": autoguard.guards.Reference.of(() => exports.SEEK),
            "STOP": autoguard.guards.Reference.of(() => exports.STOP),
            "PLAY": autoguard.guards.Reference.of(() => exports.PLAY),
            "GET_STATUS": autoguard.guards.Reference.of(() => exports.GET_STATUS),
            "VOLUME": autoguard.guards.Reference.of(() => exports.VOLUME),
            "INVALID_PLAYER_STATE": autoguard.guards.Reference.of(() => exports.INVALID_PLAYER_STATE),
            "LOAD_FAILED": autoguard.guards.Reference.of(() => exports.LOAD_FAILED),
            "LOAD_CANCELLED": autoguard.guards.Reference.of(() => exports.LOAD_CANCELLED),
            "INVALID_REQUEST": autoguard.guards.Reference.of(() => exports.INVALID_REQUEST),
            "MEDIA_STATUS": autoguard.guards.Reference.of(() => exports.MEDIA_STATUS)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/chromecast/schema/receiver/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.RECEIVER_STATUS = exports.SET_VOLUME = exports.GET_APP_AVAILABILITY = exports.GET_STATUS = exports.STOP = exports.LAUNCH = void 0;
    exports.LAUNCH = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("LAUNCH"),
        "requestId": autoguard.guards.Number,
        "appId": autoguard.guards.String
    });
    exports.STOP = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("STOP"),
        "requestId": autoguard.guards.Number,
        "sessionId": autoguard.guards.String
    });
    exports.GET_STATUS = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("GET_STATUS"),
        "requestId": autoguard.guards.Number
    });
    exports.GET_APP_AVAILABILITY = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("GET_APP_AVAILABILITY"),
        "requestId": autoguard.guards.Number,
        "appId": autoguard.guards.Array.of(autoguard.guards.String)
    });
    exports.SET_VOLUME = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("SET_VOLUME"),
        "requestId": autoguard.guards.Number,
        "volume": autoguard.guards.Group.of(autoguard.guards.Union.of(autoguard.guards.Object.of({
            "level": autoguard.guards.Number
        }), autoguard.guards.Object.of({
            "muted": autoguard.guards.Boolean
        })))
    });
    exports.RECEIVER_STATUS = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("RECEIVER_STATUS"),
        "requestId": autoguard.guards.Number,
        "status": autoguard.guards.Object.of({
            "applications": autoguard.guards.Union.of(autoguard.guards.Array.of(autoguard.guards.Object.of({
                "appId": autoguard.guards.String,
                "displayName": autoguard.guards.String,
                "iconUrl": autoguard.guards.String,
                "isIdleScreen": autoguard.guards.Boolean,
                "launchedFromCloud": autoguard.guards.Boolean,
                "namespaces": autoguard.guards.Array.of(autoguard.guards.Object.of({
                    "name": autoguard.guards.String
                })),
                "sessionId": autoguard.guards.String,
                "statusText": autoguard.guards.String,
                "transportId": autoguard.guards.String
            })), autoguard.guards.Undefined),
            "userEq": autoguard.guards.Object.of({}),
            "volume": autoguard.guards.Object.of({
                "controlType": autoguard.guards.String,
                "level": autoguard.guards.Number,
                "muted": autoguard.guards.Boolean,
                "stepInterval": autoguard.guards.Number
            })
        })
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "LAUNCH": autoguard.guards.Reference.of(() => exports.LAUNCH),
            "STOP": autoguard.guards.Reference.of(() => exports.STOP),
            "GET_STATUS": autoguard.guards.Reference.of(() => exports.GET_STATUS),
            "GET_APP_AVAILABILITY": autoguard.guards.Reference.of(() => exports.GET_APP_AVAILABILITY),
            "SET_VOLUME": autoguard.guards.Reference.of(() => exports.SET_VOLUME),
            "RECEIVER_STATUS": autoguard.guards.Reference.of(() => exports.RECEIVER_STATUS)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/chromecast/schema/index", ["require", "exports", "build/chromecast/schema/connection/index", "build/chromecast/schema/heartbeat/index", "build/chromecast/schema/media/index", "build/chromecast/schema/objects/index", "build/chromecast/schema/receiver/index"], function (require, exports, connection, heartbeat, media, objects, receiver) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.receiver = exports.objects = exports.media = exports.heartbeat = exports.connection = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.receiver = exports.objects = exports.media = exports.heartbeat = exports.connection = void 0;
    exports.connection = connection;
    exports.heartbeat = heartbeat;
    exports.media = media;
    exports.objects = objects;
    exports.receiver = receiver;
});
define("build/languages", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pref = exports.db = void 0;
    const db = {
        eng: {
            title: "English",
            iso639_1: "en",
            iso3166_1: "US"
        },
        swe: {
            title: "Swedish",
            iso639_1: "sv",
            iso3166_1: "SE"
        },
        jpn: {
            title: "Japanese",
            iso639_1: "ja",
            iso3166_1: "JP"
        }
    };
    exports.db = db;
    const pref = [
        "swe",
        "eng",
        "jpn"
    ];
    exports.pref = pref;
});
define("build/chromecast/chromecasts", ["require", "exports", "tls", "build/chromecast/cast_message", "build/mdns/index", "build/chromecast/schema/index", "build/is", "build/languages", "build/observers/index", "build/player/client", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-sockets/dist/lib/index", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/api/schema/objects/index"], function (require, exports, libtls, cast_message, mdns, schema, is, languages, observers, libcontext, autoguard, sockets, stdlib, objects_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.discover = exports.observe = void 0;
    const DEBUG = false;
    function getLanguage(language) {
        let entry = languages.db[language ?? "eng"] ?? languages.db["eng"];
        return {
            language: [
                entry.iso639_1,
                entry.iso3166_1
            ].join("-"),
            name: entry.title
        };
    }
    function makeMediaInformation(item, media_server_host, token) {
        if (objects_1.Episode.is(item)) {
            let episode = item;
            let season = episode.season;
            let show = season.show;
            return {
                contentId: `${media_server_host}/api/files/${item.media.file_id}/?token=${token}`,
                contentType: episode.media.mime,
                streamType: "BUFFERED",
                metadata: {
                    metadataType: 0,
                    title: episode.title,
                    subtitle: show.title
                },
                tracks: episode.subtitles.map((subtitle, subtitleIndex) => ({
                    ...getLanguage(subtitle.language),
                    trackId: subtitleIndex,
                    type: "TEXT",
                    trackType: "TEXT",
                    trackContentId: `${media_server_host}/api/files/${subtitle.file_id}/?token=${token}`,
                    trackContentType: subtitle.mime,
                    subtype: "SUBTITLES"
                }))
            };
        }
        else if (objects_1.Movie.is(item)) {
            let movie = item;
            return {
                contentId: `${media_server_host}/api/files/${item.media.file_id}/?token=${token}`,
                contentType: movie.media.mime,
                streamType: "BUFFERED",
                metadata: {
                    metadataType: 0,
                    title: movie.title,
                    images: movie.artwork.map((image) => ({
                        url: `${media_server_host}/api/files/${image.file_id}/?token=${token}`
                    }))
                },
                tracks: movie.subtitles.map((subtitle, subtitleIndex) => ({
                    ...getLanguage(subtitle.language),
                    trackId: subtitleIndex,
                    type: "TEXT",
                    trackType: "TEXT",
                    trackContentId: `${media_server_host}/api/files/${subtitle.file_id}/?token=${token}`,
                    trackContentType: subtitle.mime,
                    subtype: "SUBTITLES"
                }))
            };
        }
        else if (objects_1.Track.is(item)) {
            let track = item;
            let disc = track.disc;
            let album = disc.album;
            return {
                contentId: `${media_server_host}/api/files/${item.media.file_id}/?token=${token}`,
                contentType: item.media.mime,
                streamType: "BUFFERED",
                metadata: {
                    metadataType: 0,
                    title: track.title,
                    subtitle: track.artists.map((artist) => artist.title).join(" \u00b7 "),
                    images: album.artwork.map((image) => ({
                        url: `${media_server_host}/api/files/${image.file_id}/?token=${token}`
                    }))
                }
            };
        }
        else {
            throw `Expected code to be unreachable!`;
        }
    }
    function getDeviceName(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "fn") {
                    return parts.slice(1).join("=");
                }
            }
        }
        return "Chromecast";
    }
    function getDeviceType(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "md") {
                    return parts.slice(1).join("=");
                }
            }
        }
        return "Generic Cast Device";
    }
    const connections = new Map();
    function observe(wss, media_server_host) {
        mdns.observe("_googlecast._tcp.local", async (service_device) => {
            try {
                let { hostname, service_info } = { ...service_device };
                let connection = connections.get(hostname);
                if (is.absent(connection)) {
                    let socket = libtls.connect({
                        host: hostname,
                        port: 8009,
                        rejectUnauthorized: false
                    });
                    connections.set(hostname, socket);
                    socket.on("secureConnect", () => {
                        console.log(`Connected to Cast device at ${hostname}.`);
                        let deviceName = getDeviceName(service_info ?? []);
                        let deviceType = getDeviceType(service_info ?? []);
                        new ChromecastPlayer(socket, wss, media_server_host, deviceName, deviceType);
                    });
                    socket.on("close", () => {
                        console.log(`Disconnected from Cast device at ${hostname}.`);
                        connections.delete(hostname);
                    });
                    socket.on("error", (error) => {
                        socket.destroy();
                    });
                }
            }
            catch (error) {
                console.log(error);
            }
        });
    }
    exports.observe = observe;
    ;
    function discover() {
        mdns.sendDiscoveryPacket("_googlecast._tcp.local");
    }
    exports.discover = discover;
    ;
    function unwrapPacketPayload(socket, onpayload) {
        let buffered = Buffer.alloc(0);
        let waiting_header = true;
        let bytes_required = 4;
        socket.on("data", (chunk) => {
            buffered = Buffer.concat([buffered, chunk]);
            while (buffered.length >= bytes_required) {
                let buffer = buffered.slice(0, bytes_required);
                buffered = buffered.slice(bytes_required);
                if (waiting_header) {
                    waiting_header = false;
                    bytes_required = buffer.readUInt32BE(0);
                }
                else {
                    waiting_header = true;
                    bytes_required = 4;
                    onpayload(buffer);
                }
            }
        });
    }
    class MessageHandler {
        socket;
        constructor(socket, onmessage) {
            this.socket = socket;
            unwrapPacketPayload(socket, (payload) => {
                try {
                    let message = cast_message.parseCastMessage(payload);
                    if (DEBUG && message.namespace !== HearbeatHandler.NAMESPACE) {
                        console.log("incoming", message);
                    }
                    onmessage(message);
                }
                catch (error) {
                    console.log(error);
                }
            });
        }
        getRequestId() {
            return Math.floor(Math.random() * 65536);
        }
        send(message) {
            if (DEBUG && message.namespace !== HearbeatHandler.NAMESPACE) {
                console.log("outgoing", message);
            }
            let buffer = cast_message.serializeCastMessage({
                protocol_version: message.protocol_version ?? cast_message.ProtocolVersion.CASTV2_1_0,
                source_id: message.source_id ?? "sender-0",
                destination_id: message.destination_id ?? "receiver-0",
                namespace: message.namespace,
                payload_type: message.payload_type ?? cast_message.PayloadType.STRING,
                payload_utf8: message.payload_utf8,
                payload_binary: message.payload_binary
            });
            let header = Buffer.alloc(4);
            header.writeUInt32BE(buffer.length, 0);
            this.socket.write(header);
            this.socket.write(buffer);
        }
    }
    class ConnectionHandler {
        static NAMESPACE = "urn:x-cast:com.google.cast.tp.connection";
        messageHandler;
        serializer;
        listeners;
        constructor(messageHandler) {
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.connection.Autoguard.Guards);
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                this.listeners.route(type, data);
            });
        }
        send(type, data, transportId) {
            this.messageHandler.send({
                namespace: ConnectionHandler.NAMESPACE,
                destination_id: transportId,
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    class HearbeatHandler {
        static NAMESPACE = "urn:x-cast:com.google.cast.tp.heartbeat";
        messageHandler;
        serializer;
        listeners;
        constructor(messageHandler) {
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.heartbeat.Autoguard.Guards);
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                this.listeners.route(type, data);
            });
        }
        send(type, data) {
            this.messageHandler.send({
                namespace: HearbeatHandler.NAMESPACE,
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    class MediaHandler {
        static NAMESPACE = "urn:x-cast:com.google.cast.media";
        messageHandler;
        serializer;
        callbacks;
        listeners;
        transportId = new observers.ObservableClass(undefined);
        mediaSessionId = new observers.ObservableClass(undefined);
        constructor(messageHandler) {
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.media.Autoguard.Guards);
            this.callbacks = new Map();
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            try {
                this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                    let callback = this.callbacks.get(data.requestId);
                    if (is.present(callback)) {
                        this.callbacks.delete(data.requestId);
                        callback(data);
                    }
                    this.listeners.route(type, data);
                });
            }
            catch (error) {
                console.log(JSON.stringify(data, null, 2));
            }
        }
        send(type, data, callback) {
            data.requestId = this.messageHandler.getRequestId();
            if (is.present(callback)) {
                this.callbacks.set(data.requestId, callback);
            }
            this.messageHandler.send({
                namespace: MediaHandler.NAMESPACE,
                destination_id: this.transportId.getState(),
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    class ReceiverHandler {
        static NAMESPACE = "urn:x-cast:com.google.cast.receiver";
        messageHandler;
        serializer;
        callbacks;
        listeners;
        constructor(messageHandler) {
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.receiver.Autoguard.Guards);
            this.callbacks = new Map();
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                let callback = this.callbacks.get(data.requestId);
                if (is.present(callback)) {
                    this.callbacks.delete(data.requestId);
                    callback(data);
                }
                this.listeners.route(type, data);
            });
        }
        send(type, data, callback) {
            data.requestId = this.messageHandler.getRequestId();
            if (is.present(callback)) {
                this.callbacks.set(data.requestId, callback);
            }
            this.messageHandler.send({
                namespace: ReceiverHandler.NAMESPACE,
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    const APPLICATION_ID = "CC1AD845";
    class ChromecastPlayer {
        socket;
        heartbeatHandler;
        connectionHandler;
        mediaHandler;
        receiverHandler;
        context;
        timer;
        setTimer() {
            if (is.present(this.timer)) {
                clearTimeout(this.timer);
                this.timer = undefined;
            }
            this.timer = setTimeout(() => {
                this.timer = undefined;
                this.heartbeatHandler.send("PING", {
                    type: "PING"
                });
                this.timer = setTimeout(() => {
                    this.socket.destroy();
                }, 5000);
            }, 5000);
        }
        constructor(socket, wss, media_server_host, device_name, device_type) {
            let messageHandler = new MessageHandler(socket, (message) => {
                let namespace = message.namespace;
                if (namespace === ConnectionHandler.NAMESPACE) {
                    this.connectionHandler.handle(message);
                }
                else if (namespace === HearbeatHandler.NAMESPACE) {
                    this.heartbeatHandler.handle(message);
                }
                else if (namespace === MediaHandler.NAMESPACE) {
                    this.mediaHandler.handle(message);
                }
                else if (namespace === ReceiverHandler.NAMESPACE) {
                    this.receiverHandler.handle(message);
                }
            });
            this.socket = socket;
            this.heartbeatHandler = new HearbeatHandler(messageHandler);
            this.connectionHandler = new ConnectionHandler(messageHandler);
            this.mediaHandler = new MediaHandler(messageHandler);
            this.receiverHandler = new ReceiverHandler(messageHandler);
            let url = `${wss ? "wss:" : "ws:"}//127.0.0.1/sockets/context/?protocol=cast&name=${encodeURIComponent(device_name)}&type=${encodeURIComponent(device_type)}`;
            this.context = new libcontext.ContextClient(url, (url) => new sockets.WebSocketClient(url));
            this.timer = undefined;
            socket.on("close", () => {
                if (is.present(this.timer)) {
                    clearTimeout(this.timer);
                }
                this.context.close();
            });
            this.connectionHandler.send("CONNECT", {
                type: "CONNECT"
            });
            this.connectionHandler.listeners.addObserver("CLOSE", (message) => {
                this.mediaHandler.transportId.updateState(undefined);
            });
            this.heartbeatHandler.listeners.addObserver("PING", (message) => {
                this.heartbeatHandler.send("PONG", {
                    "type": "PONG"
                });
            });
            this.heartbeatHandler.listeners.addObserver("PONG", (message) => {
                this.setTimer();
            });
            this.receiverHandler.listeners.addObserver("RECEIVER_STATUS", (message) => {
                let applications = message.status.applications ?? [];
                let application = applications.find((application) => {
                    return application.appId === APPLICATION_ID;
                });
                if (is.present(application)) {
                    this.mediaHandler.transportId.updateState(application.transportId);
                }
                else {
                    this.mediaHandler.transportId.updateState(undefined);
                }
            });
            this.mediaHandler.listeners.addObserver("MEDIA_STATUS", (message) => {
                let status = message.status[message.status.length - 1];
                if (is.present(status)) {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        if (status.mediaSessionId === mediaSessionId) {
                            if (this.context.isDeviceLocal.getState()) {
                                if (status.playerState === "IDLE" && status.idleReason === "FINISHED") {
                                    this.context.next();
                                }
                            }
                        }
                        else {
                            this.mediaHandler.mediaSessionId.updateState(undefined);
                        }
                    }
                }
            });
            this.setTimer();
            this.mediaHandler.transportId.addObserver((transportId) => {
                if (is.present(transportId)) {
                    this.connectionHandler.send("CONNECT", {
                        type: "CONNECT"
                    }, transportId);
                }
            });
            this.context.isDeviceLocal.addObserver((isDeviceLocal) => {
                if (isDeviceLocal) {
                    let transportId = this.mediaHandler.transportId.getState();
                    if (is.absent(transportId)) {
                        this.receiverHandler.send("LAUNCH", {
                            type: "LAUNCH",
                            requestId: -1,
                            appId: APPLICATION_ID
                        });
                    }
                }
                else {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        this.mediaHandler.send("STOP", {
                            type: "STOP",
                            requestId: -1,
                            mediaSessionId: mediaSessionId
                        });
                    }
                }
            });
            {
                let computer = () => {
                    let transportId = this.mediaHandler.transportId.getState();
                    let currentLocalEntry = this.context.currentLocalEntry.getState();
                    let token = this.context.token.getState();
                    if (is.present(transportId) && is.present(currentLocalEntry) && is.present(token)) {
                        let media = makeMediaInformation(currentLocalEntry, media_server_host, token);
                        let activeTrackIds;
                        if (is.present(media.tracks)) {
                            let swe = media.tracks.find((track) => {
                                return track.language === "sv-SE";
                            });
                            if (is.present(swe)) {
                                activeTrackIds = [swe.trackId];
                            }
                            else {
                                let eng = media.tracks.find((track) => {
                                    return track.language === "en-US";
                                });
                                if (is.present(eng)) {
                                    activeTrackIds = [eng.trackId];
                                }
                                else {
                                    let jpn = media.tracks.find((track) => {
                                        return track.language === "ja-JP";
                                    });
                                    if (is.present(jpn)) {
                                        activeTrackIds = [jpn.trackId];
                                    }
                                    else {
                                        if (media.tracks.length > 0) {
                                            activeTrackIds = [0];
                                        }
                                    }
                                }
                            }
                        }
                        this.mediaHandler.send("LOAD", {
                            type: "LOAD",
                            requestId: -1,
                            media: media,
                            autoplay: false,
                            activeTrackIds: activeTrackIds
                        }, (message) => {
                            if (schema.media.MEDIA_STATUS.is(message)) {
                                let status = message.status[message.status.length - 1];
                                if (is.present(status)) {
                                    this.mediaHandler.mediaSessionId.updateState(status.mediaSessionId);
                                }
                            }
                        });
                    }
                };
                this.mediaHandler.transportId.addObserver(computer);
                this.context.currentLocalEntry.addObserver(computer);
                this.context.token.addObserver(computer);
            }
            {
                // Transfer context when application is lost and device is local.
                this.mediaHandler.transportId.addObserver((transportId) => {
                    if (is.absent(transportId) && this.context.isDeviceLocal.getState()) {
                        this.context.transfer(undefined);
                    }
                });
            }
            {
                // Reset media session when application is lost.
                this.mediaHandler.transportId.addObserver((transportId) => {
                    if (is.absent(transportId)) {
                        this.mediaHandler.mediaSessionId.updateState(undefined);
                    }
                });
            }
            {
                // Handle playback changes when there is an active media session.
                let computer = () => {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        let playback = this.context.playback.getState();
                        if (playback) {
                            this.mediaHandler.send("PLAY", {
                                type: "PLAY",
                                requestId: -1,
                                mediaSessionId: mediaSessionId
                            });
                        }
                        else {
                            this.mediaHandler.send("PAUSE", {
                                type: "PAUSE",
                                requestId: -1,
                                mediaSessionId: mediaSessionId
                            });
                        }
                    }
                };
                this.mediaHandler.mediaSessionId.addObserver(computer);
                this.context.playback.addObserver(computer);
            }
            {
                // Handle progress changes when there is an active media session.
                let computer = () => {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        let progress = this.context.progress.getState() ?? 0;
                        this.mediaHandler.send("SEEK", {
                            type: "SEEK",
                            requestId: -1,
                            mediaSessionId: mediaSessionId,
                            currentTime: progress
                        });
                    }
                };
                this.mediaHandler.mediaSessionId.addObserver(computer);
                this.context.progress.addObserver(computer);
            }
        }
    }
});
define("build/airplay/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.StoppedEvent = exports.PausedEvent = exports.PlayingEvent = exports.LoadingEvent = void 0;
    exports.LoadingEvent = autoguard.guards.Object.of({
        "sessionID": autoguard.guards.Number,
        "state": autoguard.guards.StringLiteral.of("loading")
    });
    exports.PlayingEvent = autoguard.guards.Object.of({
        "sessionID": autoguard.guards.Number,
        "state": autoguard.guards.StringLiteral.of("playing")
    });
    exports.PausedEvent = autoguard.guards.Object.of({
        "sessionID": autoguard.guards.Number,
        "state": autoguard.guards.StringLiteral.of("paused")
    });
    exports.StoppedEvent = autoguard.guards.Object.of({
        "sessionID": autoguard.guards.Number,
        "state": autoguard.guards.StringLiteral.of("stopped"),
        "reason": autoguard.guards.String
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "LoadingEvent": autoguard.guards.Reference.of(() => exports.LoadingEvent),
            "PlayingEvent": autoguard.guards.Reference.of(() => exports.PlayingEvent),
            "PausedEvent": autoguard.guards.Reference.of(() => exports.PausedEvent),
            "StoppedEvent": autoguard.guards.Reference.of(() => exports.StoppedEvent)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/airplay/schema/index", ["require", "exports", "build/airplay/schema/messages/index"], function (require, exports, messages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.messages = void 0;
    exports.messages = messages;
});
define("build/airplay/api", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getServerInfo = exports.stop = exports.scrub = exports.rate = exports.play = void 0;
    function play(socket, session_id, url, progress_factor) {
        return socket.request({
            method: "POST",
            path: `/play`,
            headers: [
                { key: "Content-Type", value: "text/parameters" },
                { key: "X-Apple-Session-ID", value: session_id },
            ],
            body: Buffer.from([
                `Content-Location: ${url}`,
                `Start-Position: ${progress_factor}`,
                ``
            ].join("\n"))
        });
    }
    exports.play = play;
    ;
    function rate(socket, session_id, factor) {
        return socket.request({
            method: "POST",
            path: `/rate?value=${factor}`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.rate = rate;
    ;
    function scrub(socket, session_id, seconds) {
        return socket.request({
            method: "POST",
            path: `/scrub?position=${seconds}`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.scrub = scrub;
    ;
    function stop(socket, session_id) {
        return socket.request({
            method: "POST",
            path: `/stop`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.stop = stop;
    ;
    function getServerInfo(socket, session_id) {
        return socket.request({
            method: "GET",
            path: `/server-info`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.getServerInfo = getServerInfo;
    ;
});
define("build/airplay/http", ["require", "exports", "net", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/is"], function (require, exports, libnet, stdlib, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InboundSocket = exports.OutboundSocket = exports.serializeResponse = exports.parseResponse = exports.serializeRequest = exports.parseRequest = exports.serializeMessage = exports.parseMessage = void 0;
    function parseMessage(buffer) {
        let string = buffer.toString("binary");
        let lines = string.split("\r\n");
        let i = 0;
        let line = lines[i++];
        let headers = new Array();
        while (i < lines.length) {
            let line = lines[i++];
            if (line === "") {
                break;
            }
            let parts = line.split(": ");
            let key = parts[0];
            let value = parts.slice(1).join(": ");
            headers.push({
                key: Buffer.from(key, "binary").toString(),
                value: Buffer.from(value, "binary").toString()
            });
        }
        let body = Buffer.from(lines.slice(i).join("\r\n"), "binary");
        return {
            line: Buffer.from(line, "binary").toString(),
            headers,
            body
        };
    }
    exports.parseMessage = parseMessage;
    ;
    function serializeMessage(message) {
        let body = message.body ?? Buffer.alloc(0);
        let headers = [
            { key: "Content-Length", value: `${body.length}` },
            ...(message.headers ?? [])
        ];
        let head = Buffer.from([
            message.line,
            ...headers.map((header) => `${header.key}: ${header.value}`),
            ``,
            ``
        ].join("\r\n"));
        return Buffer.concat([head, body]);
    }
    exports.serializeMessage = serializeMessage;
    ;
    function parseRequest(buffer) {
        let message = parseMessage(buffer);
        let line = message.line;
        let parts = line.split(" ");
        if (parts.length !== 3) {
            throw `Expected three parts in request line!`;
        }
        return {
            method: parts[0],
            path: parts[1],
            version: parts[2],
            headers: message.headers,
            body: message.body
        };
    }
    exports.parseRequest = parseRequest;
    ;
    function serializeRequest(request) {
        return serializeMessage({
            line: `${request.method ?? "GET"} ${request.path ?? "/"} ${request.version ?? "HTTP/1.1"}`,
            headers: request.headers,
            body: request.body
        });
    }
    exports.serializeRequest = serializeRequest;
    ;
    function parseResponse(buffer) {
        let message = parseMessage(buffer);
        let line = message.line;
        let parts = line.split(" ");
        if (parts.length < 3) {
            throw `Expected at least three parts in response line!`;
        }
        if (!/^[1-9][0-9][0-9]$/.test(parts[1])) {
            throw `Expected a three-digit status!`;
        }
        return {
            version: parts[0],
            status: Number.parseInt(parts[1]),
            reason: parts.slice(2).join(" "),
            headers: message.headers,
            body: message.body
        };
    }
    exports.parseResponse = parseResponse;
    ;
    function serializeResponse(response) {
        return serializeMessage({
            line: `${response.version ?? "HTTP/1.1"} ${response.status ?? 200} ${response.reason ?? "OK"}`,
            headers: response.headers,
            body: response.body
        });
    }
    exports.serializeResponse = serializeResponse;
    ;
    class OutboundSocket extends stdlib.routing.MessageRouter {
        socket;
        constructor(options) {
            super();
            let socket = libnet.createConnection(options);
            socket.on("connect", () => {
            });
            socket.on("close", () => {
                this.route("close", {});
            });
            socket.on("error", () => {
                socket.destroy();
            });
            this.socket = socket;
        }
        close() {
            this.socket.destroy();
        }
        async request(request) {
            return new Promise((resolve, reject) => {
                this.socket.write(serializeRequest(request));
                let ondata = async (buffer) => {
                    this.socket.off("data", ondata);
                    let response = parseResponse(buffer);
                    resolve(response);
                };
                this.socket.on("data", ondata);
            });
        }
    }
    exports.OutboundSocket = OutboundSocket;
    ;
    class InboundSocket extends stdlib.routing.MessageRouter {
        socket;
        constructor(options, upgrade, handle) {
            super();
            let socket = libnet.createConnection(options);
            let ondata = (buffer) => {
                let response = parseResponse(buffer);
                if (response.status !== 101) {
                    return socket.emit("error", `Expected status 101!`);
                }
                let connection = response.headers.find((header) => header.key.toLowerCase() === "connection");
                if (is.absent(connection) || connection.value !== "Upgrade") {
                    return socket.emit("error", `Expected a valid connection header!`);
                }
                let upgrade = response.headers.find((header) => header.key.toLowerCase() === "upgrade");
                if (is.absent(upgrade) || upgrade.value !== "PTTH/1.0") {
                    return socket.emit("error", `Expected a valid upgrade header!`);
                }
                socket.off("data", ondata);
                socket.on("data", async (buffer) => {
                    try {
                        let request = parseRequest(buffer);
                        let response = await handle(request);
                        socket.write(serializeResponse(response));
                    }
                    catch (error) {
                        socket.emit("error", error);
                    }
                });
            };
            socket.on("data", ondata);
            socket.on("connect", () => {
                socket.write(serializeRequest({
                    ...upgrade,
                    headers: [
                        { key: "Connection", value: "Upgrade" },
                        { key: "Upgrade", value: "PTTH/1.0" },
                        ...(upgrade.headers ?? [])
                    ]
                }));
            });
            socket.on("close", () => {
                this.route("close", {});
            });
            socket.on("error", () => {
                socket.destroy();
            });
            this.socket = socket;
        }
        close() {
            this.socket.destroy();
        }
    }
    exports.InboundSocket = InboundSocket;
    ;
});
define("build/xml/index", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.XMLElement = exports.XMLAttribute = exports.XMLText = exports.XMLNode = exports.expect = exports.Tokenizer = void 0;
    const MATCHERS = {
        "WS": /^([\t\r\n ]+)/isu,
        "<": /^([<])/isu,
        ">": /^([>])/isu,
        "!": /^([!])/isu,
        "?": /^([?])/isu,
        "=": /^([=])/isu,
        "</": /^([<][/])/isu,
        "/>": /^([/][>])/isu,
        "IDENTIFIER": /^([a-z][a-z0-9_-]*)/isu,
        "STRING_LITERAL": /^("[^"]*")/isu,
        "TEXT_NODE": /^([^<>]+)[<]/isu
    };
    class Tokenizer {
        tokens;
        offset;
        peek() {
            return this.tokens[this.offset];
        }
        read() {
            if (this.offset >= this.tokens.length) {
                throw `Unexpectedly reached end of stream!`;
            }
            return this.tokens[this.offset++];
        }
        constructor(string) {
            let tokens = new Array();
            let row = 1;
            let col = 1;
            while (string.length > 0) {
                let token;
                for (let key in MATCHERS) {
                    let type = key;
                    let exec = MATCHERS[type].exec(string);
                    if (is.absent(exec)) {
                        continue;
                    }
                    if (is.absent(token) || (exec[1].length > token[1].length)) {
                        token = [type, exec[1]];
                    }
                }
                if (is.absent(token)) {
                    throw `Unrecognized token at row ${row}, col ${col}!`;
                }
                tokens.push({
                    type: token[0],
                    value: token[1],
                    row: row,
                    col: col
                });
                string = string.slice(token[1].length);
                let lines = token[1].split(/\r?\n/);
                if (lines.length > 1) {
                    row += lines.length - 1;
                    col = 1;
                }
                col += lines[lines.length - 1].length;
            }
            this.tokens = tokens.filter((token) => {
                return token.type !== "WS";
            });
            this.offset = 0;
        }
        newContext(producer) {
            let offset = this.offset;
            try {
                return producer(() => this.read(), () => this.peek());
            }
            catch (error) {
                this.offset = offset;
                throw error;
            }
        }
    }
    exports.Tokenizer = Tokenizer;
    ;
    function expect(token, family) {
        let families = Array.isArray(family) ? family : [family];
        if (!families.includes(token.type)) {
            throw `Unexpected ${token.type} at row ${token.row}, col ${token.col}!`;
        }
        return token;
    }
    exports.expect = expect;
    ;
    class XMLNode {
        asElement() {
            throw `Expected node to be an XMLElement!`;
        }
        isElement() {
            try {
                this.asElement();
                return true;
            }
            catch (error) { }
            return false;
        }
        asText() {
            throw `Expected node to be an XMLText!`;
        }
        isText() {
            try {
                this.asText();
                return true;
            }
            catch (error) { }
            return false;
        }
    }
    exports.XMLNode = XMLNode;
    ;
    function parseNode(tokenizer) {
        try {
            return parseElement(tokenizer);
        }
        catch (error) { }
        try {
            return parseText(tokenizer);
        }
        catch (error) { }
        return tokenizer.newContext((read, peek) => {
            let token = peek();
            if (is.present(token)) {
                throw `Unexpected ${token.type} at ${token.row}, ${token.col}!`;
            }
            else {
                throw `Unexpectedly reached end of stream!`;
            }
        });
    }
    class XMLText extends XMLNode {
        $value;
        constructor(value) {
            super();
            this.$value = value;
        }
        asText() {
            return this;
        }
        value() {
            return this.$value;
        }
    }
    exports.XMLText = XMLText;
    ;
    function parseText(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            let value = expect(read(), ["TEXT_NODE", "IDENTIFIER"]).value;
            return new XMLText(value);
        });
    }
    class XMLAttribute {
        $key;
        $value;
        constructor(key, value) {
            this.$key = key;
            this.$value = value;
        }
        key() {
            return this.$key;
        }
        value() {
            return this.$value;
        }
    }
    exports.XMLAttribute = XMLAttribute;
    ;
    function parseAttribute(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            let key = expect(read(), "IDENTIFIER").value;
            expect(read(), "=");
            let value = expect(read(), "STRING_LITERAL").value.slice(1, -1);
            return new XMLAttribute(key, value);
        });
    }
    class XMLArray {
        array;
        constructor(iterable) {
            this.array = Array.from(iterable);
        }
        get(index) {
            if (index < 0 || index >= this.array.length) {
                throw `Expected index ${index} to be between 0 and ${this.array.length}!`;
            }
            return this.array[index];
        }
        length() {
            return this.array.length;
        }
        [Symbol.iterator]() {
            return this.array[Symbol.iterator]();
        }
    }
    ;
    class XMLElement extends XMLNode {
        $tag;
        $attributes;
        $children;
        constructor(tag, attributes, children) {
            super();
            this.$tag = tag;
            this.$attributes = new XMLArray(attributes);
            this.$children = new XMLArray(children);
        }
        asElement() {
            return this;
        }
        tag(...expected) {
            let tag = this.$tag;
            if (!expected.includes(tag)) {
                throw `Expected tag to be one of [${expected.join(", ")}] but was ${tag}!`;
            }
            return tag;
        }
        attributes() {
            return this.$attributes;
        }
        children() {
            return this.$children;
        }
    }
    exports.XMLElement = XMLElement;
    ;
    function parseElement(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            expect(read(), "<");
            let tag = expect(read(), "IDENTIFIER").value;
            let attributes = new Array();
            while (peek()?.type !== ">" && peek()?.type !== "/>") {
                let attribute = parseAttribute(tokenizer);
                attributes.push(attribute);
            }
            let children = new Array();
            let token = expect(read(), [">", "/>"]);
            if (token.type === ">") {
                while (peek()?.type !== "</") {
                    let child = parseNode(tokenizer);
                    children.push(child);
                }
                expect(read(), "</");
                if (expect(read(), "IDENTIFIER").value !== tag) {
                    throw ``;
                }
                expect(read(), ">");
            }
            return new XMLElement(tag, attributes, children);
        });
    }
    function parseHeader(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            expect(read(), "<");
            expect(read(), "?");
            if (expect(read(), "IDENTIFIER").value !== "xml") {
                throw ``;
            }
            if (expect(read(), "IDENTIFIER").value !== "version") {
                throw ``;
            }
            expect(read(), "=");
            expect(read(), "STRING_LITERAL");
            if (expect(read(), "IDENTIFIER").value !== "encoding") {
                throw ``;
            }
            expect(read(), "=");
            expect(read(), "STRING_LITERAL");
            expect(read(), "?");
            expect(read(), ">");
        });
    }
    function parseDoctype(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            expect(read(), "<");
            expect(read(), "!");
            if (expect(read(), "IDENTIFIER").value !== "DOCTYPE") {
                throw ``;
            }
            let name = expect(read(), "IDENTIFIER").value;
            let access = expect(read(), "IDENTIFIER").value;
            let type = expect(read(), "STRING_LITERAL").value;
            let url = expect(read(), "STRING_LITERAL").value;
            expect(read(), ">");
        });
    }
    function parseDocument(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            let header = parseHeader(tokenizer);
            let doctype = parseDoctype(tokenizer);
            let root = parseElement(tokenizer);
            return {
                root
            };
        });
    }
    function parse(string) {
        let tokenizer = new Tokenizer(string.trim());
        return parseDocument(tokenizer);
    }
    exports.parse = parse;
});
define("build/airplay/plist", ["require", "exports", "build/xml/index"], function (require, exports, xml) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseFromString = void 0;
    function parseArray(element) {
        element.tag("array");
        let children = element.children();
        let array = [];
        for (let i = 0; i < children.length(); i += 1) {
            let value = children.get(i + 0).asElement();
            array.push(parseJSON(value));
        }
        return array;
    }
    function parseFalse(element) {
        element.tag("false");
        let children = element.children();
        if (children.length() !== 0) {
            throw `Expected exactly zero children!`;
        }
        return false;
    }
    function parseTrue(element) {
        element.tag("true");
        let children = element.children();
        if (children.length() !== 0) {
            throw `Expected exactly zero children!`;
        }
        return true;
    }
    function parseBoolean(element) {
        try {
            return parseFalse(element);
        }
        catch (error) { }
        try {
            return parseTrue(element);
        }
        catch (error) { }
        throw `Expected a boolean!`;
    }
    function parseInteger(element) {
        element.tag("integer");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        let number = Number.parseInt(text);
        if (Number.isNaN(number)) {
            throw `Expected an integer number!`;
        }
        return number;
    }
    function parseReal(element) {
        element.tag("real");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        let number = Number.parseFloat(text);
        if (Number.isNaN(number)) {
            throw `Expected a real-valued number!`;
        }
        return number;
    }
    function parseNumber(element) {
        try {
            return parseInteger(element);
        }
        catch (error) { }
        try {
            return parseReal(element);
        }
        catch (error) { }
        throw `Expected a number!`;
    }
    function parseKey(element) {
        element.tag("key");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        return text;
    }
    function parseObject(element) {
        element.tag("dict");
        let children = element.children();
        let object = {};
        for (let i = 0; i < children.length(); i += 2) {
            let key = children.get(i + 0).asElement();
            let value = children.get(i + 1).asElement();
            object[parseKey(key)] = parseJSON(value);
        }
        return object;
    }
    function parseString(element) {
        element.tag("string");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        return text;
    }
    function parseJSON(node) {
        try {
            return parseArray(node);
        }
        catch (error) { }
        try {
            return parseBoolean(node);
        }
        catch (error) { }
        try {
            return parseNumber(node);
        }
        catch (error) { }
        try {
            return parseObject(node);
        }
        catch (error) { }
        try {
            return parseString(node);
        }
        catch (error) { }
        throw `Expected a type!`;
    }
    function parseFromString(string) {
        let document = xml.parse(string);
        let root = document.root;
        root.tag("plist");
        let children = root.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        return parseJSON(children.get(0).asElement());
    }
    exports.parseFromString = parseFromString;
    ;
});
define("build/airplay/device", ["require", "exports", "crypto", "node_modules/@joelek/ts-sockets/dist/lib/index", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/player/client", "build/is", "build/observers/index", "build/airplay/schema/index", "build/airplay/api", "build/airplay/http", "build/airplay/plist"], function (require, exports, libcrypto, sockets, stdlib, player, is, observers, schema, api, http, plist) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Device = void 0;
    const PORT = 7000;
    function makeCorrelationID() {
        return [
            libcrypto.randomBytes(4).toString("hex"),
            libcrypto.randomBytes(2).toString("hex"),
            libcrypto.randomBytes(2).toString("hex"),
            libcrypto.randomBytes(2).toString("hex"),
            libcrypto.randomBytes(6).toString("hex")
        ].join("-");
    }
    class Device extends stdlib.routing.MessageRouter {
        constructor(host, wss, media_server_host, device_name, device_type) {
            super();
            let correlation_id = makeCorrelationID();
            let outbound = new http.OutboundSocket({ host: host, port: PORT });
            outbound.addObserver("close", () => {
                this.route("close", {});
            });
            api.getServerInfo(outbound, correlation_id).then(() => {
                let inbound = new http.InboundSocket({ host: host, port: PORT }, {
                    method: "POST",
                    path: "/reverse",
                    headers: [
                        { key: "X-Apple-Purpose", value: "event" },
                        { key: "X-Apple-Session-ID", value: correlation_id }
                    ]
                }, async (request) => {
                    let string = request.body.toString();
                    let document = plist.parseFromString(string);
                    if (schema.messages.PlayingEvent.is(document)) {
                        context.resume();
                    }
                    else if (schema.messages.PausedEvent.is(document)) {
                        context.pause();
                    }
                    else if (schema.messages.StoppedEvent.is(document) && document.reason === "ended") {
                        context.next();
                    }
                    return {
                        status: 200,
                        reason: "OK"
                    };
                });
                inbound.addObserver("close", () => {
                    this.route("close", {});
                });
                let url = `${wss ? "wss:" : "ws:"}//127.0.0.1/sockets/context/?protocol=airplay&name=${encodeURIComponent(device_name)}&type=${encodeURIComponent(device_type)}`;
                let context = new player.ContextClient(url, (url) => new sockets.WebSocketClient(url));
                observers.computed(async (currentLocalEntry, token) => {
                    if (is.present(currentLocalEntry) && is.present(token)) {
                        let url = `${media_server_host}/api/files/${currentLocalEntry.media.file_id}/?token=${token}`;
                        await api.play(outbound, correlation_id, url, 0.0);
                    }
                    else {
                        await api.stop(outbound, correlation_id);
                    }
                }, context.currentLocalEntry, context.token);
                observers.computed(async (currentLocalEntry, progress) => {
                    if (is.present(currentLocalEntry) && is.present(progress)) {
                        await api.scrub(outbound, correlation_id, progress);
                    }
                }, context.currentLocalEntry, context.progress);
                observers.computed(async (playback) => {
                    await api.rate(outbound, correlation_id, playback ? 1.0 : 0.0);
                }, context.playback);
                this.addObserver("close", () => {
                    context.close();
                    outbound.close();
                    inbound.close();
                });
            });
        }
    }
    exports.Device = Device;
    ;
});
define("build/airplay/index", ["require", "exports", "build/mdns/index", "build/is", "build/airplay/device"], function (require, exports, mdns, is, device_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.discover = exports.observe = void 0;
    const devices = new Map();
    function getDeviceName(service_info) {
        let last = service_info[service_info.length - 1];
        if (is.present(last)) {
            let parts = /^([^.]+)[.]_airplay[.]_tcp[.]local$/.exec(last);
            if (is.present(parts)) {
                return parts[1];
            }
        }
        return "AirPlay";
    }
    function getDeviceType(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "model") {
                    return parts.slice(1).join("=");
                }
            }
        }
        return "Generic AirPlay Device";
    }
    function isProtocolSupported(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "protovers") {
                    return parts.slice(1).join("=") === "1.0";
                }
            }
        }
        return true;
    }
    function observe(wss, media_server_host) {
        mdns.observe("_airplay._tcp.local", async (service_device) => {
            try {
                let { hostname, service_info } = { ...service_device };
                let device = devices.get(hostname);
                if (is.absent(device) && isProtocolSupported(service_info ?? [])) {
                    let device_name = getDeviceName(service_info ?? []);
                    let device_type = getDeviceType(service_info ?? []);
                    let device = new device_1.Device(hostname, wss, media_server_host, device_name, device_type);
                    devices.set(hostname, device);
                    device.addObserver("close", function onclose() {
                        device.removeObserver("close", onclose);
                        devices.delete(hostname);
                    });
                }
            }
            catch (error) {
                console.log(error);
            }
        });
    }
    exports.observe = observe;
    ;
    function discover() {
        mdns.sendDiscoveryPacket("_airplay._tcp.local");
    }
    exports.discover = discover;
    ;
});
define("build/server/server", ["require", "exports", "fs", "http", "https", "os", "build/api/api", "build/database/indexer", "build/server/subsearch", "build/player/index", "build/playlists/index", "build/chromecast/chromecasts", "build/airplay/index", "build/is", "build/config/index"], function (require, exports, libfs, libhttp, libhttps, libos, api, indexer, subsearch, context, playlists, chromecasts, airplay, is, config_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    const contextServer = new context.server.ContextServer();
    const playlistsServer = new playlists.server.PlaylistsServer();
    let indexTimer;
    function setupIndexTimer() {
        if (is.present(indexTimer)) {
            clearTimeout(indexTimer);
        }
        indexTimer = setTimeout(() => {
            indexTimer = undefined;
            indexer.runIndexer();
        }, 60 * 60 * 1000);
    }
    async function requestHandler(request, response) {
        let host = request.headers["host"] || "";
        let method = request.method || "";
        let path = request.url || "";
        if (/^[/]sockets[/]context[/]/.test(path)) {
            return contextServer.getRequestHandler()(request, response);
        }
        if (/^[/]sockets[/]playlists[/]/.test(path)) {
            return playlistsServer.getRequestHandler()(request, response);
        }
        let startMs = Date.now();
        response.on("finish", () => {
            let duration_ms = Date.now() - startMs;
            process.stderr.write(`${response.statusCode} ${method}:${path} (${duration_ms} ms)\n`);
            setupIndexTimer();
        });
        if (false && /^[0-9]+[.][0-9]+[.][0-9]+[.][0-9]+(:[0-9]+)?$/.test(host)) {
            response.writeHead(400);
            response.end();
            return;
        }
        let parts;
        if (method === 'GET' && path === '/favicon.ico') {
            response.writeHead(404);
            response.end();
            return;
        }
        if (method === "POST" && path === "/discover") {
            airplay.discover();
            chromecasts.discover();
            response.writeHead(200);
            return response.end("{}");
        }
        if (/^[/]media[/]/.test(path)) {
            if ((parts = /^[/]media[/]stills[/]([0-9a-f]{16})[/]/.exec(path)) != null) {
                let file_id = parts[1];
                let file = indexer.files.lookup(file_id);
                let filename = [".", "private", "stills", file.file_id];
                if (libfs.existsSync(filename.join("/"))) {
                    let stream = libfs.createReadStream(filename.join("/"));
                    stream.on("open", () => {
                        response.writeHead(200, {
                            "Access-Control-Allow-Origin": "*",
                            "Cache-Control": "public, max-age=86400",
                            "Content-Type": "image/jpeg"
                        });
                        stream.pipe(response);
                    });
                }
                else {
                    response.writeHead(404);
                    return response.end();
                }
                return;
            }
            if ((parts = /^[/]media[/]gifs[/]([0-9a-f]{16})[/]/.exec(path)) != null) {
                let cue_id = parts[1];
                let cue = indexer.cues.lookup(cue_id);
                let filename = [".", "private", "gifs", cue.cue_id];
                if (libfs.existsSync(filename.join("/"))) {
                    let stream = libfs.createReadStream(filename.join("/"));
                    stream.on("open", () => {
                        response.writeHead(200, {
                            "Access-Control-Allow-Origin": "*",
                            "Cache-Control": "public, max-age=86400",
                            "Content-Type": "image/gif"
                        });
                        stream.pipe(response);
                    });
                }
                else {
                    subsearch.generateMeme(filename, cue, () => {
                        if (!libfs.existsSync(filename.join("/"))) {
                            response.writeHead(500);
                            return response.end();
                        }
                        let stream = libfs.createReadStream(filename.join("/"));
                        stream.on("open", () => {
                            response.writeHead(200, {
                                "Access-Control-Allow-Origin": "*",
                                "Cache-Control": "public, max-age=86400",
                                "Content-Type": "image/gif"
                            });
                            stream.pipe(response);
                        });
                    });
                }
                return;
            }
        }
        if (/^[/]api[/]/.test(path)) {
            return api.server(request, response);
        }
        if (path === "/manifest.json") {
            response.writeHead(200, {
                "Content-Type": "application/json"
            });
            return response.end(JSON.stringify({
                "name": "Circus",
                "start_url": "/",
                "display": "standalone",
                "theme_color": "#df4f7f",
                "background_color": "#1f1f1f",
                "icons": []
            }));
        }
        if (path === "/logo.png") {
            response.writeHead(200, {
                "Content-Type": "image/png"
            });
            libfs.createReadStream("./public/logo.png").pipe(response);
            return;
        }
        if (path === "/backdrop.png") {
            response.writeHead(200, {
                "Content-Type": "image/png"
            });
            libfs.createReadStream("./public/backdrop.png").pipe(response);
            return;
        }
        if (method === 'GET') {
            response.writeHead(200);
            response.end(`<!doctype html><html><head><base href="/"/><meta charset="utf-8"/><meta content="https://circus.joelek.se/backdrop.png" property="og:image"/><meta content="Transform your media library into your personal streaming service." name="description"/><meta content="width=device-width,initial-scale=1.0" name="viewport"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /><link rel="apple-touch-icon" href="logo.png" /><link rel="manifest" href="/manifest.json"/><link href="https://fonts.googleapis.com/css2?family=Nunito&family=Pacifico&display=swap" rel="stylesheet"/><title>Circus</title></head><body><script>${libfs.readFileSync('./dist/client.min.js')}</script></body></html>`);
            return;
        }
        console.log('unhandled', JSON.stringify(request.headers, null, "\t"));
        response.writeHead(400);
        response.end();
        return;
    }
    if (!libfs.existsSync("./private/certs/")) {
        libfs.mkdirSync("./private/certs/", { recursive: true });
    }
    function read(path) {
        if (libfs.existsSync(path)) {
            return libfs.readFileSync(path);
        }
        return undefined;
    }
    function getLocalIp(family = "ipv4") {
        let networkInterfaces = libos.networkInterfaces();
        for (let interfaceInfos of Object.values(networkInterfaces)) {
            if (is.present(interfaceInfos)) {
                for (let interfaceInfo of interfaceInfos) {
                    if (interfaceInfo.internal === true) {
                        continue;
                    }
                    if (interfaceInfo.family.toLowerCase() === family.toLowerCase()) {
                        return interfaceInfo.address;
                    }
                }
            }
        }
        throw `Expected a local interface!`;
    }
    let full_chain = read(config_1.default.certificate_path.join("/"));
    let dhparam = read("./private/certs/dhparam.pem");
    let certificate_key = read(config_1.default.certificate_key_path.join("/"));
    // TODO: Use hostname from certificate.
    let hostname = getLocalIp();
    let media_server_host = `http://${hostname}`;
    let http_server = libhttp.createServer({}, requestHandler);
    http_server.listen(config_1.default.http_port, () => {
        console.log(`http://${hostname}:${config_1.default.http_port}`);
    });
    http_server.keepAliveTimeout = 60 * 1000;
    if (full_chain && certificate_key) {
        let https_server = libhttps.createServer({
            cert: full_chain,
            dhparam: dhparam,
            key: certificate_key
        }, requestHandler);
        https_server.listen(config_1.default.https_port, () => {
            console.log(`https://${hostname}:${config_1.default.https_port}`);
        });
        https_server.keepAliveTimeout = 60 * 1000;
        airplay.observe(true, media_server_host);
        chromecasts.observe(true, media_server_host);
    }
    else {
        airplay.observe(false, media_server_host);
        chromecasts.observe(false, media_server_host);
    }
    for (let key of indexer.getKeysFromUser.lookup(undefined)) {
        console.log(`Registration key available: ${key.key_id}`);
    }
});
function define(e,t,l){let n=define;function u(e){return require(e)}null==n.moduleStates&&(n.moduleStates=new Map),null==n.dependentsMap&&(n.dependentsMap=new Map);let d=n.moduleStates.get(e);if(null!=d)throw"Duplicate module found with name "+e+"!";d={callback:l,dependencies:t,module:null},n.moduleStates.set(e,d);for(let l of t){let t=n.dependentsMap.get(l);null==t&&(t=new Set,n.dependentsMap.set(l,t)),t.add(e)}!function e(t){let l=n.moduleStates.get(t);if(null==l||null!=l.module)return;let d=Array(),o={exports:{}};for(let e of l.dependencies){if("require"===e){d.push(u);continue}if("module"===e){d.push(o);continue}if("exports"===e){d.push(o.exports);continue}try{d.push(u(e));continue}catch(e){}let t=n.moduleStates.get(e);if(null==t||null==t.module)return;d.push(t.module.exports)}l.callback(...d),l.module=o;let p=n.dependentsMap.get(t);if(null!=p)for(let t of p)e(t)}(e)}