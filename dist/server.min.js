var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageSerializer = exports.MessageGuardError = exports.MessageGuardBase = void 0;
    ;
    class MessageGuardBase {
        constructor() { }
        is(subject, path) {
            try {
                this.as(subject, path);
                return true;
            }
            catch (error) {
                return false;
            }
        }
        decode(codec, buffer) {
            return this.as(codec.decode(buffer));
        }
        encode(codec, subject) {
            return codec.encode(this.as(subject));
        }
    }
    exports.MessageGuardBase = MessageGuardBase;
    ;
    class MessageGuardError {
        constructor(guard, subject, path) {
            this.guard = guard;
            this.subject = subject;
            this.path = path;
        }
        getSubjectType() {
            if (this.subject === null) {
                return "null";
            }
            if (this.subject instanceof Array) {
                return "array";
            }
            return typeof this.subject;
        }
        toString() {
            return `The type ${this.getSubjectType()} at ${this.path} is type-incompatible with the expected type: ${this.guard.ts()}`;
        }
    }
    exports.MessageGuardError = MessageGuardError;
    ;
    class MessageSerializer {
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let json = JSON.parse(string);
            if ((json != null) && (json.constructor === Object)) {
                if ((json.type != null) && (json.type.constructor === String)) {
                    let type = json.type;
                    let data = json.data;
                    let guard = this.guards[type];
                    if (guard === undefined) {
                        throw "Unknown message type \"" + type + "\"!";
                    }
                    cb(type, guard.as(data));
                    return;
                }
            }
            throw "Invalid message envelope!";
        }
        serialize(type, data) {
            return JSON.stringify({
                type,
                data
            });
        }
    }
    exports.MessageSerializer = MessageSerializer;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/guards", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization"], function (require, exports, serialization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Union = exports.UnionGuard = exports.Undefined = exports.UndefinedGuard = exports.Tuple = exports.TupleGuard = exports.StringLiteral = exports.StringLiteralGuard = exports.String = exports.StringGuard = exports.Reference = exports.ReferenceGuard = exports.Record = exports.RecordGuard = exports.Object = exports.ObjectGuard = exports.NumberLiteral = exports.NumberLiteralGuard = exports.Number = exports.NumberGuard = exports.Null = exports.NullGuard = exports.Intersection = exports.IntersectionGuard = exports.Group = exports.GroupGuard = exports.BooleanLiteral = exports.BooleanLiteralGuard = exports.Boolean = exports.BooleanGuard = exports.Binary = exports.BinaryGuard = exports.BigInt = exports.BigIntGuard = exports.Array = exports.ArrayGuard = exports.Any = exports.AnyGuard = void 0;
    class AnyGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            return subject;
        }
        ts(eol = "\n") {
            return "any";
        }
    }
    exports.AnyGuard = AnyGuard;
    ;
    exports.Any = new AnyGuard();
    class ArrayGuard extends serialization.MessageGuardBase {
        constructor(guard) {
            super();
            this.guard = guard;
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Array)) {
                for (let i = 0; i < subject.length; i++) {
                    this.guard.as(subject[i], path + "[" + i + "]");
                }
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return `array<${this.guard.ts(eol)}>`;
        }
    }
    exports.ArrayGuard = ArrayGuard;
    ;
    exports.Array = {
        of(guard) {
            return new ArrayGuard(guard);
        }
    };
    class BigIntGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.BigInt)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "bigint";
        }
    }
    exports.BigIntGuard = BigIntGuard;
    ;
    exports.BigInt = new BigIntGuard();
    class BinaryGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Uint8Array)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "binary";
        }
    }
    exports.BinaryGuard = BinaryGuard;
    ;
    exports.Binary = new BinaryGuard();
    class BooleanGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Boolean)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "boolean";
        }
    }
    exports.BooleanGuard = BooleanGuard;
    ;
    exports.Boolean = new BooleanGuard();
    class BooleanLiteralGuard extends serialization.MessageGuardBase {
        constructor(value) {
            super();
            this.value = value;
        }
        as(subject, path = "") {
            if (subject === this.value) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return `${this.value}`;
        }
    }
    exports.BooleanLiteralGuard = BooleanLiteralGuard;
    ;
    exports.BooleanLiteral = {
        of(value) {
            return new BooleanLiteralGuard(value);
        }
    };
    class GroupGuard extends serialization.MessageGuardBase {
        constructor(guard, name) {
            super();
            this.guard = guard;
            this.name = name;
        }
        as(subject, path = "") {
            return this.guard.as(subject, path);
        }
        ts(eol = "\n") {
            var _a;
            return (_a = this.name) !== null && _a !== void 0 ? _a : this.guard.ts(eol);
        }
    }
    exports.GroupGuard = GroupGuard;
    ;
    exports.Group = {
        of(guard, name) {
            return new GroupGuard(guard, name);
        }
    };
    class IntersectionGuard extends serialization.MessageGuardBase {
        constructor(...guards) {
            super();
            this.guards = guards;
        }
        as(subject, path = "") {
            for (let guard of this.guards) {
                guard.as(subject, path);
            }
            return subject;
        }
        ts(eol = "\n") {
            let lines = new globalThis.Array();
            for (let guard of this.guards) {
                lines.push("\t" + guard.ts(eol + "\t"));
            }
            return lines.length === 0 ? "intersection<>" : "intersection<" + eol + lines.join("," + eol) + eol + ">";
        }
    }
    exports.IntersectionGuard = IntersectionGuard;
    ;
    exports.Intersection = {
        of(...guards) {
            return new IntersectionGuard(...guards);
        }
    };
    class NullGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if (subject === null) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "null";
        }
    }
    exports.NullGuard = NullGuard;
    ;
    exports.Null = new NullGuard();
    class NumberGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Number)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "number";
        }
    }
    exports.NumberGuard = NumberGuard;
    ;
    exports.Number = new NumberGuard();
    class NumberLiteralGuard extends serialization.MessageGuardBase {
        constructor(value) {
            super();
            this.value = value;
        }
        as(subject, path = "") {
            if (subject === this.value) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return `${this.value}`;
        }
    }
    exports.NumberLiteralGuard = NumberLiteralGuard;
    ;
    exports.NumberLiteral = {
        of(value) {
            return new NumberLiteralGuard(value);
        }
    };
    class ObjectGuard extends serialization.MessageGuardBase {
        constructor(required, optional) {
            super();
            this.required = required;
            this.optional = optional;
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Object)) {
                for (let key in this.required) {
                    this.required[key].as(subject[key], path + (/^([a-z][a-z0-9_]*)$/isu.test(key) ? "." + key : "[\"" + key + "\"]"));
                }
                for (let key in this.optional) {
                    if (key in subject && subject[key] !== undefined) {
                        this.optional[key].as(subject[key], path + (/^([a-z][a-z0-9_]*)$/isu.test(key) ? "." + key : "[\"" + key + "\"]"));
                    }
                }
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            let lines = new globalThis.Array();
            for (let [key, value] of globalThis.Object.entries(this.required)) {
                lines.push(`\t"${key}": ${value.ts(eol + "\t")}`);
            }
            for (let [key, value] of globalThis.Object.entries(this.optional)) {
                lines.push(`\t"${key}"?: ${value.ts(eol + "\t")}`);
            }
            return lines.length === 0 ? "object<>" : "object<" + eol + lines.join("," + eol) + eol + ">";
        }
    }
    exports.ObjectGuard = ObjectGuard;
    ;
    exports.Object = {
        of(required, optional = {}) {
            return new ObjectGuard(required, optional);
        }
    };
    class RecordGuard extends serialization.MessageGuardBase {
        constructor(guard) {
            super();
            this.guard = guard;
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Object)) {
                let wrapped = exports.Union.of(exports.Undefined, this.guard);
                for (let key of globalThis.Object.keys(subject)) {
                    wrapped.as(subject[key], path + "[\"" + key + "\"]");
                }
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return `record<${this.guard.ts(eol)}>`;
        }
    }
    exports.RecordGuard = RecordGuard;
    ;
    exports.Record = {
        of(guard) {
            return new RecordGuard(guard);
        }
    };
    class ReferenceGuard extends serialization.MessageGuardBase {
        constructor(guard) {
            super();
            this.guard = guard;
        }
        as(subject, path = "") {
            return this.guard().as(subject, path);
        }
        ts(eol = "\n") {
            return this.guard().ts(eol);
        }
    }
    exports.ReferenceGuard = ReferenceGuard;
    ;
    exports.Reference = {
        of(guard) {
            return new ReferenceGuard(guard);
        }
    };
    class StringGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.String)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "string";
        }
    }
    exports.StringGuard = StringGuard;
    ;
    exports.String = new StringGuard();
    class StringLiteralGuard extends serialization.MessageGuardBase {
        constructor(value) {
            super();
            this.value = value;
        }
        as(subject, path = "") {
            if (subject === this.value) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return `"${this.value}"`;
        }
    }
    exports.StringLiteralGuard = StringLiteralGuard;
    ;
    exports.StringLiteral = {
        of(value) {
            return new StringLiteralGuard(value);
        }
    };
    class TupleGuard extends serialization.MessageGuardBase {
        constructor(...guards) {
            super();
            this.guards = guards;
        }
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Array)) {
                for (let i = 0; i < this.guards.length; i++) {
                    this.guards[i].as(subject[i], path + "[" + i + "]");
                }
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            let lines = new globalThis.Array();
            for (let guard of this.guards) {
                lines.push(`\t${guard.ts(eol + "\t")}`);
            }
            return lines.length === 0 ? "tuple<>" : "tuple<" + eol + lines.join("," + eol) + eol + ">";
        }
    }
    exports.TupleGuard = TupleGuard;
    ;
    exports.Tuple = {
        of(...guards) {
            return new TupleGuard(...guards);
        }
    };
    class UndefinedGuard extends serialization.MessageGuardBase {
        constructor() {
            super();
        }
        as(subject, path = "") {
            if (subject === undefined) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            return "undefined";
        }
    }
    exports.UndefinedGuard = UndefinedGuard;
    ;
    exports.Undefined = new UndefinedGuard();
    class UnionGuard extends serialization.MessageGuardBase {
        constructor(...guards) {
            super();
            this.guards = guards;
        }
        as(subject, path = "") {
            for (let guard of this.guards) {
                try {
                    return guard.as(subject, path);
                }
                catch (error) { }
            }
            throw new serialization.MessageGuardError(this, subject, path);
        }
        ts(eol = "\n") {
            let lines = new globalThis.Array();
            for (let guard of this.guards) {
                lines.push("\t" + guard.ts(eol + "\t"));
            }
            return lines.length === 0 ? "union<>" : "union<" + eol + lines.join("," + eol) + eol + ">";
        }
    }
    exports.UnionGuard = UnionGuard;
    ;
    exports.Union = {
        of(...guards) {
            return new UnionGuard(...guards);
        }
    };
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/api", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards"], function (require, exports, guards) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __asyncValues = (this && this.__asyncValues) || function (o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapMessageGuard = exports.deserializePayload = exports.deserializeStringPayload = exports.compareArrays = exports.serializePayload = exports.serializeStringPayload = exports.collectPayload = exports.deserializeValue = exports.serializeValue = exports.Headers = exports.Options = exports.JSON = exports.Primitive = exports.Binary = exports.SyncBinary = exports.AsyncBinary = exports.decodeUndeclaredHeaders = exports.decodeHeaderValue = exports.decodeHeaderValues = exports.decodeUndeclaredParameters = exports.decodeParameterValue = exports.decodeParameterValues = exports.encodeUndeclaredParameterPairs = exports.encodeParameterPairs = exports.escapeParameterValue = exports.escapeParameterKey = exports.encodeComponents = exports.escapeComponent = exports.encodeUndeclaredHeaderPairs = exports.encodeHeaderPairs = exports.escapeHeaderValue = exports.escapeHeaderKey = exports.splitHeaders = exports.combineParameters = exports.splitParameters = exports.combineComponents = exports.splitComponents = exports.decodeURIComponent = void 0;
    function decodeURIComponent(string) {
        try {
            return globalThis.decodeURIComponent(string);
        }
        catch (error) { }
    }
    exports.decodeURIComponent = decodeURIComponent;
    ;
    function splitComponents(url) {
        let components = new Array();
        for (let part of url.split("?")[0].split("/").slice(1)) {
            components.push(part);
        }
        return components;
    }
    exports.splitComponents = splitComponents;
    ;
    function combineComponents(components) {
        return "/" + components.join("/");
    }
    exports.combineComponents = combineComponents;
    ;
    function splitParameters(url) {
        let parameters = new Array();
        let query = url.split("?").slice(1).join("?");
        if (query !== "") {
            for (let part of query.split("&")) {
                let parts = part.split("=");
                if (parts.length === 1) {
                    let key = parts[0];
                    let value = "";
                    parameters.push([key, value]);
                }
                else {
                    let key = parts[0];
                    let value = parts.slice(1).join("=");
                    parameters.push([key, value]);
                }
            }
        }
        return parameters;
    }
    exports.splitParameters = splitParameters;
    ;
    function combineParameters(parameters) {
        let parts = parameters.map((parameters) => {
            let key = parameters[0];
            let value = parameters[1];
            return `${key}=${value}`;
        });
        if (parts.length === 0) {
            return "";
        }
        return `?${parts.join("&")}`;
    }
    exports.combineParameters = combineParameters;
    ;
    function splitHeaders(lines) {
        return lines.map((part) => {
            let parts = part.split(":");
            if (parts.length === 1) {
                let key = parts[0].toLowerCase();
                let value = "";
                return [key, value];
            }
            else {
                let key = parts[0].toLowerCase();
                let value = parts.slice(1).join(":").trim();
                return [key, value];
            }
        });
    }
    exports.splitHeaders = splitHeaders;
    ;
    const RFC7320_DELIMITERS = "\"(),/:;<=>?@[\\]{}";
    const RFC7320_WHITESPACE = "\t ";
    // The specification (rfc7320) allows octets 33-126 and forbids delimiters. Octets 128-255 have been deprecated since rfc2616.
    function escapeHeaderKey(string, alwaysEncode = "") {
        return escapeHeaderValue(string, RFC7320_DELIMITERS + RFC7320_WHITESPACE + alwaysEncode);
    }
    exports.escapeHeaderKey = escapeHeaderKey;
    ;
    // The specification (rfc7320) allows octets 33-126 and whitespace. Octets 128-255 have been deprecated since rfc2616.
    function escapeHeaderValue(string, alwaysEncode = "") {
        return [...string]
            .map((codePointString) => {
            var _a;
            if (!alwaysEncode.includes(codePointString) && codePointString !== "%") {
                let codePoint = (_a = codePointString.codePointAt(0)) !== null && _a !== void 0 ? _a : 0;
                if (codePoint >= 33 && codePoint <= 126) {
                    return codePointString;
                }
                if (RFC7320_WHITESPACE.includes(codePointString)) {
                    return codePointString;
                }
            }
            return encodeURIComponent(codePointString);
        })
            .join("");
    }
    exports.escapeHeaderValue = escapeHeaderValue;
    ;
    function encodeHeaderPairs(key, values, plain) {
        let pairs = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                if (plain) {
                    pairs.push([
                        escapeHeaderKey(key),
                        escapeHeaderValue(serialized)
                    ]);
                }
                else {
                    pairs.push([
                        escapeHeaderKey(key),
                        escapeHeaderKey(serialized)
                    ]);
                }
            }
        }
        return pairs;
    }
    exports.encodeHeaderPairs = encodeHeaderPairs;
    ;
    function encodeUndeclaredHeaderPairs(record, exclude) {
        let pairs = new Array();
        for (let [key, value] of Object.entries(record)) {
            if (!exclude.includes(key) && value !== undefined) {
                if (guards.String.is(value)) {
                    pairs.push(...encodeHeaderPairs(key, [value], true));
                }
                else if (guards.Array.of(guards.String).is(value)) {
                    pairs.push(...encodeHeaderPairs(key, value, true));
                }
                else {
                    throw `Expected type of undeclared header "${key}" to be string or string[]!`;
                }
            }
        }
        return pairs;
    }
    exports.encodeUndeclaredHeaderPairs = encodeUndeclaredHeaderPairs;
    ;
    function escapeComponent(string) {
        return encodeURIComponent(string);
    }
    exports.escapeComponent = escapeComponent;
    ;
    function encodeComponents(values, plain) {
        let array = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                array.push(escapeComponent(serialized));
            }
        }
        return array;
    }
    exports.encodeComponents = encodeComponents;
    ;
    function escapeParameterKey(string) {
        return encodeURIComponent(string);
    }
    exports.escapeParameterKey = escapeParameterKey;
    ;
    function escapeParameterValue(string) {
        return encodeURIComponent(string);
    }
    exports.escapeParameterValue = escapeParameterValue;
    ;
    function encodeParameterPairs(key, values, plain) {
        let pairs = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                pairs.push([
                    escapeParameterKey(key),
                    escapeParameterValue(serialized)
                ]);
            }
        }
        return pairs;
    }
    exports.encodeParameterPairs = encodeParameterPairs;
    ;
    function encodeUndeclaredParameterPairs(record, exclude) {
        let pairs = new Array();
        for (let [key, value] of Object.entries(record)) {
            if (!exclude.includes(key) && value !== undefined) {
                if (guards.String.is(value)) {
                    pairs.push(...encodeParameterPairs(key, [value], true));
                }
                else if (guards.Array.of(guards.String).is(value)) {
                    pairs.push(...encodeParameterPairs(key, value, true));
                }
                else {
                    throw `Expected type of undeclared parameter "${key}" to be string or string[]!`;
                }
            }
        }
        return pairs;
    }
    exports.encodeUndeclaredParameterPairs = encodeUndeclaredParameterPairs;
    ;
    function decodeParameterValues(pairs, key, plain) {
        let values = new Array();
        for (let pair of pairs) {
            if (key === decodeURIComponent(pair[0])) {
                let parts = pair[1].split(",");
                for (let part of parts) {
                    let value = deserializeValue(decodeURIComponent(part), plain);
                    if (value === undefined) {
                        throw `Expected parameter "${key}" to be properly encoded!`;
                    }
                    values.push(value);
                }
            }
        }
        return values;
    }
    exports.decodeParameterValues = decodeParameterValues;
    ;
    function decodeParameterValue(pairs, key, plain) {
        let values = decodeParameterValues(pairs, key, plain);
        if (values.length > 1) {
            throw `Expected no more than one "${key}" parameter!`;
        }
        return values[0];
    }
    exports.decodeParameterValue = decodeParameterValue;
    ;
    function decodeUndeclaredParameters(pairs, exclude) {
        let map = {};
        for (let pair of pairs) {
            let key = decodeURIComponent(pair[0]);
            let value = decodeURIComponent(pair[1]);
            if (key === undefined || value === undefined) {
                throw `Expected undeclared parameter "${key}" to be properly encoded!`;
            }
            if (!exclude.includes(key)) {
                let values = map[key];
                if (values === undefined) {
                    values = new Array();
                    map[key] = values;
                }
                values.push(value);
            }
        }
        let record = {};
        for (let [key, value] of Object.entries(map)) {
            if (value.length === 1) {
                record[key] = value[0];
            }
            else {
                record[key] = value;
            }
        }
        return record;
    }
    exports.decodeUndeclaredParameters = decodeUndeclaredParameters;
    ;
    function decodeHeaderValues(pairs, key, plain) {
        let values = new Array();
        for (let pair of pairs) {
            if (key === decodeURIComponent(pair[0])) {
                let parts = pair[1].split(",");
                for (let part of parts) {
                    let value = deserializeValue(decodeURIComponent(part.trim()), plain);
                    if (value === undefined) {
                        throw `Expected header "${key}" to be properly encoded!`;
                    }
                    values.push(value);
                }
            }
        }
        return values;
    }
    exports.decodeHeaderValues = decodeHeaderValues;
    ;
    function decodeHeaderValue(pairs, key, plain) {
        let values = decodeHeaderValues(pairs, key, plain);
        if (values.length > 1) {
            throw `Expected no more than one "${key}" header!`;
        }
        return values[0];
    }
    exports.decodeHeaderValue = decodeHeaderValue;
    ;
    function decodeUndeclaredHeaders(pairs, exclude) {
        let map = {};
        for (let pair of pairs) {
            let key = decodeURIComponent(pair[0]);
            let value = decodeURIComponent(pair[1]);
            if (key === undefined || value === undefined) {
                throw `Expected undeclared header "${key}" to be properly encoded!`;
            }
            if (!exclude.includes(key)) {
                let values = map[key];
                if (values === undefined) {
                    values = new Array();
                    map[key] = values;
                }
                values.push(value);
            }
        }
        let record = {};
        for (let [key, value] of Object.entries(map)) {
            if (value.length === 1) {
                record[key] = value[0];
            }
            else {
                record[key] = value;
            }
        }
        return record;
    }
    exports.decodeUndeclaredHeaders = decodeUndeclaredHeaders;
    ;
    exports.AsyncBinary = {
        as(subject, path = "") {
            if (subject != null) {
                let member = subject[Symbol.asyncIterator];
                if (member != null && member.constructor === globalThis.Function) {
                    return subject;
                }
            }
            throw "Expected AsyncBinary at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `AsyncBinary`;
        }
    };
    exports.SyncBinary = {
        as(subject, path = "") {
            if (subject != null) {
                let member = subject[Symbol.iterator];
                if (member != null && member.constructor === globalThis.Function) {
                    return subject;
                }
            }
            throw "Expected SyncBinary at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `SyncBinary`;
        }
    };
    exports.Binary = guards.Union.of(exports.AsyncBinary, exports.SyncBinary);
    exports.Primitive = guards.Union.of(guards.Boolean, guards.Number, guards.String, guards.Undefined);
    exports.JSON = guards.Group.of(guards.Union.of(guards.Boolean, guards.Null, guards.Number, guards.String, guards.Array.of(guards.Reference.of(() => exports.JSON)), guards.Record.of(guards.Reference.of(() => exports.JSON)), guards.Undefined), "JSON");
    exports.Options = guards.Record.of(exports.JSON);
    exports.Headers = guards.Record.of(exports.JSON);
    function serializeValue(value, plain) {
        if (value === undefined) {
            return;
        }
        return plain ? String(value) : globalThis.JSON.stringify(value);
    }
    exports.serializeValue = serializeValue;
    ;
    function deserializeValue(value, plain) {
        if (value === undefined || plain) {
            return value;
        }
        try {
            return globalThis.JSON.parse(value);
        }
        catch (error) { }
    }
    exports.deserializeValue = deserializeValue;
    ;
    function collectPayload(binary) {
        var binary_1, binary_1_1;
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            let chunks = new Array();
            let length = 0;
            try {
                for (binary_1 = __asyncValues(binary); binary_1_1 = yield binary_1.next(), !binary_1_1.done;) {
                    let chunk = binary_1_1.value;
                    chunks.push(chunk);
                    length += chunk.length;
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (binary_1_1 && !binary_1_1.done && (_a = binary_1.return))
                        yield _a.call(binary_1);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            let payload = new Uint8Array(length);
            let offset = 0;
            for (let chunk of chunks) {
                payload.set(chunk, offset);
                offset += chunk.length;
            }
            return payload;
        });
    }
    exports.collectPayload = collectPayload;
    ;
    function serializeStringPayload(string) {
        // @ts-ignore
        let encoder = new TextEncoder();
        let array = encoder.encode(string);
        return [array];
    }
    exports.serializeStringPayload = serializeStringPayload;
    ;
    function serializePayload(payload) {
        let serialized = serializeValue(payload, false);
        if (serialized === undefined) {
            return [];
        }
        return serializeStringPayload(serialized);
    }
    exports.serializePayload = serializePayload;
    ;
    function compareArrays(one, two) {
        if (one.length !== two.length) {
            return false;
        }
        for (let i = 0; i < one.length; i++) {
            if (one[i] !== two[i]) {
                return false;
            }
        }
        return true;
    }
    exports.compareArrays = compareArrays;
    ;
    function deserializeStringPayload(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            let buffer = yield collectPayload(binary);
            // @ts-ignore
            let decoder = new TextDecoder();
            let string = decoder.decode(buffer);
            // @ts-ignore
            let encoder = new TextEncoder();
            let encoded = encoder.encode(string);
            if (!compareArrays(buffer, encoded)) {
                throw `Expected payload to be UTF-8 encoded!`;
            }
            return string;
        });
    }
    exports.deserializeStringPayload = deserializeStringPayload;
    ;
    function deserializePayload(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            let string = yield deserializeStringPayload(binary);
            if (string === "") {
                return;
            }
            let value = deserializeValue(string, false);
            if (value === undefined) {
                throw `Expected payload to be JSON encoded!`;
            }
            return value;
        });
    }
    exports.deserializePayload = deserializePayload;
    ;
    function wrapMessageGuard(guard, log) {
        return Object.assign(Object.assign({}, guard), { as(subject, path) {
                if (log) {
                    console.log(subject);
                }
                return guard.as(subject, path);
            } });
    }
    exports.wrapMessageGuard = wrapMessageGuard;
    ;
});
define("node_modules/@joelek/bedrock/dist/lib/utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VarLength = exports.VarInteger = exports.VarCategory = exports.Chunk = exports.IntegerAssert = exports.Parser = void 0;
    class Parser {
        buffer;
        offset;
        constructor(buffer, offset) {
            this.buffer = buffer;
            this.offset = offset ?? 0;
        }
        chunk(length) {
            length = length ?? this.buffer.length - this.offset;
            if (this.offset + length > this.buffer.length) {
                throw `Expected to read at least ${length} bytes!`;
            }
            let buffer = this.buffer.slice(this.offset, this.offset + length);
            this.offset += length;
            return buffer;
        }
        eof() {
            return this.offset >= this.buffer.length;
        }
        signed(length, endian) {
            let value = this.unsigned(length, endian);
            let bias = 2 ** (length * 8 - 1);
            if (value >= bias) {
                value -= bias + bias;
            }
            return value;
        }
        try(supplier) {
            let offset = this.offset;
            try {
                return supplier(this);
            }
            catch (error) {
                this.offset = offset;
                throw error;
            }
        }
        tryArray(suppliers) {
            let offset = this.offset;
            for (let supplier of suppliers) {
                try {
                    return supplier(this);
                }
                catch (error) {
                    this.offset = offset;
                }
            }
            throw `Expected one supplier to succeed!`;
        }
        unsigned(length, endian) {
            IntegerAssert.between(1, length, 6);
            if (this.offset + length > this.buffer.length) {
                throw `Expected to read at least ${length} bytes!`;
            }
            if (endian === "little") {
                let value = 0;
                for (let i = length - 1; i >= 0; i--) {
                    value *= 256;
                    value += this.buffer[this.offset + i];
                }
                this.offset += length;
                return value;
            }
            else {
                let value = 0;
                for (let i = 0; i < length; i++) {
                    value *= 256;
                    value += this.buffer[this.offset + i];
                }
                this.offset += length;
                return value;
            }
        }
    }
    exports.Parser = Parser;
    ;
    class IntegerAssert {
        constructor() { }
        static atLeast(min, value) {
            this.integer(min);
            this.integer(value);
            if (value < min) {
                throw `Expected ${value} to be at least ${min}!`;
            }
            return value;
        }
        static atMost(max, value) {
            this.integer(value);
            this.integer(max);
            if (value > max) {
                throw `Expected ${value} to be at most ${max}!`;
            }
            return value;
        }
        static between(min, value, max) {
            this.integer(min);
            this.integer(value);
            this.integer(max);
            if (value < min || value > max) {
                throw `Expected ${value} to be between ${min} and ${max}!`;
            }
            return value;
        }
        static exactly(value, expected) {
            this.integer(expected);
            this.integer(value);
            if (value !== expected) {
                throw `Expected ${value} to be exactly ${expected}!`;
            }
            return value;
        }
        static integer(value) {
            if (!Number.isInteger(value)) {
                throw `Expected ${value} to be an integer!`;
            }
            return value;
        }
    }
    exports.IntegerAssert = IntegerAssert;
    ;
    class Chunk {
        constructor() { }
        static fromString(string, encoding) {
            if (encoding === "binary") {
                let bytes = new Array();
                for (let i = 0; i < string.length; i += 1) {
                    let byte = string.charCodeAt(i);
                    bytes.push(byte);
                }
                return Uint8Array.from(bytes);
            }
            if (encoding === "base64") {
                return Chunk.fromString(atob(string), "binary");
            }
            if (encoding === "base64url") {
                return Chunk.fromString(string.replaceAll("-", "+").replaceAll("_", "/"), "base64");
            }
            if (encoding === "hex") {
                if (string.length % 2 === 1) {
                    string = `0${string}`;
                }
                let bytes = new Array();
                for (let i = 0; i < string.length; i += 2) {
                    let part = string.slice(i, i + 2);
                    let byte = Number.parseInt(part, 16);
                    bytes.push(byte);
                }
                return Uint8Array.from(bytes);
            }
            // @ts-ignore
            return new TextEncoder().encode(string);
        }
        static toString(chunk, encoding) {
            if (encoding === "binary") {
                let parts = new Array();
                for (let byte of chunk) {
                    let part = String.fromCharCode(byte);
                    parts.push(part);
                }
                return parts.join("");
            }
            if (encoding === "base64") {
                return btoa(Chunk.toString(chunk, "binary"));
            }
            if (encoding === "base64url") {
                return Chunk.toString(chunk, "base64").replaceAll("+", "-").replaceAll("/", "_").replaceAll("=", "");
            }
            if (encoding === "hex") {
                let parts = new Array();
                for (let byte of chunk) {
                    let part = byte.toString(16).toUpperCase().padStart(2, "0");
                    parts.push(part);
                }
                return parts.join("");
            }
            // @ts-ignore
            return new TextDecoder().decode(chunk);
        }
        static equals(one, two) {
            return this.comparePrefixes(one, two) === 0;
        }
        static comparePrefixes(one, two) {
            for (let i = 0; i < Math.min(one.length, two.length); i++) {
                let a = one[i];
                let b = two[i];
                if (a < b) {
                    return -1;
                }
                if (a > b) {
                    return 1;
                }
            }
            if (one.length < two.length) {
                return -1;
            }
            if (one.length > two.length) {
                return 1;
            }
            return 0;
        }
        static concat(buffers) {
            let length = buffers.reduce((sum, buffer) => sum + buffer.length, 0);
            let result = new Uint8Array(length);
            let offset = 0;
            for (let buffer of buffers) {
                result.set(buffer, offset);
                offset += buffer.length;
            }
            return result;
        }
    }
    exports.Chunk = Chunk;
    ;
    class VarCategory {
        constructor() { }
        static decode(parser, maxBytes = 8) {
            parser = parser instanceof Parser ? parser : new Parser(parser);
            return parser.try((parser) => {
                let value = 0;
                for (let i = 0; i < maxBytes; i++) {
                    let byte = parser.unsigned(1);
                    let asis = (byte >> 7) & 0x01;
                    let cont = (byte >> 6) & 0x01;
                    if (asis === 0) {
                        let bits = ~byte & 0x3F;
                        value = value + bits;
                        if (cont === 1) {
                            value = value + 1;
                            value = 0 - value;
                            return value;
                        }
                        if (i === 0 && bits === 0) {
                            throw `Expected a distinguished encoding!`;
                        }
                    }
                    else {
                        let bits = byte & 0x3F;
                        value = value + bits;
                        if (cont === 0) {
                            return value;
                        }
                        if (i === 0 && bits === 0) {
                            throw `Expected a distinguished encoding!`;
                        }
                    }
                }
                throw `Expected to decode at most ${maxBytes} bytes!`;
            });
        }
        ;
        static encode(value, maxBytes = 8) {
            IntegerAssert.integer(value);
            let bytes = new Array();
            if (value >= 0) {
                do {
                    let bits = value > 63 ? 63 : value;
                    value = value - bits;
                    bytes.push(128 + bits);
                } while (value > 0);
                for (let i = 0; i < bytes.length - 1; i++) {
                    bytes[i] += 64;
                }
            }
            else {
                value = 0 - value;
                value = value - 1;
                do {
                    let bits = value > 63 ? 63 : value;
                    value = value - bits;
                    bytes.push(~bits & 0x3F);
                } while (value > 0);
                bytes[bytes.length - 1] += 64;
            }
            if (bytes.length > maxBytes) {
                throw `Expected to encode at most ${maxBytes} bytes!`;
            }
            return Uint8Array.from(bytes);
        }
        ;
    }
    exports.VarCategory = VarCategory;
    ;
    class VarInteger {
        constructor() { }
        static decode(parser, maxBytes = 8) {
            parser = parser instanceof Parser ? parser : new Parser(parser);
            return parser.try((parser) => {
                let value = 0;
                for (let i = 0; i < maxBytes; i++) {
                    let byte = parser.unsigned(1);
                    let asis = (byte >> 7) & 0x01;
                    let cont = (byte >> 6) & 0x01;
                    if (asis === 0) {
                        let bits = ~byte & 0x3F;
                        value = (value * 64) + bits;
                        if (cont === 1) {
                            value = value + 1;
                            value = 0 - value;
                            return value;
                        }
                        if (i === 0 && bits === 0) {
                            throw `Expected a distinguished encoding!`;
                        }
                    }
                    else {
                        let bits = byte & 0x3F;
                        value = (value * 64) + bits;
                        if (cont === 0) {
                            return value;
                        }
                        if (i === 0 && bits === 0) {
                            throw `Expected a distinguished encoding!`;
                        }
                    }
                }
                throw `Expected to decode at most ${maxBytes} bytes!`;
            });
        }
        ;
        static encode(value, maxBytes = 8) {
            IntegerAssert.integer(value);
            let bytes = new Array();
            if (value >= 0) {
                do {
                    let bits = value % 64;
                    value = Math.floor(value / 64);
                    bytes.push(128 + bits);
                } while (value > 0);
                bytes.reverse();
                for (let i = 0; i < bytes.length - 1; i++) {
                    bytes[i] += 64;
                }
            }
            else {
                value = 0 - value;
                value = value - 1;
                do {
                    let bits = value % 64;
                    value = Math.floor(value / 64);
                    bytes.push(128 + ~bits & 0x3F);
                } while (value > 0);
                bytes.reverse();
                bytes[bytes.length - 1] += 64;
            }
            if (bytes.length > maxBytes) {
                throw `Expected to encode at most ${maxBytes} bytes!`;
            }
            return Uint8Array.from(bytes);
        }
        ;
    }
    exports.VarInteger = VarInteger;
    ;
    class VarLength {
        constructor() { }
        static decode(parser, maxBytes = 8) {
            parser = parser instanceof Parser ? parser : new Parser(parser);
            return parser.try((parser) => {
                let value = 0;
                for (let i = 0; i < maxBytes; i++) {
                    let byte = parser.unsigned(1);
                    let cont = (byte >> 7) & 0x01;
                    let bits = (byte >> 0) & 0x7F;
                    value = (value * 128) + bits;
                    if (cont === 0) {
                        return value;
                    }
                    if (i === 0 && bits === 0) {
                        throw `Expected a distinguished encoding!`;
                    }
                }
                throw `Expected to decode at most ${maxBytes} bytes!`;
            });
        }
        ;
        static encode(value, maxBytes = 8) {
            IntegerAssert.atLeast(0, value);
            let bytes = new Array();
            do {
                let bits = value % 128;
                value = Math.floor(value / 128);
                bytes.push(bits);
            } while (value > 0);
            bytes.reverse();
            for (let i = 0; i < bytes.length - 1; i++) {
                bytes[i] += 128;
            }
            if (bytes.length > maxBytes) {
                throw `Expected to encode at most ${maxBytes} bytes!`;
            }
            return Uint8Array.from(bytes);
        }
        ;
    }
    exports.VarLength = VarLength;
    ;
});
define("node_modules/@joelek/bedrock/dist/lib/codecs", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/utils"], function (require, exports, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanLiteral = exports.BooleanLiteralCodec = exports.BigIntLiteral = exports.BigIntLiteralCodec = exports.NumberLiteral = exports.NumberLiteralCodec = exports.StringLiteral = exports.StringLiteralCodec = exports.Integer = exports.IntegerCodec = exports.Intersection = exports.IntersectionCodec = exports.Union = exports.UnionCodec = exports.Object = exports.ObjectCodec = exports.Tuple = exports.TupleCodec = exports.Record = exports.RecordCodec = exports.Array = exports.ArrayCodec = exports.Boolean = exports.BooleanCodec = exports.Unknown = exports.UnknownCodec = exports.UnknownValue = exports.Map = exports.MapCodec = exports.List = exports.ListCodec = exports.BigInt = exports.BigIntCodec = exports.Binary = exports.BinaryCodec = exports.String = exports.StringCodec = exports.Number = exports.NumberCodec = exports.True = exports.TrueCodec = exports.False = exports.FalseCodec = exports.Null = exports.NullCodec = exports.Any = exports.AnyCodec = exports.Codec = exports.Tag = exports.Packet = void 0;
    exports.IntegerLiteral = exports.IntegerLiteralCodec = void 0;
    class Packet {
        constructor() { }
        static decode(parser) {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                let length = utils.VarLength.decode(parser);
                let payload = parser.chunk(length);
                return payload;
            });
        }
        static encode(payload) {
            return utils.Chunk.concat([
                utils.VarLength.encode(payload.length),
                payload
            ]);
        }
    }
    exports.Packet = Packet;
    ;
    var Tag;
    (function (Tag) {
        Tag[Tag["NULL"] = 0] = "NULL";
        Tag[Tag["FALSE"] = 1] = "FALSE";
        Tag[Tag["TRUE"] = 2] = "TRUE";
        Tag[Tag["NUMBER"] = 3] = "NUMBER";
        Tag[Tag["STRING"] = 4] = "STRING";
        Tag[Tag["BINARY"] = 5] = "BINARY";
        Tag[Tag["BIGINT"] = 6] = "BIGINT";
        Tag[Tag["LIST"] = 7] = "LIST";
        Tag[Tag["MAP"] = 8] = "MAP";
    })(Tag = exports.Tag || (exports.Tag = {}));
    ;
    class Codec {
        constructor() { }
        decode(parser, path = "") {
            let payload = Packet.decode(parser);
            return this.decodePayload(payload, path);
        }
        encode(subject, path = "") {
            let payload = this.encodePayload(subject, path);
            return Packet.encode(payload);
        }
    }
    exports.Codec = Codec;
    ;
    class AnyCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.tryArray([
                (parser) => exports.Null.decodePayload(parser, path),
                (parser) => exports.False.decodePayload(parser, path),
                (parser) => exports.True.decodePayload(parser, path),
                (parser) => exports.Number.decodePayload(parser, path),
                (parser) => exports.String.decodePayload(parser, path),
                (parser) => exports.Binary.decodePayload(parser, path),
                (parser) => exports.BigInt.decodePayload(parser, path),
                (parser) => exports.List.decodePayload(parser, path),
                (parser) => exports.Map.decodePayload(parser, path),
                (parser) => exports.Unknown.decodePayload(parser, path)
            ]);
        }
        encodePayload(subject, path = "") {
            try {
                return exports.Null.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.False.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.True.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.Number.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.String.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.Binary.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.BigInt.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.List.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.Map.encodePayload(subject, path);
            }
            catch (error) { }
            try {
                return exports.Unknown.encodePayload(subject, path);
            }
            catch (error) { }
            throw `Expected subject to be encodable!`;
        }
    }
    exports.AnyCodec = AnyCodec;
    ;
    exports.Any = new AnyCodec();
    class NullCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.NULL) {
                    throw `Expected Null at ${path}!`;
                }
                return null;
            });
        }
        encodePayload(subject, path = "") {
            if (subject !== null) {
                throw `Expected Null at ${path}!`;
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.NULL));
            return utils.Chunk.concat(chunks);
        }
    }
    exports.NullCodec = NullCodec;
    ;
    exports.Null = new NullCodec();
    class FalseCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.FALSE) {
                    throw `Expected False at ${path}!`;
                }
                return false;
            });
        }
        encodePayload(subject, path = "") {
            if (subject !== false) {
                throw `Expected False at ${path}!`;
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.FALSE));
            return utils.Chunk.concat(chunks);
        }
    }
    exports.FalseCodec = FalseCodec;
    ;
    exports.False = new FalseCodec();
    class TrueCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.TRUE) {
                    throw `Expected True at ${path}!`;
                }
                return true;
            });
        }
        encodePayload(subject, path = "") {
            if (subject !== true) {
                throw `Expected True at ${path}!`;
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.TRUE));
            return utils.Chunk.concat(chunks);
        }
    }
    exports.TrueCodec = TrueCodec;
    ;
    exports.True = new TrueCodec();
    class NumberCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.NUMBER) {
                    throw `Expected Number at ${path}!`;
                }
                let chunk = parser.chunk(8);
                if (((chunk[0] >> 7) & 0x01) === 0x01) {
                    chunk[0] ^= 0x80;
                    for (let i = 1; i < chunk.length; i++) {
                        chunk[i] ^= 0x00;
                    }
                }
                else {
                    chunk[0] ^= 0xFF;
                    for (let i = 1; i < chunk.length; i++) {
                        chunk[i] ^= 0xFF;
                    }
                }
                let value = new DataView(chunk.buffer).getFloat64(0, false);
                return value;
            });
        }
        encodePayload(subject, path = "") {
            if (subject == null || subject.constructor !== globalThis.Number) {
                throw `Expected Number at ${path}!`;
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.NUMBER));
            let chunk = new Uint8Array(8);
            new DataView(chunk.buffer).setFloat64(0, subject, false);
            if (((chunk[0] >> 7) & 0x01) === 0x00) {
                chunk[0] ^= 0x80;
                for (let i = 1; i < chunk.length; i++) {
                    chunk[i] ^= 0x00;
                }
            }
            else {
                chunk[0] ^= 0xFF;
                for (let i = 1; i < chunk.length; i++) {
                    chunk[i] ^= 0xFF;
                }
            }
            chunks.push(chunk);
            return utils.Chunk.concat(chunks);
        }
    }
    exports.NumberCodec = NumberCodec;
    ;
    exports.Number = new NumberCodec();
    class StringCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.STRING) {
                    throw `Expected String at ${path}!`;
                }
                let value = utils.Chunk.toString(parser.chunk(), "utf-8");
                return value;
            });
        }
        encodePayload(subject, path = "") {
            if (subject == null || subject.constructor !== globalThis.String) {
                throw `Expected String at ${path}!`;
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.STRING));
            chunks.push(utils.Chunk.fromString(subject, "utf-8"));
            return utils.Chunk.concat(chunks);
        }
    }
    exports.StringCodec = StringCodec;
    ;
    exports.String = new StringCodec();
    class BinaryCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.BINARY) {
                    throw `Expected Binary at ${path}!`;
                }
                let value = parser.chunk();
                return value;
            });
        }
        encodePayload(subject, path = "") {
            if (subject == null || subject.constructor !== globalThis.Uint8Array) {
                throw `Expected Binary at ${path}!`;
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.BINARY));
            chunks.push(subject);
            return utils.Chunk.concat(chunks);
        }
    }
    exports.BinaryCodec = BinaryCodec;
    ;
    exports.Binary = new BinaryCodec();
    class BigIntCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.BIGINT) {
                    throw `Expected BigInt at ${path}!`;
                }
                let category = utils.VarCategory.decode(parser);
                let value = 0n;
                if (category >= 0) {
                    let size = category + 1;
                    for (let i = 0; i < size; i++) {
                        let byte = globalThis.BigInt(parser.unsigned(1));
                        value = value << 8n;
                        value = value | byte;
                    }
                }
                else {
                    let size = 0 - category;
                    for (let i = 0; i < size; i++) {
                        let byte = globalThis.BigInt(~parser.unsigned(1) & 0xFF);
                        value = value << 8n;
                        value = value | byte;
                    }
                    value = value + 1n;
                    value = 0n - value;
                }
                return value;
            });
        }
        encodePayload(subject, path = "") {
            if (subject == null || subject.constructor !== globalThis.BigInt) {
                throw `Expected BigInt at ${path}!`;
            }
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.BIGINT));
            let bytes = [];
            let value = subject;
            if (value >= 0n) {
                do {
                    let byte = globalThis.Number(value & 0xffn);
                    value = value >> 8n;
                    bytes.push(byte);
                } while (value > 0n);
                let category = utils.VarCategory.encode(bytes.length - 1);
                chunks.push(category);
            }
            else {
                value = 0n - value;
                value = value - 1n;
                do {
                    let byte = ~globalThis.Number(value & 0xffn) & 0xFF;
                    value = value >> 8n;
                    bytes.push(byte);
                } while (value > 0n);
                let category = utils.VarCategory.encode(0 - bytes.length);
                chunks.push(category);
            }
            bytes.reverse();
            chunks.push(Uint8Array.from(bytes));
            return utils.Chunk.concat(chunks);
        }
    }
    exports.BigIntCodec = BigIntCodec;
    ;
    exports.BigInt = new BigIntCodec();
    class ListCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "", decode) {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.LIST) {
                    throw `Expected List at ${path}!`;
                }
                decode = decode ?? ((key, path, parser) => exports.Any.decode(parser, path));
                let value = [];
                let index = 0;
                while (!parser.eof()) {
                    let subpath = `${path}[${index}]`;
                    value.push(decode(index, subpath, parser));
                    index += 1;
                }
                return value;
            });
        }
        encodePayload(subject, path = "", encode) {
            if (subject == null || subject.constructor !== globalThis.Array) {
                throw `Expected List at ${path}!`;
            }
            encode = encode ?? ((key, path, subject) => exports.Any.encode(subject, path));
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.LIST));
            for (let index = 0; index < subject.length; index++) {
                let value = subject[index];
                if (value === undefined) {
                    value = null;
                }
                let subpath = `${path}[${index}]`;
                chunks.push(encode(index, subpath, value));
            }
            return utils.Chunk.concat(chunks);
        }
    }
    exports.ListCodec = ListCodec;
    ;
    exports.List = new ListCodec();
    class MapCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "", decode) {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                if (parser.unsigned(1) !== Tag.MAP) {
                    throw `Expected Map at ${path}!`;
                }
                decode = decode ?? ((key, path, parser) => exports.Any.decode(parser, path));
                let value = {};
                while (!parser.eof()) {
                    let key = exports.String.decode(parser);
                    let subpath = /^[a-z][a-z0-9_]*$/isu.test(key) ? `${path}.${key}` : `${path}["${key}"]`;
                    value[key] = decode(key, subpath, parser);
                }
                return value;
            });
        }
        encodePayload(subject, path = "", encode) {
            if (subject == null || subject.constructor !== globalThis.Object) {
                throw `Expected Map at ${path}!`;
            }
            encode = encode ?? ((key, path, subject) => exports.Any.encode(subject, path));
            let chunks = [];
            chunks.push(Uint8Array.of(Tag.MAP));
            let pairs = [];
            for (let key in subject) {
                let value = subject[key];
                if (value === undefined) {
                    continue;
                }
                let subpath = /^[a-z][a-z0-9_]*$/isu.test(key) ? `${path}.${key}` : `${path}["${key}"]`;
                pairs.push({
                    key: exports.String.encodePayload(key),
                    value: encode(key, subpath, value)
                });
            }
            pairs.sort((one, two) => utils.Chunk.comparePrefixes(one.key, two.key));
            for (let pair of pairs) {
                chunks.push(Packet.encode(pair.key));
                chunks.push(pair.value);
            }
            return utils.Chunk.concat(chunks);
        }
    }
    exports.MapCodec = MapCodec;
    ;
    exports.Map = new MapCodec();
    class UnknownValue {
        chunk;
        constructor(chunk) {
            utils.IntegerAssert.atLeast(1, chunk.length);
            if (chunk[0] in Tag) {
                throw `Expected tag ${Tag[chunk[0]]} to be unknown!`;
            }
            this.chunk = chunk;
        }
        getChunk() {
            return this.chunk;
        }
    }
    exports.UnknownValue = UnknownValue;
    ;
    class UnknownCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                let value = parser.chunk();
                return new UnknownValue(value);
            });
        }
        encodePayload(subject, path = "") {
            if (subject == null || subject.constructor !== UnknownValue) {
                throw `Expected Unknown at ${path}!`;
            }
            let chunks = [];
            chunks.push(subject.getChunk());
            return utils.Chunk.concat(chunks);
        }
    }
    exports.UnknownCodec = UnknownCodec;
    ;
    exports.Unknown = new UnknownCodec();
    class BooleanCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.tryArray([
                (parser) => exports.True.decodePayload(parser, path),
                (parser) => exports.False.decodePayload(parser, path)
            ]);
        }
        encodePayload(subject, path = "") {
            if (subject) {
                return exports.True.encodePayload(subject, path);
            }
            else {
                return exports.False.encodePayload(subject, path);
            }
        }
    }
    exports.BooleanCodec = BooleanCodec;
    ;
    exports.Boolean = new BooleanCodec();
    class ArrayCodec extends Codec {
        codec;
        constructor(codec) {
            super();
            this.codec = codec;
        }
        decodePayload(parser, path = "") {
            return exports.List.decodePayload(parser, path, (index, path, parser) => {
                return this.codec.decode(parser, path);
            });
        }
        encodePayload(subject, path = "") {
            return exports.List.encodePayload(subject, path, (index, path, subject) => {
                return this.codec.encode(subject, path);
            });
        }
    }
    exports.ArrayCodec = ArrayCodec;
    ;
    exports.Array = {
        of(codec) {
            return new ArrayCodec(codec);
        }
    };
    class RecordCodec extends Codec {
        codec;
        constructor(codec) {
            super();
            this.codec = codec;
        }
        decodePayload(parser, path = "") {
            return exports.Map.decodePayload(parser, path, (key, path, parser) => {
                return this.codec.decode(parser, path);
            });
        }
        encodePayload(subject, path = "") {
            return exports.Map.encodePayload(subject, path, (key, path, subject) => {
                return this.codec.encode(subject, path);
            });
        }
    }
    exports.RecordCodec = RecordCodec;
    ;
    exports.Record = {
        of(codec) {
            return new RecordCodec(codec);
        }
    };
    class TupleCodec extends Codec {
        codecs;
        constructor(...codecs) {
            super();
            this.codecs = codecs;
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                let indices = new globalThis.Set(this.codecs.keys());
                let subject = exports.List.decodePayload(parser, path, (index, path, parser) => {
                    indices.delete(index);
                    if (index in this.codecs) {
                        return this.codecs[index].decode(parser, path);
                    }
                    else {
                        return exports.Any.decode(parser, path);
                    }
                });
                if (indices.size !== 0) {
                    throw `Expected members ${globalThis.Array.from(indices)} to be decoded!`;
                }
                return subject;
            });
        }
        encodePayload(subject, path = "") {
            let indices = new globalThis.Set(this.codecs.keys());
            let payload = exports.List.encodePayload(subject, path, (index, path, subject) => {
                indices.delete(index);
                if (index in this.codecs) {
                    return this.codecs[index].encode(subject, path);
                }
                else {
                    return exports.Any.encode(subject, path);
                }
            });
            if (indices.size !== 0) {
                throw `Expected members ${globalThis.Array.from(indices)} to be encoded!`;
            }
            return payload;
        }
    }
    exports.TupleCodec = TupleCodec;
    ;
    exports.Tuple = {
        of(...codecs) {
            return new TupleCodec(...codecs);
        }
    };
    class ObjectCodec extends Codec {
        codecs;
        constructor(codecs) {
            super();
            this.codecs = codecs;
        }
        decodePayload(parser, path = "") {
            parser = parser instanceof utils.Parser ? parser : new utils.Parser(parser);
            return parser.try((parser) => {
                let keys = new Set(globalThis.Object.keys(this.codecs));
                let subject = exports.Map.decodePayload(parser, path, (key, path, parser) => {
                    keys.delete(key);
                    if (key in this.codecs) {
                        return this.codecs[key].decode(parser, path);
                    }
                    else {
                        return exports.Any.decode(parser, path);
                    }
                });
                if (keys.size !== 0) {
                    throw `Expected members ${globalThis.Array.from(keys)} to be decoded!`;
                }
                return subject;
            });
        }
        encodePayload(subject, path = "") {
            let keys = new Set(globalThis.Object.keys(this.codecs));
            let payload = exports.Map.encodePayload(subject, path, (key, path, subject) => {
                keys.delete(key);
                if (key in this.codecs) {
                    return this.codecs[key].encode(subject, path);
                }
                else {
                    return exports.Any.encode(subject, path);
                }
            });
            if (keys.size !== 0) {
                throw `Expected members ${globalThis.Array.from(keys)} to be encoded!`;
            }
            return payload;
        }
    }
    exports.ObjectCodec = ObjectCodec;
    ;
    exports.Object = {
        of(codecs) {
            return new ObjectCodec(codecs);
        }
    };
    class UnionCodec extends Codec {
        codecs;
        constructor(...codecs) {
            super();
            this.codecs = codecs;
        }
        decodePayload(parser, path = "") {
            for (let codec of this.codecs) {
                try {
                    return codec.decodePayload(parser, path);
                }
                catch (error) { }
            }
            throw `Expected subject to be decodable!`;
        }
        encodePayload(subject, path = "") {
            for (let codec of this.codecs) {
                try {
                    return codec.encodePayload(subject, path);
                }
                catch (error) { }
            }
            throw `Expected subject to be encodable!`;
        }
    }
    exports.UnionCodec = UnionCodec;
    ;
    exports.Union = {
        of(...codecs) {
            return new UnionCodec(...codecs);
        }
    };
    class IntersectionCodec extends Codec {
        codecs;
        constructor(...codecs) {
            super();
            this.codecs = codecs;
        }
        decodePayload(parser, path = "") {
            for (let codec of this.codecs) {
                codec.decodePayload(parser, path);
            }
            return exports.Any.decodePayload(parser, path);
        }
        encodePayload(subject, path = "") {
            for (let codec of this.codecs) {
                codec.encodePayload(subject, path);
            }
            return exports.Any.encodePayload(subject, path);
        }
    }
    exports.IntersectionCodec = IntersectionCodec;
    ;
    exports.Intersection = {
        of(...codecs) {
            return new IntersectionCodec(...codecs);
        }
    };
    class IntegerCodec extends Codec {
        constructor() {
            super();
        }
        decodePayload(parser, path = "") {
            let subject = exports.BigInt.decodePayload(parser, path);
            if (subject < globalThis.BigInt(globalThis.Number.MIN_SAFE_INTEGER)) {
                throw `Expected ${subject} at ${path} to be within safe range!`;
            }
            if (subject > globalThis.BigInt(globalThis.Number.MAX_SAFE_INTEGER)) {
                throw `Expected ${subject} at ${path} to be within safe range!`;
            }
            return globalThis.Number(subject);
        }
        encodePayload(subject, path = "") {
            return exports.BigInt.encodePayload(globalThis.BigInt(subject), path);
        }
    }
    exports.IntegerCodec = IntegerCodec;
    ;
    exports.Integer = new IntegerCodec();
    class StringLiteralCodec extends Codec {
        value;
        constructor(value) {
            super();
            this.value = value;
        }
        decodePayload(parser, path = "") {
            let subject = exports.String.decodePayload(parser, path);
            if (subject !== this.value) {
                throw `Expected "${this.value}" at ${path}!`;
            }
            return this.value;
        }
        encodePayload(subject, path = "") {
            if (subject !== this.value) {
                throw `Expected "${this.value}" at ${path}!`;
            }
            return exports.String.encodePayload(subject, path);
        }
    }
    exports.StringLiteralCodec = StringLiteralCodec;
    ;
    exports.StringLiteral = {
        of(value) {
            return new StringLiteralCodec(value);
        }
    };
    class NumberLiteralCodec extends Codec {
        value;
        constructor(value) {
            super();
            this.value = value;
        }
        decodePayload(parser, path = "") {
            let subject = exports.Number.decodePayload(parser, path);
            if (subject !== this.value) {
                throw `Expected ${this.value} at ${path}!`;
            }
            return this.value;
        }
        encodePayload(subject, path = "") {
            if (subject !== this.value) {
                throw `Expected ${this.value} at ${path}!`;
            }
            return exports.Number.encodePayload(subject, path);
        }
    }
    exports.NumberLiteralCodec = NumberLiteralCodec;
    ;
    exports.NumberLiteral = {
        of(value) {
            return new NumberLiteralCodec(value);
        }
    };
    class BigIntLiteralCodec extends Codec {
        value;
        constructor(value) {
            super();
            this.value = value;
        }
        decodePayload(parser, path = "") {
            let subject = exports.BigInt.decodePayload(parser, path);
            if (subject !== this.value) {
                throw `Expected ${this.value} at ${path}!`;
            }
            return this.value;
        }
        encodePayload(subject, path = "") {
            if (subject !== this.value) {
                throw `Expected ${this.value} at ${path}!`;
            }
            return exports.BigInt.encodePayload(subject, path);
        }
    }
    exports.BigIntLiteralCodec = BigIntLiteralCodec;
    ;
    exports.BigIntLiteral = {
        of(value) {
            return new BigIntLiteralCodec(value);
        }
    };
    class BooleanLiteralCodec extends Codec {
        value;
        constructor(value) {
            super();
            this.value = value;
        }
        decodePayload(parser, path = "") {
            let subject = exports.Boolean.decodePayload(parser, path);
            if (subject !== this.value) {
                throw `Expected ${this.value} at ${path}!`;
            }
            return this.value;
        }
        encodePayload(subject, path = "") {
            if (subject !== this.value) {
                throw `Expected ${this.value} at ${path}!`;
            }
            return exports.Boolean.encodePayload(subject, path);
        }
    }
    exports.BooleanLiteralCodec = BooleanLiteralCodec;
    ;
    exports.BooleanLiteral = {
        of(value) {
            return new BooleanLiteralCodec(value);
        }
    };
    class IntegerLiteralCodec extends Codec {
        value;
        constructor(value) {
            super();
            this.value = value;
        }
        decodePayload(parser, path = "") {
            let subject = exports.Integer.decodePayload(parser, path);
            if (subject !== this.value) {
                throw `Expected ${this.value} at ${path}!`;
            }
            return this.value;
        }
        encodePayload(subject, path = "") {
            if (subject !== this.value) {
                throw `Expected ${this.value} at ${path}!`;
            }
            return exports.Integer.encodePayload(subject, path);
        }
    }
    exports.IntegerLiteralCodec = IntegerLiteralCodec;
    ;
    exports.IntegerLiteral = {
        of(value) {
            return new IntegerLiteralCodec(value);
        }
    };
});
define("node_modules/@joelek/bedrock/dist/lib/index", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/codecs", "node_modules/@joelek/bedrock/dist/lib/utils"], function (require, exports, codecs, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.codecs = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.codecs = void 0;
    exports.codecs = codecs;
    exports.utils = utils;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/bedrock", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/index"], function (require, exports, bedrock) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CODEC = exports.BedrockCodec = void 0;
    class BedrockCodec {
        constructor() { }
        decode(buffer) {
            return bedrock.codecs.Any.decode(buffer);
        }
        encode(subject) {
            return bedrock.codecs.Any.encode(subject);
        }
    }
    exports.BedrockCodec = BedrockCodec;
    ;
    exports.CODEC = new BedrockCodec();
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/json", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/index", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards"], function (require, exports, bedrock, guards) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CODEC = exports.JSONCodec = void 0;
    const BIGINT_GUARD = guards.Object.of({
        type: guards.StringLiteral.of("@bigint"),
        data: guards.String
    });
    const BINARY_GUARD = guards.Object.of({
        type: guards.StringLiteral.of("@binary"),
        data: guards.String
    });
    class JSONCodec {
        constructor() { }
        decode(buffer) {
            let string = bedrock.utils.Chunk.toString(buffer, "utf-8");
            let subject = string.length === 0 ? undefined : JSON.parse(string, (key, subject) => {
                if (BIGINT_GUARD.is(subject)) {
                    return BigInt(subject.data);
                }
                if (BINARY_GUARD.is(subject)) {
                    return bedrock.utils.Chunk.fromString(subject.data, "base64url");
                }
                return subject;
            });
            return subject;
        }
        encode(subject) {
            let string = subject === undefined ? "" : JSON.stringify(subject, (key, subject) => {
                if (guards.BigInt.is(subject)) {
                    return {
                        type: "@bigint",
                        data: subject.toString()
                    };
                }
                if (guards.Binary.is(subject)) {
                    return {
                        type: "@binary",
                        data: bedrock.utils.Chunk.toString(subject, "base64url")
                    };
                }
                return subject;
            });
            let packet = bedrock.utils.Chunk.fromString(string, "utf-8");
            return packet;
        }
    }
    exports.JSONCodec = JSONCodec;
    ;
    exports.CODEC = new JSONCodec();
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/bedrock", "node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/json"], function (require, exports, bedrock, json) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.json = exports.bedrock = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.json = exports.bedrock = void 0;
    exports.bedrock = bedrock;
    exports.json = json;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/api", "node_modules/@joelek/ts-autoguard/dist/lib-shared/codecs/index", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards", "node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization"], function (require, exports, api, codecs, guards, serialization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialization = exports.guards = exports.codecs = exports.api = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialization = exports.guards = exports.codecs = exports.api = void 0;
    exports.api = api;
    exports.codecs = codecs;
    exports.guards = guards;
    exports.serialization = serialization;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-server/api", ["require", "exports", "fs", "http", "https", "path", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-autoguard/dist/lib-shared/api"], function (require, exports, libfs, libhttp, libhttps, libpath, shared, api_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function () { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (this && this.__exportStar) || function (m, exports) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
                __createBinding(exports, m, p);
    };
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __asyncValues = (this && this.__asyncValues) || function (o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeReadStreamResponse = exports.makeDirectoryListing = exports.getContentTypeFromExtension = exports.parseRangeHeader = exports.route = exports.respond = exports.finalizeResponse = exports.acceptsMethod = exports.acceptsComponents = exports.makeNodeRequestHandler = exports.combineNodeRawHeaders = exports.DynamicRouteMatcher = exports.StaticRouteMatcher = exports.ClientRequest = exports.EndpointError = void 0;
    __exportStar(api_1, exports);
    class EndpointError {
        constructor(response) {
            this.response = response;
        }
        getResponse() {
            var _a, _b, _c;
            let status = (_a = this.response.status) !== null && _a !== void 0 ? _a : 500;
            let headers = (_b = this.response.headers) !== null && _b !== void 0 ? _b : [];
            let payload = (_c = this.response.payload) !== null && _c !== void 0 ? _c : [];
            return {
                status,
                headers,
                payload
            };
        }
    }
    exports.EndpointError = EndpointError;
    ;
    class ClientRequest {
        constructor(request, collect, auxillary) {
            this.request = request;
            this.collect = collect;
            this.auxillary = auxillary;
        }
        options() {
            let options = this.request.options;
            return Object.assign({}, options);
        }
        headers() {
            let headers = this.request.headers;
            return Object.assign({}, headers);
        }
        payload() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.collectedPayload !== undefined) {
                    return this.collectedPayload;
                }
                let payload = this.request.payload;
                let collectedPayload = (this.collect ? yield shared.api.collectPayload(payload) : payload);
                this.collectedPayload = collectedPayload;
                return collectedPayload;
            });
        }
        socket() {
            return this.auxillary.socket;
        }
    }
    exports.ClientRequest = ClientRequest;
    ;
    ;
    class StaticRouteMatcher {
        constructor(string) {
            this.string = string;
            this.accepted = false;
        }
        acceptComponent(component) {
            if (this.accepted) {
                return false;
            }
            this.accepted = component === this.string;
            return this.accepted;
        }
        getValue() {
            return this.string;
        }
        isSatisfied() {
            return this.accepted;
        }
    }
    exports.StaticRouteMatcher = StaticRouteMatcher;
    ;
    class DynamicRouteMatcher {
        constructor(minOccurences, maxOccurences, plain, guard) {
            this.minOccurences = minOccurences;
            this.maxOccurences = maxOccurences;
            this.plain = plain;
            this.guard = guard;
            this.values = new Array();
        }
        acceptComponent(component) {
            if (this.values.length >= this.maxOccurences) {
                return false;
            }
            try {
                let value = shared.api.deserializeValue(component, this.plain);
                if (this.guard.is(value)) {
                    this.values.push(value);
                    return true;
                }
            }
            catch (error) { }
            return false;
        }
        getValue() {
            if (this.maxOccurences === 1) {
                return this.values[0];
            }
            else {
                return this.values;
            }
        }
        isSatisfied() {
            return this.minOccurences <= this.values.length && this.values.length <= this.maxOccurences;
        }
    }
    exports.DynamicRouteMatcher = DynamicRouteMatcher;
    ;
    function combineNodeRawHeaders(raw) {
        let headers = new Array();
        for (let i = 0; i < raw.length; i += 2) {
            headers.push(`${raw[i + 0]}: ${raw[i + 1]}`);
        }
        return headers;
    }
    exports.combineNodeRawHeaders = combineNodeRawHeaders;
    ;
    function makeNodeRequestHandler(options) {
        return (raw, clientOptions) => {
            var _a;
            let urlPrefix = (_a = clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.urlPrefix) !== null && _a !== void 0 ? _a : "";
            let lib = urlPrefix.startsWith("https:") ? libhttps : libhttp;
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let payload = yield shared.api.collectPayload(raw.payload);
                let headers = {
                    "Content-Length": `${payload.length}`
                };
                for (let header of raw.headers) {
                    let key = header[0];
                    let value = header[1];
                    let values = headers[key];
                    if (values === undefined) {
                        headers[key] = value;
                    }
                    else if (Array.isArray(values)) {
                        values.push(value);
                    }
                    else {
                        headers[key] = [values, value];
                    }
                }
                let url = urlPrefix;
                url += shared.api.combineComponents(raw.components);
                url += shared.api.combineParameters(raw.parameters);
                let request = lib.request(url, Object.assign(Object.assign({}, options), { method: raw.method, headers: headers }), (response) => {
                    var _a;
                    let status = (_a = response.statusCode) !== null && _a !== void 0 ? _a : 200;
                    let headers = shared.api.splitHeaders(combineNodeRawHeaders(response.rawHeaders));
                    let payload = {
                        [Symbol.asyncIterator]: () => response[Symbol.asyncIterator]()
                    };
                    let raw = {
                        status,
                        headers,
                        payload
                    };
                    resolve(raw);
                });
                request.on("abort", reject);
                request.on("error", reject);
                request.write(payload);
                request.end();
            }));
        };
    }
    exports.makeNodeRequestHandler = makeNodeRequestHandler;
    ;
    function acceptsComponents(components, matchers) {
        let currentMatcher = 0;
        outer: for (let component of components) {
            let decoded = decodeURIComponent(component);
            if (decoded === undefined) {
                throw `Expected component to be properly encoded!`;
            }
            inner: for (let matcher of matchers.slice(currentMatcher)) {
                if (matcher.acceptComponent(decoded)) {
                    continue outer;
                }
                else {
                    if (matcher.isSatisfied()) {
                        currentMatcher += 1;
                        continue inner;
                    }
                    else {
                        break outer;
                    }
                }
            }
            break outer;
        }
        if (currentMatcher >= matchers.length) {
            return false;
        }
        for (let matcher of matchers.slice(currentMatcher)) {
            if (!matcher.isSatisfied()) {
                return false;
            }
        }
        return true;
    }
    exports.acceptsComponents = acceptsComponents;
    ;
    function acceptsMethod(one, two) {
        return one === two;
    }
    exports.acceptsMethod = acceptsMethod;
    ;
    function finalizeResponse(raw, defaultHeaders) {
        let headersToAppend = defaultHeaders.filter((defaultHeader) => {
            let found = raw.headers.find((header) => header[0].toLowerCase() === defaultHeader[0].toLowerCase());
            return found === undefined;
        });
        return Object.assign(Object.assign({}, raw), { headers: [
                ...raw.headers,
                ...headersToAppend
            ] });
    }
    exports.finalizeResponse = finalizeResponse;
    ;
    function respond(httpResponse, raw, serverOptions) {
        var e_1, _a;
        var _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let rawHeaders = new Array();
            for (let header of (_b = raw.headers) !== null && _b !== void 0 ? _b : []) {
                rawHeaders.push(...header);
            }
            httpResponse.writeHead((_c = raw.status) !== null && _c !== void 0 ? _c : 200, rawHeaders);
            try {
                for (var _e = __asyncValues((_d = raw.payload) !== null && _d !== void 0 ? _d : []), _f; _f = yield _e.next(), !_f.done;) {
                    let chunk = _f.value;
                    if (!httpResponse.write(chunk)) {
                        yield new Promise((resolve, reject) => {
                            httpResponse.once("drain", resolve);
                        });
                    }
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_f && !_f.done && (_a = _e.return))
                        yield _a.call(_e);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            httpResponse.end();
            yield new Promise((resolve, reject) => {
                httpResponse.once("finish", resolve);
            });
        });
    }
    exports.respond = respond;
    ;
    function route(endpoints, httpRequest, httpResponse, serverOptions) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            let urlPrefix = (_a = serverOptions === null || serverOptions === void 0 ? void 0 : serverOptions.urlPrefix) !== null && _a !== void 0 ? _a : "";
            let method = (_b = httpRequest.method) !== null && _b !== void 0 ? _b : "GET";
            let url = (_c = httpRequest.url) !== null && _c !== void 0 ? _c : "";
            if (!url.startsWith(urlPrefix)) {
                throw `Expected url "${url}" to have prefix "${urlPrefix}"!`;
            }
            url = url.slice(urlPrefix.length);
            try {
                let components = shared.api.splitComponents(url);
                let parameters = shared.api.splitParameters(url);
                let headers = shared.api.splitHeaders(combineNodeRawHeaders(httpRequest.rawHeaders));
                let payload = {
                    [Symbol.asyncIterator]: () => httpRequest[Symbol.asyncIterator]()
                };
                let socket = httpRequest.socket;
                let raw = {
                    method,
                    components,
                    parameters,
                    headers,
                    payload
                };
                let auxillary = {
                    socket
                };
                let filteredEndpoints = endpoints.map((endpoint) => endpoint(raw, auxillary));
                filteredEndpoints = filteredEndpoints.filter((endpoint) => endpoint.acceptsComponents());
                if (filteredEndpoints.length === 0) {
                    return respond(httpResponse, {
                        status: 404
                    }, serverOptions);
                }
                filteredEndpoints = filteredEndpoints.filter((endpoint) => endpoint.acceptsMethod());
                if (filteredEndpoints.length === 0) {
                    return respond(httpResponse, {
                        status: 405
                    }, serverOptions);
                }
                let endpoint = filteredEndpoints[0];
                let valid = yield endpoint.validateRequest();
                try {
                    let handled = yield valid.handleRequest();
                    try {
                        let raw = yield handled.validateResponse();
                        return yield respond(httpResponse, raw, serverOptions);
                    }
                    catch (error) {
                        return respond(httpResponse, {
                            status: 500,
                            payload: shared.api.serializeStringPayload(String(error))
                        }, serverOptions);
                    }
                }
                catch (error) {
                    if (typeof error === "number" && Number.isInteger(error) && error >= 100 && error <= 999) {
                        return respond(httpResponse, {
                            status: error
                        }, serverOptions);
                    }
                    if (error instanceof EndpointError) {
                        let raw = error.getResponse();
                        return respond(httpResponse, raw, serverOptions);
                    }
                    return respond(httpResponse, {
                        status: 500
                    }, serverOptions);
                }
            }
            catch (error) {
                return respond(httpResponse, {
                    status: 400,
                    payload: shared.api.serializeStringPayload(String(error))
                }, serverOptions);
            }
        });
    }
    exports.route = route;
    ;
    // TODO: Move to Nexus in v6.
    function parseRangeHeader(value, size) {
        var _a, _b, _c;
        if (value === undefined) {
            return {
                status: 200,
                offset: 0,
                length: size,
                size: size
            };
        }
        let s416 = {
            status: 416,
            offset: 0,
            length: 0,
            size: size
        };
        let parts;
        parts = (_a = /^bytes[=]([0-9]+)[-]$/.exec(String(value))) !== null && _a !== void 0 ? _a : undefined;
        if (parts !== undefined) {
            let one = Number.parseInt(parts[1], 10);
            if (one >= size) {
                return s416;
            }
            return {
                status: 206,
                offset: one,
                length: size - one,
                size: size
            };
        }
        parts = (_b = /^bytes[=]([0-9]+)[-]([0-9]+)$/.exec(String(value))) !== null && _b !== void 0 ? _b : undefined;
        if (parts !== undefined) {
            let one = Number.parseInt(parts[1], 10);
            let two = Number.parseInt(parts[2], 10);
            if (two < one) {
                return s416;
            }
            if (one >= size) {
                return s416;
            }
            if (two >= size) {
                two = size - 1;
            }
            return {
                status: 206,
                offset: one,
                length: two - one + 1,
                size: size
            };
        }
        parts = (_c = /^bytes[=][-]([0-9]+)$/.exec(String(value))) !== null && _c !== void 0 ? _c : undefined;
        if (parts !== undefined) {
            let one = Number.parseInt(parts[1], 10);
            if (one < 1) {
                return s416;
            }
            if (size < 1) {
                return s416;
            }
            if (one > size) {
                one = size;
            }
            return {
                status: 206,
                offset: size - one,
                length: one,
                size: size
            };
        }
        return s416;
    }
    exports.parseRangeHeader = parseRangeHeader;
    ;
    // TODO: Move to Nexus in v6.
    function getContentTypeFromExtension(extension) {
        let extensions = {
            ".aac": "audio/aac",
            ".bmp": "image/bmp",
            ".css": "text/css",
            ".csv": "text/csv",
            ".gif": "image/gif",
            ".htm": "text/html",
            ".html": "text/html",
            ".jpg": "image/jpeg",
            ".jpeg": "image/jpeg",
            ".js": "text/javascript",
            ".json": "application/json",
            ".mid": "audio/midi",
            ".mp3": "audio/mpeg",
            ".mp4": "video/mp4",
            ".otf": "font/otf",
            ".pdf": "application/pdf",
            ".png": "image/png",
            ".svg": "image/svg+xml",
            ".tif": "image/tiff",
            ".tiff": "image/tiff",
            ".ttf": "font/ttf",
            ".txt": "text/plain",
            ".wav": "audio/wav",
            ".woff": "font/woff",
            ".woff2": "font/woff2",
            ".xml": "text/xml"
        };
        return extensions[extension];
    }
    exports.getContentTypeFromExtension = getContentTypeFromExtension;
    ;
    // TODO: Move to Nexus in v6.
    function makeDirectoryListing(pathPrefix, pathSuffix, request) {
        let pathSuffixParts = libpath.normalize(pathSuffix).split(libpath.sep);
        if (pathSuffixParts[0] === "..") {
            throw 400;
        }
        if (pathSuffixParts[pathSuffixParts.length - 1] !== "") {
            pathSuffixParts.push("");
        }
        let fullPath = libpath.join(pathPrefix, ...pathSuffixParts);
        if (!libfs.existsSync(fullPath) || !libfs.statSync(fullPath).isDirectory()) {
            throw 404;
        }
        let entries = libfs.readdirSync(fullPath, { withFileTypes: true });
        let directories = entries
            .filter((entry) => entry.isDirectory())
            .map((entry) => {
            return {
                name: entry.name
            };
        })
            .sort((one, two) => one.name.localeCompare(two.name));
        let files = entries
            .filter((entry) => entry.isFile())
            .map((entry) => {
            let stat = libfs.statSync(libpath.join(fullPath, entry.name));
            return {
                name: entry.name,
                size: stat.size,
                timestamp: stat.mtime.valueOf()
            };
        })
            .sort((one, two) => one.name.localeCompare(two.name));
        let components = pathSuffixParts;
        return {
            components,
            directories,
            files
        };
    }
    exports.makeDirectoryListing = makeDirectoryListing;
    ;
    // TODO: Move to Nexus in v6.
    function makeReadStreamResponse(pathPrefix, pathSuffix, request) {
        if (libpath.normalize(pathSuffix).split(libpath.sep)[0] === "..") {
            throw 400;
        }
        let path = libpath.join(pathPrefix, pathSuffix);
        while (libfs.existsSync(path) && libfs.statSync(path).isDirectory()) {
            path = libpath.join(path, "index.html");
        }
        if (!libfs.existsSync(path)) {
            throw 404;
        }
        let stat = libfs.statSync(path);
        let range = parseRangeHeader(request.headers().range, stat.size);
        let stream = libfs.createReadStream(path, {
            start: range.offset,
            end: range.offset + range.length
        });
        return {
            status: range.status,
            headers: {
                "Accept-Ranges": "bytes",
                "Content-Length": `${range.length}`,
                "Content-Range": range.length > 0 ? `bytes ${range.offset}-${range.offset + range.length - 1}/${range.size}` : `bytes */${range.size}`,
                "Content-Type": getContentTypeFromExtension(libpath.extname(path)),
                "Last-Modified": stat.mtime.toUTCString()
            },
            payload: stream
        };
    }
    exports.makeReadStreamResponse = makeReadStreamResponse;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-server/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-autoguard/dist/lib-server/api"], function (require, exports, lib_shared_1, api) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.api = void 0;
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function () { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (this && this.__exportStar) || function (m, exports) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
                __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.api = void 0;
    __exportStar(lib_shared_1, exports);
    exports.api = api;
});
define("build/server/passwords", ["require", "exports", "crypto"], function (require, exports, libcrypto) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verify = exports.generate = void 0;
    function generate(password) {
        let cost = 14;
        let blockSize = 8;
        let paralellization = 1;
        let salt = libcrypto.randomBytes(16);
        let password_hash = libcrypto.scryptSync(password, salt, 32, {
            N: (1 << cost),
            r: blockSize,
            p: paralellization,
            maxmem: (256 << cost) * blockSize
        });
        let params = Buffer.alloc(4);
        params[0] = (cost >> 8);
        params[1] = (cost >> 0);
        params[2] = (blockSize >> 0);
        params[3] = (paralellization >> 0);
        return `$s0$${params.toString("hex")}$${salt.toString("base64")}$${password_hash.toString("base64")}`;
    }
    exports.generate = generate;
    function verify(password, chunk) {
        let parts = /^\$s0\$([0-9a-fA-F]{8})\$([A-Za-z0-9+/]{22}==)\$([A-Za-z0-9+/]{43}=)$/.exec(chunk);
        if (parts == null) {
            throw `Expected a valid scrypt chunk!`;
        }
        let parameters = Buffer.from(parts[1], "hex");
        let salt = Buffer.from(parts[2], "base64");
        let hash = Buffer.from(parts[3], "base64");
        let cost = (parameters[0] << 8) | (parameters[1] << 0);
        let blockSize = (parameters[2] << 0);
        let paralellization = (parameters[3] << 0);
        let password_hash = libcrypto.scryptSync(password, salt, 32, {
            N: (1 << cost),
            r: blockSize,
            p: paralellization,
            maxmem: (256 << cost) * blockSize
        });
        return libcrypto.timingSafeEqual(hash, password_hash);
    }
    exports.verify = verify;
});
define("node_modules/@joelek/atlas/dist/lib/filters", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/index"], function (require, exports, bedrock) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EqualityFilter = exports.Filter = void 0;
    class Filter {
        constructor() { }
    }
    exports.Filter = Filter;
    ;
    class EqualityFilter extends Filter {
        value;
        constructor(value) {
            super();
            this.value = value;
        }
        getEncodedValue() {
            return bedrock.codecs.Any.encodePayload(this.value);
        }
        getValue() {
            return this.value;
        }
        matches(value) {
            let one = bedrock.codecs.Any.encodePayload(this.value);
            let two = bedrock.codecs.Any.encodePayload(value);
            return bedrock.utils.Chunk.comparePrefixes(one, two) === 0;
        }
    }
    exports.EqualityFilter = EqualityFilter;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/streams", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamIterable = void 0;
    function* filter(iterable, predicate) {
        let index = 0;
        for (let value of iterable) {
            if (predicate(value, index++)) {
                yield value;
            }
        }
    }
    ;
    function* include(iterable, predicate) {
        let index = 0;
        for (let value of iterable) {
            if (predicate(value, index++)) {
                yield value;
            }
        }
    }
    ;
    function* limit(iterable, length) {
        if (length > 0) {
            let index = 0;
            for (let value of iterable) {
                yield value;
                index += 1;
                if (index >= length) {
                    break;
                }
            }
        }
    }
    ;
    function* map(iterable, transform) {
        let index = 0;
        for (let value of iterable) {
            yield transform(value, index++);
        }
    }
    ;
    class StreamIterable {
        values;
        constructor(values) {
            this.values = values;
        }
        *[Symbol.iterator]() {
            for (let value of this.values) {
                yield value;
            }
        }
        collect() {
            return Array.from(this.values);
        }
        filter(predicate) {
            return new StreamIterable(filter(this.values, predicate));
        }
        find(predicate) {
            let index = 0;
            for (let value of this.values) {
                if (predicate(value, index++)) {
                    return value;
                }
            }
        }
        include(predicate) {
            return new StreamIterable(include(this.values, predicate));
        }
        includes(predicate) {
            let index = 0;
            for (let value of this.values) {
                if (predicate(value, index++)) {
                    return true;
                }
            }
            return false;
        }
        limit(length) {
            return new StreamIterable(limit(this.values, length));
        }
        map(transform) {
            return new StreamIterable(map(this.values, transform));
        }
        shift() {
            for (let value of this.values) {
                return value;
            }
        }
        slice(start, end) {
            let array = this.collect().slice(start, end);
            return new StreamIterable(array);
        }
        sort(comparator) {
            let array = this.collect().sort(comparator);
            return new StreamIterable(array);
        }
        unique() {
            return new StreamIterable(new Set(this.values));
        }
        static of(values) {
            return new StreamIterable(values ?? new Array());
        }
    }
    exports.StreamIterable = StreamIterable;
    ;
});
define("node_modules/@joelek/atlas/dist/mod/asserts/bigint", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BigintAssert = void 0;
    class BigintAssert {
        constructor() { }
        static atLeast(min, value) {
            if (value < min) {
                throw `Expected ${value} to be at least ${min}!`;
            }
            return value;
        }
        static atMost(max, value) {
            if (value > max) {
                throw `Expected ${value} to be at most ${max}!`;
            }
            return value;
        }
        static between(min, value, max) {
            if (value < min || value > max) {
                throw `Expected ${value} to be between ${min} and ${max}!`;
            }
            return value;
        }
        static exactly(value, expected) {
            if (value !== expected) {
                throw `Expected ${value} to be exactly ${expected}!`;
            }
            return value;
        }
    }
    exports.BigintAssert = BigintAssert;
    ;
});
define("node_modules/@joelek/atlas/dist/mod/asserts/boolean", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanAssert = void 0;
    class BooleanAssert {
        constructor() { }
        static true(value) {
            if (value !== true) {
                throw `Expected ${value} to be true!`;
            }
            return value;
        }
        static false(value) {
            if (value !== false) {
                throw `Expected ${value} to be false!`;
            }
            return value;
        }
    }
    exports.BooleanAssert = BooleanAssert;
    ;
});
define("node_modules/@joelek/atlas/dist/mod/asserts/integer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntegerAssert = void 0;
    class IntegerAssert {
        constructor() { }
        static atLeast(min, value) {
            this.integer(min);
            this.integer(value);
            if (value < min) {
                throw `Expected ${value} to be at least ${min}!`;
            }
            return value;
        }
        static atMost(max, value) {
            this.integer(value);
            this.integer(max);
            if (value > max) {
                throw `Expected ${value} to be at most ${max}!`;
            }
            return value;
        }
        static between(min, value, max) {
            this.integer(min);
            this.integer(value);
            this.integer(max);
            if (value < min || value > max) {
                throw `Expected ${value} to be between ${min} and ${max}!`;
            }
            return value;
        }
        static exactly(value, expected) {
            this.integer(expected);
            this.integer(value);
            if (value !== expected) {
                throw `Expected ${value} to be exactly ${expected}!`;
            }
            return value;
        }
        static integer(value) {
            if (!Number.isInteger(value)) {
                throw `Expected ${value} to be an integer!`;
            }
            return value;
        }
    }
    exports.IntegerAssert = IntegerAssert;
    ;
});
define("node_modules/@joelek/atlas/dist/mod/asserts/string", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringAssert = void 0;
    class StringAssert {
        constructor() { }
        static identical(value, expected) {
            if (value !== expected) {
                throw `Expected "${value}" to be identical to ${expected}!`;
            }
            return value;
        }
    }
    exports.StringAssert = StringAssert;
    ;
});
define("node_modules/@joelek/atlas/dist/mod/asserts/index", ["require", "exports", "node_modules/@joelek/atlas/dist/mod/asserts/bigint", "node_modules/@joelek/atlas/dist/mod/asserts/boolean", "node_modules/@joelek/atlas/dist/mod/asserts/integer", "node_modules/@joelek/atlas/dist/mod/asserts/string"], function (require, exports, bigint_1, boolean_1, integer_1, string_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function () { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (this && this.__exportStar) || function (m, exports) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
                __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(bigint_1, exports);
    __exportStar(boolean_1, exports);
    __exportStar(integer_1, exports);
    __exportStar(string_1, exports);
});
define("node_modules/@joelek/atlas/dist/lib/chunks", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chunk = void 0;
    ;
    ;
    class Chunk {
        buffer;
        constructor(buffer) {
            this.buffer = buffer;
        }
        read(readable, offset) {
            readable.read(this.buffer, offset);
        }
        write(writable, offset) {
            writable.write(this.buffer, offset);
        }
    }
    exports.Chunk = Chunk;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/variables", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEBUG = exports.getBoolean = void 0;
    function getBoolean(key, defaultValue) {
        let string = globalThis?.process?.env[key];
        try {
            let json = JSON.parse(string);
            if (typeof json === "boolean") {
                return json;
            }
        }
        catch (error) { }
        return defaultValue;
    }
    exports.getBoolean = getBoolean;
    ;
    exports.DEBUG = getBoolean("DEBUG", false);
});
define("node_modules/@joelek/atlas/dist/lib/utils", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/index", "node_modules/@joelek/atlas/dist/mod/asserts/index", "node_modules/@joelek/atlas/dist/lib/variables"], function (require, exports, bedrock, asserts, variables_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseQueue = exports.Binary = void 0;
    class Binary {
        constructor() { }
        static string(buffer, offset, length, encoding, value) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, offset, buffer.byteLength - 1);
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, length, buffer.byteLength - offset);
            if (value == null) {
                let subarray = buffer.subarray(offset, offset + length);
                let value = bedrock.utils.Chunk.toString(subarray, encoding).replace(/[\0]*$/g, "");
                return value;
            }
            else {
                let encoded = bedrock.utils.Chunk.fromString(value, encoding);
                if (variables_1.DEBUG)
                    asserts.IntegerAssert.between(0, encoded.byteLength, length);
                buffer.set(encoded, offset);
                buffer.fill(0, offset + encoded.length, offset + length);
                return value;
            }
        }
        static boolean(buffer, offset, bit, value) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, bit, 7);
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, offset, buffer.byteLength - 1);
            if (value == null) {
                let byte = buffer[offset];
                let value = ((byte >> bit) & 0x01) === 0x01;
                return value;
            }
            else {
                let byte = buffer[offset];
                buffer[offset] = (byte & ~(1 << bit)) | ((~~value) << bit);
                return value;
            }
        }
        static signed(buffer, offset, length, value, endian) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(1, length, 6);
            let bias = 2 ** (length * 8 - 1);
            if (value == null) {
                let value = this.unsigned(buffer, offset, length, undefined, endian);
                if (value >= bias) {
                    value -= bias + bias;
                }
                return value;
            }
            else {
                let copy = value;
                if (copy < 0) {
                    copy += bias + bias;
                }
                this.unsigned(buffer, offset, length, copy, endian);
                return value;
            }
        }
        static unsigned(buffer, offset, length, value, endian) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(1, length, 6);
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, offset, buffer.byteLength - length);
            if (value == null) {
                let value = 0;
                for (let i = 0; i < length; i++) {
                    value *= 256;
                    if (endian === "little") {
                        value += buffer[offset + length - 1 - i];
                    }
                    else {
                        value += buffer[offset + i];
                    }
                }
                return value;
            }
            else {
                if (variables_1.DEBUG)
                    asserts.IntegerAssert.between(0, value, 2 ** (8 * length) - 1);
                let copy = value;
                for (let i = 0; i < length; i++) {
                    if (endian === "little") {
                        buffer[offset + i] = copy % 256;
                    }
                    else {
                        buffer[offset + length - 1 - i] = copy % 256;
                    }
                    copy = Math.floor(copy / 256);
                }
                return value;
            }
        }
    }
    exports.Binary = Binary;
    ;
    class PromiseQueue {
        lock;
        open;
        constructor() {
            this.lock = Promise.resolve();
            this.open = true;
        }
        close() {
            this.open = false;
        }
        enqueue(operation) {
            if (!this.open) {
                throw `Expected queue to be open!`;
            }
            try {
                return this.lock = this.lock
                    .then(operation instanceof Promise ? () => operation : operation);
            }
            finally {
                this.lock = this.lock.catch(() => null);
            }
        }
    }
    exports.PromiseQueue = PromiseQueue;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/blocks", ["require", "exports", "node_modules/@joelek/atlas/dist/mod/asserts/index", "node_modules/@joelek/atlas/dist/lib/chunks", "node_modules/@joelek/atlas/dist/lib/variables", "node_modules/@joelek/atlas/dist/lib/utils"], function (require, exports, asserts, chunks_1, variables_1, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockManager = exports.BinHeader = exports.BlockReference = exports.BlockHeader = exports.BlockFlags = void 0;
    var BlockFlags;
    (function (BlockFlags) {
        BlockFlags[BlockFlags["APPLICATION_0"] = 0] = "APPLICATION_0";
        BlockFlags[BlockFlags["APPLICATION_1"] = 1] = "APPLICATION_1";
        BlockFlags[BlockFlags["APPLICATION_2"] = 2] = "APPLICATION_2";
        BlockFlags[BlockFlags["APPLICATION_3"] = 3] = "APPLICATION_3";
        BlockFlags[BlockFlags["RESERVED_4"] = 4] = "RESERVED_4";
        BlockFlags[BlockFlags["RESERVED_5"] = 5] = "RESERVED_5";
        BlockFlags[BlockFlags["RESERVED_6"] = 6] = "RESERVED_6";
        BlockFlags[BlockFlags["DELETED"] = 7] = "DELETED";
    })(BlockFlags = exports.BlockFlags || (exports.BlockFlags = {}));
    ;
    class BlockHeader extends chunks_1.Chunk {
        constructor(buffer) {
            super(buffer ?? new Uint8Array(BlockHeader.LENGTH));
            if (variables_1.DEBUG)
                asserts.IntegerAssert.exactly(this.buffer.length, BlockHeader.LENGTH);
        }
        flag(bit, value) {
            return utils.Binary.boolean(this.buffer, 0, bit, value);
        }
        flags(value) {
            return utils.Binary.unsigned(this.buffer, 0, 1, value);
        }
        category(value) {
            return utils.Binary.unsigned(this.buffer, 1, 1, value);
        }
        offset(value) {
            return utils.Binary.unsigned(this.buffer, 2, 6, value);
        }
        length(value) {
            let category = this.category(value != null ? BlockHeader.getCategory(value) : undefined);
            return BlockHeader.getLength(category);
        }
        static getCategory(minLength) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(1, minLength);
            let category = Math.ceil(Math.log2(minLength));
            return category;
        }
        static getLength(category) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, category);
            let length = Math.pow(2, category);
            return length;
        }
        static LENGTH = 8;
    }
    exports.BlockHeader = BlockHeader;
    ;
    class BlockReference extends chunks_1.Chunk {
        constructor(buffer) {
            super(buffer ?? new Uint8Array(BlockReference.LENGTH));
            if (variables_1.DEBUG)
                asserts.IntegerAssert.exactly(this.buffer.length, BlockReference.LENGTH);
        }
        metadata(value) {
            return utils.Binary.unsigned(this.buffer, 0, 2, value);
        }
        value(value) {
            return utils.Binary.unsigned(this.buffer, 2, 6, value);
        }
        static LENGTH = 8;
    }
    exports.BlockReference = BlockReference;
    ;
    class BinHeader extends chunks_1.Chunk {
        table;
        count;
        pools;
        constructor(buffer) {
            super(buffer ?? new Uint8Array(BinHeader.LENGTH));
            if (variables_1.DEBUG)
                asserts.IntegerAssert.exactly(this.buffer.length, BinHeader.LENGTH);
            this.identifier(BinHeader.IDENTIFIER);
            this.table = new BlockHeader(this.buffer.subarray(16, 16 + BlockHeader.LENGTH));
            this.count = new BlockReference(this.buffer.subarray(24, 24 + BlockReference.LENGTH));
            this.pools = new Array();
            let offset = 32;
            for (let i = 0; i < 64; i++) {
                let pool = new BlockHeader(this.buffer.subarray(offset, offset + BlockHeader.LENGTH));
                this.pools.push(pool);
                offset += BlockHeader.LENGTH;
            }
        }
        identifier(value) {
            return utils.Binary.string(this.buffer, 0, 8, "binary", value);
        }
        read(readable, offset) {
            super.read(readable, offset);
            if (this.identifier() !== BinHeader.IDENTIFIER) {
                throw `Expected identifier to be ${BinHeader.IDENTIFIER}!`;
            }
        }
        static IDENTIFIER = "atlasbin";
        static LENGTH = 32 + 64 * BlockHeader.LENGTH;
    }
    exports.BinHeader = BinHeader;
    ;
    class BlockManager {
        file;
        header;
        constructor(file, options) {
            this.file = file;
            this.header = new BinHeader();
            if (this.file.size() === 0) {
                this.header.write(this.file, 0);
            }
            else {
                this.header.read(this.file, 0);
            }
            let initialTableCapacity = options?.initialTableCapacity ?? 256;
            let initialPoolCapacity = options?.initialPoolCapacity ?? 16;
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(1, initialTableCapacity);
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(1, initialPoolCapacity);
            if (this.header.table.offset() === 0) {
                this.allocateBlock(this.header.table, initialTableCapacity * BlockHeader.LENGTH);
            }
            for (let pool of this.header.pools) {
                if (pool.offset() === 0) {
                    this.allocateBlock(pool, initialPoolCapacity * BlockReference.LENGTH);
                }
            }
            this.header.write(this.file, 0);
            this.file.persist();
        }
        allocateBlock(header, minLength) {
            let offset = header.offset(this.file.size());
            let length = header.length(minLength);
            this.file.resize(offset + length);
        }
        resizeSystemBlock(header, minLength) {
            if (BlockHeader.getCategory(minLength) <= header.category()) {
                return;
            }
            let offset = header.offset();
            let length = header.length();
            let oldHeader = new BlockHeader();
            oldHeader.offset(offset);
            oldHeader.length(length);
            let buffer = new Uint8Array(length);
            this.file.read(buffer, offset);
            this.allocateBlock(header, minLength);
            this.file.write(buffer, header.offset());
            let count = this.header.count.value();
            this.header.count.value(count + 1);
            this.header.write(this.file, 0);
            let id = count;
            this.writeBlockHeader(id, oldHeader);
            this.deleteBlock(id);
        }
        createNewBlock(minLength) {
            let length = this.header.table.length();
            let count = this.header.count.value();
            let capactity = Math.floor(length / BlockHeader.LENGTH);
            if (count === capactity) {
                this.resizeSystemBlock(this.header.table, length + length);
                // The old system block becomes an application block which affects the block count.
                count = this.header.count.value();
            }
            this.header.count.value(count + 1);
            this.header.write(this.file, 0);
            let id = count;
            let header = new BlockHeader();
            this.allocateBlock(header, minLength);
            this.writeBlockHeader(id, header);
            return id;
        }
        createOldBlock(minLength) {
            let category = BlockHeader.getCategory(minLength);
            let pool = this.header.pools[category];
            let offset = pool.offset();
            let counter = new BlockReference();
            counter.read(this.file, offset);
            let count = counter.value();
            if (count === 0) {
                throw `Expected pool to contain at least one free block!`;
            }
            let pointer = new BlockReference();
            pointer.read(this.file, offset + BlockReference.LENGTH + (count - 1) * BlockReference.LENGTH);
            let id = pointer.value();
            pointer.value(0);
            pointer.write(this.file, offset + BlockReference.LENGTH + (count - 1) * BlockReference.LENGTH);
            counter.value(count - 1);
            counter.write(this.file, offset);
            let header = new BlockHeader();
            this.readBlockHeader(id, header, true);
            header.flag(BlockFlags.DELETED, false);
            this.writeBlockHeader(id, header);
            return id;
        }
        readBlockHeader(id, header, deleted) {
            let count = this.getBlockCount();
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, id, count - 1);
            let offset = this.header.table.offset();
            header.read(this.file, offset + id * BlockHeader.LENGTH);
            if (deleted != null) {
                if (deleted) {
                    if (!header.flag(BlockFlags.DELETED)) {
                        throw `Expected block to be deleted!`;
                    }
                }
                else {
                    if (header.flag(BlockFlags.DELETED)) {
                        throw `Expected block to not be deleted!`;
                    }
                }
            }
        }
        writeBlockHeader(id, header) {
            let count = this.getBlockCount();
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, id, count - 1);
            let offset = this.header.table.offset();
            header.write(this.file, offset + id * BlockHeader.LENGTH);
        }
        *[Symbol.iterator]() {
            for (let bid = 0; bid < this.getBlockCount(); bid++) {
                let header = new BlockHeader();
                this.readBlockHeader(bid, header);
                if (!header.flag(BlockFlags.DELETED)) {
                    let buffer = this.readBlock(bid);
                    yield {
                        bid,
                        buffer
                    };
                }
            }
        }
        clearBlock(id) {
            let header = new BlockHeader();
            this.readBlockHeader(id, header, false);
            let buffer = new Uint8Array(header.length());
            this.writeBlock(id, buffer, 0);
        }
        cloneBlock(idOne) {
            let headerOne = new BlockHeader();
            this.readBlockHeader(idOne, headerOne, false);
            let buffer = new Uint8Array(headerOne.length());
            this.readBlock(idOne, buffer, 0);
            let idTwo = this.createBlock(buffer.length);
            this.writeBlock(idTwo, buffer, 0);
            return idTwo;
        }
        createBlock(minLength) {
            try {
                return this.createOldBlock(minLength);
            }
            catch (error) { }
            try {
                return this.createNewBlock(minLength);
            }
            catch (error) { }
            throw `Expected block with a length of at least ${minLength} bytes to be created!`;
        }
        deleteBlock(id) {
            let header = new BlockHeader();
            this.readBlockHeader(id, header, false);
            let category = header.category();
            let pool = this.header.pools[category];
            let offset = pool.offset();
            let counter = new BlockReference();
            counter.read(this.file, offset);
            let count = counter.value();
            let minLength = BlockReference.LENGTH + (count + 1) * BlockReference.LENGTH;
            if (minLength > pool.length()) {
                this.resizeSystemBlock(pool, minLength);
                offset = pool.offset();
                // The pool block may in theory be deleted and placed in itself.
                counter.read(this.file, offset);
                count = counter.value();
            }
            let pointer = new BlockReference();
            pointer.value(id);
            pointer.write(this.file, offset + BlockReference.LENGTH + count * BlockReference.LENGTH);
            counter.value(count + 1);
            counter.write(this.file, offset);
            this.clearBlock(id);
            header.flags(0);
            header.flag(BlockFlags.DELETED, true);
            this.writeBlockHeader(id, header);
        }
        getBlockCount() {
            return this.header.count.value();
        }
        getBlockFlag(id, bit) {
            let header = new BlockHeader();
            this.readBlockHeader(id, header, false);
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(BlockFlags.APPLICATION_0, bit, BlockFlags.APPLICATION_3);
            return header.flag(bit);
        }
        getBlockSize(id) {
            let header = new BlockHeader();
            this.readBlockHeader(id, header, false);
            return header.length();
        }
        makeReadable(id) {
            return {
                read: (buffer, offset) => this.readBlock(id, buffer, offset)
            };
        }
        makeWritable(id) {
            return {
                write: (buffer, offset) => this.writeBlock(id, buffer, offset)
            };
        }
        readBlock(id, data, blockOffset) {
            let header = new BlockHeader();
            this.readBlockHeader(id, header, false);
            let offset = header.offset();
            let length = header.length();
            data = data ?? new Uint8Array(length);
            let activeBlockOffset = blockOffset ?? 0;
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, activeBlockOffset, length);
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, data.length, length - activeBlockOffset);
            if (blockOffset == null) {
                let buffer = new Uint8Array(length);
                this.file.read(buffer, offset + activeBlockOffset);
                data.set(buffer.subarray(0, data.length), 0);
            }
            else {
                this.file.read(data, offset + activeBlockOffset);
            }
            return data;
        }
        resizeBlock(idOne, minLength) {
            let headerOne = new BlockHeader();
            this.readBlockHeader(idOne, headerOne, false);
            if (BlockHeader.getCategory(minLength) === headerOne.category()) {
                return;
            }
            let idTwo = this.createBlock(minLength);
            let headerTwo = new BlockHeader();
            this.readBlockHeader(idTwo, headerTwo, false);
            let length = Math.min(headerOne.length(), headerTwo.length());
            let buffer = new Uint8Array(length);
            this.readBlock(idOne, buffer, 0);
            this.writeBlock(idTwo, buffer, 0);
            this.swapBlocks(idOne, idTwo);
            this.deleteBlock(idTwo);
        }
        setBlockFlag(id, bit, value) {
            let header = new BlockHeader();
            this.readBlockHeader(id, header, false);
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(BlockFlags.APPLICATION_0, bit, BlockFlags.APPLICATION_3);
            header.flag(bit, value);
            this.writeBlockHeader(id, header);
        }
        swapBlocks(idOne, idTwo) {
            let headerOne = new BlockHeader();
            this.readBlockHeader(idOne, headerOne, false);
            let headerTwo = new BlockHeader();
            this.readBlockHeader(idTwo, headerTwo, false);
            this.writeBlockHeader(idOne, headerTwo);
            this.writeBlockHeader(idTwo, headerOne);
        }
        writeBlock(id, data, blockOffset) {
            let header = new BlockHeader();
            this.readBlockHeader(id, header, false);
            let offset = header.offset();
            let length = header.length();
            let activeBlockOffset = blockOffset ?? 0;
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, activeBlockOffset, length);
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, data.length, length - activeBlockOffset);
            if (blockOffset == null) {
                let buffer = new Uint8Array(length);
                buffer.set(data, 0);
                this.file.write(buffer, offset + activeBlockOffset);
            }
            else {
                this.file.write(data, offset + activeBlockOffset);
            }
            return data;
        }
    }
    exports.BlockManager = BlockManager;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/tables", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/index", "crypto", "node_modules/@joelek/atlas/dist/lib/blocks", "node_modules/@joelek/atlas/dist/lib/chunks", "node_modules/@joelek/atlas/dist/lib/variables", "node_modules/@joelek/atlas/dist/mod/asserts/index", "node_modules/@joelek/atlas/dist/mod/asserts/index"], function (require, exports, bedrock, libcrypto, blocks_1, chunks_1, variables_1, asserts, asserts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Table = exports.HashTableSlot = exports.HashTableHeader = exports.compareBuffers = void 0;
    function compareBuffers(one, two) {
        if (one.length < two.length) {
            return -1;
        }
        if (one.length > two.length) {
            return 1;
        }
        for (let i = 0; i < one.length; i++) {
            let comparison = bedrock.utils.Chunk.comparePrefixes(one[i], two[i]);
            if (comparison !== 0) {
                return comparison;
            }
        }
        return 0;
    }
    exports.compareBuffers = compareBuffers;
    ;
    class HashTableHeader extends chunks_1.Chunk {
        count;
        table;
        constructor(buffer) {
            super(buffer ?? new Uint8Array(HashTableHeader.LENGTH));
            if (variables_1.DEBUG)
                asserts.IntegerAssert.exactly(this.buffer.length, HashTableHeader.LENGTH);
            this.count = new blocks_1.BlockReference(this.buffer.subarray(16, 16 + blocks_1.BlockReference.LENGTH));
            this.table = new blocks_1.BlockReference(this.buffer.subarray(24, 24 + blocks_1.BlockReference.LENGTH));
        }
        static LENGTH = 32;
    }
    exports.HashTableHeader = HashTableHeader;
    ;
    class HashTableSlot extends blocks_1.BlockReference {
        constructor(buffer) {
            super(buffer ?? new Uint8Array(HashTableSlot.LENGTH));
        }
        probeDistance(value) {
            return this.metadata(value);
        }
    }
    exports.HashTableSlot = HashTableSlot;
    ;
    ;
    class Table {
        blockManager;
        bid;
        detail;
        header;
        minimumCapacity;
        constructor(blockManager, detail, options) {
            let blockId = options?.bid;
            this.blockManager = blockManager;
            this.bid = blockId ?? blockManager.createBlock(HashTableHeader.LENGTH);
            this.detail = detail;
            this.header = new HashTableHeader();
            this.minimumCapacity = asserts.IntegerAssert.atLeast(1, options?.minimumCapacity ?? 64);
            if (blockId != null) {
                this.header.read(blockManager.makeReadable(blockId), 0);
            }
            if (this.header.table.value() === 0) {
                let table = blockManager.createBlock(this.minimumCapacity * HashTableSlot.LENGTH);
                this.header.table.value(table);
            }
            this.header.write(blockManager.makeWritable(this.bid), 0);
        }
        readSlot(index, slot) {
            slot.read(this.blockManager.makeReadable(this.header.table.value()), index * HashTableSlot.LENGTH);
            return slot;
        }
        writeSlot(index, slot) {
            slot.write(this.blockManager.makeWritable(this.header.table.value()), index * HashTableSlot.LENGTH);
            return slot;
        }
        computeOptimalSlot(key) {
            let slotCount = this.getSlotCount();
            let hash = Buffer.alloc(6);
            for (let keyPart of key) {
                hash = libcrypto.createHash("sha256")
                    .update(hash)
                    .update(keyPart)
                    .digest();
            }
            return hash.readUIntBE(0, 6) % slotCount;
        }
        doInsert(key, value) {
            let optimalSlot = this.computeOptimalSlot(key);
            let slotCount = this.getSlotCount();
            let probeDistance = 0;
            let slotIndex = optimalSlot;
            let slot = new HashTableSlot();
            for (let i = 0; i < slotCount; i++) {
                this.readSlot(slotIndex, slot);
                if (slot.value() === 0) {
                    slot.probeDistance(probeDistance);
                    slot.value(value);
                    this.writeSlot(slotIndex, slot);
                    return slotIndex;
                }
                if (compareBuffers(this.detail.getKeyFromValue(slot.value()), key) === 0) {
                    return;
                }
                if (probeDistance > slot.probeDistance()) {
                    let replacementSlot = new HashTableSlot();
                    replacementSlot.probeDistance(probeDistance);
                    replacementSlot.value(value);
                    this.writeSlot(slotIndex, replacementSlot);
                    value = slot.value();
                    probeDistance = slot.probeDistance();
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
        }
        doLookup(key) {
            let optimalSlot = this.computeOptimalSlot(key);
            let slotCount = this.getSlotCount();
            let probeDistance = 0;
            let slotIndex = optimalSlot;
            let slot = new HashTableSlot();
            for (let i = 0; i < slotCount; i++) {
                this.readSlot(slotIndex, slot);
                let value = slot.value();
                if (value === 0 || probeDistance > slot.probeDistance()) {
                    return;
                }
                if (compareBuffers(this.detail.getKeyFromValue(value), key) === 0) {
                    return slotIndex;
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
        }
        doRemove(key) {
            let optimalSlot = this.computeOptimalSlot(key);
            let slotCount = this.getSlotCount();
            let probeDistance = 0;
            let slotIndex = optimalSlot;
            let slot = new HashTableSlot();
            for (let i = 0; i < slotCount; i++) {
                this.readSlot(slotIndex, slot);
                let value = slot.value();
                if (value === 0 || probeDistance > slot.probeDistance()) {
                    return;
                }
                if (compareBuffers(this.detail.getKeyFromValue(value), key) === 0) {
                    this.writeSlot(slotIndex, new HashTableSlot());
                    return slotIndex;
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
        }
        getSlotCount() {
            let blockSize = this.blockManager.getBlockSize(this.header.table.value());
            return Math.floor(blockSize / blocks_1.BlockReference.LENGTH);
        }
        propagateBackwards(slotIndex) {
            let slotCount = this.getSlotCount();
            let slot = new HashTableSlot();
            for (let i = 0; i < slotCount; i++) {
                this.readSlot((slotIndex + 1) % slotCount, slot);
                let probeDistance = slot.probeDistance();
                if (probeDistance === 0) {
                    this.writeSlot(slotIndex, new HashTableSlot());
                    break;
                }
                slot.probeDistance(probeDistance - 1);
                this.writeSlot(slotIndex, slot);
                slotIndex = (slotIndex + 1) % slotCount;
            }
        }
        resizeIfNecessary() {
            let slotCount = this.getSlotCount();
            let currentLoadFactor = this.header.count.value() / slotCount;
            let desiredSlotCount = slotCount;
            if (currentLoadFactor <= 0.25) {
                desiredSlotCount = Math.max(Math.ceil(slotCount / 2), this.minimumCapacity);
            }
            if (currentLoadFactor >= 0.75) {
                desiredSlotCount = slotCount * 2;
            }
            if (desiredSlotCount === slotCount) {
                return;
            }
            let values = new Array();
            let slot = new HashTableSlot();
            for (let i = 0; i < slotCount; i++) {
                this.readSlot(i, slot);
                let value = slot.value();
                if (value !== 0) {
                    values.push(value);
                }
            }
            let minLength = desiredSlotCount * blocks_1.BlockReference.LENGTH;
            this.blockManager.resizeBlock(this.header.table.value(), minLength);
            this.blockManager.clearBlock(this.header.table.value());
            for (let value of values) {
                let key = this.detail.getKeyFromValue(value);
                this.doInsert(key, value);
            }
            this.header.write(this.blockManager.makeWritable(this.bid), 0);
        }
        *[Symbol.iterator]() {
            let slotCount = this.getSlotCount();
            let slot = new HashTableSlot();
            for (let i = 0; i < slotCount; i++) {
                this.readSlot(i, slot);
                let value = slot.value();
                if (value !== 0) {
                    yield value;
                }
            }
        }
        delete() {
            this.blockManager.deleteBlock(this.header.table.value());
            this.blockManager.deleteBlock(this.bid);
            this.header.count.value(0);
        }
        insert(key, value) {
            if (variables_1.DEBUG)
                asserts_1.IntegerAssert.atLeast(1, value);
            let slotIndex = this.doInsert(key, value);
            if (slotIndex == null) {
                return false;
            }
            this.header.count.value(this.header.count.value() + 1);
            this.header.write(this.blockManager.makeWritable(this.bid), 0);
            this.resizeIfNecessary();
            return true;
        }
        length() {
            return this.header.count.value();
        }
        lookup(key) {
            let slotIndex = this.doLookup(key);
            if (slotIndex == null) {
                return;
            }
            let slot = new HashTableSlot();
            this.readSlot(slotIndex, slot);
            return slot.value();
        }
        remove(key) {
            let slotIndex = this.doRemove(key);
            if (slotIndex == null) {
                return false;
            }
            this.header.count.value(this.header.count.value() - 1);
            this.header.write(this.blockManager.makeWritable(this.bid), 0);
            this.propagateBackwards(slotIndex);
            this.resizeIfNecessary();
            return true;
        }
        vacate() {
            this.blockManager.clearBlock(this.header.table.value());
            this.header.count.value(0);
            this.header.write(this.blockManager.makeWritable(this.bid), 0);
        }
        static LENGTH = HashTableHeader.LENGTH;
    }
    exports.Table = Table;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/orders", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/index"], function (require, exports, bedrock) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecreasingOrder = exports.IncreasingOrder = exports.Order = void 0;
    class Order {
        constructor() { }
    }
    exports.Order = Order;
    ;
    class IncreasingOrder extends Order {
        constructor() {
            super();
        }
        compare(one, two) {
            let oneEncoded = bedrock.codecs.Any.encodePayload(one);
            let twoEncoded = bedrock.codecs.Any.encodePayload(two);
            return bedrock.utils.Chunk.comparePrefixes(oneEncoded, twoEncoded);
        }
        getDirection() {
            return "increasing";
        }
    }
    exports.IncreasingOrder = IncreasingOrder;
    class DecreasingOrder extends Order {
        constructor() {
            super();
        }
        compare(one, two) {
            let oneEncoded = bedrock.codecs.Any.encodePayload(one);
            let twoEncoded = bedrock.codecs.Any.encodePayload(two);
            return bedrock.utils.Chunk.comparePrefixes(twoEncoded, oneEncoded);
        }
        getDirection() {
            return "decreasing";
        }
    }
    exports.DecreasingOrder = DecreasingOrder;
});
define("node_modules/@joelek/atlas/dist/lib/records", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/index"], function (require, exports, bedrock) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecordManager = exports.NullableStringField = exports.StringField = exports.NullableNumberField = exports.NumberField = exports.NullableIntegerField = exports.IntegerField = exports.NullableBooleanField = exports.BooleanField = exports.NullableBinaryField = exports.BinaryField = exports.NullableBigIntField = exports.BigIntField = exports.Field = void 0;
    class Field {
        codec;
        defaultValue;
        constructor(codec, defaultValue) {
            this.codec = codec;
            this.defaultValue = defaultValue;
        }
        getCodec() {
            return this.codec;
        }
        getDefaultValue() {
            return this.defaultValue;
        }
    }
    exports.Field = Field;
    ;
    class BigIntField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.BigInt, defaultValue);
        }
    }
    exports.BigIntField = BigIntField;
    ;
    class NullableBigIntField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.Union.of(bedrock.codecs.BigInt, bedrock.codecs.Null), defaultValue);
        }
    }
    exports.NullableBigIntField = NullableBigIntField;
    ;
    class BinaryField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.Binary, defaultValue);
        }
    }
    exports.BinaryField = BinaryField;
    ;
    class NullableBinaryField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.Union.of(bedrock.codecs.Binary, bedrock.codecs.Null), defaultValue);
        }
    }
    exports.NullableBinaryField = NullableBinaryField;
    ;
    class BooleanField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.Boolean, defaultValue);
        }
    }
    exports.BooleanField = BooleanField;
    ;
    class NullableBooleanField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.Union.of(bedrock.codecs.Boolean, bedrock.codecs.Null), defaultValue);
        }
    }
    exports.NullableBooleanField = NullableBooleanField;
    ;
    class IntegerField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.Integer, defaultValue);
        }
    }
    exports.IntegerField = IntegerField;
    ;
    class NullableIntegerField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.Union.of(bedrock.codecs.Integer, bedrock.codecs.Null), defaultValue);
        }
    }
    exports.NullableIntegerField = NullableIntegerField;
    ;
    class NumberField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.Number, defaultValue);
        }
    }
    exports.NumberField = NumberField;
    ;
    class NullableNumberField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.Union.of(bedrock.codecs.Number, bedrock.codecs.Null), defaultValue);
        }
    }
    exports.NullableNumberField = NullableNumberField;
    ;
    class StringField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.String, defaultValue);
        }
    }
    exports.StringField = StringField;
    ;
    class NullableStringField extends Field {
        constructor(defaultValue) {
            super(bedrock.codecs.Union.of(bedrock.codecs.String, bedrock.codecs.Null), defaultValue);
        }
    }
    exports.NullableStringField = NullableStringField;
    ;
    class RecordManager {
        fields;
        tupleKeys;
        tupleCodec;
        constructor(fields) {
            this.fields = fields;
            this.tupleKeys = Object.keys(fields).sort();
            this.tupleCodec = bedrock.codecs.Tuple.of(...this.tupleKeys.map((key) => fields[key].getCodec()));
        }
        decode(buffer) {
            let values = this.tupleCodec.decode(buffer, "record");
            let record = {};
            for (let [index, key] of this.tupleKeys.entries()) {
                record[key] = values[index];
            }
            return record;
        }
        encode(record) {
            let values = this.tupleKeys.map((key) => record[key]);
            let buffer = this.tupleCodec.encode(values, "record");
            return buffer;
        }
        decodeKeys(keys, buffers) {
            let record = {};
            for (let [index, key] of keys.entries()) {
                record[key] = this.fields[key].getCodec().decodePayload(buffers[index]);
            }
            return record;
        }
        encodeKeys(keys, record) {
            let buffers = keys.map((key) => this.fields[key].getCodec().encodePayload(record[key]));
            return buffers;
        }
    }
    exports.RecordManager = RecordManager;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/trees", ["require", "exports", "node_modules/@joelek/atlas/dist/mod/asserts/index", "node_modules/@joelek/atlas/dist/lib/chunks", "node_modules/@joelek/atlas/dist/lib/utils", "node_modules/@joelek/atlas/dist/lib/variables"], function (require, exports, asserts_1, chunks_1, utils_1, variables_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RadixTree = exports.RadixTreeWalker = exports.NodeBody = exports.NodeHead = exports.getBytesFromNibbles = exports.getNibblesFromBytes = exports.computeCommonPrefixLength = void 0;
    function computeCommonPrefixLength(one, two) {
        let length = Math.min(one.length, two.length);
        for (let i = 0; i < length; i++) {
            if (one[i] !== two[i]) {
                return i;
            }
        }
        return length;
    }
    exports.computeCommonPrefixLength = computeCommonPrefixLength;
    ;
    function getNibblesFromBytes(buffer) {
        let nibbles = new Array();
        for (let byte of buffer) {
            let one = (byte >> 4) & 0x0F;
            let two = (byte >> 0) & 0x0F;
            nibbles.push(one, two);
        }
        return nibbles;
    }
    exports.getNibblesFromBytes = getNibblesFromBytes;
    ;
    function getBytesFromNibbles(nibbles) {
        if (variables_1.DEBUG)
            asserts_1.IntegerAssert.exactly(nibbles.length % 2, 0);
        let bytes = new Array();
        for (let i = 0; i < nibbles.length; i += 2) {
            let one = nibbles[i + 0];
            if (variables_1.DEBUG)
                asserts_1.IntegerAssert.between(0, one, 15);
            let two = nibbles[i + 1];
            if (variables_1.DEBUG)
                asserts_1.IntegerAssert.between(0, two, 15);
            let byte = (one << 4) | (two << 0);
            bytes.push(byte);
        }
        return Uint8Array.from(bytes);
    }
    exports.getBytesFromNibbles = getBytesFromNibbles;
    ;
    class NodeHead extends chunks_1.Chunk {
        nibbles(offset, length, value) {
            if (value != null) {
                if (variables_1.DEBUG)
                    asserts_1.IntegerAssert.between(0, value.length, length * 2);
                let bytes = getBytesFromNibbles(value.length % 2 === 1 ? [...value, 0] : value);
                this.prefixLength(value.length);
                this.buffer.set(bytes, offset);
                this.buffer.fill(0, offset + bytes.length, offset + length);
                return value;
            }
            else {
                let bytes = this.buffer.subarray(offset, offset + length);
                let nibbles = getNibblesFromBytes(bytes);
                return nibbles.slice(0, this.prefixLength());
            }
        }
        constructor(buffer) {
            super(buffer ?? new Uint8Array(NodeHead.LENGTH));
            if (variables_1.DEBUG)
                asserts_1.IntegerAssert.exactly(this.buffer.length, NodeHead.LENGTH);
        }
        prefixLength(value) {
            return utils_1.Binary.unsigned(this.buffer, 0, 1, value);
        }
        prefix(value) {
            return this.nibbles(1, NodeHead.MAX_PREFIX_BYTES, value);
        }
        resident(value) {
            return utils_1.Binary.unsigned(this.buffer, 14, 6, value);
        }
        subtree(value) {
            return utils_1.Binary.unsigned(this.buffer, 20, 6, value);
        }
        total(value) {
            return utils_1.Binary.unsigned(this.buffer, 26, 6, value);
        }
        static LENGTH = 32;
        static MAX_PREFIX_BYTES = 13;
        static MAX_PREFIX_NIBBLES = NodeHead.MAX_PREFIX_BYTES * 2;
    }
    exports.NodeHead = NodeHead;
    ;
    class NodeBody extends chunks_1.Chunk {
        constructor(buffer) {
            super(buffer ?? new Uint8Array(NodeBody.LENGTH));
            if (variables_1.DEBUG)
                asserts_1.IntegerAssert.exactly(this.buffer.length, NodeBody.LENGTH);
        }
        child(index, value) {
            if (variables_1.DEBUG)
                asserts_1.IntegerAssert.between(0, index, 15);
            return utils_1.Binary.unsigned(this.buffer, index * 6, 6, value);
        }
        static OFFSET = NodeHead.LENGTH;
        static LENGTH = 16 * 6;
    }
    exports.NodeBody = NodeBody;
    ;
    class RadixTreeWalker {
        blockManager;
        relationship;
        keys;
        directions;
        *doYield(bid, depth, relationship, reverse, include) {
            let iterables = [];
            if (include.resident || include.subtree) {
                let head = new NodeHead();
                this.blockManager.readBlock(bid, head.buffer, 0);
                if (include.resident) {
                    let resident = head.resident();
                    if (resident !== 0) {
                        iterables.push([resident]);
                    }
                }
                if (include.subtree) {
                    let subtree = head.subtree();
                    if (subtree !== 0) {
                        let reverse = this.directions[depth + 1] === "decreasing";
                        let relationship = this.relationship;
                        if (reverse) {
                            if (relationship === "<") {
                                relationship = ">";
                            }
                            else if (relationship === "<=") {
                                relationship = ">=";
                            }
                            else if (relationship === ">") {
                                relationship = "<";
                            }
                            else if (relationship === ">=") {
                                relationship = "<=";
                            }
                        }
                        iterables.push(this.doYield(subtree, depth + 1, relationship, reverse, { resident: true, subtree: true, children: true }));
                    }
                }
            }
            if (include.children) {
                if (this.blockManager.getBlockSize(bid) >= NodeHead.LENGTH + NodeBody.LENGTH) {
                    let body = new NodeBody();
                    this.blockManager.readBlock(bid, body.buffer, NodeBody.OFFSET);
                    for (let i = 0; i < 16; i++) {
                        let child = body.child(i);
                        if (child !== 0) {
                            iterables.push(this.doYield(child, depth, relationship, reverse, { resident: true, subtree: true, children: true }));
                        }
                    }
                }
            }
            for (let iterable of reverse ? iterables.reverse() : iterables) {
                yield* iterable;
            }
        }
        *onKeyIsNodeKey(bid, depth, relationship, reverse) {
            let iterables = [];
            if (relationship === "^=") {
                if (depth === this.keys.length - 1) {
                    iterables.push(this.doYield(bid, depth, relationship, reverse, { resident: true, subtree: true, children: true }));
                }
                else {
                    let head = new NodeHead();
                    this.blockManager.readBlock(bid, head.buffer, 0);
                    let subtree = head.subtree();
                    if (subtree !== 0) {
                        iterables.push(this.doTraverse(subtree, depth + 1));
                    }
                }
            }
            else if (relationship === "=") {
                if (depth === this.keys.length - 1) {
                    iterables.push(this.doYield(bid, depth, relationship, reverse, { resident: true, subtree: false, children: false }));
                }
                else {
                    let head = new NodeHead();
                    this.blockManager.readBlock(bid, head.buffer, 0);
                    let subtree = head.subtree();
                    if (subtree !== 0) {
                        iterables.push(this.doTraverse(subtree, depth + 1));
                    }
                }
            }
            else if (relationship === ">") {
                if (depth === this.keys.length - 1) {
                    iterables.push(this.doYield(bid, depth, relationship, reverse, { resident: false, subtree: true, children: true }));
                }
                else {
                    let head = new NodeHead();
                    this.blockManager.readBlock(bid, head.buffer, 0);
                    let subtree = head.subtree();
                    if (subtree !== 0) {
                        iterables.push(this.doTraverse(subtree, depth + 1));
                    }
                }
            }
            else if (relationship === ">=") {
                if (depth === this.keys.length - 1) {
                    iterables.push(this.doYield(bid, depth, relationship, reverse, { resident: true, subtree: true, children: true }));
                }
                else {
                    let head = new NodeHead();
                    this.blockManager.readBlock(bid, head.buffer, 0);
                    let subtree = head.subtree();
                    if (subtree !== 0) {
                        iterables.push(this.doTraverse(subtree, depth + 1));
                    }
                }
            }
            else if (relationship === "<") {
                if (depth === this.keys.length - 1) {
                    iterables.push(this.doYield(bid, depth, relationship, reverse, { resident: false, subtree: false, children: false }));
                }
                else {
                    let head = new NodeHead();
                    this.blockManager.readBlock(bid, head.buffer, 0);
                    let resident = head.resident();
                    if (resident !== 0) {
                        iterables.push([resident]);
                    }
                    let subtree = head.subtree();
                    if (subtree !== 0) {
                        iterables.push(this.doTraverse(subtree, depth + 1));
                    }
                }
            }
            else if (relationship === "<=") {
                if (depth === this.keys.length - 1) {
                    iterables.push(this.doYield(bid, depth, relationship, reverse, { resident: true, subtree: false, children: false }));
                }
                else {
                    let head = new NodeHead();
                    this.blockManager.readBlock(bid, head.buffer, 0);
                    let resident = head.resident();
                    if (resident !== 0) {
                        iterables.push([resident]);
                    }
                    let subtree = head.subtree();
                    if (subtree !== 0) {
                        iterables.push(this.doTraverse(subtree, depth + 1));
                    }
                }
            }
            for (let iterable of reverse ? iterables.reverse() : iterables) {
                yield* iterable;
            }
        }
        *onKeyIsPrefixForNodeKey(bid, depth, relationship, reverse) {
            let iterables = [];
            if (relationship === "^=") {
                if (depth === this.keys.length - 1) {
                    iterables.push(this.doYield(bid, depth, relationship, reverse, { resident: true, subtree: true, children: true }));
                }
            }
            else if (relationship === ">") {
                iterables.push(this.doYield(bid, depth, relationship, reverse, { resident: true, subtree: true, children: true }));
            }
            else if (relationship === ">=") {
                iterables.push(this.doYield(bid, depth, relationship, reverse, { resident: true, subtree: true, children: true }));
            }
            for (let iterable of reverse ? iterables.reverse() : iterables) {
                yield* iterable;
            }
        }
        *onKeyIsBeforeNodeKey(bid, depth, relationship, reverse) {
            if (relationship === ">") {
                yield* this.doYield(bid, depth, relationship, reverse, { resident: true, subtree: true, children: true });
            }
            else if (relationship === ">=") {
                yield* this.doYield(bid, depth, relationship, reverse, { resident: true, subtree: true, children: true });
            }
        }
        *onKeyIsAfterNodeKey(bid, depth, relationship, reverse) {
            if (relationship === "<") {
                yield* this.doYield(bid, depth, relationship, reverse, { resident: true, subtree: true, children: true });
            }
            else if (relationship === "<=") {
                yield* this.doYield(bid, depth, relationship, reverse, { resident: true, subtree: true, children: true });
            }
        }
        *onNodeKeyIsPrefixForKey(bid, depth, relationship, reverse, suffix) {
            let iterables = [];
            if (relationship === "<" || relationship === "<=") {
                let head = new NodeHead();
                this.blockManager.readBlock(bid, head.buffer, 0);
                let resident = head.resident();
                if (resident !== 0) {
                    iterables.push([resident]);
                }
                let subtree = head.subtree();
                if (subtree !== 0) {
                    iterables.push(this.doTraverse(subtree, depth + 1));
                }
            }
            if (this.blockManager.getBlockSize(bid) >= NodeHead.LENGTH + NodeBody.LENGTH) {
                let body = new NodeBody();
                this.blockManager.readBlock(bid, body.buffer, NodeBody.OFFSET);
                let index = suffix[0];
                if (relationship === "<" || relationship === "<=") {
                    for (let i = 0; i < index; i++) {
                        let child = body.child(i);
                        if (child !== 0) {
                            iterables.push(this.doYield(child, depth, relationship, reverse, { resident: true, subtree: true, children: true }));
                        }
                    }
                }
                let child = body.child(index);
                if (child !== 0) {
                    iterables.push(this.visitNode(child, depth, relationship, reverse, suffix.slice(1)));
                }
                if (relationship === ">" || relationship === ">=") {
                    for (let i = index + 1; i < 16; i++) {
                        let child = body.child(i);
                        if (child !== 0) {
                            iterables.push(this.doYield(child, depth, relationship, reverse, { resident: true, subtree: true, children: true }));
                        }
                    }
                }
            }
            for (let iterable of reverse ? iterables.reverse() : iterables) {
                yield* iterable;
            }
        }
        *visitNode(bid, depth, relationship, reverse, suffix) {
            let head = new NodeHead();
            this.blockManager.readBlock(bid, head.buffer, 0);
            let prefix = head.prefix();
            let commonPrefixLength = computeCommonPrefixLength(prefix, suffix);
            let nextPrefixNibble = prefix[commonPrefixLength];
            let nextSuffixNibble = suffix[commonPrefixLength];
            if (nextSuffixNibble == null) {
                if (nextPrefixNibble == null) {
                    yield* this.onKeyIsNodeKey(bid, depth, relationship, reverse);
                }
                else {
                    yield* this.onKeyIsPrefixForNodeKey(bid, depth, relationship, reverse);
                }
            }
            else {
                if (nextPrefixNibble == null) {
                    yield* this.onNodeKeyIsPrefixForKey(bid, depth, relationship, reverse, suffix.slice(commonPrefixLength));
                }
                else {
                    if (nextSuffixNibble < nextPrefixNibble) {
                        yield* this.onKeyIsBeforeNodeKey(bid, depth, relationship, reverse);
                    }
                    else {
                        yield* this.onKeyIsAfterNodeKey(bid, depth, relationship, reverse);
                    }
                }
            }
        }
        *doTraverse(bid, depth) {
            let suffix = this.keys[depth]?.slice() ?? [];
            let direction = this.directions[depth] ?? "increasing";
            let reverse = direction === "decreasing";
            let relationship = this.relationship;
            if (reverse) {
                if (relationship === "<") {
                    relationship = ">";
                }
                else if (relationship === "<=") {
                    relationship = ">=";
                }
                else if (relationship === ">") {
                    relationship = "<";
                }
                else if (relationship === ">=") {
                    relationship = "<=";
                }
            }
            yield* this.visitNode(bid, depth, relationship, reverse, suffix);
        }
        constructor(blockManager, relationship, keys, directions) {
            this.blockManager = blockManager;
            this.relationship = relationship;
            this.keys = keys.length > 0 ? keys : [[]];
            this.directions = directions;
        }
        *traverse(bid) {
            yield* this.doTraverse(bid, 0);
        }
    }
    exports.RadixTreeWalker = RadixTreeWalker;
    ;
    class RadixTree {
        blockManager;
        blockIndex;
        doDelete(bid) {
            let head = new NodeHead();
            this.blockManager.readBlock(bid, head.buffer, 0);
            if (this.blockManager.getBlockSize(bid) >= NodeHead.LENGTH + NodeBody.LENGTH) {
                let body = new NodeBody();
                this.blockManager.readBlock(bid, body.buffer, NodeBody.OFFSET);
                for (let i = 0; i < 16; i++) {
                    let child = body.child(i);
                    if (child !== 0) {
                        this.doDelete(child);
                    }
                }
            }
            let subtree = head.subtree();
            if (subtree !== 0) {
                this.doDelete(subtree);
            }
            this.blockManager.deleteBlock(bid);
        }
        doInsert(keys, value, bid, suffix) {
            let head = new NodeHead();
            this.blockManager.readBlock(bid, head.buffer, 0);
            let prefix = head.prefix();
            let total = head.total();
            let commonPrefixLength = computeCommonPrefixLength(prefix, suffix);
            let nextPrefixNibble = prefix[commonPrefixLength];
            let nextSuffixNibble = suffix[commonPrefixLength];
            if (nextSuffixNibble == null) {
                if (nextPrefixNibble == null) {
                    // Key is identical to node.
                    if (keys.length === 0) {
                        let resident = head.resident();
                        if (resident !== 0) {
                            resident = head.resident(value);
                            this.blockManager.writeBlock(bid, head.buffer, 0);
                            return;
                        }
                        total = head.total(total + 1);
                        resident = head.resident(value);
                        this.blockManager.writeBlock(bid, head.buffer, 0);
                        return total;
                    }
                    else {
                        let subtree = head.subtree();
                        if (subtree === 0) {
                            subtree = head.subtree(this.blockManager.createBlock(NodeHead.LENGTH));
                            this.blockManager.writeBlock(bid, head.buffer, 0);
                        }
                        let outcome = this.doInsert(keys.slice(1), value, subtree, keys[0]);
                        if (outcome == null) {
                            return;
                        }
                        total = head.total(total + 1);
                        this.blockManager.writeBlock(bid, head.buffer, 0);
                        return total;
                    }
                }
                else {
                    // Key is prefix to node.
                    let index = nextPrefixNibble;
                    head.prefix(prefix.slice(commonPrefixLength + 1));
                    this.blockManager.writeBlock(bid, head.buffer, 0);
                    let bidTwo = this.blockManager.createBlock(NodeHead.LENGTH + NodeBody.LENGTH);
                    let headTwo = new NodeHead();
                    headTwo.prefix(prefix.slice(0, commonPrefixLength));
                    headTwo.total(total);
                    this.blockManager.writeBlock(bidTwo, headTwo.buffer, 0);
                    let bodyTwo = new NodeBody();
                    bodyTwo.child(index, bidTwo);
                    this.blockManager.writeBlock(bidTwo, bodyTwo.buffer, NodeBody.OFFSET);
                    this.blockManager.swapBlocks(bid, bidTwo);
                    return this.doInsert(keys, value, bid, suffix);
                }
            }
            else {
                if (nextPrefixNibble == null) {
                    // Node is prefix to key.
                    if (commonPrefixLength === 0 && total === 0) {
                        head.prefix(suffix.slice(0, NodeHead.MAX_PREFIX_NIBBLES));
                        this.blockManager.writeBlock(bid, head.buffer, 0);
                        return this.doInsert(keys, value, bid, suffix);
                    }
                    else {
                        if (this.blockManager.getBlockSize(bid) < NodeHead.LENGTH + NodeBody.LENGTH) {
                            this.blockManager.resizeBlock(bid, NodeHead.LENGTH + NodeBody.LENGTH);
                        }
                        let index = nextSuffixNibble;
                        let body = new NodeBody();
                        this.blockManager.readBlock(bid, body.buffer, NodeBody.OFFSET);
                        let child = body.child(index);
                        if (child === 0) {
                            child = body.child(index, this.blockManager.createBlock(NodeHead.LENGTH));
                            this.blockManager.writeBlock(bid, body.buffer, NodeBody.OFFSET);
                        }
                        let outcome = this.doInsert(keys, value, child, suffix.slice(commonPrefixLength + 1));
                        if (outcome == null) {
                            return;
                        }
                        total = head.total(total + 1);
                        this.blockManager.writeBlock(bid, head.buffer, 0);
                        return total;
                    }
                }
                else {
                    // Key is sibling to node.
                    let index = nextPrefixNibble;
                    head.prefix(prefix.slice(commonPrefixLength + 1));
                    this.blockManager.writeBlock(bid, head.buffer, 0);
                    let bidTwo = this.blockManager.createBlock(NodeHead.LENGTH + NodeBody.LENGTH);
                    let headTwo = new NodeHead();
                    headTwo.prefix(prefix.slice(0, commonPrefixLength));
                    headTwo.total(total);
                    this.blockManager.writeBlock(bidTwo, headTwo.buffer, 0);
                    let bodyTwo = new NodeBody();
                    bodyTwo.child(index, bidTwo);
                    this.blockManager.writeBlock(bidTwo, bodyTwo.buffer, NodeBody.OFFSET);
                    this.blockManager.swapBlocks(bid, bidTwo);
                    return this.doInsert(keys, value, bid, suffix);
                }
            }
        }
        doLocate(keys, bid, suffix) {
            let head = new NodeHead();
            this.blockManager.readBlock(bid, head.buffer, 0);
            let prefix = head.prefix();
            let total = head.total();
            let commonPrefixLength = computeCommonPrefixLength(prefix, suffix);
            let nextPrefixNibble = prefix[commonPrefixLength];
            let nextSuffixNibble = suffix[commonPrefixLength];
            if (nextSuffixNibble == null) {
                if (nextPrefixNibble == null) {
                    // Key is identical to node.
                    if (keys.length === 0) {
                        return bid;
                    }
                    else {
                        let subtree = head.subtree();
                        if (subtree === 0) {
                            return;
                        }
                        return this.doLocate(keys.slice(1), subtree, keys[0]);
                    }
                }
                else {
                    // Key is prefix to node.
                    return;
                }
            }
            else {
                if (nextPrefixNibble == null) {
                    // Node is prefix to key.
                    if (commonPrefixLength === 0 && total === 0) {
                        return;
                    }
                    else {
                        if (this.blockManager.getBlockSize(bid) < NodeHead.LENGTH + NodeBody.LENGTH) {
                            return;
                        }
                        let index = nextSuffixNibble;
                        let body = new NodeBody();
                        this.blockManager.readBlock(bid, body.buffer, NodeBody.OFFSET);
                        let child = body.child(index);
                        if (child === 0) {
                            return;
                        }
                        return this.doLocate(keys, child, suffix.slice(commonPrefixLength + 1));
                    }
                }
                else {
                    // Key is sibling to node.
                    return;
                }
            }
        }
        doRemove(keys, bid, suffix) {
            let head = new NodeHead();
            this.blockManager.readBlock(bid, head.buffer, 0);
            let prefix = head.prefix();
            let total = head.total();
            let commonPrefixLength = computeCommonPrefixLength(prefix, suffix);
            let nextPrefixNibble = prefix[commonPrefixLength];
            let nextSuffixNibble = suffix[commonPrefixLength];
            if (nextSuffixNibble == null) {
                if (nextPrefixNibble == null) {
                    // Key is identical to node.
                    if (keys.length === 0) {
                        let resident = head.resident();
                        if (resident === 0) {
                            return;
                        }
                        resident = head.resident(0);
                        total = head.total(total - 1);
                        this.blockManager.writeBlock(bid, head.buffer, 0);
                        return total;
                    }
                    else {
                        let subtree = head.subtree();
                        if (subtree === 0) {
                            return;
                        }
                        let outcome = this.doRemove(keys.slice(1), subtree, keys[0]);
                        if (outcome == null) {
                            return;
                        }
                        if (outcome === 0) {
                            this.blockManager.deleteBlock(subtree);
                            subtree = head.subtree(0);
                            this.blockManager.writeBlock(bid, head.buffer, 0);
                        }
                        total = head.total(total - 1);
                        this.blockManager.writeBlock(bid, head.buffer, 0);
                        return total;
                    }
                }
                else {
                    // Key is prefix to node.
                    return;
                }
            }
            else {
                if (nextPrefixNibble == null) {
                    // Node is prefix to key.
                    if (commonPrefixLength === 0 && total === 0) {
                        return;
                    }
                    else {
                        if (this.blockManager.getBlockSize(bid) < NodeHead.LENGTH + NodeBody.LENGTH) {
                            return;
                        }
                        let index = nextSuffixNibble;
                        let body = new NodeBody();
                        this.blockManager.readBlock(bid, body.buffer, NodeBody.OFFSET);
                        let child = body.child(index);
                        if (child === 0) {
                            return;
                        }
                        let outcome = this.doRemove(keys, child, suffix.slice(commonPrefixLength + 1));
                        if (outcome == null) {
                            return;
                        }
                        if (outcome === 0) {
                            this.blockManager.deleteBlock(child);
                            child = body.child(index, 0);
                            this.blockManager.writeBlock(bid, body.buffer, NodeBody.OFFSET);
                        }
                        total = head.total(total - 1);
                        this.blockManager.writeBlock(bid, head.buffer, 0);
                        return total;
                    }
                }
                else {
                    // Key is sibling to node.
                    return;
                }
            }
        }
        doVacate(bid) {
            let head = new NodeHead();
            this.blockManager.readBlock(bid, head.buffer, 0);
            if (this.blockManager.getBlockSize(bid) >= NodeHead.LENGTH + NodeBody.LENGTH) {
                let body = new NodeBody();
                this.blockManager.readBlock(bid, body.buffer, NodeBody.OFFSET);
                for (let i = 0; i < 16; i++) {
                    let child = body.child(i);
                    if (child !== 0) {
                        this.doVacate(child);
                    }
                }
            }
            let subtree = head.subtree();
            if (subtree !== 0) {
                this.doVacate(subtree);
            }
            if (bid === this.blockIndex) {
                this.blockManager.clearBlock(bid);
            }
            else {
                this.blockManager.deleteBlock(bid);
            }
        }
        locate(keys) {
            let nibbles = keys.map(getNibblesFromBytes);
            return this.doLocate(nibbles.slice(1), this.blockIndex, nibbles[0] ?? []);
        }
        constructor(blockManager, blockIndex) {
            this.blockManager = blockManager;
            this.blockIndex = blockIndex;
        }
        *[Symbol.iterator]() {
            yield* this.filter("^=", []);
        }
        branch(keys) {
            let bid = this.locate(keys);
            if (bid == null) {
                return;
            }
            let head = new NodeHead();
            this.blockManager.readBlock(bid, head.buffer, 0);
            let subtree = head.subtree();
            if (subtree === 0) {
                return;
            }
            return new RadixTree(this.blockManager, subtree);
        }
        delete() {
            this.doDelete(this.blockIndex);
        }
        *filter(relationship, keys, directions) {
            let nibbles = keys.map(getNibblesFromBytes);
            let treeWalker = new RadixTreeWalker(this.blockManager, relationship, nibbles, directions ?? []);
            yield* treeWalker.traverse(this.blockIndex);
        }
        insert(keys, value) {
            if (variables_1.DEBUG)
                asserts_1.IntegerAssert.atLeast(1, value);
            let nibbles = keys.map(getNibblesFromBytes);
            return this.doInsert(nibbles.slice(1), value, this.blockIndex, nibbles[0] ?? []) != null;
        }
        length() {
            let head = new NodeHead();
            this.blockManager.readBlock(this.blockIndex, head.buffer, 0);
            return head.total();
        }
        lookup(keys) {
            let bid = this.locate(keys);
            if (bid == null) {
                return;
            }
            let head = new NodeHead();
            this.blockManager.readBlock(bid, head.buffer, 0);
            let resident = head.resident();
            if (resident === 0) {
                return;
            }
            return resident;
        }
        remove(keys) {
            let nibbles = keys.map(getNibblesFromBytes);
            return this.doRemove(nibbles.slice(1), this.blockIndex, nibbles[0] ?? []) != null;
        }
        vacate() {
            this.doVacate(this.blockIndex);
        }
        static INITIAL_SIZE = NodeHead.LENGTH;
    }
    exports.RadixTree = RadixTree;
    ;
});
define("node_modules/@joelek/atlas/dist/mod/sorters/composite", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompositeSorter = void 0;
    exports.CompositeSorter = {
        of(...rankers) {
            return (one, two) => {
                for (let ranker of rankers) {
                    let rank = ranker(one, two);
                    if (rank !== 0) {
                        return rank;
                    }
                }
                return 0;
            };
        }
    };
});
define("node_modules/@joelek/atlas/dist/mod/sorters/custom", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CustomSorter = void 0;
    exports.CustomSorter = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (o == null) {
                    if (t == null) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (t == null) {
                    if (o == null) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return (t ? 1 : 0) - (o ? 1 : 0);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (o == null) {
                    if (t == null) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (t == null) {
                    if (o == null) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return (o ? 1 : 0) - (t ? 1 : 0);
            };
        }
    };
});
define("node_modules/@joelek/atlas/dist/mod/sorters/number", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumberSorter = void 0;
    exports.NumberSorter = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (o == null) {
                    if (t == null) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (t == null) {
                    if (o == null) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t - o;
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (o == null) {
                    if (t == null) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (t == null) {
                    if (o == null) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o - t;
            };
        }
    };
});
define("node_modules/@joelek/atlas/dist/mod/sorters/shared", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("node_modules/@joelek/atlas/dist/mod/sorters/string", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringSorter = void 0;
    exports.StringSorter = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (o == null) {
                    if (t == null) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (t == null) {
                    if (o == null) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t.localeCompare(o);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (o == null) {
                    if (t == null) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (t == null) {
                    if (o == null) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o.localeCompare(t);
            };
        }
    };
});
define("node_modules/@joelek/atlas/dist/mod/sorters/index", ["require", "exports", "node_modules/@joelek/atlas/dist/mod/sorters/composite", "node_modules/@joelek/atlas/dist/mod/sorters/custom", "node_modules/@joelek/atlas/dist/mod/sorters/number", "node_modules/@joelek/atlas/dist/mod/sorters/shared", "node_modules/@joelek/atlas/dist/mod/sorters/string"], function (require, exports, composite_1, custom_1, number_1, shared_1, string_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function () { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (this && this.__exportStar) || function (m, exports) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
                __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(composite_1, exports);
    __exportStar(custom_1, exports);
    __exportStar(number_1, exports);
    __exportStar(shared_1, exports);
    __exportStar(string_2, exports);
});
define("node_modules/@joelek/atlas/dist/lib/stores", ["require", "exports", "node_modules/@joelek/atlas/dist/lib/streams", "node_modules/@joelek/atlas/dist/lib/filters", "node_modules/@joelek/atlas/dist/lib/tables", "node_modules/@joelek/atlas/dist/lib/orders", "node_modules/@joelek/atlas/dist/lib/records", "node_modules/@joelek/atlas/dist/lib/trees", "node_modules/@joelek/atlas/dist/mod/sorters/index"], function (require, exports, streams_1, filters_1, tables_1, orders_1, records_1, trees_1, sorters_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OverridableWritableStore = exports.Store = exports.Index = exports.StoreManager = exports.IndexManager = exports.FilteredStore = exports.WritableStoreManager = void 0;
    ;
    class WritableStoreManager {
        storeManager;
        constructor(storeManager) {
            this.storeManager = storeManager;
        }
        async filter(...parameters) {
            return this.storeManager.filter(...parameters);
        }
        async insert(...parameters) {
            return this.storeManager.insert(...parameters);
        }
        async length(...parameters) {
            return this.storeManager.length(...parameters);
        }
        async lookup(...parameters) {
            return this.storeManager.lookup(...parameters);
        }
        async remove(...parameters) {
            return this.storeManager.remove(...parameters);
        }
        async update(...parameters) {
            return this.storeManager.update(...parameters);
        }
        async vacate(...parameters) {
            return this.storeManager.vacate(...parameters);
        }
    }
    exports.WritableStoreManager = WritableStoreManager;
    ;
    class FilteredStore {
        recordManager;
        blockManager;
        bids;
        filters;
        orders;
        anchor;
        constructor(recordManager, blockManager, bids, filters, orders, anchor) {
            this.recordManager = recordManager;
            this.blockManager = blockManager;
            this.bids = bids;
            this.filters = filters ?? {};
            this.orders = orders ?? {};
            this.anchor = anchor;
        }
        *[Symbol.iterator]() {
            let iterable = streams_1.StreamIterable.of(this.bids)
                .map((bid) => {
                let buffer = this.blockManager.readBlock(bid);
                let record = this.recordManager.decode(buffer);
                return record;
            })
                .filter((record) => {
                for (let key in this.filters) {
                    let filter = this.filters[key];
                    if (filter == null) {
                        continue;
                    }
                    let value = record[key];
                    if (!filter.matches(value)) {
                        return false;
                    }
                }
                return true;
            });
            if (Object.keys(this.orders).length > 0) {
                iterable = iterable.sort((one, two) => {
                    for (let key in this.orders) {
                        let order = this.orders[key];
                        if (order == null) {
                            continue;
                        }
                        let comparison = order.compare(one[key], two[key]);
                        if (comparison !== 0) {
                            return comparison;
                        }
                    }
                    return 0;
                });
            }
            if (this.anchor != null) {
                let encodedAnchor = this.recordManager.encode(this.anchor);
                let found = false;
                iterable = iterable.filter((record) => {
                    if (!found) {
                        let encodedRecord = this.recordManager.encode(record);
                        if ((0, tables_1.compareBuffers)([encodedAnchor], [encodedRecord]) === 0) {
                            found = true;
                            return false;
                        }
                    }
                    return found;
                });
            }
            yield* iterable;
        }
        static getOptimal(filteredStores) {
            filteredStores.sort(sorters_1.CompositeSorter.of(sorters_1.NumberSorter.decreasing((value) => Object.keys(value.orders).length), sorters_1.NumberSorter.decreasing((value) => Object.keys(value.filters).length)));
            return filteredStores.pop();
        }
    }
    exports.FilteredStore = FilteredStore;
    ;
    class IndexManager {
        recordManager;
        blockManager;
        bid;
        keys;
        tree;
        constructor(recordManager, blockManager, keys, options) {
            let bid = options?.bid ?? blockManager.createBlock(trees_1.RadixTree.INITIAL_SIZE);
            this.recordManager = recordManager;
            this.blockManager = blockManager;
            this.bid = bid;
            this.keys = keys;
            this.tree = new trees_1.RadixTree(blockManager, bid);
        }
        *[Symbol.iterator]() {
            yield* new FilteredStore(this.recordManager, this.blockManager, this.tree, {}, {});
        }
        delete() {
            this.tree.delete();
        }
        filter(filters, orders, anchor) {
            filters = filters ?? {};
            orders = orders ?? {};
            filters = { ...filters };
            orders = { ...orders };
            let keysConsumed = [];
            let keysRemaining = [...this.keys];
            let tree = this.tree;
            for (let indexKey of this.keys) {
                let filter = filters[indexKey];
                if (filter == null) {
                    break;
                }
                if (filter instanceof filters_1.EqualityFilter) {
                    let encodedValue = filter.getEncodedValue();
                    let branch = tree.branch([encodedValue]);
                    if (branch == null) {
                        return;
                    }
                    delete filters[indexKey];
                    delete orders[indexKey];
                    keysConsumed.push(keysRemaining.shift());
                    tree = branch;
                }
            }
            let directions = [];
            let orderKeys = Object.keys(orders);
            for (let i = 0; i < orderKeys.length; i++) {
                if (keysRemaining[i] !== orderKeys[i]) {
                    break;
                }
                let order = orders[orderKeys[i]];
                if (order == null) {
                    break;
                }
                directions.push(order.getDirection());
                delete orders[orderKeys[i]];
            }
            let relationship = "^=";
            let keys = [];
            if (anchor != null) {
                relationship = ">";
                keys = this.recordManager.encodeKeys(keysRemaining, anchor);
            }
            let iterable = tree.filter(relationship, keys, directions);
            return new FilteredStore(this.recordManager, this.blockManager, iterable, filters, orders);
        }
        insert(keysRecord, bid) {
            let keys = this.recordManager.encodeKeys(this.keys, keysRecord);
            this.tree.insert(keys, bid);
        }
        remove(keysRecord) {
            let keys = this.recordManager.encodeKeys(this.keys, keysRecord);
            this.tree.remove(keys);
        }
        update(oldKeysRecord, newKeysRecord, bid) {
            let oldKeys = this.recordManager.encodeKeys(this.keys, oldKeysRecord);
            let newKeys = this.recordManager.encodeKeys(this.keys, newKeysRecord);
            if ((0, tables_1.compareBuffers)(oldKeys, newKeys) === 0) {
                return;
            }
            this.tree.remove(oldKeys);
            this.tree.insert(newKeys, bid);
        }
        vacate() {
            this.tree.vacate();
        }
    }
    exports.IndexManager = IndexManager;
    ;
    class StoreManager {
        blockManager;
        fields;
        keys;
        orders;
        recordManager;
        table;
        indexManagers;
        getDefaultRecord() {
            let record = {};
            for (let key in this.fields) {
                record[key] = this.fields[key].getDefaultValue();
            }
            return record;
        }
        constructor(blockManager, fields, keys, orders, table, indexManagers) {
            this.blockManager = blockManager;
            this.fields = fields;
            this.keys = keys;
            this.orders = orders;
            this.recordManager = new records_1.RecordManager(fields);
            this.table = table;
            this.indexManagers = indexManagers;
        }
        *[Symbol.iterator]() {
            yield* this.filter();
        }
        delete() {
            for (let bid of this.table) {
                this.blockManager.deleteBlock(bid);
            }
            for (let indexManager of this.indexManagers) {
                indexManager.delete();
            }
            this.table.delete();
        }
        filter(filters, orders, anchorKeysRecord, limit) {
            orders = orders ?? this.orders;
            for (let key of this.keys) {
                if (!(key in orders)) {
                    orders[key] = new orders_1.IncreasingOrder();
                }
            }
            let anchor = anchorKeysRecord != null ? this.lookup(anchorKeysRecord) : undefined;
            let filteredStores = [];
            for (let indexManager of this.indexManagers) {
                let filteredStore = indexManager.filter(filters, orders, anchor);
                if (filteredStore == null) {
                    // We can exit early as the index manager has signaled that there are no matching records.
                    return [];
                }
                filteredStores.push(filteredStore);
            }
            filteredStores.push(new FilteredStore(this.recordManager, this.blockManager, this.table, filters, orders, anchor));
            let filteredStore = FilteredStore.getOptimal(filteredStores);
            let iterable = streams_1.StreamIterable.of(filteredStore);
            if (limit != null) {
                iterable = iterable.limit(limit);
            }
            return iterable.collect();
        }
        insert(record) {
            let key = this.recordManager.encodeKeys(this.keys, record);
            let encoded = this.recordManager.encode(record);
            let index = this.table.lookup(key);
            if (index == null) {
                index = this.blockManager.createBlock(encoded.length);
                this.blockManager.writeBlock(index, encoded);
                this.table.insert(key, index);
                for (let indexManager of this.indexManagers) {
                    indexManager.insert(record, index);
                }
            }
            else {
                let buffer = this.blockManager.readBlock(index);
                // Bedrock encodes records with a payload length prefix making it sufficient to compare the encoded record to the prefix of the block.
                if ((0, tables_1.compareBuffers)([encoded], [buffer.subarray(0, encoded.length)]) === 0) {
                    return;
                }
                let oldRecord = this.recordManager.decode(buffer);
                this.blockManager.resizeBlock(index, encoded.length);
                this.blockManager.writeBlock(index, encoded);
                for (let indexManager of this.indexManagers) {
                    indexManager.update(oldRecord, record, index);
                }
            }
        }
        length() {
            return this.table.length();
        }
        lookup(keysRecord) {
            let key = this.recordManager.encodeKeys(this.keys, keysRecord);
            let index = this.table.lookup(key);
            if (index == null) {
                let key = this.keys.map((key) => keysRecord[key]).join(", ");
                throw `Expected a matching record for key ${key}!`;
            }
            let buffer = this.blockManager.readBlock(index);
            let record = this.recordManager.decode(buffer);
            return record;
        }
        remove(keysRecord) {
            let key = this.recordManager.encodeKeys(this.keys, keysRecord);
            let index = this.table.lookup(key);
            if (index != null) {
                let buffer = this.blockManager.readBlock(index);
                let oldRecord = this.recordManager.decode(buffer);
                this.table.remove(key);
                this.blockManager.deleteBlock(index);
                for (let indexManager of this.indexManagers) {
                    indexManager.remove(oldRecord);
                }
            }
        }
        update(keysRecord) {
            let record = {
                ...this.getDefaultRecord(),
                ...keysRecord
            };
            try {
                record = {
                    ...this.lookup(keysRecord),
                    ...keysRecord
                };
            }
            catch (error) { }
            return this.insert(record);
        }
        vacate() {
            for (let bid of this.table) {
                this.blockManager.deleteBlock(bid);
            }
            for (let indexManager of this.indexManagers) {
                indexManager.vacate();
            }
            this.table.vacate();
        }
        static construct(blockManager, options) {
            let fields = options.fields;
            let keys = options.keys;
            let orders = options.orders ?? {};
            let indices = options.indices ?? [];
            let recordManager = new records_1.RecordManager(fields);
            let storage = new tables_1.Table(blockManager, {
                getKeyFromValue: (value) => {
                    let buffer = blockManager.readBlock(value);
                    let record = recordManager.decode(buffer);
                    return recordManager.encodeKeys(keys, record);
                }
            });
            let indexManagers = indices.map((index) => new IndexManager(recordManager, blockManager, index.keys));
            let manager = new StoreManager(blockManager, fields, keys, orders, storage, indexManagers);
            return manager;
        }
    }
    exports.StoreManager = StoreManager;
    ;
    class Index {
        keys;
        constructor(keys) {
            this.keys = keys;
        }
        equals(that) {
            if (this.keys.length !== that.keys.length) {
                return false;
            }
            for (let i = 0; i < this.keys.length; i++) {
                if (this.keys[i] !== that.keys[i]) {
                    return false;
                }
            }
            return true;
        }
    }
    exports.Index = Index;
    ;
    class Store {
        fields;
        keys;
        orders;
        indices;
        constructor(fields, keys, orders) {
            this.fields = fields;
            this.keys = keys;
            this.orders = orders ?? {};
            this.indices = [];
            this.index(this.createIndex());
        }
        createIndex() {
            let keys = [];
            for (let key in this.orders) {
                let order = this.orders[key];
                if (order == null) {
                    continue;
                }
                if (!keys.includes(key)) {
                    keys.push(key);
                }
            }
            for (let key of this.keys) {
                if (!keys.includes(key)) {
                    keys.push(key);
                }
            }
            return new Index(keys);
        }
        index(that) {
            for (let index of this.indices) {
                if (index.equals(that)) {
                    return;
                }
            }
            this.indices.push(that);
        }
    }
    exports.Store = Store;
    ;
    class OverridableWritableStore {
        storeManager;
        overrides;
        constructor(storeManager, overrides) {
            this.storeManager = storeManager;
            this.overrides = overrides;
        }
        async filter(...parameters) {
            return this.overrides.filter?.(...parameters) ?? this.storeManager.filter(...parameters);
        }
        async insert(...parameters) {
            return this.overrides.insert?.(...parameters) ?? this.storeManager.insert(...parameters);
        }
        async length(...parameters) {
            return this.overrides.length?.(...parameters) ?? this.storeManager.length(...parameters);
        }
        async lookup(...parameters) {
            return this.overrides.lookup?.(...parameters) ?? this.storeManager.lookup(...parameters);
        }
        async remove(...parameters) {
            return this.overrides.remove?.(...parameters) ?? this.storeManager.remove(...parameters);
        }
        async update(...parameters) {
            return this.overrides.update?.(...parameters) ?? this.storeManager.update(...parameters);
        }
        async vacate(...parameters) {
            return this.overrides.vacate?.(...parameters) ?? this.storeManager.vacate(...parameters);
        }
    }
    exports.OverridableWritableStore = OverridableWritableStore;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/links", ["require", "exports", "node_modules/@joelek/atlas/dist/lib/filters", "node_modules/@joelek/atlas/dist/lib/stores"], function (require, exports, filters_1, stores_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OverridableWritableLink = exports.Link = exports.LinkManager = exports.WritableLinkManager = void 0;
    ;
    class WritableLinkManager {
        linkManager;
        constructor(linkManager) {
            this.linkManager = linkManager;
        }
        async filter(...parameters) {
            return this.linkManager.filter(...parameters);
        }
        async lookup(...parameters) {
            return this.linkManager.lookup(...parameters);
        }
    }
    exports.WritableLinkManager = WritableLinkManager;
    ;
    class LinkManager {
        parent;
        child;
        keysRecordMap;
        orders;
        constructor(parent, child, keysRecordMap, orders) {
            this.parent = parent;
            this.child = child;
            this.keysRecordMap = keysRecordMap;
            this.orders = orders ?? {};
        }
        getParent() {
            return this.parent;
        }
        getChild() {
            return this.child;
        }
        filter(keysRecord, anchor, limit) {
            let filters = {};
            for (let key in this.keysRecordMap) {
                let keyOne = key;
                let keyTwo = this.keysRecordMap[keyOne];
                filters[keyTwo] = new filters_1.EqualityFilter(keysRecord?.[keyOne] ?? null);
            }
            return this.child.filter(filters, this.orders, anchor, limit);
        }
        lookup(keysRecord) {
            let parentKeysRecord = {};
            for (let key in this.keysRecordMap) {
                let keyOne = key;
                let keyTwo = this.keysRecordMap[keyOne];
                if (keysRecord[keyTwo] === null) {
                    return;
                }
                parentKeysRecord[keyOne] = keysRecord[keyTwo];
            }
            return this.parent.lookup(parentKeysRecord);
        }
        static construct(parent, child, recordKeysMap, orders) {
            return new LinkManager(parent, child, recordKeysMap, orders);
        }
    }
    exports.LinkManager = LinkManager;
    ;
    class Link {
        parent;
        child;
        recordKeysMap;
        orders;
        constructor(parent, child, recordKeysMap, orders) {
            this.parent = parent;
            this.child = child;
            this.recordKeysMap = recordKeysMap;
            this.orders = orders ?? {};
            this.child.index(this.createIndex());
        }
        createIndex() {
            let keys = [];
            for (let key in this.recordKeysMap) {
                let thatKey = this.recordKeysMap[key];
                if (!keys.includes(thatKey)) {
                    keys.push(thatKey);
                }
            }
            for (let key in this.orders) {
                let order = this.orders[key];
                if (order == null) {
                    continue;
                }
                if (!keys.includes(key)) {
                    keys.push(key);
                }
            }
            for (let key of this.child.keys) {
                if (!keys.includes(key)) {
                    keys.push(key);
                }
            }
            return new stores_1.Index(keys);
        }
    }
    exports.Link = Link;
    ;
    class OverridableWritableLink {
        linkManager;
        overrides;
        constructor(linkManager, overrides) {
            this.linkManager = linkManager;
            this.overrides = overrides;
        }
        async filter(...parameters) {
            return this.overrides.filter?.(...parameters) ?? this.linkManager.filter(...parameters);
        }
        async lookup(...parameters) {
            return this.overrides.lookup?.(...parameters) ?? this.linkManager.lookup(...parameters);
        }
    }
    exports.OverridableWritableLink = OverridableWritableLink;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/collections/avl", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tree = exports.Node = void 0;
    class Node {
        constructor(key, value, height) {
            this.key = key;
            this.value = value;
            this.height = height !== null && height !== void 0 ? height : 1;
            this.parent = undefined;
            this.lower = undefined;
            this.upper = undefined;
        }
        compare(filter) {
            if (filter.operator === "<") {
                if (this.key > filter.key) {
                    return -1;
                }
                else if (this.key < filter.key) {
                    return 0;
                }
                else {
                    return -1;
                }
            }
            if (filter.operator === "<=") {
                if (this.key > filter.key) {
                    return -1;
                }
                else if (this.key < filter.key) {
                    return 0;
                }
                else {
                    return 0;
                }
            }
            if (filter.operator === "=") {
                if (this.key > filter.key) {
                    return -1;
                }
                else if (this.key < filter.key) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            if (filter.operator === ">=") {
                if (this.key > filter.key) {
                    return 0;
                }
                else if (this.key < filter.key) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            if (filter.operator === ">") {
                if (this.key > filter.key) {
                    return 0;
                }
                else if (this.key < filter.key) {
                    return 1;
                }
                else {
                    return 1;
                }
            }
            throw `Expected code to be unreachable!`;
        }
        computeBalance() {
            var _a, _b, _c, _d;
            return ((_b = (_a = this.upper) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0) - ((_d = (_c = this.lower) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0);
        }
        computeHeight() {
            var _a, _b, _c, _d;
            return Math.max(((_b = (_a = this.lower) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0), ((_d = (_c = this.upper) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0)) + 1;
        }
        entry() {
            return {
                key: this.key,
                value: this.value
            };
        }
        *filter(...filters) {
            let lower = true;
            let current = true;
            let upper = true;
            for (let filter of filters) {
                let comparison = this.compare(filter);
                lower = lower && comparison <= 0;
                current = current && comparison === 0;
                upper = upper && comparison >= 0;
            }
            if (lower && this.lower != null) {
                yield* this.lower.filter(...filters);
            }
            if (current) {
                yield this.entry();
            }
            if (upper && this.upper != null) {
                yield* this.upper.filter(...filters);
            }
        }
        getMaximum() {
            let node = this;
            while (node.upper != null) {
                node = node.upper;
            }
            return node;
        }
        getMinimum() {
            let node = this;
            while (node.lower != null) {
                node = node.lower;
            }
            return node;
        }
        getLowerParent() {
            let parent = this.parent;
            let child = this;
            while (parent != null && child === parent.lower) {
                child = parent;
                parent = parent.parent;
            }
            return parent;
        }
        getUpperParent() {
            let parent = this.parent;
            let child = this;
            while (parent != null && child === parent.upper) {
                child = parent;
                parent = parent.parent;
            }
            return parent;
        }
        getPredecessor() {
            if (this.lower != null) {
                return this.lower.getMaximum();
            }
            return this.getLowerParent();
        }
        getSuccessor() {
            if (this.upper != null) {
                return this.upper.getMinimum();
            }
            return this.getUpperParent();
        }
        insert(node) {
            if (node.key === this.key) {
                this.value = node.value;
                return this;
            }
            if (node.key < this.key) {
                if (this.lower == null) {
                    this.setLower(node);
                }
                else {
                    this.setLower(this.lower.insert(node));
                }
            }
            else {
                if (this.upper == null) {
                    this.setUpper(node);
                }
                else {
                    this.setUpper(this.upper.insert(node));
                }
            }
            this.setHeight(this.computeHeight());
            return this.rebalance();
        }
        locate(filter) {
            if (filter.key === this.key) {
                if (filter.operator === "<") {
                    return this.getPredecessor();
                }
                if (filter.operator === "<=") {
                    return this;
                }
                if (filter.operator === "=") {
                    return this;
                }
                if (filter.operator === ">=") {
                    return this;
                }
                if (filter.operator === ">") {
                    return this.getSuccessor();
                }
            }
            if (filter.key < this.key) {
                if (this.lower != null) {
                    return this.lower.locate(filter);
                }
                else {
                    if (filter.operator === "<") {
                        return this.getLowerParent();
                    }
                    if (filter.operator === "<=") {
                        return this.getLowerParent();
                    }
                    if (filter.operator === ">=") {
                        return this;
                    }
                    if (filter.operator === ">") {
                        return this;
                    }
                }
            }
            else {
                if (this.upper != null) {
                    return this.upper.locate(filter);
                }
                else {
                    if (filter.operator === "<") {
                        return this;
                    }
                    if (filter.operator === "<=") {
                        return this;
                    }
                    if (filter.operator === ">=") {
                        return this.getUpperParent();
                    }
                    if (filter.operator === ">") {
                        return this.getUpperParent();
                    }
                }
            }
        }
        rebalance() {
            let balance = this.computeBalance();
            if (balance < -1) {
                if (this.lower == null) {
                    throw `Expected lower child to be non-null!`;
                }
                let balance = this.lower.computeBalance();
                if (balance <= 0) {
                    return this.rotateRight();
                }
                else {
                    this.setLower(this.lower.rotateLeft());
                    return this.rotateRight();
                }
            }
            if (balance > 1) {
                if (this.upper == null) {
                    throw `Expected upper child to be non-null!`;
                }
                let balance = this.upper.computeBalance();
                if (balance >= 0) {
                    return this.rotateLeft();
                }
                else {
                    this.setUpper(this.upper.rotateRight());
                    return this.rotateLeft();
                }
            }
            return this;
        }
        remove(key) {
            if (key === this.key) {
                if (this.lower != null) {
                    if (this.upper != null) {
                        let { key, value } = this.upper.getMinimum();
                        this.setUpper(this.upper.remove(key));
                        this.key = key;
                        this.value = value;
                        this.setHeight(this.computeHeight());
                        return this.rebalance();
                    }
                    else {
                        return this.lower;
                    }
                }
                else {
                    if (this.upper != null) {
                        return this.upper;
                    }
                    else {
                        return;
                    }
                }
            }
            if (key < this.key) {
                if (this.lower != null) {
                    this.setLower(this.lower.remove(key));
                }
                else {
                    return this;
                }
            }
            else {
                if (this.upper != null) {
                    this.setUpper(this.upper.remove(key));
                }
                else {
                    return this;
                }
            }
            this.setHeight(this.computeHeight());
            return this.rebalance();
        }
        rotateLeft() {
            let upper = this.upper;
            if (upper == null) {
                throw `Expected upper child to be non-null!`;
            }
            this.setUpper(upper.lower);
            upper.setLower(this);
            this.setHeight(this.computeHeight());
            upper.setHeight(upper.computeHeight());
            return upper;
        }
        rotateRight() {
            let lower = this.lower;
            if (lower == null) {
                throw `Expected lower child to be non-null!`;
            }
            this.setLower(lower.upper);
            lower.setUpper(this);
            this.setHeight(this.computeHeight());
            lower.setHeight(lower.computeHeight());
            return lower;
        }
        getHeight() {
            return this.height;
        }
        setHeight(height) {
            return this.height = height;
        }
        getParent() {
            return this.parent;
        }
        setParent(parent) {
            if (this.parent != null) {
                if (this.parent.lower === this) {
                    this.parent.lower = undefined;
                }
                else if (this.parent.upper === this) {
                    this.parent.upper = undefined;
                }
            }
            this.parent = parent;
        }
        getLower() {
            return this.lower;
        }
        setLower(lower) {
            if (lower != null) {
                lower.setParent(this);
            }
            if (this.lower != null) {
                this.lower.setParent(undefined);
            }
            this.lower = lower;
        }
        getUpper() {
            return this.upper;
        }
        setUpper(upper) {
            if (upper != null) {
                upper.setParent(this);
            }
            if (this.upper != null) {
                this.upper.setParent(undefined);
            }
            this.upper = upper;
        }
    }
    exports.Node = Node;
    ;
    class Tree {
        constructor() {
            this.root = undefined;
        }
        *[Symbol.iterator]() {
            yield* this.filter();
        }
        clear() {
            this.root = undefined;
        }
        *filter(...filters) {
            if (this.root == null) {
                return;
            }
            for (let node of this.root.filter(...filters)) {
                yield {
                    key: node.key,
                    value: node.value
                };
            }
        }
        insert(key, value) {
            var _a;
            let node = new Node(key, value);
            if (this.root != null) {
                this.root = this.root.insert(node);
                (_a = this.root) === null || _a === void 0 ? void 0 : _a.setParent(undefined);
            }
            else {
                this.root = node;
            }
        }
        length() {
            let length = 0;
            for (let entry of this) {
                length += 1;
            }
            return length;
        }
        locate(filter) {
            var _a;
            if (this.root != null) {
                return (_a = this.root.locate(filter)) === null || _a === void 0 ? void 0 : _a.entry();
            }
        }
        lookup(key) {
            var _a;
            return (_a = this.locate({ operator: "=", key: key })) === null || _a === void 0 ? void 0 : _a.value;
        }
        remove(key) {
            var _a;
            if (this.root != null) {
                this.root = this.root.remove(key);
                (_a = this.root) === null || _a === void 0 ? void 0 : _a.setParent(undefined);
            }
        }
    }
    exports.Tree = Tree;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/collections/index", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/collections/avl"], function (require, exports, avl) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.avl = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.avl = void 0;
    exports.avl = avl;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/routing/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamespacedMessageRouter = exports.MessageRouter = void 0;
    class MessageRouter {
        constructor() {
            this.observers = Object.create(null);
        }
        addObserver(type, observer) {
            let observers = this.observers[type];
            if (observers === undefined) {
                observers = new Set();
                this.observers[type] = observers;
            }
            observers.add(observer);
        }
        removeObserver(type, observer) {
            let observers = this.observers[type];
            if (observers !== undefined) {
                observers.delete(observer);
                if (observers.size === 0) {
                    delete this.observers[type];
                }
            }
        }
        route(type, message) {
            let observers = this.observers[type];
            if (observers !== undefined) {
                for (let observer of observers) {
                    observer(message);
                }
            }
        }
        size() {
            return Object.keys(this.observers).length;
        }
    }
    exports.MessageRouter = MessageRouter;
    ;
    class NamespacedMessageRouter {
        constructor() {
            this.routers = Object.create(null);
        }
        addObserver(namespace, type, observer) {
            let router = this.routers[namespace];
            if (router === undefined) {
                router = new MessageRouter();
                this.routers[namespace] = router;
            }
            router.addObserver(type, observer);
        }
        removeObserver(namespace, type, observer) {
            let router = this.routers[namespace];
            if (router !== undefined) {
                router.removeObserver(type, observer);
                if (router.size() === 0) {
                    delete this.routers[namespace];
                }
            }
        }
        route(namespace, type, message) {
            let router = this.routers[namespace];
            if (router !== undefined) {
                router.route(type, message);
            }
        }
    }
    exports.NamespacedMessageRouter = NamespacedMessageRouter;
    ;
});
define("node_modules/@joelek/ts-stdlib/dist/lib/index", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/collections/index", "node_modules/@joelek/ts-stdlib/dist/lib/routing/index"], function (require, exports, collections, routing) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = exports.collections = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = exports.collections = void 0;
    exports.collections = collections;
    exports.routing = routing;
});
define("node_modules/@joelek/atlas/dist/lib/caches", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cache = void 0;
    ;
    class Cache {
        detail;
        map;
        status;
        purgeIfNecessary() {
            if (this.status.maxWeight != null) {
                for (let [key, value] of this.map.entries()) {
                    if (this.status.weight <= this.status.maxWeight) {
                        break;
                    }
                    this.status.weight -= this.detail.getWeightForValue(value);
                    this.map.delete(key);
                    this.detail.onRemove?.(key);
                }
            }
        }
        constructor(detail, maxWeight) {
            this.detail = detail ?? {
                getWeightForValue: () => 1
            };
            this.map = new Map();
            this.status = {
                weight: 0,
                maxWeight: maxWeight
            };
        }
        *[Symbol.iterator]() {
            for (let tuple of this.map) {
                yield {
                    key: tuple[0],
                    value: tuple[1]
                };
            }
        }
        clear() {
            for (let [key, value] of this.map) {
                this.detail.onRemove?.(key);
            }
            this.map.clear();
            this.status.weight = 0;
        }
        insert(key, value) {
            this.remove(key);
            this.map.set(key, value);
            this.status.weight += this.detail.getWeightForValue(value);
            this.detail.onInsert?.(key, value);
            this.purgeIfNecessary();
        }
        length() {
            return this.map.size;
        }
        lookup(key) {
            return this.map.get(key);
        }
        remove(key) {
            let value = this.map.get(key);
            if (value == null) {
                return;
            }
            this.status.weight -= this.detail.getWeightForValue(value);
            this.map.delete(key);
            this.detail.onRemove?.(key);
            return value;
        }
    }
    exports.Cache = Cache;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/files", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/index", "fs", "path", "node_modules/@joelek/atlas/dist/mod/asserts/index", "node_modules/@joelek/atlas/dist/lib/caches", "node_modules/@joelek/atlas/dist/lib/chunks", "node_modules/@joelek/atlas/dist/lib/variables", "node_modules/@joelek/atlas/dist/lib/utils"], function (require, exports, stdlib, libfs, libpath, asserts, caches_1, chunks_1, variables_1, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VirtualFile = exports.PhysicalFile = exports.PagedFile = exports.DurableFile = exports.LogDeltaHeader = exports.LogHeader = exports.CachedFile = exports.File = void 0;
    class File {
        constructor() { }
    }
    exports.File = File;
    ;
    class CachedFile extends File {
        file;
        tree;
        cache;
        constructor(file, maxWeight) {
            super();
            this.file = file;
            this.tree = new stdlib.collections.avl.Tree();
            this.cache = new caches_1.Cache({
                getWeightForValue: (value) => 64 + value.length,
                onInsert: (key, value) => this.tree.insert(key, value),
                onRemove: (key) => this.tree.remove(key)
            }, maxWeight);
        }
        discard() {
            this.file.discard();
        }
        persist() {
            this.file.persist();
        }
        read(buffer, offset) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, offset);
            let current = offset;
            let bytes = 0;
            let end = offset + buffer.length;
            let entry = this.tree.locate({ operator: "<=", key: offset });
            if (entry != null) {
                let distance = current - entry.key;
                let overlap = Math.min(entry.value.length - distance, buffer.length);
                if (overlap > 0) {
                    buffer.set(entry.value.subarray(distance, distance + overlap), bytes);
                    this.cache.insert(entry.key, entry.value);
                    current += overlap;
                    bytes += overlap;
                }
            }
            if (current >= end) {
                return buffer;
            }
            let entries = Array.from(this.tree.filter({ operator: ">", key: offset }, { operator: "<", key: end }));
            for (let entry of entries) {
                let gap = entry.key - current;
                if (gap > 0) {
                    let value = buffer.subarray(bytes, bytes + gap);
                    let distance = this.file.size() - current;
                    if (distance > 0) {
                        this.file.read(value.subarray(0, distance), current);
                    }
                    this.cache.insert(current, value.slice());
                    current += gap;
                    bytes += gap;
                }
                let overlap = Math.min(entry.value.length, end - current);
                buffer.set(entry.value.subarray(0, overlap), bytes);
                this.cache.insert(entry.key, entry.value);
                current += overlap;
                bytes += overlap;
            }
            let gap = end - current;
            if (gap > 0) {
                let value = buffer.subarray(bytes, bytes + gap);
                let distance = this.file.size() - current;
                if (distance > 0) {
                    this.file.read(value.subarray(0, distance), current);
                }
                this.cache.insert(current, value.slice());
                current += gap;
                bytes += gap;
            }
            return buffer;
        }
        resize(size) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, size);
            this.file.resize(size);
            let entry = this.tree.locate({ operator: "<", key: size });
            if (entry != null) {
                let distance = size - entry.key;
                let overlap = entry.value.length - distance;
                if (overlap > 0) {
                    let value = entry.value.subarray(0, distance);
                    this.cache.insert(entry.key, value.slice());
                }
            }
            let entries = Array.from(this.tree.filter({ operator: ">=", key: size }));
            for (let entry of entries) {
                this.cache.remove(entry.key);
            }
        }
        size() {
            return this.file.size();
        }
        write(buffer, offset) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, offset);
            this.file.write(buffer, offset);
            let current = offset;
            let bytes = 0;
            let end = offset + buffer.length;
            let entry = this.tree.locate({ operator: "<=", key: offset });
            if (entry != null) {
                let distance = current - entry.key;
                let overlap = Math.min(entry.value.length - distance, buffer.length);
                if (overlap > 0) {
                    entry.value.set(buffer.subarray(bytes, bytes + overlap), distance);
                    this.cache.insert(entry.key, entry.value);
                    current += overlap;
                    bytes += overlap;
                }
            }
            if (current >= end) {
                return buffer;
            }
            let entries = Array.from(this.tree.filter({ operator: ">", key: offset }, { operator: "<", key: end }));
            for (let entry of entries) {
                let gap = entry.key - current;
                if (gap > 0) {
                    let value = buffer.subarray(bytes, bytes + gap);
                    this.cache.insert(current, value.slice());
                    current += gap;
                    bytes += gap;
                }
                let overlap = Math.min(entry.value.length, end - current);
                entry.value.set(buffer.subarray(bytes, bytes + overlap), 0);
                this.cache.insert(entry.key, entry.value);
                current += overlap;
                bytes += overlap;
            }
            let gap = end - current;
            if (gap > 0) {
                let value = buffer.subarray(bytes, bytes + gap);
                this.cache.insert(current, value.slice());
                current += gap;
                bytes += gap;
            }
            return buffer;
        }
    }
    exports.CachedFile = CachedFile;
    ;
    class LogHeader extends chunks_1.Chunk {
        constructor(buffer) {
            super(buffer ?? new Uint8Array(LogHeader.LENGTH));
            if (variables_1.DEBUG)
                asserts.IntegerAssert.exactly(this.buffer.length, LogHeader.LENGTH);
            this.identifier(LogHeader.IDENTIFIER);
        }
        identifier(value) {
            return utils.Binary.string(this.buffer, 0, 8, "binary", value);
        }
        redoSize(value) {
            return utils.Binary.unsigned(this.buffer, 18, 6, value);
        }
        undoSize(value) {
            return utils.Binary.unsigned(this.buffer, 26, 6, value);
        }
        read(readable, offset) {
            super.read(readable, offset);
            if (this.identifier() !== LogHeader.IDENTIFIER) {
                throw `Expected identifier to be ${LogHeader.IDENTIFIER}!`;
            }
        }
        static IDENTIFIER = "atlaslog";
        static LENGTH = 32;
    }
    exports.LogHeader = LogHeader;
    ;
    class LogDeltaHeader extends chunks_1.Chunk {
        constructor(buffer) {
            super(buffer ?? new Uint8Array(LogDeltaHeader.LENGTH));
            if (variables_1.DEBUG)
                asserts.IntegerAssert.exactly(this.buffer.length, LogDeltaHeader.LENGTH);
        }
        offset(value) {
            return utils.Binary.unsigned(this.buffer, 2, 6, value);
        }
        length(value) {
            return utils.Binary.unsigned(this.buffer, 10, 6, value);
        }
        static LENGTH = 16;
    }
    exports.LogDeltaHeader = LogDeltaHeader;
    ;
    class DurableFile extends File {
        bin;
        log;
        header;
        tree;
        readDelta(offset) {
            let header = new LogDeltaHeader();
            header.read(this.log, offset);
            offset += LogDeltaHeader.LENGTH;
            let length = header.length();
            let redo = new Uint8Array(length);
            this.log.read(redo, offset);
            offset += length;
            let undo = new Uint8Array(length);
            this.log.read(undo, offset);
            offset += length;
            let delta = {
                header,
                redo,
                undo
            };
            return delta;
        }
        writeDelta(delta, offset) {
            delta.header.write(this.log, offset);
            offset += LogDeltaHeader.LENGTH;
            this.log.write(delta.redo, offset);
            offset += delta.redo.length;
            this.log.write(delta.undo, offset);
            offset += delta.undo.length;
        }
        appendRedo(redo, offset) {
            let header = new LogDeltaHeader();
            header.offset(offset);
            header.length(redo.length);
            let undo = new Uint8Array(redo.length);
            let distance = this.bin.size() - offset;
            if (distance > 0) {
                this.bin.read(undo.subarray(0, distance), offset);
            }
            let delta = {
                header,
                undo,
                redo
            };
            this.tree.insert(offset, this.log.size());
            this.writeDelta(delta, this.log.size());
            this.header.redoSize(Math.max(this.header.redoSize(), offset + redo.length));
        }
        redo() {
            let redoSize = this.header.redoSize();
            let entries = this.tree.filter({ operator: "<", key: redoSize });
            for (let entry of entries) {
                let delta = this.readDelta(entry.value);
                this.bin.write(delta.redo, entry.key);
            }
            this.bin.resize(redoSize);
            this.bin.persist();
            this.discard();
        }
        undo() {
            let undoSize = this.header.undoSize();
            let entries = this.tree.filter({ operator: "<", key: undoSize });
            for (let entry of entries) {
                let delta = this.readDelta(entry.value);
                this.bin.write(delta.undo, entry.key);
            }
            this.bin.resize(undoSize);
            this.bin.persist();
            this.discard();
        }
        constructor(bin, log) {
            super();
            this.bin = bin;
            this.log = log;
            this.header = new LogHeader();
            this.header.redoSize(this.bin.size());
            this.header.undoSize(this.bin.size());
            this.tree = new stdlib.collections.avl.Tree();
            if (log.size() === 0) {
                this.header.write(this.log, 0);
            }
            else {
                let offset = 0;
                this.header.read(this.log, offset);
                offset += LogHeader.LENGTH;
                // A corrupted log should be discarded since it is persisted before and after bin is persisted.
                try {
                    while (offset < this.log.size()) {
                        let header = new LogDeltaHeader();
                        header.read(this.log, offset);
                        this.tree.insert(header.offset(), offset);
                        let length = header.length();
                        offset += LogDeltaHeader.LENGTH + length + length;
                    }
                    this.undo();
                }
                catch (error) {
                    this.discard();
                }
            }
        }
        discard() {
            if (this.log.size() > LogHeader.LENGTH) {
                this.log.resize(0);
                this.header.redoSize(this.bin.size());
                this.header.undoSize(this.bin.size());
                this.header.write(this.log, 0);
                this.log.persist();
                this.tree.clear();
            }
        }
        persist() {
            if (this.log.size() > LogHeader.LENGTH) {
                this.header.write(this.log, 0);
                this.log.persist();
                this.redo();
            }
        }
        read(buffer, offset) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, offset);
            let current = offset;
            let bytes = 0;
            let end = offset + buffer.length;
            let entry = this.tree.locate({ operator: "<=", key: offset });
            if (entry != null) {
                let header = new LogDeltaHeader();
                header.read(this.log, entry.value);
                let distance = current - entry.key;
                let overlap = Math.min(header.length() - distance, buffer.length);
                if (overlap > 0) {
                    this.log.read(buffer.subarray(bytes, bytes + overlap), entry.value + LogDeltaHeader.LENGTH + distance);
                    current += overlap;
                    bytes += overlap;
                }
            }
            if (current >= end) {
                return buffer;
            }
            let entries = this.tree.filter({ operator: ">", key: offset }, { operator: "<", key: end });
            for (let entry of entries) {
                let gap = entry.key - current;
                if (gap > 0) {
                    let redo = buffer.subarray(bytes, bytes + gap);
                    redo.fill(0);
                    let distance = this.bin.size() - current;
                    if (distance > 0) {
                        this.bin.read(redo.subarray(0, distance), current);
                    }
                    current += gap;
                    bytes += gap;
                }
                let header = new LogDeltaHeader();
                header.read(this.log, entry.value);
                let overlap = Math.min(header.length(), end - current);
                this.log.read(buffer.subarray(bytes, bytes + overlap), entry.value + LogDeltaHeader.LENGTH + 0);
                current += overlap;
                bytes += overlap;
            }
            let gap = end - current;
            if (gap > 0) {
                let redo = buffer.subarray(bytes, bytes + gap);
                redo.fill(0);
                let distance = this.bin.size() - current;
                if (distance > 0) {
                    this.bin.read(redo.subarray(0, distance), current);
                }
                current += gap;
                bytes += gap;
            }
            return buffer;
        }
        resize(size) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, size);
            let entry = this.tree.locate({ operator: "<", key: size });
            if (entry != null) {
                let header = new LogDeltaHeader();
                header.read(this.log, entry.value);
                let distance = size - entry.key;
                let overlap = header.length() - distance;
                if (overlap > 0) {
                    this.tree.remove(entry.key);
                    let redo = new Uint8Array(distance);
                    this.log.read(redo, entry.value + LogDeltaHeader.LENGTH + 0);
                    this.appendRedo(redo, entry.key);
                }
            }
            let entries = Array.from(this.tree.filter({ operator: ">=", key: size }));
            for (let entry of entries) {
                this.tree.remove(entry.key);
            }
            this.header.redoSize(size);
        }
        size() {
            return this.header.redoSize();
        }
        write(buffer, offset) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, offset);
            let current = offset;
            let bytes = 0;
            let end = offset + buffer.length;
            let entry = this.tree.locate({ operator: "<=", key: offset });
            if (entry != null) {
                let header = new LogDeltaHeader();
                header.read(this.log, entry.value);
                let distance = current - entry.key;
                let overlap = Math.min(header.length() - distance, buffer.length);
                if (overlap > 0) {
                    this.log.write(buffer.subarray(bytes, bytes + overlap), entry.value + LogDeltaHeader.LENGTH + distance);
                    current += overlap;
                    bytes += overlap;
                }
            }
            if (current >= end) {
                return buffer;
            }
            let entries = Array.from(this.tree.filter({ operator: ">", key: offset }, { operator: "<", key: end }));
            for (let entry of entries) {
                let gap = entry.key - current;
                if (gap > 0) {
                    let redo = buffer.subarray(bytes, bytes + gap);
                    this.appendRedo(redo, current);
                    current += gap;
                    bytes += gap;
                }
                let header = new LogDeltaHeader();
                header.read(this.log, entry.value);
                let overlap = Math.min(header.length(), end - current);
                this.log.write(buffer.subarray(bytes, bytes + overlap), entry.value + LogDeltaHeader.LENGTH + 0);
                current += overlap;
                bytes += overlap;
            }
            let gap = end - current;
            if (gap > 0) {
                let redo = buffer.subarray(bytes, bytes + gap);
                this.appendRedo(redo, current);
                current += gap;
                bytes += gap;
            }
            return buffer;
        }
    }
    exports.DurableFile = DurableFile;
    ;
    class PagedFile extends File {
        file;
        pageSizeLog2;
        pageSize;
        cache;
        constructor(file, pageSizeLog2, maxPageCount) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, pageSizeLog2);
            super();
            this.file = file;
            this.pageSizeLog2 = pageSizeLog2;
            this.pageSize = 2 ** pageSizeLog2;
            this.cache = new caches_1.Cache(undefined, maxPageCount);
        }
        discard() {
            this.file.discard();
        }
        persist() {
            this.file.persist();
        }
        read(buffer, offset) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, offset);
            if (variables_1.DEBUG)
                asserts.IntegerAssert.between(0, buffer.length, this.size() - offset);
            if (buffer.length === 0) {
                return buffer;
            }
            let firstByte = offset;
            let lastByte = offset + buffer.length - 1;
            let firstPageIndex = firstByte >> this.pageSizeLog2;
            let lastPageIndex = lastByte >> this.pageSizeLog2;
            let firstPageOffset = firstByte & (this.pageSize - 1);
            let lastPageOffset = (lastByte & (this.pageSize - 1)) + 1;
            let bytes = 0;
            for (let pageIndex = firstPageIndex; pageIndex <= lastPageIndex; pageIndex++) {
                let pageOffset = pageIndex === firstPageIndex ? firstPageOffset : 0;
                let pageLength = (pageIndex === lastPageIndex ? lastPageOffset : this.pageSize) - pageOffset;
                let page = this.cache.lookup(pageIndex);
                if (page == null) {
                    let readOffset = pageIndex << this.pageSizeLog2;
                    let readLength = Math.min(this.size() - readOffset, this.pageSize);
                    page = new Uint8Array(readLength);
                    this.file.read(page, readOffset);
                }
                this.cache.insert(pageIndex, page);
                buffer.set(page.subarray(pageOffset, pageOffset + pageLength), bytes);
                bytes += pageLength;
            }
            return buffer;
        }
        resize(size) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, size);
            let currentSize = this.size();
            if (size === currentSize) {
                return;
            }
            this.file.resize(size);
            if (size === 0) {
                this.cache.clear();
                return;
            }
            let firstByte = Math.min(size, currentSize);
            let lastByte = Math.max(size, currentSize) - 1;
            let firstPageIndex = firstByte >> this.pageSizeLog2;
            let lastPageIndex = lastByte >> this.pageSizeLog2;
            for (let pageIndex = firstPageIndex; pageIndex <= lastPageIndex; pageIndex++) {
                this.cache.remove(pageIndex);
            }
        }
        size() {
            return this.file.size();
        }
        write(buffer, offset) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, offset);
            if (buffer.length === 0) {
                return buffer;
            }
            this.file.write(buffer, offset);
            let firstByte = offset;
            let lastByte = offset + buffer.length - 1;
            let firstPageIndex = firstByte >> this.pageSizeLog2;
            let lastPageIndex = lastByte >> this.pageSizeLog2;
            let firstPageOffset = firstByte & (this.pageSize - 1);
            let lastPageOffset = (lastByte & (this.pageSize - 1)) + 1;
            let bytes = 0;
            for (let pageIndex = firstPageIndex; pageIndex <= lastPageIndex; pageIndex++) {
                let pageOffset = pageIndex === firstPageIndex ? firstPageOffset : 0;
                let pageLength = (pageIndex === lastPageIndex ? lastPageOffset : this.pageSize) - pageOffset;
                let page = this.cache.lookup(pageIndex);
                if (page != null) {
                    let readOffset = pageIndex << this.pageSizeLog2;
                    let readLength = Math.min(this.size() - readOffset, this.pageSize);
                    if (page.length !== readLength) {
                        page = new Uint8Array(readLength);
                        this.file.read(page, readOffset);
                    }
                    page.set(buffer.subarray(bytes, bytes + pageLength), pageOffset);
                    this.cache.insert(pageIndex, page);
                }
                bytes += pageLength;
            }
            return buffer;
        }
    }
    exports.PagedFile = PagedFile;
    ;
    class PhysicalFile extends File {
        fd;
        currentSize;
        constructor(filename, clear) {
            super();
            libfs.mkdirSync(libpath.dirname(filename), { recursive: true });
            this.fd = libfs.openSync(filename, libfs.existsSync(filename) ? "r+" : "w+");
            this.currentSize = libfs.fstatSync(this.fd).size;
            if (clear) {
                this.resize(0);
            }
        }
        discard() {
            throw `Expected discard() to be delegated to another implementation!`;
        }
        hint() {
            let pageSizeLog2 = Math.log2(libfs.fstatSync(this.fd).blksize);
            return {
                pageSizeLog2
            };
        }
        persist() {
            libfs.fsyncSync(this.fd);
        }
        read(buffer, offset) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, offset);
            let bytesRead = libfs.readSync(this.fd, buffer, {
                position: offset
            });
            if (bytesRead !== buffer.length) {
                throw `Expected to read ${buffer.length} bytes but ${bytesRead} bytes were read!`;
            }
            return buffer;
        }
        resize(size) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, size);
            libfs.ftruncateSync(this.fd, size);
            this.currentSize = size;
        }
        size() {
            return this.currentSize;
        }
        write(buffer, offset) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, offset);
            let bytesWritten = libfs.writeSync(this.fd, buffer, 0, buffer.length, offset);
            if (bytesWritten !== buffer.length) {
                throw `Expected to write ${buffer.length} bytes but ${bytesWritten} bytes were written!`;
            }
            this.currentSize = Math.max(this.currentSize, offset + buffer.length);
            return buffer;
        }
    }
    exports.PhysicalFile = PhysicalFile;
    ;
    class VirtualFile extends File {
        backup;
        buffer;
        constructor(size) {
            super();
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, size);
            this.backup = new Uint8Array(size);
            this.buffer = new Uint8Array(size);
        }
        discard() {
            this.buffer = new Uint8Array(this.backup.length);
            this.buffer.set(this.backup, 0);
        }
        persist() {
            this.backup = new Uint8Array(this.buffer.length);
            this.backup.set(this.buffer, 0);
        }
        read(buffer, offset) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, offset);
            let minSize = offset + buffer.length;
            let size = this.size();
            if (size < minSize) {
                throw `Expected to read ${buffer.length} bytes at offset ${offset} from a total of ${size}!`;
            }
            buffer.set(this.buffer.subarray(offset, offset + buffer.length), 0);
            return buffer;
        }
        resize(size) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, size);
            let buffer = new Uint8Array(size);
            buffer.set(this.buffer.subarray(0, Math.min(size, this.size())), 0);
            this.buffer = buffer;
        }
        size() {
            return this.buffer.length;
        }
        write(buffer, offset) {
            if (variables_1.DEBUG)
                asserts.IntegerAssert.atLeast(0, offset);
            let minSize = offset + buffer.length;
            let size = this.size();
            if (size < minSize) {
                this.resize(minSize);
            }
            this.buffer.set(buffer, offset);
            return buffer;
        }
    }
    exports.VirtualFile = VirtualFile;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/operators", ["require", "exports", "node_modules/@joelek/atlas/dist/lib/filters"], function (require, exports, filters_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EqualityOperator = exports.Operator = void 0;
    class Operator {
        constructor() { }
    }
    exports.Operator = Operator;
    ;
    class EqualityOperator extends Operator {
        constructor() {
            super();
        }
        createFilter(value) {
            return new filters_1.EqualityFilter(value);
        }
    }
    exports.EqualityOperator = EqualityOperator;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/queries", ["require", "exports", "node_modules/@joelek/atlas/dist/lib/operators", "node_modules/@joelek/atlas/dist/lib/stores"], function (require, exports, operators_1, stores_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OverridableWritableQuery = exports.Query = exports.QueryManager = exports.WritableQueryManager = void 0;
    ;
    class WritableQueryManager {
        queryManager;
        constructor(queryManager) {
            this.queryManager = queryManager;
        }
        async filter(...parameters) {
            return this.queryManager.filter(...parameters);
        }
    }
    exports.WritableQueryManager = WritableQueryManager;
    ;
    class QueryManager {
        storeManager;
        operators;
        orders;
        constructor(storeManager, operators, orders) {
            this.storeManager = storeManager;
            this.operators = operators;
            this.orders = orders;
        }
        filter(parameters, anchor, limit) {
            let filters = {};
            for (let key in this.operators) {
                filters[key] = this.operators[key].createFilter(parameters[key]);
            }
            let orders = {};
            for (let key in this.orders) {
                orders[key] = this.orders[key];
            }
            return this.storeManager.filter(filters, orders, anchor, limit);
        }
    }
    exports.QueryManager = QueryManager;
    ;
    class Query {
        store;
        operators;
        orders;
        constructor(store, operators, orders) {
            this.store = store;
            this.operators = operators;
            this.orders = orders;
            this.store.index(this.createIndex());
        }
        createIndex() {
            let keys = [];
            for (let key in this.operators) {
                let operator = this.operators[key];
                if (!(operator instanceof operators_1.EqualityOperator)) {
                    continue;
                }
                if (!keys.includes(key)) {
                    keys.push(key);
                }
            }
            for (let key in this.orders) {
                let order = this.orders[key];
                if (order == null) {
                    continue;
                }
                if (!keys.includes(key)) {
                    keys.push(key);
                }
            }
            for (let key of this.store.keys) {
                if (!keys.includes(key)) {
                    keys.push(key);
                }
            }
            return new stores_1.Index(keys);
        }
    }
    exports.Query = Query;
    ;
    class OverridableWritableQuery {
        queryManager;
        overrides;
        constructor(queryManager, overrides) {
            this.queryManager = queryManager;
            this.overrides = overrides;
        }
        async filter(...parameters) {
            return this.overrides.filter?.(...parameters) ?? this.queryManager.filter(...parameters);
        }
    }
    exports.OverridableWritableQuery = OverridableWritableQuery;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/transactions", ["require", "exports", "node_modules/@joelek/atlas/dist/lib/utils"], function (require, exports, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransactionManager = exports.TransactionalQuery = exports.TransactionalLink = exports.TransactionalStore = exports.WritableQueue = exports.ReadableQueue = void 0;
    class ReadableQueue {
        queue;
        constructor(queue) {
            this.queue = queue;
        }
        enqueueReadableOperation(operation) {
            return this.queue.enqueue(operation);
        }
    }
    exports.ReadableQueue = ReadableQueue;
    ;
    class WritableQueue extends ReadableQueue {
        constructor(queue) {
            super(queue);
        }
        enqueueWritableOperation(operation) {
            return this.queue.enqueue(operation);
        }
    }
    exports.WritableQueue = WritableQueue;
    ;
    class TransactionalStore {
        store;
        constructor(store) {
            this.store = store;
        }
        filter(queue, ...parameters) {
            return queue.enqueueReadableOperation(() => this.store.filter(...parameters));
        }
        insert(queue, ...parameters) {
            return queue.enqueueWritableOperation(() => this.store.insert(...parameters));
        }
        length(queue, ...parameters) {
            return queue.enqueueReadableOperation(() => this.store.length(...parameters));
        }
        lookup(queue, ...parameters) {
            return queue.enqueueReadableOperation(() => this.store.lookup(...parameters));
        }
        remove(queue, ...parameters) {
            return queue.enqueueWritableOperation(() => this.store.remove(...parameters));
        }
        update(queue, ...parameters) {
            return queue.enqueueWritableOperation(() => this.store.update(...parameters));
        }
        vacate(queue, ...parameters) {
            return queue.enqueueWritableOperation(() => this.store.vacate(...parameters));
        }
    }
    exports.TransactionalStore = TransactionalStore;
    ;
    class TransactionalLink {
        link;
        constructor(link) {
            this.link = link;
        }
        filter(queue, ...parameters) {
            return queue.enqueueReadableOperation(() => this.link.filter(...parameters));
        }
        lookup(queue, ...parameters) {
            return queue.enqueueReadableOperation(() => this.link.lookup(...parameters));
        }
    }
    exports.TransactionalLink = TransactionalLink;
    ;
    class TransactionalQuery {
        query;
        constructor(query) {
            this.query = query;
        }
        filter(queue, ...parameters) {
            return queue.enqueueReadableOperation(() => this.query.filter(...parameters));
        }
    }
    exports.TransactionalQuery = TransactionalQuery;
    ;
    class TransactionManager {
        file;
        readableTransactionLock;
        writableTransactionLock;
        writableStores;
        writableLinks;
        writableQueries;
        constructor(file, writableStores, writableLinks, writableQueries) {
            this.file = file;
            this.readableTransactionLock = Promise.resolve();
            this.writableTransactionLock = Promise.resolve();
            this.writableStores = writableStores;
            this.writableLinks = writableLinks;
            this.writableQueries = writableQueries;
        }
        createTransactionalStores() {
            let transactionalStores = {};
            for (let key in this.writableStores) {
                transactionalStores[key] = new TransactionalStore(this.writableStores[key]);
            }
            return transactionalStores;
        }
        createTransactionalLinks() {
            let transactionalLinks = {};
            for (let key in this.writableLinks) {
                transactionalLinks[key] = new TransactionalLink(this.writableLinks[key]);
            }
            return transactionalLinks;
        }
        createTransactionalQueries() {
            let transactionalQueries = {};
            for (let key in this.writableQueries) {
                transactionalQueries[key] = new TransactionalQuery(this.writableQueries[key]);
            }
            return transactionalQueries;
        }
        async enqueueReadableTransaction(transaction) {
            let queue = new utils_1.PromiseQueue();
            let readableQueue = new ReadableQueue(queue);
            let promise = this.readableTransactionLock
                .then(() => transaction(readableQueue))
                .then((value) => queue.enqueue(() => value));
            this.writableTransactionLock = this.writableTransactionLock
                .then(() => promise)
                .catch(() => { });
            try {
                let value = await promise;
                return value;
            }
            catch (error) {
                throw error;
            }
            finally {
                queue.close();
            }
        }
        async enqueueWritableTransaction(transaction) {
            let queue = new utils_1.PromiseQueue();
            let writableQueue = new WritableQueue(queue);
            let promise = this.writableTransactionLock
                .then(() => transaction(writableQueue))
                .then((value) => queue.enqueue(() => value));
            this.writableTransactionLock = this.readableTransactionLock = this.writableTransactionLock
                .then(() => promise)
                .catch(() => { });
            try {
                let value = await promise;
                this.file.persist();
                return value;
            }
            catch (error) {
                this.file.discard();
                throw error;
            }
            finally {
                queue.close();
            }
        }
    }
    exports.TransactionManager = TransactionManager;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/databases", ["require", "exports", "node_modules/@joelek/atlas/dist/lib/links", "node_modules/@joelek/atlas/dist/lib/queries", "node_modules/@joelek/atlas/dist/lib/stores", "node_modules/@joelek/atlas/dist/lib/transactions"], function (require, exports, links_1, queries_1, stores_1, transactions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Database = exports.DatabaseManager = void 0;
    class DatabaseManager {
        storeManagers;
        linkManagers;
        queryManagers;
        linksWhereStoreIsParent;
        linksWhereStoreIsChild;
        doInsert(storeManager, records) {
            for (let record of records) {
                for (let linkManager of this.getLinksWhereStoreIsChild(storeManager)) {
                    linkManager.lookup(record);
                }
                storeManager.insert(record);
            }
        }
        doRemove(storeManager, records) {
            let queue = new Array();
            queue.push({
                storeManager,
                records
            });
            while (queue.length > 0) {
                let queueEntry = queue.splice(0, 1)[0];
                for (let record of queueEntry.records) {
                    queueEntry.storeManager.remove(record);
                }
                for (let linkManager of this.getLinksWhereStoreIsParent(queueEntry.storeManager)) {
                    let storeManager = linkManager.getChild();
                    let records = new Array();
                    for (let record of queueEntry.records) {
                        for (let childRecord of linkManager.filter(record)) {
                            records.push(childRecord);
                        }
                    }
                    if (records.length > 0) {
                        queue.push({
                            storeManager,
                            records
                        });
                    }
                }
            }
        }
        doVacate(storeManager, orphans) {
            if (storeManager.length() > 0) {
                storeManager.vacate();
                for (let linkManager of this.getLinksWhereStoreIsParent(storeManager)) {
                    this.doVacate(linkManager.getChild(), linkManager.filter());
                }
            }
            for (let orphan of orphans) {
                storeManager.insert(orphan);
            }
        }
        getLinksWhereStoreIsParent(storeManager) {
            let set = this.linksWhereStoreIsParent.get(storeManager);
            if (set == null) {
                throw `Expected link set!`;
            }
            return set;
        }
        getLinksWhereStoreIsChild(storeManager) {
            let set = this.linksWhereStoreIsChild.get(storeManager);
            if (set == null) {
                throw `Expected link set!`;
            }
            return set;
        }
        constructor(storeManagers, linkManagers, queryManagers) {
            this.storeManagers = storeManagers;
            this.linkManagers = linkManagers;
            this.queryManagers = queryManagers;
            this.linksWhereStoreIsParent = new Map();
            this.linksWhereStoreIsChild = new Map();
            for (let key in storeManagers) {
                let storeManager = storeManagers[key];
                let linksWhereStoreIsChild = new Set();
                let linksWhereStoreIsParent = new Set();
                for (let key in this.linkManagers) {
                    let linkManager = this.linkManagers[key];
                    if (storeManager === linkManager.getParent()) {
                        linksWhereStoreIsParent.add(linkManager);
                    }
                    if (storeManager === linkManager.getChild()) {
                        linksWhereStoreIsChild.add(linkManager);
                    }
                }
                this.linksWhereStoreIsParent.set(storeManager, linksWhereStoreIsParent);
                this.linksWhereStoreIsChild.set(storeManager, linksWhereStoreIsChild);
            }
        }
        createTransactionManager(file) {
            let writableStores = this.createWritableStores();
            let writableLinks = this.createWritableLinks();
            let writableQueries = this.createWritableQueries();
            return new transactions_1.TransactionManager(file, writableStores, writableLinks, writableQueries);
        }
        createWritableStores() {
            let writableStores = {};
            for (let key in this.storeManagers) {
                let storeManager = this.storeManagers[key];
                writableStores[key] = new stores_1.OverridableWritableStore(storeManager, {
                    insert: async (record) => this.doInsert(storeManager, [record]),
                    remove: async (record) => this.doRemove(storeManager, [record]),
                    vacate: async () => this.doVacate(storeManager, [])
                });
            }
            return writableStores;
        }
        createWritableLinks() {
            let writableLinks = {};
            for (let key in this.linkManagers) {
                let linkManager = this.linkManagers[key];
                writableLinks[key] = new links_1.OverridableWritableLink(linkManager, {});
            }
            return writableLinks;
        }
        createWritableQueries() {
            let writableQueries = {};
            for (let key in this.queryManagers) {
                let queryManager = this.queryManagers[key];
                writableQueries[key] = new queries_1.OverridableWritableQuery(queryManager, {});
            }
            return writableQueries;
        }
        enforceStoreConsistency(storeNames) {
            for (let key of storeNames) {
                let storeManager = this.storeManagers[key];
                for (let linkManager of this.getLinksWhereStoreIsParent(storeManager)) {
                    let child = linkManager.getChild();
                    let records = [];
                    for (let childRecord of child) {
                        try {
                            linkManager.lookup(childRecord);
                        }
                        catch (error) {
                            records.push(childRecord);
                        }
                    }
                    this.doRemove(child, records);
                }
            }
        }
        enforceLinkConsistency(linkNames) {
            for (let key of linkNames) {
                let linkManager = this.linkManagers[key];
                let child = linkManager.getChild();
                let records = [];
                for (let childRecord of child) {
                    try {
                        linkManager.lookup(childRecord);
                    }
                    catch (error) {
                        records.push(childRecord);
                    }
                }
                this.doRemove(child, records);
            }
        }
        enforceConsistency(storeNames, linkNames) {
            let linkManagers = new Set();
            for (let key of storeNames) {
                for (let linkManager of this.getLinksWhereStoreIsParent(this.storeManagers[key])) {
                    linkManagers.add(linkManager);
                }
            }
            for (let key of linkNames) {
                let linkManager = this.linkManagers[key];
                linkManagers.add(linkManager);
            }
            for (let linkManager of linkManagers) {
                let child = linkManager.getChild();
                let records = [];
                for (let childRecord of child) {
                    try {
                        linkManager.lookup(childRecord);
                    }
                    catch (error) {
                        records.push(childRecord);
                    }
                }
                this.doRemove(child, records);
            }
        }
    }
    exports.DatabaseManager = DatabaseManager;
    ;
    class Database {
        stores;
        links;
        queries;
        constructor(stores, links, queries) {
            this.stores = stores ?? {};
            this.links = links ?? {};
            this.queries = queries ?? {};
        }
    }
    exports.Database = Database;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/schemas", ["require", "exports", "node_modules/@joelek/bedrock/dist/lib/index", "node_modules/@joelek/atlas/dist/lib/databases", "node_modules/@joelek/atlas/dist/lib/tables", "node_modules/@joelek/atlas/dist/lib/links", "node_modules/@joelek/atlas/dist/lib/orders", "node_modules/@joelek/atlas/dist/lib/records", "node_modules/@joelek/atlas/dist/lib/stores", "node_modules/@joelek/atlas/dist/lib/blocks", "node_modules/@joelek/atlas/dist/lib/queries", "node_modules/@joelek/atlas/dist/lib/operators", "node_modules/@joelek/atlas/dist/lib/trees"], function (require, exports, bedrock, databases_1, tables_1, links_1, orders_1, records_1, stores_1, blocks_1, queries_1, operators_1, trees_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SchemaManager = exports.isSchemaCompatible = exports.DatabaseSchema = exports.QueriesSchema = exports.QuerySchema = exports.LinksSchema = exports.LinkSchema = exports.StoresSchema = exports.StoreSchema = exports.KeysMapSchema = exports.KeyOrdersSchema = exports.KeyOrderSchema = exports.OrderSchema = exports.IncreasingOrderSchema = exports.DecreasingOrderSchema = exports.KeyOperatorsSchema = exports.KeyOperatorSchema = exports.OperatorSchema = exports.EqualityOperatorSchema = exports.IndicesSchema = exports.IndexSchema = exports.KeysSchema = exports.FieldsSchema = exports.FieldSchema = exports.NullableStringFieldSchema = exports.StringFieldSchema = exports.NullableNumberFieldSchema = exports.NumberFieldSchema = exports.NullableIntegerFieldSchema = exports.IntegerFieldSchema = exports.NullableBooleanFieldSchema = exports.BooleanFieldSchema = exports.NullableBinaryFieldSchema = exports.BinaryFieldSchema = exports.NullableBigIntFieldSchema = exports.BigIntFieldSchema = void 0;
    exports.BigIntFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("BigIntField"),
        defaultValue: bedrock.codecs.BigInt
    });
    exports.NullableBigIntFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("NullableBigIntField"),
        defaultValue: bedrock.codecs.Union.of(bedrock.codecs.BigInt, bedrock.codecs.Null)
    });
    exports.BinaryFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("BinaryField"),
        defaultValue: bedrock.codecs.Binary
    });
    exports.NullableBinaryFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("NullableBinaryField"),
        defaultValue: bedrock.codecs.Union.of(bedrock.codecs.Binary, bedrock.codecs.Null)
    });
    exports.BooleanFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("BooleanField"),
        defaultValue: bedrock.codecs.Boolean
    });
    exports.NullableBooleanFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("NullableBooleanField"),
        defaultValue: bedrock.codecs.Union.of(bedrock.codecs.Boolean, bedrock.codecs.Null)
    });
    exports.IntegerFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("IntegerField"),
        defaultValue: bedrock.codecs.Integer
    });
    exports.NullableIntegerFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("NullableIntegerField"),
        defaultValue: bedrock.codecs.Union.of(bedrock.codecs.Integer, bedrock.codecs.Null)
    });
    exports.NumberFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("NumberField"),
        defaultValue: bedrock.codecs.Number
    });
    exports.NullableNumberFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("NullableNumberField"),
        defaultValue: bedrock.codecs.Union.of(bedrock.codecs.Number, bedrock.codecs.Null)
    });
    exports.StringFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("StringField"),
        defaultValue: bedrock.codecs.String
    });
    exports.NullableStringFieldSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("NullableStringField"),
        defaultValue: bedrock.codecs.Union.of(bedrock.codecs.String, bedrock.codecs.Null)
    });
    exports.FieldSchema = bedrock.codecs.Union.of(exports.BigIntFieldSchema, exports.NullableBigIntFieldSchema, exports.BinaryFieldSchema, exports.NullableBinaryFieldSchema, exports.BooleanFieldSchema, exports.NullableBooleanFieldSchema, exports.IntegerFieldSchema, exports.NullableIntegerFieldSchema, exports.NumberFieldSchema, exports.NullableNumberFieldSchema, exports.StringFieldSchema, exports.NullableStringFieldSchema);
    exports.FieldsSchema = bedrock.codecs.Record.of(exports.FieldSchema);
    exports.KeysSchema = bedrock.codecs.Array.of(bedrock.codecs.String);
    exports.IndexSchema = bedrock.codecs.Object.of({
        keys: exports.KeysSchema,
        bid: bedrock.codecs.Integer
    });
    exports.IndicesSchema = bedrock.codecs.Array.of(exports.IndexSchema);
    exports.EqualityOperatorSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("EqualityOperator")
    });
    exports.OperatorSchema = bedrock.codecs.Union.of(exports.EqualityOperatorSchema);
    exports.KeyOperatorSchema = bedrock.codecs.Object.of({
        key: bedrock.codecs.String,
        operator: exports.OperatorSchema
    });
    exports.KeyOperatorsSchema = bedrock.codecs.Array.of(exports.KeyOperatorSchema);
    exports.DecreasingOrderSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("DecreasingOrder")
    });
    exports.IncreasingOrderSchema = bedrock.codecs.Object.of({
        type: bedrock.codecs.StringLiteral.of("IncreasingOrder")
    });
    exports.OrderSchema = bedrock.codecs.Union.of(exports.DecreasingOrderSchema, exports.IncreasingOrderSchema);
    exports.KeyOrderSchema = bedrock.codecs.Object.of({
        key: bedrock.codecs.String,
        order: exports.OrderSchema
    });
    exports.KeyOrdersSchema = bedrock.codecs.Array.of(exports.KeyOrderSchema);
    exports.KeysMapSchema = bedrock.codecs.Record.of(bedrock.codecs.String);
    exports.StoreSchema = bedrock.codecs.Object.of({
        version: bedrock.codecs.Integer,
        fields: exports.FieldsSchema,
        keys: exports.KeysSchema,
        orders: exports.KeyOrdersSchema,
        indices: exports.IndicesSchema,
        storageBid: bedrock.codecs.Integer
    });
    exports.StoresSchema = bedrock.codecs.Record.of(exports.StoreSchema);
    exports.LinkSchema = bedrock.codecs.Object.of({
        version: bedrock.codecs.Integer,
        parent: bedrock.codecs.String,
        child: bedrock.codecs.String,
        keysMap: exports.KeysMapSchema,
        orders: exports.KeyOrdersSchema
    });
    exports.LinksSchema = bedrock.codecs.Record.of(exports.LinkSchema);
    exports.QuerySchema = bedrock.codecs.Object.of({
        version: bedrock.codecs.Integer,
        store: bedrock.codecs.String,
        operators: exports.KeyOperatorsSchema,
        orders: exports.KeyOrdersSchema
    });
    exports.QueriesSchema = bedrock.codecs.Record.of(exports.QuerySchema);
    exports.DatabaseSchema = bedrock.codecs.Object.of({
        stores: exports.StoresSchema,
        links: exports.LinksSchema,
        queries: exports.QueriesSchema
    });
    function isSchemaCompatible(codec, subject) {
        try {
            codec.encode(subject);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    exports.isSchemaCompatible = isSchemaCompatible;
    class SchemaManager {
        getStoreName(store, stores) {
            for (let key in stores) {
                if (stores[key] === store) {
                    return key;
                }
            }
            throw `Expected store!`;
        }
        initializeDatabase(blockManager) {
            let databaseSchema = {
                stores: {},
                links: {},
                queries: {}
            };
            let buffer = exports.DatabaseSchema.encode(databaseSchema, "schema");
            blockManager.createBlock(buffer.length);
            blockManager.writeBlock(0, buffer);
        }
        loadFieldManager(blockManager, fieldSchema) {
            if (isSchemaCompatible(exports.BigIntFieldSchema, fieldSchema)) {
                return new records_1.BigIntField(fieldSchema.defaultValue);
            }
            if (isSchemaCompatible(exports.NullableBigIntFieldSchema, fieldSchema)) {
                return new records_1.NullableBigIntField(fieldSchema.defaultValue);
            }
            if (isSchemaCompatible(exports.BinaryFieldSchema, fieldSchema)) {
                return new records_1.BinaryField(fieldSchema.defaultValue);
            }
            if (isSchemaCompatible(exports.NullableBinaryFieldSchema, fieldSchema)) {
                return new records_1.NullableBinaryField(fieldSchema.defaultValue);
            }
            if (isSchemaCompatible(exports.BooleanFieldSchema, fieldSchema)) {
                return new records_1.BooleanField(fieldSchema.defaultValue);
            }
            if (isSchemaCompatible(exports.NullableBooleanFieldSchema, fieldSchema)) {
                return new records_1.NullableBooleanField(fieldSchema.defaultValue);
            }
            if (isSchemaCompatible(exports.IntegerFieldSchema, fieldSchema)) {
                return new records_1.IntegerField(fieldSchema.defaultValue);
            }
            if (isSchemaCompatible(exports.NullableIntegerFieldSchema, fieldSchema)) {
                return new records_1.NullableIntegerField(fieldSchema.defaultValue);
            }
            if (isSchemaCompatible(exports.NumberFieldSchema, fieldSchema)) {
                return new records_1.NumberField(fieldSchema.defaultValue);
            }
            if (isSchemaCompatible(exports.NullableNumberFieldSchema, fieldSchema)) {
                return new records_1.NullableNumberField(fieldSchema.defaultValue);
            }
            if (isSchemaCompatible(exports.StringFieldSchema, fieldSchema)) {
                return new records_1.StringField(fieldSchema.defaultValue);
            }
            if (isSchemaCompatible(exports.NullableStringFieldSchema, fieldSchema)) {
                return new records_1.NullableStringField(fieldSchema.defaultValue);
            }
            throw `Expected code to be unreachable!`;
        }
        loadOperatorManager(operatorSchema) {
            if (isSchemaCompatible(exports.EqualityOperatorSchema, operatorSchema)) {
                return new operators_1.EqualityOperator();
            }
            throw `Expected code to be unreachable!`;
        }
        loadOrderManager(orderSchema) {
            if (isSchemaCompatible(exports.DecreasingOrderSchema, orderSchema)) {
                return new orders_1.DecreasingOrder();
            }
            if (isSchemaCompatible(exports.IncreasingOrderSchema, orderSchema)) {
                return new orders_1.IncreasingOrder();
            }
            throw `Expected code to be unreachable!`;
        }
        loadIndexManager(recordManager, blockManager, indexSchema) {
            return new stores_1.IndexManager(recordManager, blockManager, indexSchema.keys, {
                bid: indexSchema.bid
            });
        }
        loadRecordManager(blockManager, fieldsSchema) {
            let fields = {};
            for (let key in fieldsSchema) {
                fields[key] = this.loadFieldManager(blockManager, fieldsSchema[key]);
            }
            return new records_1.RecordManager(fields);
        }
        loadStoreManager(blockManager, oldSchema) {
            let fields = {};
            for (let key in oldSchema.fields) {
                fields[key] = this.loadFieldManager(blockManager, oldSchema.fields[key]);
            }
            let keys = oldSchema.keys;
            let orders = {};
            for (let order of oldSchema.orders) {
                orders[order.key] = this.loadOrderManager(order.order);
            }
            let recordManager = new records_1.RecordManager(fields);
            let storage = new tables_1.Table(blockManager, {
                getKeyFromValue: (value) => {
                    let buffer = blockManager.readBlock(value);
                    let record = recordManager.decode(buffer);
                    return recordManager.encodeKeys(keys, record);
                }
            }, {
                bid: oldSchema.storageBid
            });
            let indexManagers = oldSchema.indices.map((indexSchema) => {
                return this.loadIndexManager(recordManager, blockManager, indexSchema);
            });
            return new stores_1.StoreManager(blockManager, fields, keys, orders, storage, indexManagers);
        }
        loadLinkManager(blockManager, linkSchema, storeManagers) {
            let parent = storeManagers[linkSchema.parent];
            if (parent == null) {
                throw `Expected store with name "${linkSchema.parent}"!`;
            }
            let child = storeManagers[linkSchema.child];
            if (child == null) {
                throw `Expected store with name "${linkSchema.child}"!`;
            }
            let recordKeysMap = linkSchema.keysMap;
            let orders = {};
            for (let order of linkSchema.orders) {
                orders[order.key] = this.loadOrderManager(order.order);
            }
            return new links_1.LinkManager(parent, child, recordKeysMap, orders);
        }
        loadQueryManager(blockManager, querySchema, storeManagers) {
            let store = storeManagers[querySchema.store];
            if (store == null) {
                throw `Expected store with name "${querySchema.store}"!`;
            }
            let operators = {};
            for (let operator of querySchema.operators) {
                operators[operator.key] = this.loadOperatorManager(operator.operator);
            }
            let orders = {};
            for (let order of querySchema.orders) {
                orders[order.key] = this.loadOrderManager(order.order);
            }
            return new queries_1.QueryManager(store, operators, orders);
        }
        loadDatabaseManager(databaseSchema, blockManager) {
            let storeManagers = {};
            for (let key in databaseSchema.stores) {
                storeManagers[key] = this.loadStoreManager(blockManager, databaseSchema.stores[key]);
            }
            let linkManagers = {};
            for (let key in databaseSchema.links) {
                linkManagers[key] = this.loadLinkManager(blockManager, databaseSchema.links[key], storeManagers);
            }
            let queryManagers = {};
            for (let key in databaseSchema.queries) {
                queryManagers[key] = this.loadQueryManager(blockManager, databaseSchema.queries[key], storeManagers);
            }
            return new databases_1.DatabaseManager(storeManagers, linkManagers, queryManagers);
        }
        compareField(field, schema) {
            if (isSchemaCompatible(exports.BigIntFieldSchema, schema)) {
                if (field instanceof records_1.BigIntField) {
                    return true;
                }
                if (field instanceof records_1.NullableBigIntField) {
                    return true;
                }
                return false;
            }
            if (isSchemaCompatible(exports.NullableBigIntFieldSchema, schema)) {
                if (field instanceof records_1.NullableBigIntField) {
                    return true;
                }
                return false;
            }
            if (isSchemaCompatible(exports.BinaryFieldSchema, schema)) {
                if (field instanceof records_1.BinaryField) {
                    return true;
                }
                if (field instanceof records_1.NullableBinaryField) {
                    return true;
                }
                return false;
            }
            if (isSchemaCompatible(exports.NullableBinaryFieldSchema, schema)) {
                if (field instanceof records_1.NullableBinaryField) {
                    return true;
                }
                return false;
            }
            if (isSchemaCompatible(exports.BooleanFieldSchema, schema)) {
                if (field instanceof records_1.BooleanField) {
                    return true;
                }
                if (field instanceof records_1.NullableBooleanField) {
                    return true;
                }
                return false;
            }
            if (isSchemaCompatible(exports.NullableBooleanFieldSchema, schema)) {
                if (field instanceof records_1.NullableBooleanField) {
                    return true;
                }
                return false;
            }
            if (isSchemaCompatible(exports.IntegerFieldSchema, schema)) {
                if (field instanceof records_1.IntegerField) {
                    return true;
                }
                if (field instanceof records_1.NullableIntegerField) {
                    return true;
                }
                return false;
            }
            if (isSchemaCompatible(exports.NullableIntegerFieldSchema, schema)) {
                if (field instanceof records_1.NullableIntegerField) {
                    return true;
                }
                return false;
            }
            if (isSchemaCompatible(exports.NumberFieldSchema, schema)) {
                if (field instanceof records_1.NumberField) {
                    return true;
                }
                if (field instanceof records_1.NullableNumberField) {
                    return true;
                }
                return false;
            }
            if (isSchemaCompatible(exports.NullableNumberFieldSchema, schema)) {
                if (field instanceof records_1.NullableNumberField) {
                    return true;
                }
                return false;
            }
            if (isSchemaCompatible(exports.StringFieldSchema, schema)) {
                if (field instanceof records_1.StringField) {
                    return true;
                }
                if (field instanceof records_1.NullableStringField) {
                    return true;
                }
                return false;
            }
            if (isSchemaCompatible(exports.NullableStringFieldSchema, schema)) {
                if (field instanceof records_1.NullableStringField) {
                    return true;
                }
                return false;
            }
            throw `Expected code to be unreachable!`;
        }
        compareFields(fields, oldSchema) {
            for (let key in oldSchema) {
                if (fields[key] == null) {
                    return false;
                }
            }
            for (let key in fields) {
                if (oldSchema[key] == null) {
                    return false;
                }
                else {
                    if (!this.compareField(fields[key], oldSchema[key])) {
                        return false;
                    }
                }
            }
            return true;
        }
        compareKeys(keys, oldSchema) {
            if (oldSchema.length !== keys.length) {
                return false;
            }
            for (let i = 0; i < oldSchema.length; i++) {
                if (oldSchema[i] !== keys[i]) {
                    return false;
                }
            }
            return true;
        }
        compareIndex(index, oldSchema) {
            return this.compareKeys(oldSchema.keys, index.keys);
        }
        compareStore(store, oldSchema) {
            if (!this.compareKeys(store.keys, oldSchema.keys)) {
                return false;
            }
            if (!this.compareFields(store.fields, oldSchema.fields)) {
                return false;
            }
            return true;
        }
        compareLink(stores, link, oldSchema) {
            if (this.getStoreName(link.parent, stores) !== oldSchema.parent) {
                return false;
            }
            if (this.getStoreName(link.child, stores) !== oldSchema.child) {
                return false;
            }
            for (let key in link.recordKeysMap) {
                if (oldSchema.keysMap[key] !== link.recordKeysMap[key]) {
                    return false;
                }
            }
            for (let key in oldSchema.keysMap) {
                if (oldSchema.keysMap[key] !== link.recordKeysMap[key]) {
                    return false;
                }
            }
            return true;
        }
        createField(field) {
            if (field instanceof records_1.BigIntField) {
                return {
                    type: "BigIntField",
                    defaultValue: field.getDefaultValue()
                };
            }
            if (field instanceof records_1.NullableBigIntField) {
                return {
                    type: "NullableBigIntField",
                    defaultValue: field.getDefaultValue()
                };
            }
            if (field instanceof records_1.BinaryField) {
                return {
                    type: "BinaryField",
                    defaultValue: field.getDefaultValue()
                };
            }
            if (field instanceof records_1.NullableBinaryField) {
                return {
                    type: "NullableBinaryField",
                    defaultValue: field.getDefaultValue()
                };
            }
            if (field instanceof records_1.BooleanField) {
                return {
                    type: "BooleanField",
                    defaultValue: field.getDefaultValue()
                };
            }
            if (field instanceof records_1.NullableBooleanField) {
                return {
                    type: "NullableBooleanField",
                    defaultValue: field.getDefaultValue()
                };
            }
            if (field instanceof records_1.IntegerField) {
                return {
                    type: "IntegerField",
                    defaultValue: field.getDefaultValue()
                };
            }
            if (field instanceof records_1.NullableIntegerField) {
                return {
                    type: "NullableIntegerField",
                    defaultValue: field.getDefaultValue()
                };
            }
            if (field instanceof records_1.NumberField) {
                return {
                    type: "NumberField",
                    defaultValue: field.getDefaultValue()
                };
            }
            if (field instanceof records_1.NullableNumberField) {
                return {
                    type: "NullableNumberField",
                    defaultValue: field.getDefaultValue()
                };
            }
            if (field instanceof records_1.StringField) {
                return {
                    type: "StringField",
                    defaultValue: field.getDefaultValue()
                };
            }
            if (field instanceof records_1.NullableStringField) {
                return {
                    type: "NullableStringField",
                    defaultValue: field.getDefaultValue()
                };
            }
            throw `Expected code to be unreachable!`;
        }
        createIndex(blockManager, index) {
            let schema = {
                keys: index.keys,
                bid: blockManager.createBlock(trees_1.RadixTree.INITIAL_SIZE)
            };
            return schema;
        }
        createStore(blockManager, store) {
            let version = 0;
            let fields = {};
            for (let key in store.fields) {
                fields[key] = this.createField(store.fields[key]);
            }
            let keys = store.keys;
            let orders = this.createKeyOrders(blockManager, store.orders);
            let indices = [];
            for (let index of store.indices) {
                indices.push(this.createIndex(blockManager, index));
            }
            let schema = {
                version,
                fields,
                keys,
                orders,
                indices,
                storageBid: blockManager.createBlock(tables_1.Table.LENGTH)
            };
            return schema;
        }
        deleteStore(blockManager, oldSchema) {
            this.loadStoreManager(blockManager, oldSchema).delete();
        }
        deleteIndex(blockManager, indexSchema, fieldsSchema) {
            let recordManager = this.loadRecordManager(blockManager, fieldsSchema);
            this.loadIndexManager(recordManager, blockManager, indexSchema).delete();
        }
        updateStore(blockManager, store, oldSchema) {
            if (this.compareStore(store, oldSchema)) {
                let indices = [];
                newIndices: for (let index of store.indices) {
                    oldIndices: for (let indexSchema of oldSchema.indices) {
                        if (this.compareIndex(index, indexSchema)) {
                            indices.push(indexSchema);
                            continue newIndices;
                        }
                    }
                    let recordManager = this.loadRecordManager(blockManager, oldSchema.fields);
                    let indexSchema = this.createIndex(blockManager, index);
                    let indexManager = this.loadIndexManager(recordManager, blockManager, indexSchema);
                    let storage = new tables_1.Table(blockManager, {
                        getKeyFromValue: (value) => {
                            let buffer = blockManager.readBlock(value);
                            let record = recordManager.decode(buffer);
                            return recordManager.encodeKeys(oldSchema.keys, record);
                        }
                    }, {
                        bid: oldSchema.storageBid
                    });
                    for (let bid of storage) {
                        let buffer = blockManager.readBlock(bid);
                        let record = recordManager.decode(buffer);
                        indexManager.insert(record, bid);
                    }
                    indices.push(indexSchema);
                }
                oldIndices: for (let indexSchema of oldSchema.indices) {
                    newIndices: for (let index of store.indices) {
                        if (this.compareIndex(index, indexSchema)) {
                            continue oldIndices;
                        }
                    }
                    this.deleteIndex(blockManager, indexSchema, oldSchema.fields);
                }
                let orders = this.createKeyOrders(blockManager, store.orders);
                return {
                    ...oldSchema,
                    orders,
                    indices
                };
            }
            else {
                let newSchema = this.createStore(blockManager, store);
                let oldManager = this.loadStoreManager(blockManager, oldSchema);
                let newManager = this.loadStoreManager(blockManager, newSchema);
                for (let oldRecord of oldManager) {
                    try {
                        let newRecord = {};
                        for (let key in store.fields) {
                            let field = store.fields[key];
                            let codec = field.getCodec();
                            if (isSchemaCompatible(codec, oldRecord[key])) {
                                newRecord[key] = oldRecord[key];
                            }
                            else {
                                newRecord[key] = field.getDefaultValue();
                            }
                        }
                        newManager.insert(newRecord);
                    }
                    catch (error) { }
                }
                oldManager.delete();
                newSchema.version = oldSchema.version + 1;
                return newSchema;
            }
        }
        updateStores(blockManager, stores, oldSchema) {
            let newSchema = {};
            for (let key in oldSchema) {
                if (stores[key] == null) {
                    this.deleteStore(blockManager, oldSchema[key]);
                }
            }
            for (let key in stores) {
                if (oldSchema[key] == null) {
                    newSchema[key] = this.createStore(blockManager, stores[key]);
                }
                else {
                    newSchema[key] = this.updateStore(blockManager, stores[key], oldSchema[key]);
                }
            }
            return newSchema;
        }
        createOperator(operator) {
            if (operator instanceof operators_1.EqualityOperator) {
                return {
                    type: "EqualityOperator"
                };
            }
            throw `Expected code to be unreachable!`;
        }
        createKeyOperators(blockManager, operatorMap) {
            let operators = [];
            for (let key in operatorMap) {
                let operator = operatorMap[key];
                if (operator == null) {
                    continue;
                }
                operators.push({
                    key,
                    operator: this.createOperator(operator)
                });
            }
            return operators;
        }
        createOrder(order) {
            if (order instanceof orders_1.DecreasingOrder) {
                return {
                    type: "DecreasingOrder"
                };
            }
            if (order instanceof orders_1.IncreasingOrder) {
                return {
                    type: "IncreasingOrder"
                };
            }
            throw `Expected code to be unreachable!`;
        }
        createKeyOrders(blockManager, orderMap) {
            let orders = [];
            for (let key in orderMap) {
                let order = orderMap[key];
                if (order == null) {
                    continue;
                }
                orders.push({
                    key,
                    order: this.createOrder(order)
                });
            }
            return orders;
        }
        createLink(blockManager, stores, link) {
            let version = 0;
            let parent = this.getStoreName(link.parent, stores);
            let child = this.getStoreName(link.child, stores);
            let keysMap = link.recordKeysMap;
            let orders = this.createKeyOrders(blockManager, link.orders);
            return {
                version,
                parent,
                child,
                keysMap,
                orders
            };
        }
        deleteLink(blockManager, oldSchema) {
        }
        updateLink(blockManager, stores, link, oldSchema) {
            if (this.compareLink(stores, link, oldSchema)) {
                let orders = this.createKeyOrders(blockManager, link.orders);
                return {
                    ...oldSchema,
                    orders
                };
            }
            else {
                let newSchema = this.createLink(blockManager, stores, link);
                newSchema.version = oldSchema.version + 1;
                return newSchema;
            }
        }
        updateLinks(blockManager, stores, links, oldSchema) {
            let newSchema = {};
            for (let key in oldSchema) {
                if (links[key] == null) {
                    this.deleteLink(blockManager, oldSchema[key]);
                }
            }
            for (let key in links) {
                if (oldSchema[key] == null) {
                    newSchema[key] = this.createLink(blockManager, stores, links[key]);
                }
                else {
                    newSchema[key] = this.updateLink(blockManager, stores, links[key], oldSchema[key]);
                }
            }
            return newSchema;
        }
        compareQuery(stores, query, oldSchema) {
            if (this.getStoreName(query.store, stores) !== oldSchema.store) {
                return false;
            }
            return true;
        }
        createQuery(blockManager, stores, query) {
            let version = 0;
            let store = this.getStoreName(query.store, stores);
            let operators = this.createKeyOperators(blockManager, query.operators);
            let orders = this.createKeyOrders(blockManager, query.orders);
            return {
                version,
                store,
                operators,
                orders
            };
        }
        deleteQuery(blockManager, oldSchema) {
        }
        updateQuery(blockManager, stores, query, oldSchema) {
            if (this.compareQuery(stores, query, oldSchema)) {
                let operators = this.createKeyOperators(blockManager, query.operators);
                let orders = this.createKeyOrders(blockManager, query.orders);
                return {
                    ...oldSchema,
                    operators,
                    orders
                };
            }
            else {
                let newSchema = this.createQuery(blockManager, stores, query);
                newSchema.version = oldSchema.version + 1;
                return newSchema;
            }
        }
        updateQueries(blockManager, stores, queries, oldSchema) {
            let newSchema = {};
            for (let key in oldSchema) {
                if (queries[key] == null) {
                    this.deleteQuery(blockManager, oldSchema[key]);
                }
            }
            for (let key in queries) {
                if (oldSchema[key] == null) {
                    newSchema[key] = this.createQuery(blockManager, stores, queries[key]);
                }
                else {
                    newSchema[key] = this.updateQuery(blockManager, stores, queries[key], oldSchema[key]);
                }
            }
            return newSchema;
        }
        updateDatabase(blockManager, database, oldSchema) {
            let stores = this.updateStores(blockManager, database.stores, oldSchema.stores);
            let links = this.updateLinks(blockManager, database.stores, database.links, oldSchema.links);
            let queries = this.updateQueries(blockManager, database.stores, database.queries, oldSchema.queries);
            let newSchema = {
                stores,
                links,
                queries
            };
            return newSchema;
        }
        getDirtyStoreNames(oldSchema, newSchema) {
            let names = [];
            for (let key in newSchema) {
                if (newSchema[key].version !== oldSchema[key]?.version) {
                    names.push(key);
                }
            }
            return names;
        }
        getDirtyLinkNames(oldSchema, newSchema) {
            let names = [];
            for (let key in newSchema) {
                if (newSchema[key].version !== oldSchema[key]?.version) {
                    names.push(key);
                }
            }
            return names;
        }
        constructor() { }
        createDatabaseManager(file, database) {
            let blockManager = new blocks_1.BlockManager(file);
            if (blockManager.getBlockCount() === 0) {
                this.initializeDatabase(blockManager);
            }
            let oldSchema = exports.DatabaseSchema.decode(blockManager.readBlock(0), "schema");
            let newSchema = this.updateDatabase(blockManager, database, oldSchema);
            let buffer = exports.DatabaseSchema.encode(newSchema, "schema");
            blockManager.resizeBlock(0, buffer.length);
            blockManager.writeBlock(0, buffer);
            let databaseManager = this.loadDatabaseManager(newSchema, blockManager);
            let dirtyLinkNames = this.getDirtyLinkNames(oldSchema.links, newSchema.links);
            let dirtyStoreNames = this.getDirtyStoreNames(oldSchema.stores, newSchema.stores);
            databaseManager.enforceConsistency(dirtyStoreNames, dirtyLinkNames);
            file.persist();
            return databaseManager;
        }
    }
    exports.SchemaManager = SchemaManager;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/contexts", ["require", "exports", "node_modules/@joelek/atlas/dist/lib/links", "node_modules/@joelek/atlas/dist/lib/stores", "node_modules/@joelek/atlas/dist/lib/records", "node_modules/@joelek/atlas/dist/lib/orders", "node_modules/@joelek/atlas/dist/lib/files", "node_modules/@joelek/atlas/dist/lib/databases", "node_modules/@joelek/atlas/dist/lib/operators", "node_modules/@joelek/atlas/dist/lib/schemas", "node_modules/@joelek/atlas/dist/lib/queries"], function (require, exports, links_1, stores_1, records_1, orders_1, files_1, databases_1, operators_1, schemas_1, queries_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Context = exports.OperatorReference = exports.OrderReference = exports.QueryReference = exports.LinkReference = exports.StoreReference = exports.FieldReference = void 0;
    class FieldReference {
        FieldReference;
    }
    exports.FieldReference = FieldReference;
    ;
    class StoreReference {
        StoreReference;
    }
    exports.StoreReference = StoreReference;
    ;
    class LinkReference {
        LinkReference;
    }
    exports.LinkReference = LinkReference;
    ;
    class QueryReference {
        QueryReference;
    }
    exports.QueryReference = QueryReference;
    ;
    class OrderReference {
        OrderReference;
    }
    exports.OrderReference = OrderReference;
    ;
    class OperatorReference {
        OperatorReference;
    }
    exports.OperatorReference = OperatorReference;
    ;
    class Context {
        fields;
        links;
        stores;
        queries;
        operators;
        orders;
        databaseManagers;
        getField(reference) {
            let field = this.fields.get(reference);
            if (field == null) {
                throw `Expected field to be defined in context!`;
            }
            return field;
        }
        getLink(reference) {
            let link = this.links.get(reference);
            if (link == null) {
                throw `Expected link to be defined in context!`;
            }
            return link;
        }
        getStore(reference) {
            let store = this.stores.get(reference);
            if (store == null) {
                throw `Expected store to be defined in context!`;
            }
            return store;
        }
        getQuery(reference) {
            let query = this.queries.get(reference);
            if (query == null) {
                throw `Expected query to be defined in context!`;
            }
            return query;
        }
        getOperator(reference) {
            let operator = this.operators.get(reference);
            if (operator == null) {
                throw `Expected operator to be defined in context!`;
            }
            return operator;
        }
        getOrder(reference) {
            let order = this.orders.get(reference);
            if (order == null) {
                throw `Expected order to be defined in context!`;
            }
            return order;
        }
        createFile(path) {
            let bin = new files_1.PhysicalFile(`${path}.bin`);
            let log = new files_1.PhysicalFile(`${path}.log`);
            let file = new files_1.DurableFile(new files_1.PagedFile(bin, bin.hint().pageSizeLog2, 16384), new files_1.PagedFile(log, log.hint().pageSizeLog2, 16384));
            return file;
        }
        constructor() {
            this.fields = new Map();
            this.links = new Map();
            this.stores = new Map();
            this.queries = new Map();
            this.operators = new Map();
            this.orders = new Map();
            this.databaseManagers = new Map();
        }
        createBigIntField() {
            let reference = new FieldReference();
            let field = new records_1.BigIntField(0n);
            this.fields.set(reference, field);
            return reference;
        }
        createNullableBigIntField() {
            let reference = new FieldReference();
            let field = new records_1.NullableBigIntField(null);
            this.fields.set(reference, field);
            return reference;
        }
        createBinaryField() {
            let reference = new FieldReference();
            let field = new records_1.BinaryField(Uint8Array.of());
            this.fields.set(reference, field);
            return reference;
        }
        createNullableBinaryField() {
            let reference = new FieldReference();
            let field = new records_1.NullableBinaryField(null);
            this.fields.set(reference, field);
            return reference;
        }
        createBooleanField() {
            let reference = new FieldReference();
            let field = new records_1.BooleanField(false);
            this.fields.set(reference, field);
            return reference;
        }
        createNullableBooleanField() {
            let reference = new FieldReference();
            let field = new records_1.NullableBooleanField(null);
            this.fields.set(reference, field);
            return reference;
        }
        createIntegerField() {
            let reference = new FieldReference();
            let field = new records_1.IntegerField(0);
            this.fields.set(reference, field);
            return reference;
        }
        createNullableIntegerField() {
            let reference = new FieldReference();
            let field = new records_1.NullableIntegerField(null);
            this.fields.set(reference, field);
            return reference;
        }
        createNumberField() {
            let reference = new FieldReference();
            let field = new records_1.NumberField(0);
            this.fields.set(reference, field);
            return reference;
        }
        createNullableNumberField() {
            let reference = new FieldReference();
            let field = new records_1.NullableNumberField(null);
            this.fields.set(reference, field);
            return reference;
        }
        createStringField() {
            let reference = new FieldReference();
            let field = new records_1.StringField("");
            this.fields.set(reference, field);
            return reference;
        }
        createNullableStringField() {
            let reference = new FieldReference();
            let field = new records_1.NullableStringField(null);
            this.fields.set(reference, field);
            return reference;
        }
        createLink(parent, child, recordKeysMap, orderReferences) {
            let reference = new LinkReference();
            let orders = {};
            for (let key in orderReferences) {
                let orderReference = orderReferences[key];
                if (orderReference == null) {
                    continue;
                }
                orders[key] = this.getOrder(orderReference);
            }
            let link = new links_1.Link(this.getStore(parent), this.getStore(child), recordKeysMap, orders);
            this.links.set(reference, link);
            return reference;
        }
        createStore(fieldReferences, keys, orderReferences) {
            orderReferences = orderReferences ?? {};
            let fields = {};
            for (let key in fieldReferences) {
                fields[key] = this.getField(fieldReferences[key]);
            }
            let orders = {};
            for (let key in orderReferences) {
                orders[key] = this.getOrder(orderReferences[key]);
            }
            let reference = new StoreReference();
            let store = new stores_1.Store(fields, keys, orders);
            this.stores.set(reference, store);
            return reference;
        }
        createQuery(storeReference, operatorReferences, orderReferences) {
            orderReferences = orderReferences ?? {};
            let store = this.getStore(storeReference);
            let operators = {};
            for (let key in operatorReferences) {
                operators[key] = this.getOperator(operatorReferences[key]);
            }
            let orders = {};
            for (let key in orderReferences) {
                orders[key] = this.getOrder(orderReferences[key]);
            }
            let reference = new QueryReference();
            let query = new queries_1.Query(store, operators, orders);
            this.queries.set(reference, query);
            return reference;
        }
        createEqualityOperator() {
            let reference = new OperatorReference();
            let operator = new operators_1.EqualityOperator();
            this.operators.set(reference, operator);
            return reference;
        }
        createDecreasingOrder() {
            let reference = new OrderReference();
            let order = new orders_1.DecreasingOrder();
            this.orders.set(reference, order);
            return reference;
        }
        createIncreasingOrder() {
            let reference = new OrderReference();
            let order = new orders_1.IncreasingOrder();
            this.orders.set(reference, order);
            return reference;
        }
        createTransactionManager(path, storeReferences, linkReferences, queryReferences) {
            if (this.databaseManagers.has(path)) {
                throw `Expected given storage to not be in use by another database!`;
            }
            let file = this.createFile(path);
            let stores = {};
            for (let key in storeReferences) {
                stores[key] = this.getStore(storeReferences[key]);
            }
            let links = {};
            for (let key in linkReferences) {
                links[key] = this.getLink(linkReferences[key]);
            }
            let queries = {};
            for (let key in queryReferences) {
                queries[key] = this.getQuery(queryReferences[key]);
            }
            let schemaManager = new schemas_1.SchemaManager();
            let database = new databases_1.Database(stores, links, queries);
            let databaseManager = schemaManager.createDatabaseManager(file, database);
            this.databaseManagers.set(path, databaseManager);
            let transactionManager = databaseManager.createTransactionManager(file);
            return {
                transactionManager
            };
        }
    }
    exports.Context = Context;
    ;
});
define("node_modules/@joelek/atlas/dist/lib/index", ["require", "exports", "node_modules/@joelek/atlas/dist/lib/contexts", "node_modules/@joelek/atlas/dist/lib/orders", "node_modules/@joelek/atlas/dist/lib/filters"], function (require, exports, contexts_1, orders_1, filters_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEqualityFilter = exports.createDecreasingOrder = exports.createIncreasingOrder = exports.createContext = void 0;
    function createContext() {
        return new contexts_1.Context();
    }
    exports.createContext = createContext;
    ;
    function createIncreasingOrder() {
        return new orders_1.IncreasingOrder();
    }
    exports.createIncreasingOrder = createIncreasingOrder;
    ;
    function createDecreasingOrder() {
        return new orders_1.DecreasingOrder();
    }
    exports.createDecreasingOrder = createDecreasingOrder;
    ;
    function createEqualityFilter(value) {
        return new filters_1.EqualityFilter(value);
    }
    exports.createEqualityFilter = createEqualityFilter;
    ;
});
define("build/database/atlas", ["require", "exports", "node_modules/@joelek/atlas/dist/lib/index"], function (require, exports, atlas) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createStream = exports.adjustAffinity = exports.computeAffinity = exports.queries = exports.links = exports.stores = exports.transactionManager = void 0;
    const context = atlas.createContext();
    const directories = context.createStore({
        directory_id: context.createBinaryField(),
        name: context.createStringField(),
        parent_directory_id: context.createNullableBinaryField()
    }, ["directory_id"], {});
    const files = context.createStore({
        file_id: context.createBinaryField(),
        name: context.createStringField(),
        parent_directory_id: context.createNullableBinaryField(),
        index_timestamp: context.createNullableIntegerField(),
        size: context.createIntegerField()
    }, ["file_id"], {});
    const audio_files = context.createStore({
        file_id: context.createBinaryField(),
        mime: context.createStringField(),
        duration_ms: context.createIntegerField()
    }, ["file_id"], {});
    const image_files = context.createStore({
        file_id: context.createBinaryField(),
        mime: context.createStringField(),
        width: context.createIntegerField(),
        height: context.createIntegerField()
    }, ["file_id"], {});
    const metadata_files = context.createStore({
        file_id: context.createBinaryField(),
        mime: context.createStringField() // "application/json"
    }, ["file_id"], {});
    const subtitle_files = context.createStore({
        file_id: context.createBinaryField(),
        mime: context.createStringField(),
        duration_ms: context.createIntegerField(),
        language: context.createNullableStringField()
    }, ["file_id"], {});
    const video_files = context.createStore({
        file_id: context.createBinaryField(),
        mime: context.createStringField(),
        duration_ms: context.createIntegerField(),
        width: context.createIntegerField(),
        height: context.createIntegerField()
    }, ["file_id"], {});
    const video_subtitles = context.createStore({
        video_file_id: context.createBinaryField(),
        subtitle_file_id: context.createBinaryField()
    }, ["video_file_id", "subtitle_file_id"], {});
    const artists = context.createStore({
        artist_id: context.createBinaryField(),
        name: context.createStringField(),
        affinity: context.createNumberField()
    }, ["artist_id"], {
        name: context.createIncreasingOrder()
    });
    const albums = context.createStore({
        album_id: context.createBinaryField(),
        title: context.createStringField(),
        year_id: context.createNullableBinaryField(),
        timestamp_ms: context.createNullableIntegerField(),
        affinity: context.createNumberField()
    }, ["album_id"], {
        title: context.createIncreasingOrder()
    });
    const album_files = context.createStore({
        album_id: context.createBinaryField(),
        file_id: context.createBinaryField()
    }, ["album_id", "file_id"], {});
    const discs = context.createStore({
        disc_id: context.createBinaryField(),
        album_id: context.createBinaryField(),
        number: context.createIntegerField(),
        timestamp_ms: context.createNullableIntegerField(),
        affinity: context.createNumberField()
    }, ["disc_id"], {});
    const tracks = context.createStore({
        track_id: context.createBinaryField(),
        disc_id: context.createBinaryField(),
        title: context.createStringField(),
        number: context.createIntegerField(),
        copyright: context.createNullableStringField(),
        timestamp_ms: context.createNullableIntegerField(),
        affinity: context.createNumberField()
    }, ["track_id"], {
        title: context.createIncreasingOrder()
    });
    const track_files = context.createStore({
        track_id: context.createBinaryField(),
        file_id: context.createBinaryField()
    }, ["track_id", "file_id"], {});
    const album_artists = context.createStore({
        album_id: context.createBinaryField(),
        artist_id: context.createBinaryField(),
        order: context.createIntegerField()
    }, ["album_id", "artist_id"], {});
    const track_artists = context.createStore({
        track_id: context.createBinaryField(),
        artist_id: context.createBinaryField(),
        order: context.createIntegerField()
    }, ["track_id", "artist_id"], {});
    const shows = context.createStore({
        show_id: context.createBinaryField(),
        name: context.createStringField(),
        summary: context.createNullableStringField(),
        imdb: context.createNullableStringField(),
        timestamp_ms: context.createNullableIntegerField(),
        affinity: context.createNumberField()
    }, ["show_id"], {
        name: context.createIncreasingOrder()
    });
    const show_files = context.createStore({
        show_id: context.createBinaryField(),
        file_id: context.createBinaryField()
    }, ["show_id", "file_id"], {});
    const seasons = context.createStore({
        season_id: context.createBinaryField(),
        show_id: context.createBinaryField(),
        number: context.createIntegerField(),
        timestamp_ms: context.createNullableIntegerField(),
        affinity: context.createNumberField()
    }, ["season_id"], {});
    const episodes = context.createStore({
        episode_id: context.createBinaryField(),
        season_id: context.createBinaryField(),
        title: context.createStringField(),
        number: context.createIntegerField(),
        year_id: context.createNullableBinaryField(),
        summary: context.createNullableStringField(),
        copyright: context.createNullableStringField(),
        imdb: context.createNullableStringField(),
        timestamp_ms: context.createNullableIntegerField(),
        affinity: context.createNumberField()
    }, ["episode_id"], {
        title: context.createIncreasingOrder()
    });
    const episode_files = context.createStore({
        episode_id: context.createBinaryField(),
        file_id: context.createBinaryField()
    }, ["episode_id", "file_id"], {});
    const movies = context.createStore({
        movie_id: context.createBinaryField(),
        title: context.createStringField(),
        year_id: context.createNullableBinaryField(),
        summary: context.createNullableStringField(),
        copyright: context.createNullableStringField(),
        imdb: context.createNullableStringField(),
        timestamp_ms: context.createNullableIntegerField(),
        affinity: context.createNumberField()
    }, ["movie_id"], {
        title: context.createIncreasingOrder()
    });
    const movie_files = context.createStore({
        movie_id: context.createBinaryField(),
        file_id: context.createBinaryField()
    }, ["movie_id", "file_id"], {});
    const actors = context.createStore({
        actor_id: context.createBinaryField(),
        name: context.createStringField(),
        affinity: context.createNumberField()
    }, ["actor_id"], {
        name: context.createIncreasingOrder()
    });
    const movie_actors = context.createStore({
        movie_id: context.createBinaryField(),
        actor_id: context.createBinaryField(),
        order: context.createIntegerField()
    }, ["movie_id", "actor_id"], {});
    const show_actors = context.createStore({
        show_id: context.createBinaryField(),
        actor_id: context.createBinaryField(),
        order: context.createIntegerField()
    }, ["show_id", "actor_id"], {});
    const genres = context.createStore({
        genre_id: context.createBinaryField(),
        name: context.createStringField(),
        affinity: context.createNumberField()
    }, ["genre_id"], {
        name: context.createIncreasingOrder()
    });
    const movie_genres = context.createStore({
        movie_id: context.createBinaryField(),
        genre_id: context.createBinaryField(),
        order: context.createIntegerField()
    }, ["movie_id", "genre_id"], {});
    const show_genres = context.createStore({
        show_id: context.createBinaryField(),
        genre_id: context.createBinaryField(),
        order: context.createIntegerField()
    }, ["show_id", "genre_id"], {});
    const subtitles = context.createStore({
        subtitle_id: context.createBinaryField(),
        file_id: context.createBinaryField()
    }, ["subtitle_id"], {});
    const cues = context.createStore({
        cue_id: context.createBinaryField(),
        subtitle_id: context.createBinaryField(),
        start_ms: context.createIntegerField(),
        duration_ms: context.createIntegerField(),
        lines: context.createStringField()
    }, ["cue_id"], {});
    const users = context.createStore({
        user_id: context.createBinaryField(),
        name: context.createStringField(),
        username: context.createStringField(),
        password: context.createStringField()
    }, ["user_id"], {
        name: context.createIncreasingOrder()
    });
    const keys = context.createStore({
        key_id: context.createBinaryField(),
        user_id: context.createNullableBinaryField()
    }, ["key_id"], {});
    const tokens = context.createStore({
        token_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        hash: context.createBinaryField(),
        expires_ms: context.createIntegerField()
    }, ["token_id"], {});
    const streams = context.createStore({
        stream_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        file_id: context.createBinaryField(),
        timestamp_ms: context.createIntegerField()
    }, ["stream_id"], {});
    const playlists = context.createStore({
        playlist_id: context.createBinaryField(),
        title: context.createStringField(),
        description: context.createStringField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["playlist_id"], {
        title: context.createIncreasingOrder()
    });
    const playlist_items = context.createStore({
        playlist_item_id: context.createBinaryField(),
        playlist_id: context.createBinaryField(),
        track_id: context.createBinaryField(),
        number: context.createIntegerField(),
        added_ms: context.createIntegerField()
    }, ["playlist_item_id"], {});
    const years = context.createStore({
        year_id: context.createBinaryField(),
        year: context.createIntegerField(),
        affinity: context.createNumberField()
    }, ["year_id"], {
        year: context.createIncreasingOrder()
    });
    const artist_affinities = context.createStore({
        artist_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "artist_id"], {});
    const actor_affinities = context.createStore({
        actor_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "actor_id"], {});
    const genre_affinities = context.createStore({
        genre_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "genre_id"], {});
    const playlist_affinities = context.createStore({
        playlist_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "playlist_id"], {});
    const year_affinities = context.createStore({
        year_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "year_id"], {});
    const track_affinities = context.createStore({
        track_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "track_id"], {});
    const disc_affinities = context.createStore({
        disc_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "disc_id"], {});
    const album_affinities = context.createStore({
        album_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "album_id"], {});
    const movie_affinities = context.createStore({
        movie_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "movie_id"], {});
    const episode_affinities = context.createStore({
        episode_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "episode_id"], {});
    const season_affinities = context.createStore({
        season_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "season_id"], {});
    const show_affinities = context.createStore({
        show_id: context.createBinaryField(),
        user_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["user_id", "show_id"], {});
    const movie_suggestions = context.createStore({
        movie_id: context.createBinaryField(),
        suggested_movie_id: context.createBinaryField(),
        affinity: context.createNumberField()
    }, ["movie_id", "suggested_movie_id"], {});
    const movie_movie_suggestions = context.createLink(movies, movie_suggestions, {
        movie_id: "movie_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const movie_movie_suggestions_two = context.createLink(movies, movie_suggestions, {
        movie_id: "suggested_movie_id"
    }, {});
    const track_track_affinities = context.createLink(tracks, track_affinities, {
        track_id: "track_id"
    }, {});
    const user_track_affinities = context.createLink(users, track_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const disc_disc_affinities = context.createLink(discs, disc_affinities, {
        disc_id: "disc_id"
    }, {});
    const user_disc_affinities = context.createLink(users, disc_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const album_album_affinities = context.createLink(albums, album_affinities, {
        album_id: "album_id"
    }, {});
    const user_album_affinities = context.createLink(users, album_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const movie_movie_affinities = context.createLink(movies, movie_affinities, {
        movie_id: "movie_id"
    }, {});
    const user_movie_affinities = context.createLink(users, movie_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const episode_episode_affinities = context.createLink(episodes, episode_affinities, {
        episode_id: "episode_id"
    }, {});
    const user_episode_affinities = context.createLink(users, episode_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const season_season_affinities = context.createLink(seasons, season_affinities, {
        season_id: "season_id"
    }, {});
    const user_season_affinities = context.createLink(users, season_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const show_show_affinities = context.createLink(shows, show_affinities, {
        show_id: "show_id"
    }, {});
    const user_show_affinities = context.createLink(users, show_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const artist_artist_affinities = context.createLink(artists, artist_affinities, {
        artist_id: "artist_id"
    }, {});
    const user_artist_affinities = context.createLink(users, artist_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const genre_genre_affinities = context.createLink(genres, genre_affinities, {
        genre_id: "genre_id"
    }, {});
    const user_genre_affinities = context.createLink(users, genre_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const actor_actor_affinities = context.createLink(actors, actor_affinities, {
        actor_id: "actor_id"
    }, {});
    const user_actor_affinities = context.createLink(users, actor_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const playlist_playlist_affinities = context.createLink(playlists, playlist_affinities, {
        playlist_id: "playlist_id"
    }, {});
    const user_playlist_affinities = context.createLink(users, playlist_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const year_year_affinities = context.createLink(years, year_affinities, {
        year_id: "year_id"
    }, {});
    const user_year_affinities = context.createLink(users, year_affinities, {
        user_id: "user_id"
    }, {
        affinity: context.createDecreasingOrder()
    });
    const directory_directories = context.createLink(directories, directories, {
        directory_id: "parent_directory_id"
    }, {});
    const directory_files = context.createLink(directories, files, {
        directory_id: "parent_directory_id"
    }, {});
    const file_audio_files = context.createLink(files, audio_files, {
        file_id: "file_id"
    }, {});
    const file_image_files = context.createLink(files, image_files, {
        file_id: "file_id"
    }, {});
    const file_metadata_files = context.createLink(files, metadata_files, {
        file_id: "file_id"
    }, {});
    const file_subtitle_files = context.createLink(files, subtitle_files, {
        file_id: "file_id"
    }, {});
    const file_video_files = context.createLink(files, video_files, {
        file_id: "file_id"
    }, {});
    const video_file_video_subtitles = context.createLink(video_files, video_subtitles, {
        file_id: "video_file_id"
    }, {});
    const subtitle_file_video_subtitles = context.createLink(subtitle_files, video_subtitles, {
        file_id: "subtitle_file_id"
    }, {});
    const file_album_files = context.createLink(files, album_files, {
        file_id: "file_id"
    }, {});
    const album_album_files = context.createLink(albums, album_files, {
        album_id: "album_id"
    }, {});
    const album_discs = context.createLink(albums, discs, {
        album_id: "album_id"
    }, {
        number: context.createIncreasingOrder()
    });
    const disc_tracks = context.createLink(discs, tracks, {
        disc_id: "disc_id"
    }, {
        number: context.createIncreasingOrder()
    });
    const file_track_files = context.createLink(files, track_files, {
        file_id: "file_id"
    }, {});
    const track_track_files = context.createLink(tracks, track_files, {
        track_id: "track_id"
    }, {});
    const album_album_artists = context.createLink(albums, album_artists, {
        album_id: "album_id"
    }, {
        order: context.createIncreasingOrder()
    });
    const artist_album_artists = context.createLink(artists, album_artists, {
        artist_id: "artist_id"
    }, {});
    const track_track_artists = context.createLink(tracks, track_artists, {
        track_id: "track_id"
    }, {
        order: context.createIncreasingOrder()
    });
    const artist_track_artists = context.createLink(artists, track_artists, {
        artist_id: "artist_id"
    }, {});
    const file_show_files = context.createLink(files, show_files, {
        file_id: "file_id"
    }, {});
    const show_show_files = context.createLink(shows, show_files, {
        show_id: "show_id"
    }, {});
    const show_seasons = context.createLink(shows, seasons, {
        show_id: "show_id"
    }, {
        number: context.createIncreasingOrder()
    });
    const season_episodes = context.createLink(seasons, episodes, {
        season_id: "season_id"
    }, {
        number: context.createIncreasingOrder()
    });
    const file_episode_files = context.createLink(files, episode_files, {
        file_id: "file_id"
    }, {});
    const episode_episode_files = context.createLink(episodes, episode_files, {
        episode_id: "episode_id"
    }, {});
    const file_movie_files = context.createLink(files, movie_files, {
        file_id: "file_id"
    }, {});
    const movie_movie_files = context.createLink(movies, movie_files, {
        movie_id: "movie_id"
    }, {});
    const actor_movie_actors = context.createLink(actors, movie_actors, {
        actor_id: "actor_id"
    }, {});
    const movie_movie_actors = context.createLink(movies, movie_actors, {
        movie_id: "movie_id"
    }, {
        order: context.createIncreasingOrder()
    });
    const actor_show_actors = context.createLink(actors, show_actors, {
        actor_id: "actor_id"
    }, {});
    const show_show_actors = context.createLink(shows, show_actors, {
        show_id: "show_id"
    }, {
        order: context.createIncreasingOrder()
    });
    const genre_movie_genres = context.createLink(genres, movie_genres, {
        genre_id: "genre_id"
    }, {});
    const movie_movie_genres = context.createLink(movies, movie_genres, {
        movie_id: "movie_id"
    }, {
        order: context.createIncreasingOrder()
    });
    const genre_show_genres = context.createLink(genres, show_genres, {
        genre_id: "genre_id"
    }, {});
    const show_show_genres = context.createLink(shows, show_genres, {
        show_id: "show_id"
    }, {
        order: context.createIncreasingOrder()
    });
    const subtitle_cues = context.createLink(subtitles, cues, {
        subtitle_id: "subtitle_id"
    }, {
        start_ms: context.createIncreasingOrder()
    });
    const user_keys = context.createLink(users, keys, {
        user_id: "user_id"
    }, {});
    const user_tokens = context.createLink(users, tokens, {
        user_id: "user_id"
    }, {});
    const user_streams = context.createLink(users, streams, {
        user_id: "user_id"
    }, {
        timestamp_ms: context.createDecreasingOrder()
    });
    const file_streams = context.createLink(files, streams, {
        file_id: "file_id"
    }, {
        timestamp_ms: context.createDecreasingOrder()
    });
    const user_playlists = context.createLink(users, playlists, {
        user_id: "user_id"
    }, {
        title: context.createIncreasingOrder()
    });
    const playlist_playlist_items = context.createLink(playlists, playlist_items, {
        playlist_id: "playlist_id"
    }, {
        number: context.createIncreasingOrder()
    });
    const track_playlist_items = context.createLink(tracks, playlist_items, {
        track_id: "track_id"
    }, {});
    const year_movies = context.createLink(years, movies, {
        year_id: "year_id"
    }, {
        title: context.createIncreasingOrder()
    });
    const year_albums = context.createLink(years, albums, {
        year_id: "year_id"
    }, {
        title: context.createIncreasingOrder()
    });
    const year_episodes = context.createLink(years, episodes, {
        year_id: "year_id"
    }, {
        title: context.createIncreasingOrder()
    });
    const getStreamsFromUserIdAndFileId = context.createQuery(streams, {
        file_id: context.createEqualityOperator(),
        user_id: context.createEqualityOperator()
    }, {
        timestamp_ms: context.createDecreasingOrder()
    });
    const getUsersFromUsername = context.createQuery(users, {
        username: context.createEqualityOperator()
    }, {});
    const getRecentlyUpdatedAlbums = context.createQuery(albums, {}, {
        timestamp_ms: context.createDecreasingOrder()
    });
    const getRecentlyUpdatedDiscs = context.createQuery(discs, {}, {
        timestamp_ms: context.createDecreasingOrder()
    });
    const getRecentlyUpdatedTracks = context.createQuery(tracks, {}, {
        timestamp_ms: context.createDecreasingOrder()
    });
    const getRecentlyUpdatedMovies = context.createQuery(movies, {}, {
        timestamp_ms: context.createDecreasingOrder()
    });
    const getRecentlyUpdatedShows = context.createQuery(shows, {}, {
        timestamp_ms: context.createDecreasingOrder()
    });
    const getRecentlyUpdatedSeasons = context.createQuery(seasons, {}, {
        timestamp_ms: context.createDecreasingOrder()
    });
    const getRecentlyUpdatedEpisodes = context.createQuery(episodes, {}, {
        timestamp_ms: context.createDecreasingOrder()
    });
    exports.transactionManager = context.createTransactionManager("./private/db/", {
        directories,
        files,
        audio_files,
        image_files,
        metadata_files,
        subtitle_files,
        video_files,
        video_subtitles,
        artists,
        albums,
        album_files,
        discs,
        tracks,
        track_files,
        album_artists,
        track_artists,
        shows,
        show_files,
        seasons,
        episodes,
        episode_files,
        movies,
        movie_files,
        actors,
        movie_actors,
        show_actors,
        genres,
        movie_genres,
        show_genres,
        subtitles,
        cues,
        users,
        keys,
        tokens,
        streams,
        playlists,
        playlist_items,
        years,
        track_affinities,
        disc_affinities,
        album_affinities,
        movie_affinities,
        episode_affinities,
        season_affinities,
        show_affinities,
        artist_affinities,
        actor_affinities,
        genre_affinities,
        playlist_affinities,
        year_affinities,
        movie_suggestions
    }, {
        directory_directories,
        directory_files,
        file_audio_files,
        file_image_files,
        file_metadata_files,
        file_subtitle_files,
        file_video_files,
        video_file_video_subtitles,
        subtitle_file_video_subtitles,
        file_album_files,
        album_album_files,
        album_discs,
        disc_tracks,
        file_track_files,
        track_track_files,
        album_album_artists,
        artist_album_artists,
        track_track_artists,
        artist_track_artists,
        file_show_files,
        show_show_files,
        show_seasons,
        season_episodes,
        file_episode_files,
        episode_episode_files,
        file_movie_files,
        movie_movie_files,
        actor_movie_actors,
        movie_movie_actors,
        actor_show_actors,
        show_show_actors,
        genre_movie_genres,
        movie_movie_genres,
        genre_show_genres,
        show_show_genres,
        subtitle_cues,
        user_keys,
        user_tokens,
        user_streams,
        file_streams,
        user_playlists,
        playlist_playlist_items,
        track_playlist_items,
        year_movies,
        year_episodes,
        year_albums,
        user_track_affinities,
        track_track_affinities,
        user_disc_affinities,
        disc_disc_affinities,
        user_album_affinities,
        album_album_affinities,
        user_movie_affinities,
        movie_movie_affinities,
        user_episode_affinities,
        episode_episode_affinities,
        user_season_affinities,
        season_season_affinities,
        user_show_affinities,
        show_show_affinities,
        user_artist_affinities,
        artist_artist_affinities,
        user_actor_affinities,
        actor_actor_affinities,
        user_genre_affinities,
        genre_genre_affinities,
        user_playlist_affinities,
        playlist_playlist_affinities,
        user_year_affinities,
        year_year_affinities,
        movie_movie_suggestions,
        movie_movie_suggestions_two
    }, {
        getUsersFromUsername,
        getStreamsFromUserIdAndFileId,
        getRecentlyUpdatedAlbums,
        getRecentlyUpdatedDiscs,
        getRecentlyUpdatedTracks,
        getRecentlyUpdatedMovies,
        getRecentlyUpdatedShows,
        getRecentlyUpdatedSeasons,
        getRecentlyUpdatedEpisodes
    }).transactionManager;
    exports.stores = exports.transactionManager.createTransactionalStores();
    exports.links = exports.transactionManager.createTransactionalLinks();
    exports.queries = exports.transactionManager.createTransactionalQueries();
    // Double precision can store positive values between 2^-1022 (inclusive) and 2^1024 (exclusive).
    function computeAffinity(timestamp_ms) {
        let time_base_ms = (1000 * 60 * 60 * 24 * 7 * 2);
        let epoch_start_ms = new Date("2000-01-01T00:00:00Z").valueOf();
        let epoch_length_ms = (1024 + 1022) * time_base_ms;
        let time_bias_ms = epoch_start_ms + epoch_length_ms * 0.5;
        let time_delta_ms = timestamp_ms - time_bias_ms;
        return Math.pow(2.0, time_delta_ms / time_base_ms);
    }
    exports.computeAffinity = computeAffinity;
    ;
    function adjustAffinity(affinity) {
        let time_base_ms = (1000 * 60 * 60 * 24 * 7 * 2);
        let epoch_start_ms = new Date("2000-01-01T00:00:00Z").valueOf();
        let epoch_length_ms = (1024 + 1022) * time_base_ms;
        let time_bias_ms = epoch_start_ms + epoch_length_ms * 0.5;
        let time_delta_ms = Math.log2(affinity) * time_base_ms;
        let timestamp_ms = time_delta_ms + time_bias_ms;
        let adjusted_time_delta_ms = timestamp_ms - Date.now();
        return Math.pow(2.0, adjusted_time_delta_ms / time_base_ms);
    }
    exports.adjustAffinity = adjustAffinity;
    ;
    async function createTrackStream(queue, stream) {
        let affinity = computeAffinity(stream.timestamp_ms);
        let track_files = await exports.links.file_track_files.filter(queue, stream);
        if (track_files.length === 0) {
            throw ``;
        }
        for (let track_file of track_files) {
            let track = await exports.stores.tracks.lookup(queue, track_file);
            await exports.stores.tracks.insert(queue, {
                ...track,
                affinity: track.affinity + affinity
            });
            let track_affinity = {
                ...track,
                ...stream,
                affinity
            };
            try {
                track_affinity.affinity += (await exports.stores.track_affinities.lookup(queue, track_affinity)).affinity;
            }
            catch (error) { }
            await exports.stores.track_affinities.insert(queue, track_affinity);
            let disc = await exports.stores.discs.lookup(queue, track);
            await exports.stores.discs.insert(queue, {
                ...disc,
                affinity: disc.affinity + affinity
            });
            let disc_affinity = {
                ...disc,
                ...stream,
                affinity
            };
            try {
                disc_affinity.affinity += (await exports.stores.disc_affinities.lookup(queue, disc_affinity)).affinity;
            }
            catch (error) { }
            await exports.stores.disc_affinities.insert(queue, disc_affinity);
            let album = await exports.stores.albums.lookup(queue, disc);
            await exports.stores.albums.insert(queue, {
                ...album,
                affinity: album.affinity + affinity
            });
            let album_affinity = {
                ...album,
                ...stream,
                affinity
            };
            try {
                album_affinity.affinity += (await exports.stores.album_affinities.lookup(queue, album_affinity)).affinity;
            }
            catch (error) { }
            await exports.stores.album_affinities.insert(queue, album_affinity);
            if (album.year_id != null) {
                let year = await exports.stores.years.lookup(queue, { year_id: album.year_id });
                await exports.stores.years.insert(queue, {
                    ...year,
                    affinity: year.affinity + affinity
                });
                let year_affinity = {
                    ...year,
                    ...stream,
                    affinity
                };
                try {
                    year_affinity.affinity += (await exports.stores.year_affinities.lookup(queue, year_affinity)).affinity;
                }
                catch (error) { }
                await exports.stores.year_affinities.insert(queue, year_affinity);
            }
            let track_artists = await exports.links.track_track_artists.filter(queue, track);
            for (let track_artist of track_artists) {
                let artist = await exports.stores.artists.lookup(queue, track_artist);
                await exports.stores.artists.insert(queue, {
                    ...artist,
                    affinity: artist.affinity + affinity
                });
                let artist_affinity = {
                    ...artist,
                    ...stream,
                    affinity
                };
                try {
                    artist_affinity.affinity += (await exports.stores.artist_affinities.lookup(queue, artist_affinity)).affinity;
                }
                catch (error) { }
                await exports.stores.artist_affinities.insert(queue, artist_affinity);
            }
            let album_artists = await exports.links.album_album_artists.filter(queue, album);
            for (let album_artist of album_artists) {
                let artist = await exports.stores.artists.lookup(queue, album_artist);
                await exports.stores.artists.insert(queue, {
                    ...artist,
                    affinity: artist.affinity + affinity
                });
                let artist_affinity = {
                    ...artist,
                    ...stream,
                    affinity
                };
                try {
                    artist_affinity.affinity += (await exports.stores.artist_affinities.lookup(queue, artist_affinity)).affinity;
                }
                catch (error) { }
                await exports.stores.artist_affinities.insert(queue, artist_affinity);
            }
            let playlist_items = await exports.links.track_playlist_items.filter(queue, track);
            for (let playlist_item of playlist_items) {
                let playlist = await exports.stores.playlists.lookup(queue, playlist_item);
                await exports.stores.playlists.insert(queue, {
                    ...playlist,
                    affinity: playlist.affinity + affinity
                });
                let playlist_affinity = {
                    ...playlist,
                    ...stream,
                    affinity
                };
                try {
                    playlist_affinity.affinity += (await exports.stores.playlist_affinities.lookup(queue, playlist_affinity)).affinity;
                }
                catch (error) { }
                await exports.stores.playlist_affinities.insert(queue, playlist_affinity);
            }
        }
    }
    ;
    async function createMovieStream(queue, stream) {
        let affinity = computeAffinity(stream.timestamp_ms);
        let movie_files = await exports.links.file_movie_files.filter(queue, stream);
        if (movie_files.length === 0) {
            throw ``;
        }
        for (let movie_file of movie_files) {
            let movie = await exports.stores.movies.lookup(queue, movie_file);
            await exports.stores.movies.insert(queue, {
                ...movie,
                affinity: movie.affinity + affinity
            });
            let movie_affinity = {
                ...movie,
                ...stream,
                affinity
            };
            try {
                movie_affinity.affinity += (await exports.stores.movie_affinities.lookup(queue, movie_affinity)).affinity;
            }
            catch (error) { }
            await exports.stores.movie_affinities.insert(queue, movie_affinity);
            if (movie.year_id != null) {
                let year = await exports.stores.years.lookup(queue, { year_id: movie.year_id });
                await exports.stores.years.insert(queue, {
                    ...year,
                    affinity: year.affinity + affinity
                });
                let year_affinity = {
                    ...year,
                    ...stream,
                    affinity
                };
                try {
                    year_affinity.affinity += (await exports.stores.year_affinities.lookup(queue, year_affinity)).affinity;
                }
                catch (error) { }
                await exports.stores.year_affinities.insert(queue, year_affinity);
            }
            let movie_actors = await exports.links.movie_movie_actors.filter(queue, movie);
            for (let movie_actor of movie_actors) {
                let actor = await exports.stores.actors.lookup(queue, movie_actor);
                await exports.stores.actors.insert(queue, {
                    ...actor,
                    affinity: actor.affinity + affinity
                });
                let actor_affinity = {
                    ...actor,
                    ...stream,
                    affinity
                };
                try {
                    actor_affinity.affinity += (await exports.stores.actor_affinities.lookup(queue, actor_affinity)).affinity;
                }
                catch (error) { }
                await exports.stores.actor_affinities.insert(queue, actor_affinity);
            }
            let movie_genres = await exports.links.movie_movie_genres.filter(queue, movie);
            for (let movie_genre of movie_genres) {
                let genre = await exports.stores.genres.lookup(queue, movie_genre);
                await exports.stores.genres.insert(queue, {
                    ...genre,
                    affinity: genre.affinity + affinity
                });
                let genre_affinity = {
                    ...genre,
                    ...stream,
                    affinity
                };
                try {
                    genre_affinity.affinity += (await exports.stores.genre_affinities.lookup(queue, genre_affinity)).affinity;
                }
                catch (error) { }
                await exports.stores.genre_affinities.insert(queue, genre_affinity);
            }
        }
    }
    ;
    async function createEpisodeStream(queue, stream) {
        let affinity = computeAffinity(stream.timestamp_ms);
        let episode_files = await exports.links.file_episode_files.filter(queue, stream);
        if (episode_files.length === 0) {
            throw ``;
        }
        for (let episode_file of episode_files) {
            let episode = await exports.stores.episodes.lookup(queue, episode_file);
            await exports.stores.episodes.insert(queue, {
                ...episode,
                affinity: episode.affinity + affinity
            });
            let episode_affinity = {
                ...episode,
                ...stream,
                affinity
            };
            try {
                episode_affinity.affinity += (await exports.stores.episode_affinities.lookup(queue, episode_affinity)).affinity;
            }
            catch (error) { }
            await exports.stores.episode_affinities.insert(queue, episode_affinity);
            let season = await exports.stores.seasons.lookup(queue, episode);
            await exports.stores.seasons.insert(queue, {
                ...season,
                affinity: season.affinity + affinity
            });
            let season_affinity = {
                ...season,
                ...stream,
                affinity
            };
            try {
                season_affinity.affinity += (await exports.stores.season_affinities.lookup(queue, season_affinity)).affinity;
            }
            catch (error) { }
            await exports.stores.season_affinities.insert(queue, season_affinity);
            let show = await exports.stores.shows.lookup(queue, season);
            await exports.stores.shows.insert(queue, {
                ...show,
                affinity: show.affinity + affinity
            });
            let show_affinity = {
                ...show,
                ...stream,
                affinity
            };
            try {
                show_affinity.affinity += (await exports.stores.show_affinities.lookup(queue, show_affinity)).affinity;
            }
            catch (error) { }
            await exports.stores.show_affinities.insert(queue, show_affinity);
            if (episode.year_id != null) {
                let year = await exports.stores.years.lookup(queue, { year_id: episode.year_id });
                await exports.stores.years.insert(queue, {
                    ...year,
                    affinity: year.affinity + affinity
                });
                let year_affinity = {
                    ...year,
                    ...stream,
                    affinity
                };
                try {
                    year_affinity.affinity += (await exports.stores.year_affinities.lookup(queue, year_affinity)).affinity;
                }
                catch (error) { }
                await exports.stores.year_affinities.insert(queue, year_affinity);
            }
            let show_actors = await exports.links.show_show_actors.filter(queue, show);
            for (let show_actor of show_actors) {
                let actor = await exports.stores.actors.lookup(queue, show_actor);
                await exports.stores.actors.insert(queue, {
                    ...actor,
                    affinity: actor.affinity + affinity
                });
                let actor_affinity = {
                    ...actor,
                    ...stream,
                    affinity
                };
                try {
                    actor_affinity.affinity += (await exports.stores.actor_affinities.lookup(queue, actor_affinity)).affinity;
                }
                catch (error) { }
                await exports.stores.actor_affinities.insert(queue, actor_affinity);
            }
            let show_genres = await exports.links.show_show_genres.filter(queue, show);
            for (let show_genre of show_genres) {
                let genre = await exports.stores.genres.lookup(queue, show_genre);
                await exports.stores.genres.insert(queue, {
                    ...genre,
                    affinity: genre.affinity + affinity
                });
                let genre_affinity = {
                    ...genre,
                    ...stream,
                    affinity
                };
                try {
                    genre_affinity.affinity += (await exports.stores.genre_affinities.lookup(queue, genre_affinity)).affinity;
                }
                catch (error) { }
                await exports.stores.genre_affinities.insert(queue, genre_affinity);
            }
        }
    }
    ;
    async function createStream(queue, stream) {
        await exports.stores.streams.insert(queue, stream);
        try {
            await createTrackStream(queue, stream);
            return;
        }
        catch (error) { }
        try {
            await createMovieStream(queue, stream);
            return;
        }
        catch (error) { }
        try {
            await createEpisodeStream(queue, stream);
            return;
        }
        catch (error) { }
    }
    exports.createStream = createStream;
    ;
});
define("build/is", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.present = exports.absent = void 0;
    function absent(subject) {
        return subject == null;
    }
    exports.absent = absent;
    ;
    function present(subject) {
        return subject != null;
    }
    exports.present = present;
    ;
});
define("build/utils", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNextEpisode = exports.formatTimestamp = exports.join = exports.binid = exports.hexid = void 0;
    function hexid(buffer) {
        return Buffer.from(buffer).toString("hex");
    }
    exports.hexid = hexid;
    ;
    function binid(string) {
        return Uint8Array.from(Buffer.from(string, "hex"));
    }
    exports.binid = binid;
    ;
    function join(...parameters) {
        return parameters.map((parameter) => {
            return String(parameter);
        }).join("");
    }
    exports.join = join;
    function formatTimestamp(ms) {
        let s = Math.floor(ms / 1000);
        ms -= (s * 1000);
        let m = Math.floor(s / 60);
        s -= (m * 60);
        let h = Math.floor(m / 60);
        m -= (h * 60);
        let fh = join("00", h).slice(-2);
        let fm = join("00", m).slice(-2);
        let fs = join("00", s).slice(-2);
        let fms = join("000", ms).slice(-3);
        return join(fh, ":", fm, ":", fs, ".", fms);
    }
    exports.formatTimestamp = formatTimestamp;
    function getNextEpisode(show) {
        let indices;
        show.seasons.forEach((season, seasonIndex) => {
            season.episodes.forEach((episode, episodeIndex) => {
                if (is.present(episode.last_stream_date)) {
                    if (is.present(indices)) {
                        if (episode.last_stream_date < (show.seasons[indices.seasonIndex].episodes[indices.episodeIndex].last_stream_date ?? 0)) {
                            return;
                        }
                    }
                    indices = {
                        seasonIndex,
                        episodeIndex
                    };
                }
            });
        });
        if (is.present(indices)) {
            indices.episodeIndex += 1;
            if (indices.episodeIndex === show.seasons[indices.seasonIndex].episodes.length) {
                indices.episodeIndex = 0;
                indices.seasonIndex += 1;
                if (indices.seasonIndex === show.seasons.length) {
                    indices.seasonIndex = 0;
                }
            }
        }
        else {
            if (show.seasons.length > 0 && show.seasons[0].episodes.length > 0) {
                indices = {
                    seasonIndex: 0,
                    episodeIndex: 0
                };
            }
        }
        return indices;
    }
    exports.getNextEpisode = getNextEpisode;
});
define("build/server/auth", ["require", "exports", "crypto", "build/server/passwords", "build/database/atlas", "build/utils"], function (require, exports, libcrypto, passwords, atlas, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUserId = exports.createToken = void 0;
    // TODO: Move to handler.
    async function generate_token(queue, user_id) {
        let selector = libcrypto.randomBytes(8);
        let validator = libcrypto.randomBytes(8);
        let hash = libcrypto.createHash("sha256");
        hash.update(validator);
        let validator_hash = hash.digest();
        await atlas.stores.tokens.insert(queue, {
            token_id: Uint8Array.from(selector),
            user_id: (0, utils_1.binid)(user_id),
            hash: Uint8Array.from(validator_hash),
            expires_ms: Date.now() + (7 * 24 * 60 * 60 * 1000)
        });
        return `${selector.toString("hex")}${validator.toString("hex")}`;
    }
    ;
    async function createToken(queue, username, password) {
        let users = await atlas.queries.getUsersFromUsername.filter(queue, { username });
        let user = users.pop();
        if (!user) {
            throw 401;
        }
        if (!passwords.verify(password, user.password)) {
            throw 401;
        }
        return generate_token(queue, (0, utils_1.hexid)(user.user_id));
    }
    exports.createToken = createToken;
    ;
    async function getUserId(queue, chunk) {
        let parts = /^([0-9a-f]{16})([0-9a-f]{16})$/.exec(chunk);
        if (!parts) {
            throw 400;
        }
        let selector = parts[1];
        let validator = parts[2];
        let token = await atlas.stores.tokens.lookup(queue, { token_id: (0, utils_1.binid)(selector) });
        if (token.expires_ms < Date.now()) {
            throw 401;
        }
        let hash = libcrypto.createHash("sha256");
        hash.update(Buffer.from(validator, "hex"));
        let validator_hash = hash.digest();
        if (!libcrypto.timingSafeEqual(token.hash, validator_hash)) {
            throw 401;
        }
        return (0, utils_1.hexid)(token.user_id);
    }
    exports.getUserId = getUserId;
    ;
});
define("build/jsondb/sorters", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = void 0;
    exports.CombinedSort = {
        of(...rankers) {
            return (one, two) => {
                for (let ranker of rankers) {
                    let rank = ranker(one, two);
                    if (rank !== 0) {
                        return rank;
                    }
                }
                return 0;
            };
        }
    };
    exports.CustomSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return (t ? 1 : 0) - (o ? 1 : 0);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return (o ? 1 : 0) - (t ? 1 : 0);
            };
        }
    };
    exports.LexicalSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t.localeCompare(o);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o.localeCompare(t);
            };
        }
    };
    exports.NumericSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t - o;
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o - t;
            };
        }
    };
});
define("build/jsondb/indices", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/is", "build/jsondb/sorters"], function (require, exports, stdlib, is, sorters) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SearchIndex = exports.getTokens = exports.RecordIndex = exports.CollectionIndex = void 0;
    class CollectionIndex {
        getPrimaryKeysFromIndexedValue;
        lookupRecord;
        getPrimaryKey;
        getIndexedValue;
        constructor(lookupRecord, getPrimaryKey, getIndexedValue) {
            this.getPrimaryKeysFromIndexedValue = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValue = getIndexedValue;
        }
        insert(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.absent(primaryKeys)) {
                primaryKeys = new Set();
                this.getPrimaryKeysFromIndexedValue.set(indexedValue, primaryKeys);
            }
            let primaryKey = this.getPrimaryKey(record);
            primaryKeys.add(primaryKey);
        }
        lookup(key) {
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(key);
            if (is.present(primaryKeys)) {
                return Array.from(primaryKeys).map(this.lookupRecord);
            }
            return new Array();
        }
        remove(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.present(primaryKeys)) {
                let primaryKey = this.getPrimaryKey(record);
                primaryKeys.delete(primaryKey);
                if (primaryKeys.size === 0) {
                    this.getPrimaryKeysFromIndexedValue.delete(indexedValue);
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
        static fromTable(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
    }
    exports.CollectionIndex = CollectionIndex;
    ;
    class RecordIndex {
        getRecordFromKey;
        getKey;
        router;
        insertOrUpdate(next, action = "replace") {
            let key = this.getKey(next);
            let last = this.getRecordFromKey.get(key);
            if (is.present(last)) {
                if (action === "combine") {
                    for (let key in last) {
                        let lastValue = last[key];
                        let nextValue = next[key];
                        if (is.present(lastValue) && is.absent(nextValue)) {
                            next[key] = last[key];
                        }
                    }
                }
                this.getRecordFromKey.set(key, next);
                this.router.route("update", { last, next });
                this.router.route("*", {});
            }
            else {
                this.getRecordFromKey.set(key, next);
                this.router.route("insert", { next });
                this.router.route("*", {});
            }
        }
        constructor(getKey) {
            this.getRecordFromKey = new Map();
            this.getKey = getKey;
            this.router = new stdlib.routing.MessageRouter();
        }
        [Symbol.iterator]() {
            return this.getRecordFromKey.values();
        }
        insert(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        keyof(record) {
            return this.getKey(record);
        }
        length() {
            return this.getRecordFromKey.size;
        }
        lookup(key) {
            let record = this.getRecordFromKey.get(key);
            if (is.absent(record)) {
                throw `Expected "${key}" to match a record!`;
            }
            return record;
        }
        on(type, listener) {
            this.router.addObserver(type, listener);
            if (type === "insert") {
                for (let record of this.getRecordFromKey.values()) {
                    listener({ next: record });
                }
            }
        }
        off(type, listener) {
            this.router.addObserver(type, listener);
        }
        remove(record) {
            let key = this.getKey(record);
            if (this.getRecordFromKey.has(key)) {
                this.getRecordFromKey.delete(key);
                this.router.route("remove", { last: record });
                this.router.route("*", {});
            }
        }
        update(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        static from(records, getKey) {
            let index = new RecordIndex(getKey);
            for (let record of records) {
                index.insert(record);
            }
            return index;
        }
    }
    exports.RecordIndex = RecordIndex;
    ;
    function getTokens(query) {
        let normalized = query;
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFKD");
        normalized = normalized.replace(/[\p{M}]/gu, "");
        return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
    }
    exports.getTokens = getTokens;
    ;
    class SearchIndex {
        getPrimaryKeysFromToken;
        lookupRecord;
        getPrimaryKey;
        getIndexedValues;
        minTokenLength;
        constructor(lookupRecord, getPrimaryKey, getIndexedValues, minTokenLength) {
            this.getPrimaryKeysFromToken = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValues = getIndexedValues;
            this.minTokenLength = minTokenLength;
        }
        insert(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value).filter((token) => token.length >= this.minTokenLength);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.absent(primaryKeys)) {
                        primaryKeys = new Set();
                        this.getPrimaryKeysFromToken.set(token, primaryKeys);
                    }
                    let primaryKey = this.getPrimaryKey(record);
                    primaryKeys.add(primaryKey);
                }
            }
        }
        lookup(query) {
            let tokens = getTokens(query).filter((token) => token.length >= this.minTokenLength);
            let primaryKeySets = tokens.map((token) => {
                return this.getPrimaryKeysFromToken.get(token);
            }).filter(is.present);
            let map = new Map();
            for (let primaryKeys of primaryKeySets) {
                for (let primaryKey of primaryKeys) {
                    let rank = map.get(primaryKey) ?? (0 - tokens.length);
                    map.set(primaryKey, rank + 2);
                }
            }
            return Array.from(map.entries())
                .filter((entry) => entry[1] >= 0)
                .sort(sorters.NumericSort.decreasing((entry) => entry[1]))
                .map((entry) => ({
                id: entry[0],
                rank: entry[1]
            }));
        }
        remove(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.present(primaryKeys)) {
                        let primaryKey = this.getPrimaryKey(record);
                        primaryKeys.delete(primaryKey);
                        if (primaryKeys.size === 0) {
                            this.getPrimaryKeysFromToken.delete(token);
                        }
                    }
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
        static fromTable(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            for (let record of records) {
                index.insert(record);
            }
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
    }
    exports.SearchIndex = SearchIndex;
    ;
});
define("build/jsondb/index", ["require", "exports", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters"], function (require, exports, indices, sorters, indices_1, indices_2, indices_3, sorters_1, sorters_2, sorters_3, sorters_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sorters = exports.indices = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = exports.SearchIndex = exports.RecordIndex = exports.CollectionIndex = exports.sorters = exports.indices = void 0;
    exports.indices = indices;
    exports.sorters = sorters;
    Object.defineProperty(exports, "CollectionIndex", { enumerable: true, get: function () { return indices_1.CollectionIndex; } });
    Object.defineProperty(exports, "RecordIndex", { enumerable: true, get: function () { return indices_2.RecordIndex; } });
    Object.defineProperty(exports, "SearchIndex", { enumerable: true, get: function () { return indices_3.SearchIndex; } });
    Object.defineProperty(exports, "CombinedSort", { enumerable: true, get: function () { return sorters_1.CombinedSort; } });
    Object.defineProperty(exports, "CustomSort", { enumerable: true, get: function () { return sorters_2.CustomSort; } });
    Object.defineProperty(exports, "LexicalSort", { enumerable: true, get: function () { return sorters_3.LexicalSort; } });
    Object.defineProperty(exports, "NumericSort", { enumerable: true, get: function () { return sorters_4.NumericSort; } });
});
define("build/config/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "fs"], function (require, exports, ts_autoguard_1, libfs) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    const ROOT = [
        ".",
        "private",
        "config"
    ];
    const PATH = [...ROOT, "config.json"].join("/");
    let config = {
        certificate_path: [".", "private", "certs", "full_chain.pem"],
        certificate_key_path: [".", "private", "certs", "certificate_key.pem"],
        http_port: 80,
        https_port: 443,
        media_path: [".", "private", "media"],
        use_demo_mode: false,
        use_registration_keys: true
    };
    try {
        let string = libfs.readFileSync(PATH, "utf-8");
        let json = JSON.parse(string);
        if (ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any).is(json)) {
            if (ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String).is(json.certificate_key_path)) {
                config.certificate_key_path = json.certificate_key_path;
            }
            if (ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String).is(json.certificate_path)) {
                config.certificate_path = json.certificate_path;
            }
            if (ts_autoguard_1.guards.Number.is(json.http_port)) {
                config.http_port = json.http_port;
            }
            if (ts_autoguard_1.guards.Number.is(json.https_port)) {
                config.https_port = json.https_port;
            }
            if (ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String).is(json.media_path)) {
                config.media_path = json.media_path;
            }
            if (ts_autoguard_1.guards.Boolean.is(json.use_demo_mode)) {
                config.use_demo_mode = json.use_demo_mode;
            }
            if (ts_autoguard_1.guards.Boolean.is(json.use_registration_keys)) {
                config.use_registration_keys = json.use_registration_keys;
            }
        }
    }
    catch (error) { }
    if (!libfs.existsSync(ROOT.join("/"))) {
        libfs.mkdirSync(ROOT.join("/"));
    }
    libfs.writeFileSync(PATH, JSON.stringify(config, null, "\t"));
    exports.default = config;
});
define("build/database/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Year = exports.PlaylistItem = exports.Playlist = exports.Stream = exports.Token = exports.Key = exports.User = exports.Cue = exports.Subtitle = exports.ShowGenre = exports.MovieGenre = exports.Genre = exports.ShowActor = exports.MovieActor = exports.Actor = exports.MovieFile = exports.Movie = exports.EpisodeFile = exports.Episode = exports.Season = exports.ShowFile = exports.Show = exports.TrackArtist = exports.AlbumArtist = exports.TrackFile = exports.Track = exports.Disc = exports.AlbumFile = exports.Album = exports.Artist = exports.VideoSubtitle = exports.VideoFile = exports.SubtitleFile = exports.MetadataFile = exports.ImageFile = exports.AudioFile = exports.File = exports.Directory = void 0;
    exports.Directory = autoguard.guards.Object.of({
        "directory_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {
        "parent_directory_id": autoguard.guards.String
    });
    exports.File = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {
        "parent_directory_id": autoguard.guards.String,
        "index_timestamp": autoguard.guards.Number,
        "size": autoguard.guards.Number
    });
    exports.AudioFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("audio/mp4"), autoguard.guards.StringLiteral.of("audio/mp3")),
        "duration_ms": autoguard.guards.Number
    }, {});
    exports.ImageFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("image/jpeg")),
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    }, {});
    exports.MetadataFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("application/json"))
    }, {});
    exports.SubtitleFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("text/vtt")),
        "duration_ms": autoguard.guards.Number
    }, {
        "language": autoguard.guards.String
    });
    exports.VideoFile = autoguard.guards.Object.of({
        "file_id": autoguard.guards.String,
        "mime": autoguard.guards.Union.of(autoguard.guards.String, autoguard.guards.StringLiteral.of("video/mp4")),
        "duration_ms": autoguard.guards.Number,
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    }, {});
    exports.VideoSubtitle = autoguard.guards.Object.of({
        "video_file_id": autoguard.guards.String,
        "subtitle_file_id": autoguard.guards.String
    }, {});
    exports.Artist = autoguard.guards.Object.of({
        "artist_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.Album = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "title": autoguard.guards.String
    }, {
        "year": autoguard.guards.Number
    });
    exports.AlbumFile = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.Disc = autoguard.guards.Object.of({
        "disc_id": autoguard.guards.String,
        "album_id": autoguard.guards.String,
        "number": autoguard.guards.Number
    }, {});
    exports.Track = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "disc_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number
    }, {
        "copyright": autoguard.guards.String
    });
    exports.TrackFile = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.AlbumArtist = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "artist_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.TrackArtist = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "artist_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.Show = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {
        "summary": autoguard.guards.String,
        "imdb": autoguard.guards.String
    });
    exports.ShowFile = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.Season = autoguard.guards.Object.of({
        "season_id": autoguard.guards.String,
        "show_id": autoguard.guards.String,
        "number": autoguard.guards.Number
    }, {});
    exports.Episode = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "season_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number
    }, {
        "year": autoguard.guards.Number,
        "summary": autoguard.guards.String,
        "copyright": autoguard.guards.String,
        "imdb": autoguard.guards.String
    });
    exports.EpisodeFile = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.Movie = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "title": autoguard.guards.String
    }, {
        "year": autoguard.guards.Number,
        "summary": autoguard.guards.String,
        "copyright": autoguard.guards.String,
        "imdb": autoguard.guards.String
    });
    exports.MovieFile = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.Actor = autoguard.guards.Object.of({
        "actor_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.MovieActor = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "actor_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.ShowActor = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "actor_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.Genre = autoguard.guards.Object.of({
        "genre_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.MovieGenre = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "genre_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.ShowGenre = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "genre_id": autoguard.guards.String,
        "order": autoguard.guards.Number
    }, {});
    exports.Subtitle = autoguard.guards.Object.of({
        "subtitle_id": autoguard.guards.String,
        "file_id": autoguard.guards.String
    }, {});
    exports.Cue = autoguard.guards.Object.of({
        "cue_id": autoguard.guards.String,
        "subtitle_id": autoguard.guards.String,
        "start_ms": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number,
        "lines": autoguard.guards.String
    }, {});
    exports.User = autoguard.guards.Object.of({
        "user_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "username": autoguard.guards.String,
        "password": autoguard.guards.String
    }, {});
    exports.Key = autoguard.guards.Object.of({
        "key_id": autoguard.guards.String
    }, {
        "user_id": autoguard.guards.String
    });
    exports.Token = autoguard.guards.Object.of({
        "token_id": autoguard.guards.String,
        "user_id": autoguard.guards.String,
        "hash": autoguard.guards.String,
        "expires_ms": autoguard.guards.Number
    }, {});
    exports.Stream = autoguard.guards.Object.of({
        "stream_id": autoguard.guards.String,
        "user_id": autoguard.guards.String,
        "file_id": autoguard.guards.String,
        "timestamp_ms": autoguard.guards.Number
    }, {});
    exports.Playlist = autoguard.guards.Object.of({
        "playlist_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "description": autoguard.guards.String,
        "user_id": autoguard.guards.String
    }, {});
    exports.PlaylistItem = autoguard.guards.Object.of({
        "playlist_item_id": autoguard.guards.String,
        "playlist_id": autoguard.guards.String,
        "track_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "added_ms": autoguard.guards.Number
    }, {});
    exports.Year = autoguard.guards.Object.of({
        "year_id": autoguard.guards.String,
        "year": autoguard.guards.Number
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Directory": autoguard.guards.Reference.of(() => exports.Directory),
            "File": autoguard.guards.Reference.of(() => exports.File),
            "AudioFile": autoguard.guards.Reference.of(() => exports.AudioFile),
            "ImageFile": autoguard.guards.Reference.of(() => exports.ImageFile),
            "MetadataFile": autoguard.guards.Reference.of(() => exports.MetadataFile),
            "SubtitleFile": autoguard.guards.Reference.of(() => exports.SubtitleFile),
            "VideoFile": autoguard.guards.Reference.of(() => exports.VideoFile),
            "VideoSubtitle": autoguard.guards.Reference.of(() => exports.VideoSubtitle),
            "Artist": autoguard.guards.Reference.of(() => exports.Artist),
            "Album": autoguard.guards.Reference.of(() => exports.Album),
            "AlbumFile": autoguard.guards.Reference.of(() => exports.AlbumFile),
            "Disc": autoguard.guards.Reference.of(() => exports.Disc),
            "Track": autoguard.guards.Reference.of(() => exports.Track),
            "TrackFile": autoguard.guards.Reference.of(() => exports.TrackFile),
            "AlbumArtist": autoguard.guards.Reference.of(() => exports.AlbumArtist),
            "TrackArtist": autoguard.guards.Reference.of(() => exports.TrackArtist),
            "Show": autoguard.guards.Reference.of(() => exports.Show),
            "ShowFile": autoguard.guards.Reference.of(() => exports.ShowFile),
            "Season": autoguard.guards.Reference.of(() => exports.Season),
            "Episode": autoguard.guards.Reference.of(() => exports.Episode),
            "EpisodeFile": autoguard.guards.Reference.of(() => exports.EpisodeFile),
            "Movie": autoguard.guards.Reference.of(() => exports.Movie),
            "MovieFile": autoguard.guards.Reference.of(() => exports.MovieFile),
            "Actor": autoguard.guards.Reference.of(() => exports.Actor),
            "MovieActor": autoguard.guards.Reference.of(() => exports.MovieActor),
            "ShowActor": autoguard.guards.Reference.of(() => exports.ShowActor),
            "Genre": autoguard.guards.Reference.of(() => exports.Genre),
            "MovieGenre": autoguard.guards.Reference.of(() => exports.MovieGenre),
            "ShowGenre": autoguard.guards.Reference.of(() => exports.ShowGenre),
            "Subtitle": autoguard.guards.Reference.of(() => exports.Subtitle),
            "Cue": autoguard.guards.Reference.of(() => exports.Cue),
            "User": autoguard.guards.Reference.of(() => exports.User),
            "Key": autoguard.guards.Reference.of(() => exports.Key),
            "Token": autoguard.guards.Reference.of(() => exports.Token),
            "Stream": autoguard.guards.Reference.of(() => exports.Stream),
            "Playlist": autoguard.guards.Reference.of(() => exports.Playlist),
            "PlaylistItem": autoguard.guards.Reference.of(() => exports.PlaylistItem),
            "Year": autoguard.guards.Reference.of(() => exports.Year)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/database/probes/readers", ["require", "exports", "fs"], function (require, exports, libfs) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Binary = void 0;
    class Binary {
        fd;
        offset;
        read(buffer) {
            let bytes = libfs.readSync(this.fd, buffer, 0, buffer.length, this.offset);
            if (bytes !== buffer.length) {
                throw `Expected to read ${buffer.length} bytes but read ${bytes}!`;
            }
            this.offset += bytes;
            return buffer;
        }
        skip(length) {
            this.offset += length;
        }
        constructor(fd) {
            this.fd = fd;
            this.offset = 0;
        }
        newContext(context) {
            let offset = this.offset;
            try {
                return context((buffer) => this.read(buffer), (length) => this.skip(length));
            }
            catch (error) {
                this.offset = offset;
                throw error;
            }
        }
    }
    exports.Binary = Binary;
    ;
});
define("build/database/probes/jpeg", ["require", "exports", "build/database/probes/readers"], function (require, exports, readers) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    var Markers;
    (function (Markers) {
        Markers[Markers["START_OF_IMAGE"] = 65496] = "START_OF_IMAGE";
        Markers[Markers["END_OF_IMAGE"] = 65497] = "END_OF_IMAGE";
        Markers[Markers["APPLICATION_0"] = 65504] = "APPLICATION_0";
        Markers[Markers["START_OF_SCAN"] = 65498] = "START_OF_SCAN";
        Markers[Markers["START_OF_FRAME_0"] = 65472] = "START_OF_FRAME_0";
        Markers[Markers["DEFINE_QUANTIZATION_TABLE"] = 65499] = "DEFINE_QUANTIZATION_TABLE";
        Markers[Markers["DEFINE_HUFFMAN_TABLE"] = 65476] = "DEFINE_HUFFMAN_TABLE";
    })(Markers || (Markers = {}));
    function parseStartOfImage(data) {
        return {};
    }
    function parseApplication0(data) {
        let offset = 0;
        let identifier = data.slice(offset, 5);
        offset += 5;
        if (identifier.toString() !== "JFIF\0") {
            throw `Expected a JFIF tag!`;
        }
        let major = data.readUInt8(offset);
        offset += 1;
        let minor = data.readUInt8(offset);
        offset += 1;
        let units = data.readUInt8(offset);
        offset += 1;
        if ((units !== 0) && (units !== 1) && (units !== 2)) {
            throw `Expected a valid density unit!`;
        }
        let x = data.readUInt16BE(offset);
        offset += 2;
        if (x === 0) {
            throw `Expected a non-zero horisontal resolution!`;
        }
        let y = data.readUInt16BE(offset);
        offset += 2;
        if (y === 0) {
            throw `Expected a non-zero vertical resolution!`;
        }
        let w = data.readUInt8(offset);
        offset += 1;
        let h = data.readUInt8(offset);
        offset += 1;
        let preview = data.slice(offset, offset + w * h * 3);
        offset += w * h * 3;
        if (preview.length !== w * h * 3) {
            throw `Expected a valid thumbnail!`;
        }
        return {
            major,
            minor,
            units,
            x,
            y,
            w,
            h,
            preview
        };
    }
    function parseStartOfFrame0(data) {
        let offset = 0;
        let precision = data.readUInt8(offset);
        offset += 1;
        let height = data.readUInt16BE(offset);
        offset += 2;
        let width = data.readUInt16BE(offset);
        offset += 2;
        let component_count = data.readUInt8(offset);
        offset += 1;
        let components = [...Array(component_count).keys()].map(() => {
            let id = data.readUInt8(offset);
            offset += 1;
            let sampling_factors = data.readUInt8(offset);
            offset += 1;
            let quantization_table = data.readUInt8(offset);
            offset += 1;
            return {
                id,
                sampling_factors,
                quantization_table
            };
        });
        return {
            precision,
            height,
            width,
            component_count,
            components
        };
    }
    function probe(fd) {
        let reader = new readers.Binary(fd);
        return reader.newContext((read, skip) => {
            let marker = Buffer.alloc(2);
            let length = Buffer.alloc(2);
            read(marker);
            if (marker.readUInt16BE() !== Markers.START_OF_IMAGE) {
                throw `Expected SOI marker!`;
            }
            parseStartOfImage(Buffer.alloc(0));
            read(marker);
            if (marker.readUInt16BE() !== Markers.APPLICATION_0) {
                throw `Expected APP0 marker!`;
            }
            read(length);
            parseApplication0(read(Buffer.alloc(length.readUInt16BE() - 2)));
            while (true) {
                read(marker);
                read(length);
                if (marker.readUInt16BE() === Markers.START_OF_FRAME_0) {
                    let sof = parseStartOfFrame0(read(Buffer.alloc(length.readUInt16BE() - 2)));
                    let result = {
                        resources: [{
                                type: "image",
                                width: sof.width,
                                height: sof.height
                            }]
                    };
                    return result;
                }
                else {
                    skip(length.readUInt16BE() - 2);
                }
            }
        });
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Probe = exports.Resource = exports.VideoResource = exports.SubtitleResource = exports.MetadataResource = exports.ImageResource = exports.AudioResource = exports.Metadata = exports.AlbumMetadata = exports.TrackMetadata = exports.MovieMetadata = exports.EpisodeMetadata = exports.ShowMetadata = void 0;
    exports.ShowMetadata = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("show"),
        "title": autoguard.guards.String,
        "genres": autoguard.guards.Array.of(autoguard.guards.String),
        "actors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {
        "summary": autoguard.guards.String,
        "imdb": autoguard.guards.String
    });
    exports.EpisodeMetadata = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("episode"),
        "title": autoguard.guards.String,
        "season": autoguard.guards.Number,
        "episode": autoguard.guards.Number,
        "show": autoguard.guards.Object.of({
            "title": autoguard.guards.String,
            "genres": autoguard.guards.Array.of(autoguard.guards.String),
            "actors": autoguard.guards.Array.of(autoguard.guards.String)
        }, {
            "summary": autoguard.guards.String,
            "imdb": autoguard.guards.String
        })
    }, {
        "year": autoguard.guards.Number,
        "summary": autoguard.guards.String,
        "copyright": autoguard.guards.String,
        "imdb": autoguard.guards.String
    });
    exports.MovieMetadata = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("movie"),
        "title": autoguard.guards.String,
        "genres": autoguard.guards.Array.of(autoguard.guards.String),
        "actors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {
        "year": autoguard.guards.Number,
        "summary": autoguard.guards.String,
        "copyright": autoguard.guards.String,
        "imdb": autoguard.guards.String
    });
    exports.TrackMetadata = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("track"),
        "title": autoguard.guards.String,
        "disc": autoguard.guards.Number,
        "track": autoguard.guards.Number,
        "album": autoguard.guards.Object.of({
            "title": autoguard.guards.String,
            "artists": autoguard.guards.Array.of(autoguard.guards.String)
        }, {
            "year": autoguard.guards.Number
        }),
        "artists": autoguard.guards.Array.of(autoguard.guards.String)
    }, {
        "copyright": autoguard.guards.String
    });
    exports.AlbumMetadata = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("album"),
        "title": autoguard.guards.String,
        "disc": autoguard.guards.Number,
        "artists": autoguard.guards.Array.of(autoguard.guards.String),
        "tracks": autoguard.guards.Array.of(autoguard.guards.Object.of({
            "title": autoguard.guards.String,
            "artists": autoguard.guards.Array.of(autoguard.guards.String)
        }, {
            "copyright": autoguard.guards.String
        }))
    }, {
        "year": autoguard.guards.Number,
        "copyright": autoguard.guards.String
    });
    exports.Metadata = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ShowMetadata), autoguard.guards.Reference.of(() => exports.EpisodeMetadata), autoguard.guards.Reference.of(() => exports.MovieMetadata), autoguard.guards.Reference.of(() => exports.TrackMetadata), autoguard.guards.Reference.of(() => exports.AlbumMetadata));
    exports.AudioResource = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("audio"),
        "duration_ms": autoguard.guards.Number
    }, {});
    exports.ImageResource = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("image"),
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    }, {});
    exports.MetadataResource = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("metadata")
    }, {});
    exports.SubtitleResource = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("subtitle"),
        "duration_ms": autoguard.guards.Number,
        "cues": autoguard.guards.Array.of(autoguard.guards.Object.of({
            "start_ms": autoguard.guards.Number,
            "duration_ms": autoguard.guards.Number,
            "lines": autoguard.guards.Array.of(autoguard.guards.String)
        }, {}))
    }, {
        "language": autoguard.guards.String
    });
    exports.VideoResource = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("video"),
        "duration_ms": autoguard.guards.Number,
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    }, {});
    exports.Resource = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.AudioResource), autoguard.guards.Reference.of(() => exports.ImageResource), autoguard.guards.Reference.of(() => exports.MetadataResource), autoguard.guards.Reference.of(() => exports.SubtitleResource), autoguard.guards.Reference.of(() => exports.VideoResource));
    exports.Probe = autoguard.guards.Object.of({
        "resources": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Resource))
    }, {
        "metadata": autoguard.guards.Reference.of(() => exports.Metadata)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ShowMetadata": autoguard.guards.Reference.of(() => exports.ShowMetadata),
            "EpisodeMetadata": autoguard.guards.Reference.of(() => exports.EpisodeMetadata),
            "MovieMetadata": autoguard.guards.Reference.of(() => exports.MovieMetadata),
            "TrackMetadata": autoguard.guards.Reference.of(() => exports.TrackMetadata),
            "AlbumMetadata": autoguard.guards.Reference.of(() => exports.AlbumMetadata),
            "Metadata": autoguard.guards.Reference.of(() => exports.Metadata),
            "AudioResource": autoguard.guards.Reference.of(() => exports.AudioResource),
            "ImageResource": autoguard.guards.Reference.of(() => exports.ImageResource),
            "MetadataResource": autoguard.guards.Reference.of(() => exports.MetadataResource),
            "SubtitleResource": autoguard.guards.Reference.of(() => exports.SubtitleResource),
            "VideoResource": autoguard.guards.Reference.of(() => exports.VideoResource),
            "Resource": autoguard.guards.Reference.of(() => exports.Resource),
            "Probe": autoguard.guards.Reference.of(() => exports.Probe)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/database/probes/json", ["require", "exports", "fs", "build/database/probes/schema/index"], function (require, exports, libfs, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    function probe(fd) {
        let result = {
            resources: [
                {
                    type: "metadata"
                }
            ]
        };
        let buffer = libfs.readFileSync(fd);
        let json = JSON.parse(buffer.toString());
        if (schema.Metadata.is(json)) {
            result.metadata = json;
        }
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/mp3", ["require", "exports", "build/is", "build/database/probes/readers"], function (require, exports, is, readers) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    function decodeSyncSafeInteger(buffer) {
        let a = buffer.readUInt8(0);
        let b = buffer.readUInt8(1);
        let c = buffer.readUInt8(2);
        let d = buffer.readUInt8(3);
        return ((a & 0x7F) << 21) | ((b & 0x7F) << 14) | ((c & 0x7F) << 7) | ((d & 0x7F) << 0);
    }
    function parseID3v2Header(reader) {
        return reader.newContext((read, skip) => {
            let buffer = Buffer.alloc(10);
            read(buffer);
            if (buffer.slice(0, 5).toString("binary") !== "ID3\x04\x00") {
                throw `Expected an ID3v2 tag!`;
            }
            let length = decodeSyncSafeInteger(buffer.slice(6, 6 + 4));
            let body = Buffer.alloc(length);
            read(body);
            let tags = {};
            let offset = 0;
            while (offset < body.length) {
                let type = body.slice(offset, offset + 4).toString("binary");
                let length = decodeSyncSafeInteger(body.slice(offset + 4, offset + 4 + 4));
                let flags = body.slice(offset + 8, offset + 8 + 2);
                let data = body.slice(offset + 10, offset + 10 + length);
                offset += 10 + length;
                if (type === "\0\0\0\0") {
                    break;
                }
                else if (type === "TCOP") {
                    tags.copyright = data.slice(1, -1).toString();
                }
                else if (type === "TIT2") {
                    tags.title = data.slice(1, -1).toString();
                }
                else if (type === "TALB") {
                    tags.album = data.slice(1, -1).toString();
                }
                else if (type === "TDRC") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^([0-9]+)$/.exec(string);
                    if (is.present(parts)) {
                        tags.year = parseInt(parts[1]);
                    }
                }
                else if (type === "TRCK") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^([0-9]+)(?:\/([0-9]+))?$/.exec(string);
                    if (is.present(parts)) {
                        tags.track_number = parseInt(parts[1]);
                    }
                }
                else if (type === "TPOS") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^([0-9]+)(?:\/([0-9]+))?$/.exec(string);
                    if (is.present(parts)) {
                        tags.disc_number = parseInt(parts[1]);
                    }
                }
                else if (type === "TPE1") {
                    tags.artist = data.slice(1, -1).toString();
                }
                else if (type === "TPE2") {
                    tags.album_artist = data.slice(1, -1).toString();
                }
                else if (type === "TXXX") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^ALBUM ARTIST\0(.+)$/.exec(string);
                    if (is.present(parts)) {
                        tags.album_artist = parts[1];
                    }
                }
            }
            return tags;
        });
    }
    var Version;
    (function (Version) {
        Version[Version["V2_5"] = 0] = "V2_5";
        Version[Version["RESERVED"] = 1] = "RESERVED";
        Version[Version["V2"] = 2] = "V2";
        Version[Version["V1"] = 3] = "V1";
    })(Version || (Version = {}));
    ;
    var Layer;
    (function (Layer) {
        Layer[Layer["RESERVED"] = 0] = "RESERVED";
        Layer[Layer["LAYER_3"] = 1] = "LAYER_3";
        Layer[Layer["LAYER_2"] = 2] = "LAYER_2";
        Layer[Layer["LAYER_1"] = 3] = "LAYER_1";
    })(Layer || (Layer = {}));
    ;
    const KILOBITS_PER_SECOND = [
        0,
        32,
        40,
        48,
        56,
        64,
        80,
        96,
        112,
        128,
        160,
        192,
        224,
        256,
        320,
        0
    ];
    const SAMPLES_PER_SECOND = [
        44100,
        48000,
        32000,
        0
    ];
    function parseXingHeader(reader) {
        return reader.newContext((read, skip) => {
            let buffer = Buffer.alloc(4);
            read(buffer);
            let sync = ((buffer[0] & 0xFF) << 3) | ((buffer[1] & 0xE0) >> 5);
            let version = ((buffer[1] & 0x18) >> 3);
            let layer = ((buffer[1] & 0x06) >> 1);
            let skip_crc = ((buffer[1] & 0x01) >> 0);
            let bitrate = ((buffer[2] & 0xF0) >> 4);
            let sample_rate = ((buffer[2] & 0x0C) >> 2);
            let padded = ((buffer[2] & 0x02) >> 1);
            let application_private = ((buffer[2] & 0x01) >> 0);
            let channels = ((buffer[3] & 0xC0) >> 6);
            let mode_extension = ((buffer[3] & 0x30) >> 4);
            let copyrighted = ((buffer[3] & 0x08) >> 3);
            let original = ((buffer[3] & 0x04) >> 2);
            let emphasis = ((buffer[3] & 0x03) >> 0);
            if (sync === 0x07FF && version === Version.V1 && layer === Layer.LAYER_3) {
                let samples_per_frame = 1152;
                let slots = Math.floor(samples_per_frame * KILOBITS_PER_SECOND[bitrate] * 1000 / 8 / SAMPLES_PER_SECOND[sample_rate]);
                if (padded) {
                    slots += 1;
                }
                let bytes = slots * 1;
                let body = Buffer.alloc(bytes - 4);
                read(body);
                let zeroes = body.slice(0, 0 + 32);
                let xing = body.slice(32, 32 + 4);
                if (xing.toString("binary") === "Xing" || xing.toString() === "Info") {
                    let flags = body.slice(36, 36 + 4);
                    let has_quality = ((flags[3] & 0x08) >> 3);
                    let has_toc = ((flags[3] & 0x04) >> 2);
                    let has_bytes = ((flags[3] & 0x02) >> 1);
                    let has_frames = ((flags[3] & 0x01) >> 0);
                    let offset = 40;
                    if (has_frames) {
                        let num_frames = body.readUInt32BE(offset);
                        offset += 4;
                        let duration_ms = Math.ceil((num_frames * samples_per_frame / SAMPLES_PER_SECOND[sample_rate]) * 1000);
                        return duration_ms;
                    }
                    if (has_bytes) {
                        let num_bytes = body.readUInt32BE(offset);
                        offset += 4;
                    }
                    if (has_toc) {
                        offset += 100;
                    }
                    if (has_quality) {
                        let quality = body.readUInt32BE(offset);
                        offset += 4;
                    }
                }
            }
            throw `Expected a Xing header!`;
        });
    }
    function probe(fd) {
        let reader = new readers.Binary(fd);
        let tags = parseID3v2Header(reader);
        console.log(tags);
        let duration_ms = parseXingHeader(reader);
        let result = {
            resources: [
                {
                    type: "audio",
                    duration_ms: duration_ms
                }
            ]
        };
        if (is.present(tags.title) && is.present(tags.disc_number) && is.present(tags.track_number) && is.present(tags.album)) {
            let metadata = {
                type: "track",
                title: tags.title,
                disc: tags.disc_number,
                track: tags.track_number,
                album: {
                    title: tags.album,
                    year: tags.year,
                    artists: is.absent(tags.album_artist) ? [] : tags.album_artist.split(";").map((artist) => artist.trim())
                },
                artists: is.absent(tags.artist) ? [] : tags.artist.split(";").map((artist) => artist.trim()),
                copyright: tags.copyright
            };
            result.metadata = metadata;
        }
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/mp4", ["require", "exports", "fs", "build/is"], function (require, exports, libfs, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    class Atom {
        fd;
        type;
        body;
        constructor(fd, type, body) {
            this.fd = fd;
            this.type = type;
            this.body = body;
        }
        getAllChildren() {
            let scope = {
                ...this.body
            };
            let atoms = new Array();
            while (scope.length > 0) {
                let atom = Atom.parse(this.fd, scope);
                // The "udta" atom begins with a mandatory zero-terminated list.
                if (this.type === "udta") {
                    atom.body.offset += 4;
                    atom.body.length -= 4;
                }
                atoms.push(atom);
                scope.offset = atom.body.offset + atom.body.length;
                scope.length = this.body.offset + this.body.length - scope.offset;
            }
            return atoms;
        }
        getChild(type) {
            let children = this.getChildren(type);
            if (children.length !== 1) {
                throw `Expected exactly one child!`;
            }
            return children[0];
        }
        getChildren(type) {
            return this.getAllChildren().filter((atom) => {
                return atom.type === type;
            });
        }
        readBody() {
            let buffer = Buffer.alloc(this.body.length);
            if (libfs.readSync(this.fd, buffer, 0, buffer.length, this.body.offset) !== buffer.length) {
                throw `Expected to read exactly ${buffer.length} bytes!`;
            }
            return buffer;
        }
        static parse(fd, scope) {
            let offset = scope.offset;
            let buffer = Buffer.alloc(8);
            if (libfs.readSync(fd, buffer, 0, buffer.length, offset) !== buffer.length) {
                throw `Expected to read exactly ${buffer.length} bytes!`;
            }
            offset += buffer.length;
            let length = buffer.readUInt32BE(0);
            let type = buffer.slice(4, 4 + 4).toString("binary");
            if (length === 0) {
                length = scope.length - offset;
            }
            else if (length === 1) {
                if (libfs.readSync(fd, buffer, 0, buffer.length, offset) !== buffer.length) {
                    throw `Expected to read exactly ${buffer.length} bytes!`;
                }
                offset += buffer.length;
                length = Number(buffer.readBigUInt64BE(0));
            }
            if (length < 8) {
                throw `Expected a length of at least 8 bytes, got ${length}!`;
            }
            else if (length > scope.length) {
                throw `Expected a length of at most ${scope.length} bytes, got ${length}!`;
            }
            length -= 8;
            return new Atom(fd, type, {
                offset,
                length
            });
        }
    }
    ;
    function probe(fd) {
        let atom = new Atom(fd, "root", {
            offset: 0,
            length: libfs.fstatSync(fd).size
        });
        let moov = atom.getChild("moov");
        let mvhd = moov.getChild("mvhd");
        let buffer = mvhd.readBody();
        let ts = buffer.readUInt32BE(12);
        let result = {
            resources: moov.getChildren("trak").map((trak) => {
                let tkhd = trak.getChild("tkhd");
                let buffer = tkhd.readBody();
                let duration_ts = buffer.readUInt32BE(20);
                let width = buffer.readUInt16BE(76);
                let height = buffer.readUInt16BE(80);
                let duration_ms = Math.ceil(duration_ts / ts * 1000);
                if (duration_ms > 0 && width > 0 && height > 0) {
                    return {
                        type: "video",
                        duration_ms,
                        width,
                        height
                    };
                }
                else if (duration_ms > 0) {
                    return {
                        type: "audio",
                        duration_ms
                    };
                }
                else {
                    return {
                        type: "metadata"
                    };
                }
            })
        };
        try {
            let udta = moov.getChild("udta");
            let meta = udta.getChild("meta");
            let ilst = meta.getChild("ilst");
            let tags = {};
            try {
                let buffer = ilst.getChild("tvsh").getChild("data").readBody();
                tags.show = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("tven").getChild("data").readBody();
                tags.episode = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("tves").getChild("data").readBody();
                tags.episode_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("tvsn").getChild("data").readBody();
                tags.season_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9nam").getChild("data").readBody();
                tags.title = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9day").getChild("data").readBody();
                tags.year = Number.parseInt(buffer.slice(8).toString());
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9cmt").getChild("data").readBody();
                tags.comment = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9cpy").getChild("data").readBody();
                tags.copyright = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9ART").getChild("data").readBody();
                tags.artist = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9alb").getChild("data").readBody();
                tags.album = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("aART").getChild("data").readBody();
                tags.album_artist = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("trkn").getChild("data").readBody();
                tags.track_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("disk").getChild("data").readBody();
                tags.disc_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            if (result.resources.find((resource) => resource.type === "video")) {
                if (is.present(tags.episode) && is.present(tags.season_number) && is.present(tags.episode_number) && is.present(tags.show)) {
                    let metadata = {
                        type: "episode",
                        title: tags.episode,
                        season: tags.season_number,
                        episode: tags.episode_number,
                        year: tags.year,
                        summary: tags.comment,
                        show: {
                            title: tags.show,
                            summary: undefined,
                            genres: [],
                            actors: []
                        }
                    };
                    result.metadata = metadata;
                }
                else if (is.present(tags.title)) {
                    let metadata = {
                        type: "movie",
                        title: tags.title,
                        year: tags.year,
                        summary: tags.comment,
                        genres: [],
                        actors: []
                    };
                    result.metadata = metadata;
                }
            }
            else if (result.resources.find((resource) => resource.type === "audio")) {
                if (is.present(tags.title) && is.present(tags.disc_number) && is.present(tags.track_number) && is.present(tags.album)) {
                    let metadata = {
                        type: "track",
                        title: tags.title,
                        disc: tags.disc_number,
                        track: tags.track_number,
                        album: {
                            title: tags.album,
                            year: tags.year,
                            artists: is.absent(tags.album_artist) ? [] : tags.album_artist.split(";").map((artist) => artist.trim())
                        },
                        artists: is.absent(tags.artist) ? [] : tags.artist.split(";").map((artist) => artist.trim()),
                        copyright: tags.copyright
                    };
                    result.metadata = metadata;
                }
            }
        }
        catch (error) { }
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/vtt/reader", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reader = void 0;
    function isString(value) {
        return value != null && value.constructor === String;
    }
    class Reader {
        string;
        offset;
        length;
        constructor(string) {
            this.string = string;
            this.offset = 0;
            this.length = string.length;
        }
        done() {
            return (this.offset === this.length);
        }
        line() {
            let string = "";
            while (!this.done()) {
                let one = this.string[this.offset];
                this.offset += 1;
                if (false) {
                }
                else if (one === "\r") {
                    if (!this.done()) {
                        let two = this.string[this.offset];
                        if (two === "\n") {
                            this.offset += 1;
                        }
                    }
                    break;
                }
                else if (one === "\n") {
                    if (!this.done()) {
                        let two = this.string[this.offset];
                        if (two === "\r") {
                            this.offset += 1;
                        }
                    }
                    break;
                }
                else {
                    string += one;
                }
            }
            return string;
        }
        keep(characters) {
            let string = "";
            while (!this.done()) {
                if (characters.indexOf(this.peek(1)) >= 0) {
                    break;
                }
                string += this.read(1);
            }
            return string;
        }
        peek(how) {
            let length = isString(how) ? how.length : how;
            let min = Math.min(this.offset, this.offset + length);
            let max = Math.max(this.offset, this.offset + length);
            if ((min < 0) || (min >= this.length) || (max < 0) || (max > this.length)) {
                throw "Unable to read between offsets " + min + " and " + max + " because length is " + this.length + "!";
            }
            let string = this.string.substring(min, max);
            if (isString(how)) {
                if (string !== how) {
                    throw "Expected \"" + how + "\" but read \"" + string + "\"!";
                }
            }
            return string;
        }
        read(how) {
            let string = this.peek(how);
            this.offset += string.length;
            return string;
        }
        seek(offset) {
            if ((offset < 0) || (offset >= this.length)) {
                throw "Unable to seek to offset " + offset + " because length is " + this.length + "!";
            }
            this.offset = offset;
        }
        skip(characters) {
            let string = "";
            while (!this.done()) {
                if (characters.indexOf(this.peek(1)) < 0) {
                    break;
                }
                string += this.read(1);
            }
            return string;
        }
        tell() {
            return this.offset;
        }
    }
    exports.Reader = Reader;
});
define("build/database/vtt/vtt", ["require", "exports", "build/database/vtt/reader"], function (require, exports, libreader) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    const DQ = "\"";
    function readString(reader, expected) {
        let string = reader.read(expected.length);
        if (string !== expected) {
            throw "Expected " + DQ + expected + DQ + " but read " + DQ + string + DQ + "!";
        }
    }
    function readBlank(reader) {
        let line = reader.line();
        if (line !== "") {
            throw "Expected a blank line but read " + DQ + line + DQ + "!";
        }
    }
    function readTimecode(reader) {
        let parts = null;
        if ((parts = /^([0-9][0-9])[:]([0-5][0-9])[:]([0-5][0-9])[.]([0-9][0-9][0-9])$/.exec(reader.peek(12))) != null) {
            reader.read(12);
            let hours = parseInt(parts[1], 10);
            let minutes = parseInt(parts[2], 10);
            let seconds = parseInt(parts[3], 10);
            let milliseconds = parseInt(parts[4], 10);
            return ((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds;
        }
        if ((parts = /^([0-5][0-9])[:]([0-5][0-9])[.]([0-9][0-9][0-9])$/.exec(reader.peek(9))) != null) {
            reader.read(9);
            let hours = 0;
            let minutes = parseInt(parts[1], 10);
            let seconds = parseInt(parts[2], 10);
            let milliseconds = parseInt(parts[3], 10);
            return ((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds;
        }
        console.log("Expected a valid timecode!");
        return 0;
    }
    function serializeTimecode(ms) {
        let s = Math.floor(ms / 1000);
        ms -= (s * 1000);
        let m = Math.floor(s / 60);
        s -= (m * 60);
        let h = Math.floor(m / 60);
        m -= (h * 60);
        let tch = `00${h}`.slice(-2);
        let tcm = `00${m}`.slice(-2);
        let tcs = `00${s}`.slice(-2);
        let tcms = `000${ms}`.slice(-3);
        return `${tch}:${tcm}:${tcs}.${tcms}`;
    }
    function readCue(reader) {
        let start_ms = readTimecode(reader);
        readString(reader, " --> ");
        let end_ms = readTimecode(reader);
        readBlank(reader);
        let duration_ms = end_ms - start_ms;
        if (duration_ms < 0) {
            console.log("Expected a positive duration but read " + start_ms + " and " + end_ms + "!");
        }
        let lines = new Array();
        while (true) {
            let line = reader.line();
            if (line === "") {
                break;
            }
            lines.push(line);
        }
        return {
            start_ms,
            duration_ms,
            lines
        };
    }
    function serializeCue(cue, options) {
        let lines = new Array();
        lines.push(serializeTimecode(cue.start_ms) + " --> " + serializeTimecode(cue.start_ms + cue.duration_ms));
        lines.push(...cue.lines);
        lines.push("");
        return lines.join(options.eol);
    }
    function readBody(reader) {
        let cues = new Array();
        while (!reader.done()) {
            let cue = readCue(reader);
            cues.push(cue);
        }
        cues = cues.sort((one, two) => one.start_ms - two.start_ms);
        return {
            cues
        };
    }
    function serializeBody(body, options) {
        let lines = new Array();
        for (let cue of body.cues) {
            lines.push(serializeCue(cue, options));
        }
        return lines.join(options.eol);
    }
    function readHead(reader) {
        readString(reader, "WEBVTT");
        let metadata = reader.line();
        readBlank(reader);
        return {
            metadata
        };
    }
    function serializeHead(head, options) {
        let lines = new Array();
        lines.push("WEBVTT " + head.metadata);
        lines.push("");
        return lines.join(options.eol);
    }
    function readTrack(reader) {
        let head = readHead(reader);
        let body = readBody(reader);
        return {
            head,
            body
        };
    }
    function serializeTrack(track, options) {
        let lines = new Array();
        lines.push(serializeHead(track.head, options));
        lines.push(serializeBody(track.body, options));
        return lines.join(options.eol);
    }
    function decode(string) {
        let reader = new libreader.Reader(string);
        return readTrack(reader);
    }
    exports.decode = decode;
    function encode(track) {
        return serializeTrack(track, {
            eol: "\r\n"
        });
    }
    exports.encode = encode;
});
define("build/database/probes/vtt", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "fs", "build/is", "build/database/vtt/vtt"], function (require, exports, autoguard, libfs, is, vtt) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    function probe(fd) {
        let result = {
            resources: []
        };
        let buffer = libfs.readFileSync(fd);
        let track = vtt.decode(buffer.toString());
        let cues = track.body.cues;
        let cue = cues.length > 0 ? cues[cues.length - 1] : undefined;
        let duration_ms = is.present(cue) ? cue.start_ms + cue.duration_ms : 0;
        let language;
        try {
            let json = JSON.parse(track.head.metadata);
            language = autoguard.guards.String.as(json.language);
        }
        catch (error) { }
        result.resources.push({
            type: "subtitle",
            duration_ms,
            language,
            cues
        });
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/index", ["require", "exports", "build/database/probes/jpeg", "build/database/probes/json", "build/database/probes/mp3", "build/database/probes/mp4", "build/database/probes/schema/index", "build/database/probes/vtt"], function (require, exports, jpeg, json, mp3, mp4, schema, vtt) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vtt = exports.schema = exports.mp4 = exports.mp3 = exports.json = exports.jpeg = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vtt = exports.schema = exports.mp4 = exports.mp3 = exports.json = exports.jpeg = void 0;
    exports.jpeg = jpeg;
    exports.json = json;
    exports.mp3 = mp3;
    exports.mp4 = mp4;
    exports.schema = schema;
    exports.vtt = vtt;
});
define("build/jdb2/asserts/integer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntegerAssert = void 0;
    class IntegerAssert {
        constructor() { }
        static atLeast(min, value) {
            this.integer(min);
            this.integer(value);
            if (value < min) {
                throw `Expected ${value} to be at least ${min}!`;
            }
            return value;
        }
        static atMost(max, value) {
            this.integer(value);
            this.integer(max);
            if (value > max) {
                throw `Expected ${value} to be at most ${max}!`;
            }
            return value;
        }
        static between(min, value, max) {
            this.integer(min);
            this.integer(value);
            this.integer(max);
            if (value < min || value > max) {
                throw `Expected ${value} to be between ${min} and ${max}!`;
            }
            return value;
        }
        static exactly(value, expected) {
            this.integer(expected);
            this.integer(value);
            if (value !== expected) {
                throw `Expected ${value} to be exactly ${expected}!`;
            }
            return value;
        }
        static integer(value) {
            if (!Number.isInteger(value)) {
                throw `Expected ${value} to be an integer!`;
            }
            return value;
        }
    }
    exports.IntegerAssert = IntegerAssert;
    ;
});
define("build/jdb/index", ["require", "exports", "crypto", "fs", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/is", "build/jsondb/index"], function (require, exports, libcrypto, libfs, autoguard, stdlib, is, jsondb_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Index = exports.IndexRecord = exports.IndexEntry = exports.IndexHeader = exports.Table = exports.RecordIndexEntry = exports.RecordIndexHeader = exports.StreamIterable = exports.computeHash = void 0;
    function computeHash(value) {
        return libcrypto.createHash("sha256")
            .update(String(value))
            .digest("hex")
            .slice(0, 16);
    }
    exports.computeHash = computeHash;
    function* filter(iterable, predicate) {
        let index = 0;
        for (let value of iterable) {
            if (predicate(value, index++)) {
                yield value;
            }
        }
    }
    function* include(iterable, predicate) {
        let index = 0;
        for (let value of iterable) {
            if (predicate(value, index++)) {
                yield value;
            }
        }
    }
    function* map(iterable, transform) {
        let index = 0;
        for (let value of iterable) {
            yield transform(value, index++);
        }
    }
    class StreamIterable {
        values;
        constructor(values) {
            this.values = values;
        }
        *[Symbol.iterator]() {
            //yield* this.values;
            for (let value of this.values) {
                yield value;
            }
        }
        collect() {
            return Array.from(this.values);
        }
        filter(predicate) {
            return new StreamIterable(filter(this.values, predicate));
        }
        find(predicate) {
            let index = 0;
            for (let value of this.values) {
                if (predicate(value, index++)) {
                    return value;
                }
            }
        }
        include(predicate) {
            return new StreamIterable(include(this.values, predicate));
        }
        includes(predicate) {
            let index = 0;
            for (let value of this.values) {
                if (predicate(value, index++)) {
                    return true;
                }
            }
            return false;
        }
        map(transform) {
            return new StreamIterable(map(this.values, transform));
        }
        shift() {
            for (let value of this.values) {
                return value;
            }
        }
        slice(start, end) {
            let array = this.collect().slice(start, end);
            return new StreamIterable(array);
        }
        sort(comparator) {
            let array = this.collect().sort(comparator);
            return new StreamIterable(array);
        }
        unique() {
            return new StreamIterable(new Set(this.values));
        }
        static of(values) {
            return new StreamIterable(values ?? new Array());
        }
    }
    exports.StreamIterable = StreamIterable;
    ;
    function readBuffer(fd, buffer, position) {
        let bytes = libfs.readSync(fd, buffer, 0, buffer.length, position ?? null);
        if (bytes !== buffer.length) {
            throw `Expected to read ${buffer.length} bytes but read ${bytes}!`;
        }
        return buffer;
    }
    function writeBuffer(fd, buffer, position) {
        let bytes = libfs.writeSync(fd, buffer, 0, buffer.length, position ?? null);
        if (bytes !== buffer.length) {
            throw `Expected to write ${buffer.length} bytes but wrote ${bytes}!`;
        }
        return buffer;
    }
    class RecordIndexHeader {
        buffer;
        get identifier() {
            return this.buffer.slice(0, 8).toString("binary");
        }
        get chunk_size_minus_one() {
            return this.buffer.readUInt32BE(8);
        }
        set chunk_size_minus_one(value) {
            this.buffer.writeUInt32BE(value, 8);
        }
        get chunk_size() {
            return this.chunk_size_minus_one + 1;
        }
        set chunk_size(value) {
            this.chunk_size_minus_one = value - 1;
        }
        constructor() {
            let buffer = Buffer.alloc(16);
            buffer.write("\x23\x52\xDB\x07\xEC\x77\x30\x61", 0, "binary");
            buffer.writeUInt32BE(63, 8);
            this.buffer = buffer;
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
            let identifier = this.buffer.slice(0, 8).toString("binary");
            if (identifier !== this.identifier) {
                throw `Unsupported file format!`;
            }
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.RecordIndexHeader = RecordIndexHeader;
    ;
    class RecordIndexEntry {
        buffer;
        get key() {
            return this.buffer.slice(0, 8).toString("hex");
        }
        set key(value) {
            if (!/^[0-9a-f]{16}$/.test(value)) {
                throw `Invalid key, ${value}!`;
            }
            this.buffer.set(Buffer.from(value, "hex"), 0);
        }
        get chunk_offset() {
            return this.buffer.readUInt32BE(8);
        }
        set chunk_offset(value) {
            this.buffer.writeUInt32BE(value, 8);
        }
        get chunk_length_minus_one() {
            return this.buffer.readUInt32BE(12);
        }
        set chunk_length_minus_one(value) {
            this.buffer.writeUInt32BE(value, 12);
        }
        get chunk_length() {
            return this.chunk_length_minus_one + 1;
        }
        set chunk_length(value) {
            this.chunk_length_minus_one = value - 1;
        }
        constructor() {
            let buffer = Buffer.alloc(16);
            this.buffer = buffer;
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.RecordIndexEntry = RecordIndexEntry;
    ;
    class Table {
        toc;
        bin;
        header;
        indexFromKey; // 70k elements tar 5mb, 2195857 elements tar 170mb
        router;
        guard;
        key_provider;
        cache;
        free_entries;
        getNumberOfEntries() {
            let entry_count = libfs.fstatSync(this.toc).size / 16 - 1;
            if (!Number.isInteger(entry_count)) {
                throw `Expected a non-fractional number of entries!`;
            }
            return entry_count;
        }
        readEntry(index, entry) {
            entry.read(this.toc, 16 + index * 16);
            return entry;
        }
        getEntryFor(chunk_length, key) {
            let entry = new RecordIndexEntry();
            for (let entry_index of this.free_entries) {
                this.readEntry(entry_index, entry);
                if (entry.chunk_length >= chunk_length || entry_index === this.getNumberOfEntries() - 1) {
                    this.free_entries.delete(entry_index);
                    entry.key = key;
                    entry.chunk_length = Math.max(entry.chunk_length, chunk_length);
                    entry.write(this.toc, 16 + entry_index * 16);
                    return entry_index;
                }
            }
            let entry_index = this.getNumberOfEntries();
            entry.chunk_offset = Math.ceil(libfs.fstatSync(this.bin).size / this.header.chunk_size);
            entry.chunk_length = chunk_length;
            entry.key = key;
            entry.write(this.toc, 16 + entry_index * 16);
            return entry_index;
        }
        getRecord(index) {
            let record = this.cache.get(index);
            if (is.present(record)) {
                this.cache.delete(index);
                this.cache.set(index, record);
                return record;
            }
            let entry = new RecordIndexEntry();
            this.readEntry(index, entry);
            if (entry.key === "0000000000000000") {
                throw `Expected ${index} to match a record!`;
            }
            let position = entry.chunk_offset * this.header.chunk_size;
            let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
            readBuffer(this.bin, buffer, position);
            let end = buffer.length;
            while (end > 0) {
                if (buffer[end - 1] !== 0) {
                    break;
                }
                end -= 1;
            }
            let string = buffer.toString("utf8", 0, end);
            let json = JSON.parse(string);
            record = this.guard.as(json);
            this.cache.set(index, record);
            if (this.cache.size > 10000) {
                for (let idx of this.cache.keys()) {
                    this.cache.delete(idx);
                    break;
                }
            }
            return record;
        }
        insertOrUpdate(next) {
            let key = this.key_provider(next);
            let string = JSON.stringify(next);
            let binary = new TextEncoder().encode(string);
            let chunks = Math.max(1, Math.ceil(binary.length / this.header.chunk_size));
            let index = this.indexFromKey[key];
            if (is.present(index)) {
                let last = this.getRecord(index);
                let entry = this.readEntry(index, new RecordIndexEntry());
                if (chunks <= entry.chunk_length) {
                    let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    buffer.set(binary, 0);
                    writeBuffer(this.bin, buffer, entry.chunk_offset * this.header.chunk_size);
                }
                else {
                    let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    writeBuffer(this.bin, buffer, entry.chunk_offset * this.header.chunk_size);
                    delete this.indexFromKey[key];
                    entry.key = "0000000000000000";
                    entry.write(this.toc, 16 + index * 16);
                    this.free_entries.add(index);
                    index = this.getEntryFor(chunks * 2, key);
                    entry = this.readEntry(index, new RecordIndexEntry());
                    let buffer2 = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    buffer2.set(binary, 0);
                    writeBuffer(this.bin, buffer2, entry.chunk_offset * this.header.chunk_size);
                    this.indexFromKey[key] = index;
                }
                this.cache.delete(index);
                this.cache.set(index, next);
                this.router.route("update", {
                    last: last,
                    next: next
                });
                return;
            }
            index = this.getEntryFor(chunks, key);
            let entry = this.readEntry(index, new RecordIndexEntry());
            let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
            buffer.set(binary, 0);
            writeBuffer(this.bin, buffer, entry.chunk_offset * this.header.chunk_size);
            this.indexFromKey[key] = index;
            this.cache.set(index, next);
            this.router.route("insert", {
                next: next
            });
        }
        constructor(root, table_name, guard, key_provider) {
            let directory = [...root, table_name];
            if (!libfs.existsSync(directory.join("/"))) {
                libfs.mkdirSync(directory.join("/"), { recursive: true });
            }
            let toc_filename = [...directory, "toc"];
            let toc_exists = libfs.existsSync(toc_filename.join("/"));
            let toc = libfs.openSync(toc_filename.join("/"), toc_exists ? "r+" : "w+");
            let bin_filename = [...directory, "bin"];
            let bin_exists = libfs.existsSync(bin_filename.join("/"));
            let bin = libfs.openSync(bin_filename.join("/"), bin_exists ? "r+" : "w+");
            let indexFromKey = {};
            let header = new RecordIndexHeader();
            let free_entries = new Set();
            if (toc_exists) {
                header.read(toc, 0);
                let entry_count = libfs.fstatSync(toc).size / 16 - 1;
                if (!Number.isInteger(entry_count)) {
                    throw `Expected a non-fractional number of entries!`;
                }
                let entry = new RecordIndexEntry();
                for (let index = 0; index < entry_count; index++) {
                    entry.read(toc, 16 + index * 16);
                    if (entry.key !== "0000000000000000") {
                        indexFromKey[entry.key] = index;
                    }
                    else {
                        free_entries.add(index);
                    }
                }
            }
            else {
                header.write(toc, 0);
            }
            this.toc = toc;
            this.bin = bin;
            this.header = header;
            this.indexFromKey = indexFromKey;
            this.router = new stdlib.routing.MessageRouter();
            this.guard = guard;
            this.key_provider = key_provider;
            this.cache = new Map();
            this.free_entries = free_entries;
        }
        destroy() {
            libfs.closeSync(this.toc);
            libfs.closeSync(this.bin);
        }
        *[Symbol.iterator]() {
            for (let index = 0; index < this.getNumberOfEntries(); index++) {
                try {
                    yield this.getRecord(index);
                }
                catch (error) { }
            }
        }
        insert(record) {
            this.insertOrUpdate(record);
        }
        keyof(record) {
            return this.key_provider(record);
        }
        length() {
            return this.getNumberOfEntries();
        }
        lookup(key) {
            let index = this.indexFromKey[key ?? "0000000000000000"];
            if (is.present(index)) {
                let record = this.getRecord(index);
                if (this.key_provider(record) === key) {
                    return record;
                }
            }
            throw `Expected ${key} to match a record!`;
        }
        on(type, listener) {
            this.router.addObserver(type, listener);
        }
        off(type, listener) {
            this.router.addObserver(type, listener);
        }
        remove(record) {
            let key = this.key_provider(record);
            let index = this.indexFromKey[key];
            if (is.present(index)) {
                let last = this.getRecord(index);
                if (this.key_provider(last) === key) {
                    let entry = this.readEntry(index, new RecordIndexEntry());
                    let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    let position = entry.chunk_offset * this.header.chunk_size;
                    writeBuffer(this.bin, buffer, position);
                    this.cache.delete(index);
                    delete this.indexFromKey[key];
                    entry.key = Buffer.alloc(8).toString("hex");
                    entry.write(this.toc, 16 + index * 16);
                    this.free_entries.add(index);
                    this.router.route("remove", {
                        last: last
                    });
                }
            }
        }
        update(record) {
            this.insertOrUpdate(record);
        }
    }
    exports.Table = Table;
    ;
    class IndexHeader {
        buffer;
        get identifier() {
            return this.buffer.slice(0, 8).toString("binary");
        }
        constructor() {
            let buffer = Buffer.alloc(16);
            buffer.write("\x01\xfb\x2e\x28\x8a\xa7\x98\x76", 0, "binary");
            this.buffer = buffer;
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
            let identifier = this.buffer.slice(0, 8).toString("binary");
            if (identifier !== this.identifier) {
                throw `Unsupported file format!`;
            }
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.IndexHeader = IndexHeader;
    ;
    class IndexEntry {
        buffer;
        get hash() {
            return this.buffer.slice(0, 8).toString("hex");
        }
        set hash(value) {
            if (!/^[0-9a-f]{16}$/.test(value)) {
                throw `Invalid group key, ${value}!`;
            }
            this.buffer.set(Buffer.from(value, "hex"), 0);
        }
        get key() {
            return this.buffer.slice(8, 8 + 8).toString("hex");
        }
        set key(value) {
            if (!/^[0-9a-f]{16}$/.test(value)) {
                throw `Invalid key, ${value}!`;
            }
            this.buffer.set(Buffer.from(value, "hex"), 8);
        }
        get is_free() {
            return /^[0]{16}$/.test(this.buffer.toString("hex"));
        }
        set is_free(value) {
            if (value) {
                this.buffer.fill(0);
            }
        }
        constructor() {
            let buffer = Buffer.alloc(16);
            this.buffer = buffer;
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.IndexEntry = IndexEntry;
    ;
    exports.IndexRecord = autoguard.guards.Object.of({
        id: autoguard.guards.String,
        keys: autoguard.guards.Array.of(autoguard.guards.String)
    });
    function computePosition(key, keys, lower = 0, upper = keys.length - 1) {
        let length = upper - lower + 1;
        let index = lower + Math.floor(length / 2);
        if (length > 0) {
            let compareKey = keys[index];
            if (key < compareKey) {
                return computePosition(key, keys, lower, index - 1);
            }
            if (key > compareKey) {
                return computePosition(key, keys, index + 1, upper);
            }
        }
        return index;
    }
    function insert(key, keys) {
        let position = computePosition(key, keys);
        if (keys[position] !== key) {
            keys.splice(position, 0, key);
        }
    }
    function remove(key, keys) {
        let position = computePosition(key, keys);
        if (keys[position] === key) {
            keys.splice(position, 1);
        }
    }
    class Index {
        table;
        getRecordFromKey;
        getValues;
        getKey;
        getTokensFromValue;
        maxGroupSize;
        constructor(root, index_name, getRecordFromKey, getValues, getRecordKey, getQueryTokens, maxGroupSize) {
            this.table = new Table(root, index_name, exports.IndexRecord, (record) => record.id);
            this.getRecordFromKey = getRecordFromKey;
            this.getValues = getValues;
            this.getKey = getRecordKey;
            this.getTokensFromValue = getQueryTokens;
            this.maxGroupSize = maxGroupSize;
        }
        insert(record) {
            let key = this.getKey(record);
            for (let value of this.getValues(record)) {
                for (let token of this.getTokensFromValue(value)) {
                    let hash = computeHash(token);
                    let record;
                    try {
                        record = this.table.lookup(hash);
                    }
                    catch (error) { }
                    if (is.absent(record)) {
                        record = {
                            id: hash,
                            keys: []
                        };
                    }
                    let keys = record.keys;
                    if (is.present(this.maxGroupSize) && keys.length >= this.maxGroupSize) {
                        continue;
                    }
                    let position = computePosition(key, keys);
                    if (keys[position] !== key) {
                        keys.splice(position, 0, key);
                        this.table.update(record);
                    }
                }
            }
        }
        length() {
            return this.table.length();
        }
        lookup(value) {
            return this.search(value).map((result) => this.getRecordFromKey(result.id));
        }
        remove(record) {
            let key = this.getKey(record);
            for (let value of this.getValues(record)) {
                for (let token of this.getTokensFromValue(value)) {
                    let hash = computeHash(token);
                    let keys = new Array();
                    try {
                        let record = this.table.lookup(hash);
                        keys = record.keys;
                    }
                    catch (error) { }
                    let position = computePosition(key, keys);
                    if (keys[position] === key) {
                        keys.splice(position, 1);
                        if (keys.length > 0) {
                            this.table.update({
                                id: hash,
                                keys: keys
                            });
                        }
                        else {
                            this.table.remove({
                                id: hash,
                                keys: keys
                            });
                        }
                    }
                }
            }
        }
        search(value) {
            let tokens = this.getTokensFromValue(value);
            let records = tokens
                .map((token) => computeHash(token))
                .map((hash) => {
                try {
                    return this.table.lookup(hash);
                }
                catch (error) { }
            })
                .filter(is.present);
            let map = new Map();
            for (let record of records) {
                for (let key of record.keys) {
                    let rank = map.get(key) ?? (0 - tokens.length);
                    map.set(key, rank + 2);
                }
            }
            return StreamIterable.of(map.entries())
                .filter((entry) => entry[1] >= 0)
                .sort(jsondb_1.sorters.NumericSort.decreasing((entry) => entry[1]))
                .map((entry) => ({
                id: entry[0],
                rank: entry[1]
            }));
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static NUMBER_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            return Array.from(normalized.match(/(\p{N}+)/gu) ?? []);
        };
        static QUERY_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
        };
        static VALUE_TOKENIZER = (value) => {
            return [value];
        };
        static WORD_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            return Array.from(normalized.match(/(\p{L}+)/gu) ?? []);
        };
    }
    exports.Index = Index;
    ;
});
define("build/jdb2/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.IndexRecord = void 0;
    exports.IndexRecord = autoguard.guards.Object.of({
        "index": autoguard.guards.Number
    }, {
        "token": autoguard.guards.Union.of(autoguard.guards.Boolean, autoguard.guards.Null, autoguard.guards.Number, autoguard.guards.String, autoguard.guards.Undefined)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "IndexRecord": autoguard.guards.Reference.of(() => exports.IndexRecord)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/jdb2/index", ["require", "exports", "crypto", "fs", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/is", "build/jdb2/asserts/integer", "build/jdb/index", "build/jsondb/index", "build/jdb2/schema/index"], function (require, exports, libcrypto, libfs, stdlib, is, integer_1, jdb_1, jsondb_1, schema_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /*
    [v1]
        latency shows: 160 ms
        files table: 6191 kB + 431 kB
        indices: 9 MB
        tables: 15 MB
    
    [8bit branch, 32bit pointers]
        latency shows: 290 ms
        files table: 10272 kB + 747 kB
        indices: 178 MB
        tables: 35 MB
    
    [4bit branch, 32bit pointers]
        latency shows: 240 ms
        files table: 6482 kB + 807 kB
        indices: 23 MB
        tables: 20 MB
    
    [4bit branch, 32bit pointers + rhh]
        latency shows: 230 ms
        files table: 6482 kB + 807 kB
        indices: 14 MB
        tables: 20 MB
    
    [rhh + rhh]
        latency shows: 230 ms
        files table: 5823 kB + 431 kB
        indices: 11 MB
        tables: 16 MB
    */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Index = exports.RobinHoodHash = exports.Table = exports.deserializeKey = exports.serializeKey = exports.bytesFromNibbles = exports.nibblesFromBytes = exports.computeCommonPrefixLength = exports.NodeTable = exports.Node = exports.BlockHandler = exports.Cache = exports.Entry = exports.Pointer = exports.Counter = exports.Chunk = exports.write = exports.size = exports.read = exports.open = void 0;
    const DEBUG = false;
    function open(path) {
        let filename = path.join("/");
        let exists = libfs.existsSync(filename);
        libfs.mkdirSync(path.slice(0, -1).join("/"), { recursive: true });
        let fd = libfs.openSync(filename, exists ? "r+" : "w+");
        return fd;
    }
    exports.open = open;
    ;
    function read(fd, buffer, offset) {
        let length = buffer.length;
        let bytes = libfs.readSync(fd, buffer, {
            position: offset
        });
        if (bytes !== length) {
            throw `Expected to read ${length} bytes but read ${bytes}!`;
        }
        return buffer;
    }
    exports.read = read;
    ;
    function size(fd) {
        return libfs.fstatSync(fd).size;
    }
    exports.size = size;
    ;
    function write(fd, buffer, offset) {
        let length = buffer.length;
        let bytes = libfs.writeSync(fd, buffer, 0, length, offset);
        if (bytes !== length) {
            throw `Expected to write ${length} bytes but wrote ${bytes}!`;
        }
        return buffer;
    }
    exports.write = write;
    ;
    class Chunk {
        buffer;
        constructor(buffer) {
            this.buffer = buffer;
        }
        load(fd, offset) {
            read(fd, this.buffer, offset);
        }
        save(fd, offset) {
            write(fd, this.buffer, offset);
        }
    }
    exports.Chunk = Chunk;
    ;
    class Counter extends Chunk {
        static SIZE = 4;
        get count() {
            return this.buffer.readUInt32BE(0);
        }
        set count(value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
            this.buffer.writeUInt32BE(value, 0);
        }
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Counter.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Counter.SIZE);
            super(buffer);
        }
    }
    exports.Counter = Counter;
    ;
    class Pointer extends Chunk {
        static SIZE = 4;
        get index() {
            return this.buffer.readUInt32BE(0);
        }
        set index(value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
            this.buffer.writeUInt32BE(value, 0);
        }
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Pointer.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Pointer.SIZE);
            super(buffer);
        }
    }
    exports.Pointer = Pointer;
    ;
    class Entry extends Chunk {
        static SIZE = 16;
        get offset() {
            return Number(this.buffer.readBigUInt64BE(0));
        }
        set offset(value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFFFFFF);
            this.buffer.writeBigUInt64BE(BigInt(value), 0);
        }
        get deleted() {
            return this.buffer.readUInt8(8) === 0x80;
        }
        set deleted(value) {
            this.buffer.writeUInt8(value ? 0x80 : 0x00, 8);
        }
        get length() {
            return Number(this.buffer.readBigUInt64BE(8) & BigInt(0xFFFFFFFFFFFF)) + 1;
        }
        set length(value) {
            value = value - 1;
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFFFFFF);
            let deleted = this.deleted;
            this.buffer.writeBigUInt64BE(BigInt(value), 8);
            this.deleted = deleted;
        }
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Entry.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Entry.SIZE);
            super(buffer);
        }
    }
    exports.Entry = Entry;
    ;
    class Cache {
        map;
        weightProvider;
        maxWeight;
        weight;
        purge() {
            if (is.present(this.maxWeight)) {
                for (let [key, last] of this.map.entries()) {
                    if (this.weight <= this.maxWeight) {
                        break;
                    }
                    this.weight -= this.weightProvider(last);
                    this.map.delete(key);
                }
            }
        }
        constructor(weightProvider, maxWeight) {
            this.map = new Map();
            this.weightProvider = weightProvider;
            this.maxWeight = maxWeight;
            this.weight = 0;
        }
        insert(key, value) {
            this.remove(key);
            if (is.present(value)) {
                this.weight += this.weightProvider(value);
                this.map.set(key, value);
                this.purge();
            }
        }
        length() {
            return this.map.size;
        }
        lookup(key) {
            return this.map.get(key);
        }
        remove(key) {
            let value = this.map.get(key);
            if (is.present(value)) {
                this.weight -= this.weightProvider(value);
                this.map.delete(key);
            }
            return value;
        }
    }
    exports.Cache = Cache;
    ;
    class BlockHandler {
        static FIRST_APPLICATION_BLOCK = 64;
        bin;
        toc;
        blockCache;
        entryCache;
        inBatchOperation;
        close() {
            libfs.closeSync(this.bin);
            libfs.closeSync(this.toc);
        }
        computePool(minLength) {
            if (DEBUG)
                integer_1.IntegerAssert.atLeast(0, minLength);
            let lengthLog2 = Math.ceil(Math.log2(Math.max(1, minLength)));
            return lengthLog2;
        }
        createNewBlock(minLength) {
            let entry = new Entry();
            entry.offset = size(this.bin);
            entry.length = Math.pow(2, this.computePool(minLength));
            write(this.bin, Buffer.alloc(entry.length), entry.offset);
            write(this.toc, entry.buffer, size(this.toc));
            return this.getCount() - 1;
        }
        createOldBlock(minLength) {
            let pool = this.computePool(minLength);
            let counter = new Counter();
            this.readBlock(pool, counter.buffer, 0);
            if (counter.count === 0) {
                throw ``;
            }
            let pointer = new Pointer();
            this.readBlock(pool, pointer.buffer, Counter.SIZE + (counter.count - 1) * Pointer.SIZE);
            let index = pointer.index;
            pointer.index = 0;
            this.writeBlock(pool, pointer.buffer, Counter.SIZE + (counter.count - 1) * Pointer.SIZE);
            counter.count -= 1;
            this.writeBlock(pool, counter.buffer, 0);
            let entry = new Entry();
            this.readEntry(index, entry);
            entry.deleted = false;
            this.writeEntry(index, entry);
            return index;
        }
        readEntry(index, entry) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, index, this.getCount() - 1);
            let cached = this.entryCache.lookup(index);
            if (is.absent(cached)) {
                cached = new Entry();
                read(this.toc, cached.buffer, index * Entry.SIZE);
                this.entryCache.insert(index, cached);
            }
            cached.buffer.copy(entry.buffer, 0, 0);
            return entry;
        }
        writeEntry(index, entry) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, index, this.getCount() - 1);
            write(this.toc, entry.buffer, index * Entry.SIZE);
            let cached = new Entry();
            entry.buffer.copy(cached.buffer, 0, 0);
            this.entryCache.insert(index, cached);
            return entry;
        }
        constructor(path) {
            this.bin = open([...path, "bin"]);
            this.toc = open([...path, "toc"]);
            this.blockCache = new Cache((value) => value.length, 512 * 1024 * 1024);
            this.entryCache = new Cache((value) => 1, 1 * 1000 * 1000);
            this.inBatchOperation = new Set();
            if (this.getCount() === 0) {
                for (let i = 0; i < BlockHandler.FIRST_APPLICATION_BLOCK; i++) {
                    this.createNewBlock(16);
                }
            }
        }
        batchOperation(index, operation) {
            if (this.inBatchOperation.has(index)) {
                throw `Expected block ${index} to be in normal operation!`;
            }
            this.inBatchOperation.add(index);
            try {
                operation();
            }
            catch (error) {
                this.inBatchOperation.delete(index);
                throw error;
            }
            this.inBatchOperation.delete(index);
            let buffer = this.readBlock(index);
            this.writeBlock(index, buffer);
        }
        clearBlock(index) {
            this.writeBlock(index, Buffer.alloc(0));
        }
        cloneBlock(index) {
            let buffer = this.readBlock(index);
            let indexTwo = this.createBlock(buffer.length);
            this.writeBlock(indexTwo, buffer);
            return indexTwo;
        }
        createBlock(minLength) {
            if (minLength === 0) {
                return 0xFFFFFFFF;
            }
            try {
                return this.createOldBlock(minLength);
            }
            catch (error) { }
            try {
                return this.createNewBlock(minLength);
            }
            catch (error) { }
            throw `Unable to create block with length ${minLength}!`;
        }
        deleteBlock(index) {
            if (index === 0xFFFFFFFF) {
                return;
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            if (entry.deleted) {
                return;
            }
            let pool = this.computePool(entry.length);
            let counter = new Counter();
            this.readBlock(pool, counter.buffer, 0);
            let minLength = Counter.SIZE + (counter.count + 1) * Pointer.SIZE;
            let length = this.readEntry(pool, new Entry()).length;
            if (minLength > length) {
                this.resizeBlock(pool, minLength);
                this.readBlock(pool, counter.buffer, 0); // Resize can in theory consume one block.
            }
            let pointer = new Pointer();
            pointer.index = index;
            this.writeBlock(pool, pointer.buffer, Counter.SIZE + (counter.count * Pointer.SIZE));
            counter.count += 1;
            this.writeBlock(pool, counter.buffer, 0);
            let buffer = Buffer.alloc(entry.length);
            this.writeBlock(index, buffer, 0);
            entry.deleted = true;
            this.writeEntry(index, entry);
            this.blockCache.remove(index);
            this.inBatchOperation.delete(index);
        }
        getBlockSize(index) {
            if (index === 0xFFFFFFFF) {
                return 0;
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            return entry.length;
        }
        getCount() {
            let count = size(this.toc) / Entry.SIZE;
            if (DEBUG)
                integer_1.IntegerAssert.atLeast(0, count);
            return count;
        }
        readBlock(index, buffer, skipLength) {
            if (index === 0xFFFFFFFF) {
                return Buffer.alloc(0);
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            buffer = buffer ?? Buffer.alloc(entry.length);
            let offset = skipLength ?? 0;
            let length = buffer.length;
            if (DEBUG)
                integer_1.IntegerAssert.between(0, offset, entry.length - 1);
            if (DEBUG)
                integer_1.IntegerAssert.between(0, length, entry.length - offset);
            let cached = this.blockCache.lookup(index);
            if (is.absent(cached)) {
                cached = Buffer.alloc(entry.length);
                read(this.bin, cached, entry.offset);
                this.blockCache.insert(index, cached);
            }
            cached.copy(buffer, 0, offset);
            return buffer;
        }
        resizeBlock(index, minLength) {
            if (index === 0xFFFFFFFF) {
                return;
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            if (this.computePool(minLength) === this.computePool(entry.length)) {
                return;
            }
            let indexTwo = this.createBlock(minLength);
            let entryTwo = new Entry();
            this.readEntry(indexTwo, entryTwo);
            let length = Math.min(entry.length, entryTwo.length);
            let buffer = Buffer.alloc(length);
            this.readBlock(index, buffer);
            this.writeBlock(indexTwo, buffer, 0);
            this.swapBlocks(index, indexTwo);
            this.deleteBlock(indexTwo);
        }
        swapBlocks(indexOne, indexTwo) {
            let entryOne = new Entry();
            this.readEntry(indexOne, entryOne);
            let entryTwo = new Entry();
            this.readEntry(indexTwo, entryTwo);
            this.writeEntry(indexOne, entryTwo);
            this.writeEntry(indexTwo, entryOne);
            let blockOne = this.blockCache.remove(indexOne);
            let blockTwo = this.blockCache.remove(indexTwo);
            this.blockCache.insert(indexOne, blockTwo);
            this.blockCache.insert(indexTwo, blockOne);
        }
        writeBlock(index, buffer, skipLength) {
            if (index === 0xFFFFFFFF) {
                return Buffer.alloc(0);
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            buffer = buffer ?? Buffer.alloc(entry.length);
            let offset = skipLength ?? 0;
            let length = buffer.length;
            if (DEBUG)
                integer_1.IntegerAssert.between(0, offset, entry.length - 1);
            if (DEBUG)
                integer_1.IntegerAssert.between(0, length, entry.length - offset);
            let cached = this.blockCache.lookup(index);
            if (is.absent(cached)) {
                cached = this.readBlock(index);
                this.blockCache.insert(index, cached);
            }
            cached.set(buffer, offset);
            if (is.absent(skipLength)) {
                cached.set(Buffer.alloc(entry.length - buffer.length), buffer.length);
            }
            if (!this.inBatchOperation.has(index)) {
                write(this.bin, buffer, entry.offset + offset);
                if (is.absent(skipLength)) {
                    write(this.bin, Buffer.alloc(entry.length - buffer.length), entry.offset + buffer.length);
                }
            }
            return buffer;
        }
    }
    exports.BlockHandler = BlockHandler;
    ;
    class Node extends Chunk {
        static MAX_NIBBLES = 15;
        static SIZE = 8 + 8;
        prefix(value) {
            if (is.present(value)) {
                let length = value.length;
                if (DEBUG)
                    integer_1.IntegerAssert.between(0, length, Node.MAX_NIBBLES);
                let bytes = bytesFromNibbles(Buffer.of(length, ...value));
                this.buffer.set(bytes, 0);
                this.buffer.fill(0, bytes.length, 8);
                return value;
            }
            else {
                let bytes = this.buffer.slice(0, 8);
                let nibbles = nibblesFromBytes(bytes);
                let length = nibbles[0];
                return nibbles.slice(1, 1 + length);
            }
        }
        resident(value) {
            let offset = 8;
            if (is.present(value)) {
                if (DEBUG)
                    integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
                this.buffer.writeUInt32BE(value, offset);
                return value;
            }
            else {
                return this.buffer.readUInt32BE(offset);
            }
        }
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Node.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Node.SIZE);
            super(buffer);
        }
    }
    exports.Node = Node;
    ;
    class NodeTable extends Chunk {
        static LENGTH = 16;
        static SIZE = NodeTable.LENGTH * 4;
        subtree(index, value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, index, NodeTable.LENGTH - 1);
            let offset = index * 4;
            if (is.present(value)) {
                if (DEBUG)
                    integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
                this.buffer.writeUInt32BE(value, offset);
                return value;
            }
            else {
                return this.buffer.readUInt32BE(offset);
            }
        }
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(NodeTable.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, NodeTable.SIZE);
            super(buffer);
        }
    }
    exports.NodeTable = NodeTable;
    ;
    function computeCommonPrefixLength(prefixBytes, keyBytes, keyByteIndex) {
        let length = Math.min(prefixBytes.length, keyBytes.length - keyByteIndex);
        for (let i = 0; i < length; i++) {
            let prefixByte = prefixBytes[i];
            let keyByte = keyBytes[keyByteIndex + i];
            if (prefixByte !== keyByte) {
                return i;
            }
        }
        return length;
    }
    exports.computeCommonPrefixLength = computeCommonPrefixLength;
    ;
    function nibblesFromBytes(bytes) {
        let nibbles = new Array();
        for (let byte of bytes) {
            nibbles.push((byte >> 4) & 0x0F, (byte >> 0) & 0x0F);
        }
        return Buffer.from(nibbles);
    }
    exports.nibblesFromBytes = nibblesFromBytes;
    ;
    function bytesFromNibbles(nibbles) {
        let bytes = new Array();
        for (let i = 0; i < nibbles.length; i += 2) {
            bytes.push((nibbles[i + 0] << 4) | (nibbles[i + 1] << 0));
        }
        return Buffer.from(bytes);
    }
    exports.bytesFromNibbles = bytesFromNibbles;
    ;
    function serializeKey(key) {
        if (typeof key === "boolean") {
            return Buffer.of(key ? 1 : 0);
        }
        if (typeof key === "number") {
            return Buffer.from(`${key}`);
        }
        if (typeof key === "string") {
            if (/^[0-9a-f]{8,}$/i.test(key)) {
                return Buffer.from(key, "hex");
            }
            else {
                return Buffer.from(key, "binary");
            }
        }
        return Buffer.alloc(0);
    }
    exports.serializeKey = serializeKey;
    ;
    function deserializeKey(bytes) {
        return bytes.toString("binary");
    }
    exports.deserializeKey = deserializeKey;
    ;
    class Table extends stdlib.routing.MessageRouter {
        recordCache;
        blockHandler;
        recordParser;
        keyProvider;
        hashTable;
        debug() {
            this.hashTable.debug();
        }
        constructor(blockHandler, recordParser, keyProvider) {
            super();
            if (blockHandler.getCount() === BlockHandler.FIRST_APPLICATION_BLOCK) {
                blockHandler.createBlock(RobinHoodHash.INITIAL_SIZE);
            }
            this.recordCache = new Cache((record) => 1, 1 * 1000 * 1000);
            this.blockHandler = blockHandler;
            this.recordParser = recordParser;
            this.keyProvider = keyProvider;
            this.hashTable = new RobinHoodHash(blockHandler, BlockHandler.FIRST_APPLICATION_BLOCK, (index) => {
                let record = this.getRecord(index);
                return this.keyProvider(record);
            });
        }
        close() {
            this.blockHandler.close();
        }
        *[Symbol.iterator]() {
            yield* jdb_1.StreamIterable.of(this.hashTable)
                .map((value) => this.getRecord(value));
        }
        getRecord(index) {
            let record = this.recordCache.lookup(index);
            if (is.present(record)) {
                return record;
            }
            let block = this.blockHandler.readBlock(index);
            let string = block.toString().replace(/[\0]*$/, "");
            let json = JSON.parse(string);
            record = this.recordParser(json);
            this.recordCache.insert(index, record);
            return record;
        }
        entries() {
            return jdb_1.StreamIterable.of(this.hashTable)
                .map((index) => {
                let record = this.getRecord(index);
                let key = this.keyProvider(record);
                return [key, index, record];
            })
                .slice();
        }
        insert(next) {
            let bytes = Buffer.from(JSON.stringify(next));
            let key = this.keyProvider(next);
            let index = this.hashTable.lookup(key);
            if (is.absent(index)) {
                index = this.blockHandler.createBlock(bytes.length);
                this.blockHandler.writeBlock(index, bytes);
                this.hashTable.insert(key, index);
                this.recordCache.insert(index, next);
                this.route("insert", {
                    key: key,
                    index: index,
                    record: next
                });
            }
            else {
                let last = this.getRecord(index);
                this.blockHandler.resizeBlock(index, bytes.length);
                this.blockHandler.writeBlock(index, bytes);
                this.recordCache.insert(index, next);
                this.route("update", {
                    key: key,
                    index: index,
                    last: last,
                    next: next
                });
            }
        }
        length() {
            return this.hashTable.length();
        }
        lookup(key) {
            let index = this.hashTable.lookup(key);
            if (is.absent(index)) {
                throw `Expected a record for ${key}!`;
            }
            let record = this.getRecord(index);
            return record;
        }
        remove(next) {
            let key = this.keyProvider(next);
            let index = this.hashTable.lookup(key);
            if (is.absent(index)) {
                return;
            }
            this.route("remove", {
                key: key,
                index: index,
                record: next
            });
            this.hashTable.remove(key);
            this.blockHandler.deleteBlock(index);
            this.recordCache.remove(index);
        }
        update(next) {
            this.insert(next);
        }
    }
    exports.Table = Table;
    ;
    class RobinHoodHash {
        static INITIAL_SIZE = 16 + (2 * 8);
        blockHandler;
        blockIndex;
        keyFromIndexProvider;
        constructor(blockHandler, blockIndex, keyFromIndexProvider) {
            this.blockHandler = blockHandler;
            this.blockIndex = blockIndex;
            this.keyFromIndexProvider = keyFromIndexProvider;
        }
        readHeader() {
            let buffer = Buffer.alloc(16);
            this.blockHandler.readBlock(this.blockIndex, buffer, 0);
            let occupiedSlots = buffer.readUIntBE(2, 6);
            return {
                occupiedSlots
            };
        }
        writeHeader(header) {
            let buffer = Buffer.alloc(16);
            buffer.writeUIntBE(header.occupiedSlots, 2, 6);
            this.blockHandler.writeBlock(this.blockIndex, buffer, 0);
        }
        getSlotCount() {
            let blockSize = this.blockHandler.getBlockSize(this.blockIndex);
            return Math.floor((blockSize - 16) / 8);
        }
        computeOptimalSlot(serializedKey) {
            let hash = libcrypto.createHash("sha256")
                .update(serializedKey)
                .digest();
            let slotCount = this.getSlotCount();
            let optimalSlot = Number(hash.readBigUInt64BE(0) % BigInt(slotCount));
            return optimalSlot;
        }
        loadSlot(slotIndex) {
            let buffer = Buffer.alloc(8);
            this.blockHandler.readBlock(this.blockIndex, buffer, 16 + slotIndex * 8);
            let probeDistance = buffer.readUInt8(0);
            let isOccupied = buffer.readUInt8(1) === 0x01;
            let index = buffer.readUIntBE(2, 6);
            return {
                probeDistance,
                isOccupied,
                index
            };
        }
        saveSlot(slotIndex, slot) {
            let buffer = Buffer.alloc(8);
            buffer.writeUInt8(slot.probeDistance, 0);
            buffer.writeUInt8(slot.isOccupied ? 0x01 : 0x00, 1);
            buffer.writeUIntBE(slot.index, 2, 6);
            this.blockHandler.writeBlock(this.blockIndex, buffer, 16 + slotIndex * 8);
        }
        resizeIfNeccessary() {
            let slotCount = this.getSlotCount();
            let header = this.readHeader();
            let currentLoadFactor = header.occupiedSlots / slotCount;
            let desiredSlotCount = slotCount;
            if (currentLoadFactor <= 0.25) {
                desiredSlotCount = Math.max(Math.ceil(slotCount / 2), 2);
            }
            if (currentLoadFactor >= 0.75) {
                desiredSlotCount = slotCount * 2;
            }
            if (desiredSlotCount === slotCount) {
                return;
            }
            let values = jdb_1.StreamIterable.of(this).collect();
            let minLength = 16 + desiredSlotCount * 8;
            this.blockHandler.resizeBlock(this.blockIndex, minLength);
            let newSlotCount = this.getSlotCount();
            if (newSlotCount === slotCount) {
                return;
            }
            this.blockHandler.batchOperation(this.blockIndex, () => {
                this.blockHandler.clearBlock(this.blockIndex);
                for (let value of values) {
                    let key = this.keyFromIndexProvider(value);
                    this.doInsert(key, value);
                }
                this.writeHeader(header);
            });
        }
        doInsert(key, index) {
            let serializedKey = serializeKey(key);
            let optimalSlot = this.computeOptimalSlot(serializedKey);
            let slotCount = this.getSlotCount();
            let slotIndex = optimalSlot;
            let probeDistance = 0;
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot(slotIndex);
                if (!slot.isOccupied) {
                    this.saveSlot(slotIndex, {
                        index: index,
                        probeDistance: probeDistance,
                        isOccupied: true
                    });
                    return slotIndex;
                }
                if (slot.index === index) {
                    return;
                }
                if (probeDistance > slot.probeDistance) {
                    this.saveSlot(slotIndex, {
                        index: index,
                        probeDistance: probeDistance,
                        isOccupied: true
                    });
                    index = slot.index;
                    probeDistance = slot.probeDistance;
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
            throw `Expected code to be unreachable!`;
        }
        propagateBackwards(slotIndex) {
            let slotCount = this.getSlotCount();
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot((slotIndex + 1) % slotCount);
                if (slot.probeDistance === 0) {
                    this.saveSlot(slotIndex, {
                        index: 0,
                        probeDistance: 0,
                        isOccupied: false
                    });
                    break;
                }
                this.saveSlot(slotIndex, {
                    index: slot.index,
                    probeDistance: slot.probeDistance - 1,
                    isOccupied: true
                });
                slotIndex = (slotIndex + 1) % slotCount;
            }
        }
        doRemove(key) {
            let serializedKey = serializeKey(key);
            let optimalSlot = this.computeOptimalSlot(serializedKey);
            let slotCount = this.getSlotCount();
            let slotIndex = optimalSlot;
            let probeDistance = 0;
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot(slotIndex);
                if (!slot.isOccupied || probeDistance > slot.probeDistance) {
                    return;
                }
                if (this.keyFromIndexProvider(slot.index) === key) {
                    this.saveSlot(slotIndex, {
                        index: 0,
                        probeDistance: 0,
                        isOccupied: false
                    });
                    return slotIndex;
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
            throw `Expected code to be unreachable!`;
        }
        *[Symbol.iterator]() {
            let slotCount = this.getSlotCount();
            for (let slotIndex = 0; slotIndex < slotCount; slotIndex++) {
                let slot = this.loadSlot(slotIndex);
                if (slot.isOccupied) {
                    yield slot.index;
                }
            }
        }
        entries() {
            return jdb_1.StreamIterable.of(this)
                .map((index) => {
                let key = this.keyFromIndexProvider(index);
                return {
                    key,
                    index
                };
            })
                .slice();
        }
        insert(key, index) {
            let slotIndex = this.doInsert(key, index);
            if (is.present(slotIndex)) {
                let header = this.readHeader();
                header.occupiedSlots += 1;
                this.writeHeader(header);
                this.resizeIfNeccessary();
            }
        }
        length() {
            return this.readHeader().occupiedSlots;
        }
        lookup(key) {
            let serializedKey = serializeKey(key);
            let optimalSlot = this.computeOptimalSlot(serializedKey);
            let slotCount = this.getSlotCount();
            let slotIndex = optimalSlot;
            let probeDistance = 0;
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot(slotIndex);
                if (!slot.isOccupied || probeDistance > slot.probeDistance) {
                    return;
                }
                if (this.keyFromIndexProvider(slot.index) === key) {
                    return slot.index;
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
            throw `Expected code to be unreachable!`;
        }
        remove(key) {
            let slotIndex = this.doRemove(key);
            if (is.present(slotIndex)) {
                let header = this.readHeader();
                header.occupiedSlots -= 1;
                this.writeHeader(header);
                this.propagateBackwards(slotIndex);
                this.resizeIfNeccessary();
            }
        }
        debug() {
            let header = this.readHeader();
            console.log(header);
            let slotCount = this.getSlotCount();
            for (let slotIndex = 0; slotIndex < slotCount; slotIndex++) {
                let slot = this.loadSlot(slotIndex);
                let key = slot.isOccupied ? this.keyFromIndexProvider(slot.index) : undefined;
                console.log({
                    ...slot,
                    key
                });
            }
        }
    }
    exports.RobinHoodHash = RobinHoodHash;
    ;
    class Index {
        static NUMBER_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            normalized = normalized.replace(/['"`]+/g, "");
            return Array.from(normalized.match(/(\p{N}+)/gu) ?? []);
        };
        static QUERY_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            normalized = normalized.replace(/['"`]+/g, "");
            return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
        };
        static VALUE_TOKENIZER = (value) => {
            return [value];
        };
        static WORD_TOKENIZER = (value) => {
            let normalized = String(value);
            normalized = normalized.toLowerCase();
            normalized = normalized.normalize("NFC");
            normalized = normalized.replace(/['"`]+/g, "");
            return Array.from(normalized.match(/(\p{L}+)/gu) ?? []);
        };
        tokenTable;
        parentTable;
        childTable;
        getIndexedValues;
        getTokens;
        blockHandler;
        debug() {
            this.tokenTable.debug();
        }
        constructor(blockHandler, parentTable, childTable, getIndexedValues, getTokens = Index.VALUE_TOKENIZER) {
            let tokenTable = new Table(blockHandler, schema_1.IndexRecord.as, (record) => record.token);
            function insert(key, index, record) {
                let values = is.present(record) ? getIndexedValues(record) : [];
                for (let value of values) {
                    let tokens = getTokens(value);
                    for (let token of tokens) {
                        let indexRecord;
                        try {
                            indexRecord = tokenTable.lookup(token);
                        }
                        catch (error) { }
                        if (is.absent(indexRecord)) {
                            let index = blockHandler.createBlock(RobinHoodHash.INITIAL_SIZE);
                            indexRecord = {
                                token,
                                index
                            };
                            tokenTable.insert(indexRecord);
                        }
                        let rhh = new RobinHoodHash(blockHandler, indexRecord.index, (index) => index);
                        rhh.insert(index, index);
                    }
                }
            }
            function remove(key, index, record) {
                let values = is.present(record) ? getIndexedValues(record) : [];
                for (let value of values) {
                    let tokens = getTokens(value);
                    for (let token of tokens) {
                        let indexRecord;
                        try {
                            indexRecord = tokenTable.lookup(token);
                        }
                        catch (error) { }
                        if (is.absent(indexRecord)) {
                            continue;
                        }
                        let rhh = new RobinHoodHash(blockHandler, indexRecord.index, (index) => index);
                        rhh.remove(index);
                    }
                }
            }
            childTable.addObserver("insert", (event) => {
                insert(event.key, event.index, event.record);
            });
            childTable.addObserver("remove", (event) => {
                remove(event.key, event.index, event.record);
            });
            childTable.addObserver("update", (event) => {
                remove(event.key, event.index, event.last);
                insert(event.key, event.index, event.next);
            });
            parentTable.addObserver("remove", (event) => {
                // Deletion is already performed when parent and child reference the same table.
                try {
                    let token = event.key;
                    let indexRecord = tokenTable.lookup(token);
                    let rhh = new RobinHoodHash(this.blockHandler, indexRecord.index, (index) => index);
                    for (let entry of rhh.entries()) {
                        let record = childTable.getRecord(entry.index);
                        childTable.remove(record);
                    }
                }
                catch (error) { }
            });
            if (blockHandler.getCount() === BlockHandler.FIRST_APPLICATION_BLOCK + 1) {
                for (let [key, index, record] of childTable.entries()) {
                    insert(key, index, record);
                }
            }
            this.blockHandler = blockHandler;
            this.tokenTable = tokenTable;
            this.parentTable = parentTable;
            this.childTable = childTable;
            this.getIndexedValues = getIndexedValues;
            this.getTokens = getTokens;
        }
        lookup(query) {
            return this.search(query)
                .map((result) => result.lookup())
                .slice();
        }
        search(query) {
            let tokens = this.getTokens(query);
            let map = new Map();
            for (let token of tokens) {
                try {
                    let indexRecord = this.tokenTable.lookup(token);
                    let rhh = new RobinHoodHash(this.blockHandler, indexRecord.index, (index) => index);
                    for (let index of rhh) {
                        let key = index;
                        let rank = map.get(key) ?? (0 - tokens.length);
                        map.set(key, rank + 2);
                    }
                }
                catch (error) { }
            }
            return jdb_1.StreamIterable.of(map.entries())
                .filter((result) => result[1] >= 0)
                .sort(jsondb_1.sorters.NumericSort.decreasing((result) => result[1]))
                .map((entry) => ({
                index: entry[0],
                rank: entry[1],
                lookup: () => this.childTable.getRecord(entry[0])
            }));
        }
    }
    exports.Index = Index;
    ;
});
define("build/database/indexer", ["require", "exports", "crypto", "fs", "build/database/schema/index", "build/jsondb/index", "build/is", "build/database/probes/index", "build/config/index", "build/jdb2/index", "build/database/atlas", "build/utils"], function (require, exports, libcrypto, libfs, schema, indices, is, probes, config_1, jdb2, atlas_1, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.runIndexer = exports.migrateLegacyData = exports.computeMovieSuggestions = exports.computeShowTimestamps = exports.computeMovieTimestamps = exports.computeAlbumTimestamps = exports.getPath = void 0;
    function wordify(string) {
        return String(string)
            .toLowerCase()
            .normalize("NFKD")
            .replace(/[\|\/\\\_\-]/g, " ")
            .replace(/[^a-z0-9 ]/g, "")
            .trim()
            .split(/[ ]+/g);
    }
    function makeId(...components) {
        components = components
            .map((component) => wordify(component ?? ""))
            .map((words) => {
            return words.join(" ");
        });
        return libcrypto.createHash("sha256")
            .update(components.join("\0"))
            .digest("hex")
            .slice(0, 16);
    }
    function makeBinaryId(...components) {
        components = components
            .map((component) => {
            if (component instanceof Uint8Array) {
                component = Buffer.from(component).toString("hex");
            }
            return wordify(component ?? "").join(" ");
        });
        let buffer = libcrypto.createHash("sha256")
            .update(components.join("\0"))
            .digest()
            .slice(0, 8);
        return Uint8Array.from(buffer);
    }
    if (!libfs.existsSync(config_1.default.media_path.join("/"))) {
        libfs.mkdirSync(config_1.default.media_path.join("/"));
    }
    const TABLES_ROOT = [
        ".",
        "private",
        "tables"
    ];
    const INDICES_ROOT = [
        ".",
        "private",
        "indices"
    ];
    function loadTable(name, guard, getKey) {
        let blockHandler = new jdb2.BlockHandler([".", "private", "tables", name]);
        let table = new jdb2.Table(blockHandler, (json) => guard.as(json), getKey);
        return table;
    }
    async function getPath(queue, entry) {
        let path = new Array();
        while (true) {
            path.unshift(entry.name);
            let parent_directory_id = entry.parent_directory_id;
            if (is.absent(parent_directory_id)) {
                break;
            }
            let newEntry = await atlas_1.links.directory_directories.lookup(queue, {
                parent_directory_id
            });
            if (is.absent(newEntry)) {
                break;
            }
            entry = newEntry;
        }
        return [...config_1.default.media_path, ...path];
    }
    exports.getPath = getPath;
    ;
    function getFilePath(queue, file) {
        return getPath(queue, file);
    }
    ;
    async function checkFile(queue, root, paths) {
        let path = paths.join("/");
        if (libfs.existsSync(path)) {
            let stats = libfs.statSync(path);
            if (stats.isFile()) {
                if (stats.mtime.valueOf() === root.index_timestamp) {
                    return;
                }
            }
        }
        console.log(`Removing ${path} from index.`);
        await atlas_1.stores.files.remove(queue, root);
    }
    ;
    async function checkDirectory(queue, root, paths) {
        let path = paths.join("/");
        if (libfs.existsSync(path)) {
            let stats = libfs.statSync(path);
            if (stats.isDirectory()) {
                let directory_id = root.directory_id;
                for (let directory of await atlas_1.links.directory_directories.filter(queue, { directory_id })) {
                    await checkDirectory(queue, directory, [...paths, directory.name]);
                }
                for (let file of await atlas_1.links.directory_files.filter(queue, { directory_id })) {
                    await checkFile(queue, file, [...paths, file.name]);
                }
                return;
            }
        }
        console.log(`Removing ${path} from index.`);
        await atlas_1.stores.directories.remove(queue, root);
    }
    ;
    async function visitDirectory(queue, path, parent_directory_id) {
        let dirents = libfs.readdirSync(path.join("/"), { withFileTypes: true });
        for (let dirent of dirents) {
            let name = dirent.name;
            if (dirent.isDirectory()) {
                let directory_id = makeBinaryId("directory", parent_directory_id, name);
                try {
                    await atlas_1.stores.directories.lookup(queue, { directory_id });
                }
                catch (error) {
                    await atlas_1.stores.directories.insert(queue, {
                        directory_id,
                        name,
                        parent_directory_id
                    });
                }
                await visitDirectory(queue, [...path, dirent.name], directory_id);
            }
            else if (dirent.isFile()) {
                let file_id = makeBinaryId("file", parent_directory_id, name);
                try {
                    await atlas_1.stores.files.lookup(queue, { file_id });
                }
                catch (error) {
                    let stats = libfs.statSync(path.join("/"));
                    let index_timestamp = null;
                    let size = stats.size;
                    await atlas_1.stores.files.insert(queue, {
                        file_id,
                        name,
                        parent_directory_id,
                        index_timestamp,
                        size
                    });
                }
            }
        }
    }
    ;
    async function associateShowFiles(queue, show_id, ...file_ids) {
        for (let file_id of file_ids) {
            try {
                let image_file = await atlas_1.stores.image_files.lookup(queue, { file_id });
                await atlas_1.stores.show_files.insert(queue, {
                    show_id: show_id,
                    ...image_file
                });
                continue;
            }
            catch (error) { }
        }
    }
    ;
    async function associateEpisodeFiles(queue, episode_id, ...file_ids) {
        for (let file_id of file_ids) {
            try {
                let video_file = await atlas_1.stores.video_files.lookup(queue, { file_id });
                await atlas_1.stores.episode_files.insert(queue, {
                    episode_id: episode_id,
                    ...video_file
                });
                continue;
            }
            catch (error) { }
        }
    }
    ;
    async function associateMovieFiles(queue, movie_id, ...file_ids) {
        for (let file_id of file_ids) {
            try {
                let video_file = await atlas_1.stores.video_files.lookup(queue, { file_id });
                await atlas_1.stores.movie_files.insert(queue, {
                    movie_id: movie_id,
                    ...video_file
                });
                continue;
            }
            catch (error) { }
            try {
                let image_file = await atlas_1.stores.image_files.lookup(queue, { file_id });
                await atlas_1.stores.movie_files.insert(queue, {
                    movie_id: movie_id,
                    ...image_file
                });
                continue;
            }
            catch (error) { }
        }
    }
    ;
    async function associateTrackFiles(queue, track_id, ...file_ids) {
        for (let file_id of file_ids) {
            try {
                let audio_file = await atlas_1.stores.audio_files.lookup(queue, { file_id });
                await atlas_1.stores.track_files.insert(queue, {
                    track_id: track_id,
                    ...audio_file
                });
                continue;
            }
            catch (error) { }
        }
    }
    ;
    async function associateAlbumFiles(queue, album_id, ...file_ids) {
        for (let file_id of file_ids) {
            try {
                let image_file = await atlas_1.stores.image_files.lookup(queue, { file_id });
                await atlas_1.stores.album_files.insert(queue, {
                    album_id: album_id,
                    ...image_file
                });
                continue;
            }
            catch (error) { }
        }
    }
    ;
    async function indexMetadata(queue, probe, ...file_ids) {
        let metadata = probe.metadata;
        if (probes.schema.ShowMetadata.is(metadata)) {
            let show_id = makeBinaryId("show", metadata.title);
            await atlas_1.stores.shows.update(queue, {
                show_id: show_id,
                name: metadata.title,
                summary: metadata.summary ?? null,
                imdb: metadata.imdb ?? null
            });
            for (let [index, actor] of metadata.actors.entries()) {
                let actor_id = makeBinaryId("actor", actor);
                await atlas_1.stores.actors.update(queue, {
                    actor_id: actor_id,
                    name: actor
                });
                await atlas_1.stores.show_actors.insert(queue, {
                    actor_id: actor_id,
                    show_id: show_id,
                    order: index
                });
            }
            for (let [index, genre] of metadata.genres.entries()) {
                let genre_id = makeBinaryId("genre", genre);
                await atlas_1.stores.genres.update(queue, {
                    genre_id: genre_id,
                    name: genre
                });
                await atlas_1.stores.show_genres.insert(queue, {
                    genre_id: genre_id,
                    show_id: show_id,
                    order: index
                });
            }
            await associateShowFiles(queue, show_id, ...file_ids);
        }
        else if (probes.schema.EpisodeMetadata.is(metadata)) {
            let year_id;
            if (is.present(metadata.year)) {
                year_id = makeBinaryId("year", metadata.year);
                await atlas_1.stores.years.update(queue, {
                    year_id: year_id,
                    year: metadata.year
                });
            }
            let show_id = makeBinaryId("show", metadata.show.title);
            await atlas_1.stores.shows.update(queue, {
                show_id: show_id,
                name: metadata.show.title,
                summary: metadata.show.summary ?? null,
                imdb: metadata.show.imdb ?? null
            });
            let season_id = makeBinaryId("season", show_id, `${metadata.season}`);
            await atlas_1.stores.seasons.update(queue, {
                season_id: season_id,
                show_id: show_id,
                number: metadata.season
            });
            let episode_id = makeBinaryId("episode", season_id, `${metadata.episode}`);
            await atlas_1.stores.episodes.update(queue, {
                episode_id: episode_id,
                season_id: season_id,
                title: metadata.title,
                number: metadata.episode,
                year_id: year_id ?? null,
                summary: metadata.summary ?? null,
                copyright: metadata.copyright ?? null,
                imdb: metadata.imdb ?? null
            });
            for (let [index, actor] of metadata.show.actors.entries()) {
                let actor_id = makeBinaryId("actor", actor);
                await atlas_1.stores.actors.update(queue, {
                    actor_id: actor_id,
                    name: actor
                });
                await atlas_1.stores.show_actors.insert(queue, {
                    actor_id: actor_id,
                    show_id: show_id,
                    order: index
                });
            }
            for (let [index, genre] of metadata.show.genres.entries()) {
                let genre_id = makeBinaryId("genre", genre);
                await atlas_1.stores.genres.update(queue, {
                    genre_id: genre_id,
                    name: genre
                });
                await atlas_1.stores.show_genres.insert(queue, {
                    genre_id: genre_id,
                    show_id: show_id,
                    order: index
                });
            }
            await associateEpisodeFiles(queue, episode_id, ...file_ids);
        }
        else if (probes.schema.MovieMetadata.is(metadata)) {
            let year_id;
            if (is.present(metadata.year)) {
                year_id = makeBinaryId("year", metadata.year);
                await atlas_1.stores.years.update(queue, {
                    year_id: year_id,
                    year: metadata.year
                });
            }
            let movie_id = makeBinaryId("movie", metadata.title, metadata.year);
            await atlas_1.stores.movies.update(queue, {
                movie_id: movie_id,
                title: metadata.title,
                year_id: year_id ?? null,
                summary: metadata.summary ?? null,
                copyright: metadata.copyright ?? null,
                imdb: metadata.imdb ?? null
            });
            for (let [index, actor] of metadata.actors.entries()) {
                let actor_id = makeBinaryId("actor", actor);
                await atlas_1.stores.actors.update(queue, {
                    actor_id: actor_id,
                    name: actor
                });
                await atlas_1.stores.movie_actors.insert(queue, {
                    actor_id: actor_id,
                    movie_id: movie_id,
                    order: index
                });
            }
            for (let [index, genre] of metadata.genres.entries()) {
                let genre_id = makeBinaryId("genre", genre);
                await atlas_1.stores.genres.update(queue, {
                    genre_id: genre_id,
                    name: genre
                });
                await atlas_1.stores.movie_genres.insert(queue, {
                    genre_id: genre_id,
                    movie_id: movie_id,
                    order: index
                });
            }
            await associateMovieFiles(queue, movie_id, ...file_ids);
        }
        else if (probes.schema.TrackMetadata.is(metadata)) {
            let year_id;
            if (is.present(metadata.album.year)) {
                year_id = makeBinaryId("year", metadata.album.year);
                await atlas_1.stores.years.update(queue, {
                    year_id: year_id,
                    year: metadata.album.year
                });
            }
            let album_id = makeBinaryId("album", metadata.album.title, metadata.album.year);
            await atlas_1.stores.albums.update(queue, {
                album_id: album_id,
                title: metadata.album.title,
                year_id: year_id ?? null
            });
            for (let [index, artist] of metadata.album.artists.entries()) {
                let artist_id = makeBinaryId("artist", artist);
                await atlas_1.stores.artists.update(queue, {
                    artist_id: artist_id,
                    name: artist
                });
                await atlas_1.stores.album_artists.insert(queue, {
                    album_id: album_id,
                    artist_id: artist_id,
                    order: index
                });
            }
            let disc_id = makeBinaryId("disc", album_id, `${metadata.disc}`);
            await atlas_1.stores.discs.update(queue, {
                disc_id: disc_id,
                album_id: album_id,
                number: metadata.disc
            });
            let track_id = makeBinaryId("track", disc_id, `${metadata.track}`);
            await atlas_1.stores.tracks.update(queue, {
                track_id: track_id,
                disc_id: disc_id,
                title: metadata.title,
                number: metadata.track,
                copyright: metadata.copyright ?? null
            });
            for (let [index, artist] of metadata.artists.entries()) {
                let artist_id = makeBinaryId("artist", artist);
                await atlas_1.stores.artists.update(queue, {
                    artist_id: artist_id,
                    name: artist
                });
                await atlas_1.stores.track_artists.insert(queue, {
                    track_id: track_id,
                    artist_id: artist_id,
                    order: index
                });
            }
            await associateTrackFiles(queue, track_id, ...file_ids);
        }
        else if (probes.schema.AlbumMetadata.is(metadata)) {
            let year_id;
            if (is.present(metadata.year)) {
                year_id = makeBinaryId("year", metadata.year);
                await atlas_1.stores.years.update(queue, {
                    year_id: year_id,
                    year: metadata.year
                });
            }
            let album_id = makeBinaryId("album", metadata.title, metadata.year);
            await atlas_1.stores.albums.update(queue, {
                album_id: album_id,
                title: metadata.title,
                year_id: year_id ?? null
            });
            for (let [index, artist] of metadata.artists.entries()) {
                let artist_id = makeBinaryId("artist", artist);
                await atlas_1.stores.artists.update(queue, {
                    artist_id: artist_id,
                    name: artist
                });
                await atlas_1.stores.album_artists.insert(queue, {
                    album_id: album_id,
                    artist_id: artist_id,
                    order: index
                });
            }
            let disc_id = makeBinaryId("disc", album_id, `${metadata.disc}`);
            await atlas_1.stores.discs.update(queue, {
                disc_id: disc_id,
                album_id: album_id,
                number: metadata.disc
            });
            for (let [index, track] of metadata.tracks.entries()) {
                let track_id = makeBinaryId("track", disc_id, `${index}`);
                await atlas_1.stores.tracks.update(queue, {
                    track_id: track_id,
                    disc_id: disc_id,
                    title: track.title,
                    number: index + 1,
                    copyright: track.copyright ?? metadata.copyright ?? null
                });
                for (let [index, artist] of track.artists.entries()) {
                    let artist_id = makeBinaryId("artist", artist);
                    await atlas_1.stores.artists.update(queue, {
                        artist_id: artist_id,
                        name: artist
                    });
                    await atlas_1.stores.track_artists.insert(queue, {
                        track_id: track_id,
                        artist_id: artist_id,
                        order: index
                    });
                }
            }
            await associateAlbumFiles(queue, album_id, ...file_ids);
        }
    }
    ;
    async function indexFile(queue, file) {
        let file_id = file.file_id;
        let paths = await getFilePath(queue, file);
        let path = paths.join("/");
        let fd = libfs.openSync(path, "r");
        try {
            let probe = {
                resources: []
            };
            if (file.name.endsWith(".vtt")) {
                probe = probes.vtt.probe(fd);
                let subtitle_resources = probe.resources.filter((resource) => resource.type === "subtitle");
                let subtitle_resource = subtitle_resources.shift();
                if (is.present(subtitle_resource)) {
                    await atlas_1.stores.subtitle_files.insert(queue, {
                        file_id: file_id,
                        mime: "text/vtt",
                        duration_ms: subtitle_resource.duration_ms,
                        language: subtitle_resource.language ?? null
                    });
                    let subtitle_id = makeBinaryId("subtitle", file.file_id);
                    await atlas_1.stores.subtitles.insert(queue, {
                        subtitle_id: subtitle_id,
                        file_id: file.file_id
                    });
                    /* 				for (let cue of subtitle_resource.cues) {
                                        let cue_id = makeBinaryId("cue", subtitle_id, `${cue.start_ms}`);
                                        await stores.cues.insert(queue, {
                                            cue_id: cue_id,
                                            subtitle_id: subtitle_id,
                                            start_ms: cue.start_ms,
                                            duration_ms: cue.duration_ms,
                                            lines: cue.lines.join("\n")
                                        });
                                    } */
                    await indexMetadata(queue, probe);
                }
            }
            else if (file.name.endsWith(".json")) {
                probe = probes.json.probe(fd);
                let metadata_resources = probe.resources.filter((resource) => resource.type === "metadata");
                let metadata_resource = metadata_resources.shift();
                if (is.present(metadata_resource)) {
                    await atlas_1.stores.metadata_files.insert(queue, {
                        file_id: file_id,
                        mime: "application/json"
                    });
                    await indexMetadata(queue, probe);
                }
            }
            else if (file.name.endsWith(".mp3")) {
                probe = probes.mp3.probe(fd);
                let audio_resources = probe.resources.filter((resource) => resource.type === "audio");
                let audio_resource = audio_resources.shift();
                if (is.present(audio_resource)) {
                    await atlas_1.stores.audio_files.insert(queue, {
                        file_id: file_id,
                        mime: "audio/mp3",
                        duration_ms: audio_resource.duration_ms
                    });
                    await indexMetadata(queue, probe, file_id);
                }
            }
            else if (file.name.endsWith(".mp4")) {
                probe = probes.mp4.probe(fd);
                let audio_resources = probe.resources.filter((resource) => resource.type === "audio");
                let video_resources = probe.resources.filter((resource) => resource.type === "video");
                let audio_resource = audio_resources.shift();
                let video_resource = video_resources.shift();
                if (is.present(video_resource)) {
                    await atlas_1.stores.video_files.insert(queue, {
                        file_id: file_id,
                        mime: "video/mp4",
                        duration_ms: video_resource.duration_ms,
                        width: video_resource.width,
                        height: video_resource.height
                    });
                    await indexMetadata(queue, probe, file_id);
                }
                else if (is.present(audio_resource)) {
                    await atlas_1.stores.audio_files.insert(queue, {
                        file_id: file_id,
                        mime: "audio/mp4",
                        duration_ms: audio_resource.duration_ms
                    });
                    await indexMetadata(queue, probe, file_id);
                }
            }
            else if (file.name.endsWith(".jpg") || file.name.endsWith(".jpeg")) {
                probe = probes.jpeg.probe(fd);
                let image_resources = probe.resources.filter((resource) => resource.type === "image");
                let image_resource = image_resources.shift();
                if (is.present(image_resource)) {
                    await atlas_1.stores.image_files.insert(queue, {
                        file_id: file_id,
                        mime: "image/jpeg",
                        width: image_resource.width,
                        height: image_resource.height
                    });
                    await indexMetadata(queue, probe);
                }
            }
        }
        catch (error) {
            console.log(`Indexing failed for "${path}"!`);
            console.log(error);
        }
        let stats = libfs.fstatSync(fd);
        file.index_timestamp = stats.mtime.valueOf();
        file.size = stats.size;
        libfs.closeSync(fd);
        await atlas_1.stores.files.update(queue, file);
    }
    ;
    async function indexFiles(queue) {
        console.log(`Indexing files...`);
        let files = await atlas_1.stores.files.filter(queue);
        console.log(`Database contains ${files.length} files.`);
        for (let file of files) {
            if (is.absent(file.index_timestamp)) {
                console.log(`Indexing ${file.name}...`);
                await indexFile(queue, file);
            }
        }
    }
    ;
    async function getSiblingFiles(queue, subject) {
        let parent_directory = await atlas_1.links.directory_files.lookup(queue, subject);
        let candidates_in_directory = (await atlas_1.links.directory_files.filter(queue, parent_directory))
            .sort(indices.LexicalSort.increasing((file) => file.name));
        let basename = subject.name.split(".")[0];
        let candidates_sharing_basename = candidates_in_directory
            .filter((file) => (0, utils_1.hexid)(file.file_id) !== (0, utils_1.hexid)(subject.file_id))
            .filter((file) => file.name.split(".")[0] === basename);
        if (candidates_sharing_basename.length > 0) {
            return candidates_sharing_basename;
        }
        else {
            return candidates_in_directory;
        }
    }
    ;
    async function associateMetadata(queue) {
        console.log(`Associating metadata files...`);
        let metadata_files = await atlas_1.stores.metadata_files.filter(queue);
        console.log(`Database contains ${metadata_files.length} metadata files.`);
        for (let metadata_file of metadata_files) {
            let file = await atlas_1.stores.files.lookup(queue, metadata_file);
            let path = await getFilePath(queue, file);
            let fd = libfs.openSync(path.join("/"), "r");
            let probe = probes.json.probe(fd);
            libfs.closeSync(fd);
            let siblings = await getSiblingFiles(queue, file);
            await indexMetadata(queue, probe, ...siblings.map((file) => file.file_id));
        }
    }
    ;
    async function associateImages(queue) {
        console.log(`Associating image files...`);
        let image_files = await atlas_1.stores.image_files.filter(queue);
        console.log(`Database contains ${image_files.length} image files.`);
        for (let image_file of image_files) {
            let file = await atlas_1.stores.files.lookup(queue, image_file);
            let siblings = await getSiblingFiles(queue, file);
            for (let sibling of siblings) {
                let track_files = await atlas_1.links.file_track_files.filter(queue, sibling);
                if (track_files.length > 0) {
                    for (let track_file of track_files) {
                        let track = await atlas_1.stores.tracks.lookup(queue, track_file);
                        let disc = await atlas_1.stores.discs.lookup(queue, track);
                        let album = await atlas_1.stores.albums.lookup(queue, disc);
                        await associateAlbumFiles(queue, album.album_id, image_file.file_id);
                    }
                    continue;
                }
                let movie_files = await atlas_1.links.file_movie_files.filter(queue, sibling);
                if (movie_files.length > 0) {
                    for (let movie_file of movie_files) {
                        let movie = await atlas_1.stores.movies.lookup(queue, movie_file);
                        await associateMovieFiles(queue, movie.movie_id, image_file.file_id);
                    }
                    continue;
                }
                let episode_files = await atlas_1.links.file_episode_files.filter(queue, sibling);
                if (episode_files.length > 0) {
                    for (let episode_file of episode_files) {
                        let episode = await atlas_1.stores.episodes.lookup(queue, episode_file);
                        await associateEpisodeFiles(queue, episode.episode_id, image_file.file_id);
                    }
                    continue;
                }
                let show_files = await atlas_1.links.file_show_files.filter(queue, sibling);
                if (show_files.length > 0) {
                    for (let show_file of show_files) {
                        let show = await atlas_1.stores.shows.lookup(queue, show_file);
                        await associateShowFiles(queue, show.show_id, image_file.file_id);
                    }
                    continue;
                }
            }
        }
    }
    ;
    async function associateSubtitles(queue) {
        console.log(`Associating subtitle files...`);
        let subtitle_files = await atlas_1.stores.subtitle_files.filter(queue);
        console.log(`Database contains ${subtitle_files.length} subtitle files.`);
        for (let subtitle_file of subtitle_files) {
            let file = await atlas_1.stores.files.lookup(queue, subtitle_file);
            let siblings = await getSiblingFiles(queue, file);
            for (let sibling of siblings) {
                try {
                    let video_file = await atlas_1.stores.video_files.lookup(queue, sibling);
                    await atlas_1.stores.video_subtitles.insert(queue, {
                        video_file_id: video_file.file_id,
                        subtitle_file_id: subtitle_file.file_id
                    });
                    continue;
                }
                catch (error) { }
            }
        }
    }
    ;
    async function removeBrokenEntities(queue) {
        console.log(`Removing tracks without files...`);
        for (let track of await atlas_1.stores.tracks.filter(queue)) {
            let track_files = await atlas_1.links.track_track_files.filter(queue, track);
            if (track_files.length === 0) {
                await atlas_1.stores.tracks.remove(queue, track);
            }
        }
        console.log(`Removing discs without tracks...`);
        for (let disc of await atlas_1.stores.discs.filter(queue)) {
            let tracks = await atlas_1.links.disc_tracks.filter(queue, disc);
            if (tracks.length === 0) {
                await atlas_1.stores.discs.remove(queue, disc);
            }
        }
        console.log(`Removing albums without discs...`);
        for (let album of await atlas_1.stores.albums.filter(queue)) {
            let discs = await atlas_1.links.album_discs.filter(queue, album);
            if (discs.length === 0) {
                await atlas_1.stores.albums.remove(queue, album);
            }
        }
        console.log(`Removing artists without albums and tracks...`);
        for (let artist of await atlas_1.stores.artists.filter(queue)) {
            let album_artists = await atlas_1.links.artist_album_artists.filter(queue, artist);
            let track_artists = await atlas_1.links.artist_track_artists.filter(queue, artist);
            if (album_artists.length === 0 && track_artists.length === 0) {
                await atlas_1.stores.artists.remove(queue, artist);
            }
        }
        console.log(`Removing movies without files...`);
        for (let movie of await atlas_1.stores.movies.filter(queue)) {
            let movie_files = await atlas_1.links.movie_movie_files.filter(queue, movie);
            if (movie_files.length === 0) {
                await atlas_1.stores.movies.remove(queue, movie);
            }
        }
        console.log(`Removing episodes without files...`);
        for (let episode of await atlas_1.stores.episodes.filter(queue)) {
            let episode_files = await atlas_1.links.episode_episode_files.filter(queue, episode);
            if (episode_files.length === 0) {
                await atlas_1.stores.episodes.remove(queue, episode);
            }
        }
        console.log(`Removing seasons without episodes...`);
        for (let season of await atlas_1.stores.seasons.filter(queue)) {
            let episodes = await atlas_1.links.season_episodes.filter(queue, season);
            if (episodes.length === 0) {
                await atlas_1.stores.seasons.remove(queue, season);
            }
        }
        console.log(`Removing shows without seasons...`);
        for (let show of await atlas_1.stores.shows.filter(queue)) {
            let seasons = await atlas_1.links.show_seasons.filter(queue, show);
            if (seasons.length === 0) {
                await atlas_1.stores.shows.remove(queue, show);
            }
        }
        console.log(`Removing actors without movies and shows...`);
        for (let actor of await atlas_1.stores.actors.filter(queue)) {
            let movie_actors = await atlas_1.links.actor_movie_actors.filter(queue, actor);
            let show_actors = await atlas_1.links.actor_show_actors.filter(queue, actor);
            if (movie_actors.length === 0 && show_actors.length === 0) {
                await atlas_1.stores.actors.remove(queue, actor);
            }
        }
        console.log(`Removing genres without movies and shows...`);
        for (let genre of await atlas_1.stores.genres.filter(queue)) {
            let movie_genres = await atlas_1.links.genre_movie_genres.filter(queue, genre);
            let show_genres = await atlas_1.links.genre_show_genres.filter(queue, genre);
            if (movie_genres.length === 0 && show_genres.length === 0) {
                await atlas_1.stores.genres.remove(queue, genre);
            }
        }
        console.log(`Removing years without albums, movies and episodes...`);
        for (let year of await atlas_1.stores.years.filter(queue)) {
            let albums = await atlas_1.links.year_albums.filter(queue, year);
            let movies = await atlas_1.links.year_movies.filter(queue, year);
            let episodes = await atlas_1.links.year_episodes.filter(queue, year);
            if (albums.length === 0 && movies.length === 0 && episodes.length === 0) {
                await atlas_1.stores.years.remove(queue, year);
            }
        }
    }
    ;
    async function computeAlbumTimestamps(queue) {
        console.log(`Computing album timestamps...`);
        let albums = await atlas_1.stores.albums.filter(queue);
        for (let album of albums) {
            let album_timestamp_ms = album.timestamp_ms;
            let discs = await atlas_1.links.album_discs.filter(queue, album);
            for (let disc of discs) {
                let disc_timestamp_ms = disc.timestamp_ms;
                let tracks = await atlas_1.links.disc_tracks.filter(queue, disc);
                for (let track of tracks) {
                    let track_timestamp_ms = track.timestamp_ms;
                    let track_files = await atlas_1.links.track_track_files.filter(queue, track);
                    for (let track_file of track_files) {
                        let file = await atlas_1.stores.files.lookup(queue, track_file);
                        if (file.index_timestamp == null) {
                            continue;
                        }
                        track_timestamp_ms = track_timestamp_ms != null ? Math.max(track_timestamp_ms, file.index_timestamp) : file.index_timestamp;
                        disc_timestamp_ms = disc_timestamp_ms != null ? Math.max(disc_timestamp_ms, file.index_timestamp) : file.index_timestamp;
                        album_timestamp_ms = album_timestamp_ms != null ? Math.max(album_timestamp_ms, file.index_timestamp) : file.index_timestamp;
                    }
                    if (track.timestamp_ms !== track_timestamp_ms) {
                        await atlas_1.stores.tracks.insert(queue, {
                            ...track,
                            timestamp_ms: track_timestamp_ms
                        });
                    }
                }
                if (disc.timestamp_ms !== disc_timestamp_ms) {
                    await atlas_1.stores.discs.insert(queue, {
                        ...disc,
                        timestamp_ms: disc_timestamp_ms
                    });
                }
            }
            if (album.timestamp_ms !== album_timestamp_ms) {
                await atlas_1.stores.albums.insert(queue, {
                    ...album,
                    timestamp_ms: album_timestamp_ms
                });
            }
        }
    }
    exports.computeAlbumTimestamps = computeAlbumTimestamps;
    ;
    async function computeMovieTimestamps(queue) {
        console.log(`Computing movie timestamps...`);
        let movies = await atlas_1.stores.movies.filter(queue);
        for (let movie of movies) {
            let movie_timestamp_ms = movie.timestamp_ms;
            let movie_files = await atlas_1.links.movie_movie_files.filter(queue, movie);
            for (let movie_file of movie_files) {
                let file = await atlas_1.stores.files.lookup(queue, movie_file);
                if (file.index_timestamp == null) {
                    continue;
                }
                movie_timestamp_ms = movie_timestamp_ms != null ? Math.max(movie_timestamp_ms, file.index_timestamp) : file.index_timestamp;
            }
            if (movie.timestamp_ms !== movie_timestamp_ms) {
                await atlas_1.stores.movies.insert(queue, {
                    ...movie,
                    timestamp_ms: movie_timestamp_ms
                });
            }
        }
    }
    exports.computeMovieTimestamps = computeMovieTimestamps;
    ;
    async function computeShowTimestamps(queue) {
        console.log(`Computing show timestamps...`);
        let shows = await atlas_1.stores.shows.filter(queue);
        for (let show of shows) {
            let show_timestamp_ms = show.timestamp_ms;
            let seasons = await atlas_1.links.show_seasons.filter(queue, show);
            for (let season of seasons) {
                let season_timestamp_ms = season.timestamp_ms;
                let episodes = await atlas_1.links.season_episodes.filter(queue, season);
                for (let episode of episodes) {
                    let episode_timestamp_ms = episode.timestamp_ms;
                    let episode_files = await atlas_1.links.episode_episode_files.filter(queue, episode);
                    for (let episode_file of episode_files) {
                        let file = await atlas_1.stores.files.lookup(queue, episode_file);
                        if (file.index_timestamp == null) {
                            continue;
                        }
                        episode_timestamp_ms = episode_timestamp_ms != null ? Math.max(episode_timestamp_ms, file.index_timestamp) : file.index_timestamp;
                        season_timestamp_ms = season_timestamp_ms != null ? Math.max(season_timestamp_ms, file.index_timestamp) : file.index_timestamp;
                        show_timestamp_ms = show_timestamp_ms != null ? Math.max(show_timestamp_ms, file.index_timestamp) : file.index_timestamp;
                    }
                    if (episode.timestamp_ms !== episode_timestamp_ms) {
                        await atlas_1.stores.episodes.insert(queue, {
                            ...episode,
                            timestamp_ms: episode_timestamp_ms
                        });
                    }
                }
                if (season.timestamp_ms !== season_timestamp_ms) {
                    await atlas_1.stores.seasons.insert(queue, {
                        ...season,
                        timestamp_ms: season_timestamp_ms
                    });
                }
            }
            if (show.timestamp_ms !== show_timestamp_ms) {
                await atlas_1.stores.shows.insert(queue, {
                    ...show,
                    timestamp_ms: show_timestamp_ms
                });
            }
        }
    }
    exports.computeShowTimestamps = computeShowTimestamps;
    ;
    async function computeMovieSuggestions(queue) {
        console.log(`Computing movie suggestions...`);
        let movies = await Promise.all((await atlas_1.stores.movies.filter(queue)).map(async (movie) => {
            let movie_genres = await atlas_1.links.movie_movie_genres.filter(queue, movie);
            return {
                ...movie,
                movie_genres
            };
        }));
        for (let movie of movies) {
            for (let suggested_movie of movies) {
                if (suggested_movie.movie_id === movie.movie_id) {
                    continue;
                }
                let affinity = 0;
                for (let movie_genre of movie.movie_genres) {
                    if (suggested_movie.movie_genres.find((suggested_movie_genre) => (0, utils_1.hexid)(suggested_movie_genre.genre_id) === (0, utils_1.hexid)(movie_genre.genre_id)) != null) {
                        affinity += 1;
                    }
                    else {
                        affinity -= 1;
                    }
                }
                for (let suggested_movie_genre of suggested_movie.movie_genres) {
                    if (movie.movie_genres.find((movie_genre) => (0, utils_1.hexid)(movie_genre.genre_id) === (0, utils_1.hexid)(suggested_movie_genre.genre_id)) != null) {
                        affinity += 1;
                    }
                    else {
                        affinity -= 1;
                    }
                }
                if (affinity > 0) {
                    await atlas_1.stores.movie_suggestions.insert(queue, {
                        movie_id: movie.movie_id,
                        suggested_movie_id: suggested_movie.movie_id,
                        affinity: affinity
                    });
                }
            }
        }
    }
    exports.computeMovieSuggestions = computeMovieSuggestions;
    ;
    async function migrateLegacyData(queue) {
        if (libfs.existsSync(TABLES_ROOT.join("/"))) {
            console.log(`Migrating legacy data...`);
            let users = loadTable("users", schema.User, (record) => record.user_id);
            for (let user of users) {
                try {
                    await atlas_1.stores.users.insert(queue, {
                        ...user,
                        user_id: (0, utils_1.binid)(user.user_id)
                    });
                }
                catch (error) { }
            }
            users.close();
            let keys = loadTable("keys", schema.Key, (record) => record.key_id);
            for (let key of keys) {
                try {
                    await atlas_1.stores.keys.insert(queue, {
                        ...key,
                        key_id: (0, utils_1.binid)(key.key_id),
                        user_id: key.user_id != null ? (0, utils_1.binid)(key.user_id) : null
                    });
                }
                catch (error) { }
            }
            keys.close();
            let tokens = loadTable("tokens", schema.Token, (record) => record.token_id);
            for (let token of tokens) {
                try {
                    await atlas_1.stores.tokens.insert(queue, {
                        ...token,
                        token_id: (0, utils_1.binid)(token.token_id),
                        user_id: (0, utils_1.binid)(token.user_id),
                        hash: (0, utils_1.binid)(token.hash)
                    });
                }
                catch (error) { }
            }
            tokens.close();
            let streams = loadTable("streams", schema.Stream, (record) => record.stream_id);
            for (let stream of streams) {
                try {
                    let file = await atlas_1.stores.files.lookup(queue, { file_id: (0, utils_1.binid)(stream.file_id) });
                    let mime = "application/octet-stream";
                    try {
                        mime = (await atlas_1.stores.audio_files.lookup(queue, file)).mime;
                    }
                    catch (error) { }
                    try {
                        mime = (await atlas_1.stores.image_files.lookup(queue, file)).mime;
                    }
                    catch (error) { }
                    try {
                        mime = (await atlas_1.stores.metadata_files.lookup(queue, file)).mime;
                    }
                    catch (error) { }
                    try {
                        mime = (await atlas_1.stores.subtitle_files.lookup(queue, file)).mime;
                    }
                    catch (error) { }
                    try {
                        mime = (await atlas_1.stores.video_files.lookup(queue, file)).mime;
                    }
                    catch (error) { }
                    if (mime.startsWith("audio/") || mime.startsWith("video/")) {
                        await (0, atlas_1.createStream)(queue, {
                            ...stream,
                            stream_id: (0, utils_1.binid)(stream.stream_id),
                            user_id: (0, utils_1.binid)(stream.user_id),
                            file_id: (0, utils_1.binid)(stream.file_id)
                        });
                    }
                }
                catch (error) { }
            }
            streams.close();
            let playlists = loadTable("playlists", schema.Playlist, (record) => record.playlist_id);
            for (let playlist of playlists) {
                try {
                    await atlas_1.stores.playlists.insert(queue, {
                        ...playlist,
                        playlist_id: (0, utils_1.binid)(playlist.playlist_id),
                        user_id: (0, utils_1.binid)(playlist.user_id),
                        affinity: 0
                    });
                }
                catch (error) { }
            }
            playlists.close();
            let playlist_items = loadTable("playlist_items", schema.PlaylistItem, (record) => record.playlist_item_id);
            for (let playlist_item of playlist_items) {
                try {
                    await atlas_1.stores.playlist_items.insert(queue, {
                        ...playlist_item,
                        playlist_item_id: (0, utils_1.binid)(playlist_item.playlist_item_id),
                        playlist_id: (0, utils_1.binid)(playlist_item.playlist_id),
                        track_id: (0, utils_1.binid)(playlist_item.track_id)
                    });
                }
                catch (error) { }
            }
            playlist_items.close();
            libfs.rmSync(TABLES_ROOT.join("/"), { force: true, recursive: true });
        }
        if (libfs.existsSync(INDICES_ROOT.join("/"))) {
            libfs.rmSync(INDICES_ROOT.join("/"), { force: true, recursive: true });
        }
    }
    exports.migrateLegacyData = migrateLegacyData;
    ;
    async function runIndexer() {
        console.log(`Running indexer...`);
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            console.log(`Updating file lists...`);
            for (let directory of await atlas_1.links.directory_directories.filter(queue)) {
                await checkDirectory(queue, directory, [...config_1.default.media_path, directory.name]);
            }
            for (let file of await atlas_1.links.directory_files.filter(queue)) {
                await checkFile(queue, file, [...config_1.default.media_path, file.name]);
            }
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            console.log(`Traversing media directory...`);
            await visitDirectory(queue, config_1.default.media_path, null);
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            await indexFiles(queue);
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            await associateMetadata(queue);
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            await associateImages(queue);
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            await associateSubtitles(queue);
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            await removeBrokenEntities(queue);
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            await computeAlbumTimestamps(queue);
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            await computeMovieTimestamps(queue);
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            await computeShowTimestamps(queue);
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            await computeMovieSuggestions(queue);
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            await migrateLegacyData(queue);
        });
        await atlas_1.transactionManager.enqueueWritableTransaction(async (queue) => {
            console.log(`Cleaning up...`);
            for (let token of await atlas_1.stores.tokens.filter(queue)) {
                if (token.expires_ms <= Date.now()) {
                    await atlas_1.stores.tokens.remove(queue, token);
                }
            }
            if ((await atlas_1.links.user_keys.filter(queue)).length === 0) {
                await atlas_1.stores.keys.insert(queue, {
                    key_id: (0, utils_1.binid)(makeId("key", libcrypto.randomBytes(8).toString("hex"))),
                    user_id: null
                });
            }
            for (let key of await atlas_1.links.user_keys.filter(queue)) {
                console.log(`Registration key available: ${(0, utils_1.hexid)(key.key_id)}`);
            }
        });
        console.log(`Indexing finished.`);
        if (global.gc) {
            global.gc();
            let mbs = process.memoryUsage().heapUsed / 1024 / 1024;
            console.log(`Memory usage: ${mbs.toFixed()} MB`);
        }
    }
    exports.runIndexer = runIndexer;
    ;
    runIndexer()
        .catch((error) => console.log(error));
    process.on("SIGTERM", () => {
        console.log("SIGTERM");
        process.exit(0);
    });
    process.on("SIGINT", () => {
        console.log("SIGINT");
        process.exit(0);
    });
});
define("build/api/handler", ["require", "exports", "crypto", "build/server/auth", "build/server/passwords", "build/jsondb/index", "build/is", "build/config/index", "build/database/atlas", "build/utils", "build/database/indexer", "node_modules/@joelek/atlas/dist/lib/index"], function (require, exports, libcrypto, auth, passwords, jsondb, is, config_1, atlas, utils_1, indexer_1, atlas_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.searchForUsers = exports.searchForTracks = exports.searchForShows = exports.searchForSeasons = exports.searchForPlaylists = exports.searchForActors = exports.searchForMovies = exports.searchForGenres = exports.searchForEpisodes = exports.searchForDiscs = exports.searchForCues = exports.searchForArtists = exports.searchForAlbums = exports.getNewMovies = exports.getNewAlbums = exports.lookupYear = exports.lookupYearBase = exports.lookupUser = exports.lookupUserBase = exports.lookupTrack = exports.lookupTrackBase = exports.lookupSubtitle = exports.lookupSubtitleBase = exports.lookupShow = exports.lookupShowBase = exports.lookupSeason = exports.lookupSeasonBase = exports.lookupPlaylistItem = exports.lookupPlaylistItemBase = exports.lookupPlaylist = exports.lookupPlaylistBase = exports.lookupActor = exports.lookupActorBase = exports.lookupMovie = exports.lookupMovieBase = exports.lookupGenre = exports.lookupGenreBase = exports.lookupEpisode = exports.lookupEpisodeBase = exports.lookupDisc = exports.lookupDiscBase = exports.lookupCue = exports.lookupCueBase = exports.lookupArtist = exports.lookupArtistBase = exports.lookupAlbum = exports.lookupAlbumBase = exports.createUser = exports.lookupFile = exports.getStreamWeight = void 0;
    exports.getAlbumsFromYear = exports.getMoviesFromYear = exports.getUserShows = exports.getUserAlbums = exports.getUserPlaylists = exports.getShowsFromActor = exports.getShowsFromGenre = exports.getMoviesFromActor = exports.getMoviesFromGenre = exports.getMovieSuggestions = exports.getPlaylistAppearances = exports.getArtistTracks = exports.getArtistAppearances = exports.searchForEntities = exports.searchForYears = void 0;
    function getStreamWeight(timestamp_ms) {
        let ms = Date.now() - timestamp_ms;
        let weeks = ms / (1000 * 60 * 60 * 24 * 7);
        return Math.pow(0.5, weeks);
    }
    exports.getStreamWeight = getStreamWeight;
    ;
    async function lookupFile(queue, file_id, user_id) {
        let file = await atlas.stores.files.lookup(queue, { file_id: (0, utils_1.binid)(file_id) });
        let mime = "application/octet-stream";
        try {
            mime = (await atlas.stores.audio_files.lookup(queue, file)).mime;
        }
        catch (error) { }
        try {
            mime = (await atlas.stores.image_files.lookup(queue, file)).mime;
        }
        catch (error) { }
        try {
            mime = (await atlas.stores.metadata_files.lookup(queue, file)).mime;
        }
        catch (error) { }
        try {
            mime = (await atlas.stores.subtitle_files.lookup(queue, file)).mime;
        }
        catch (error) { }
        try {
            mime = (await atlas.stores.video_files.lookup(queue, file)).mime;
        }
        catch (error) { }
        let paths = await (0, indexer_1.getPath)(queue, file);
        let path = paths.join("/");
        return {
            ...file,
            file_id: (0, utils_1.hexid)(file.file_id),
            parent_directory_id: file.parent_directory_id != null ? (0, utils_1.hexid)(file.parent_directory_id) : undefined,
            index_timestamp: file.index_timestamp ?? undefined,
            mime,
            path
        };
    }
    exports.lookupFile = lookupFile;
    ;
    async function createUser(queue, request) {
        let { username, password, name, key_id } = { ...request };
        let errors = new Array();
        if ((await atlas.queries.getUsersFromUsername.filter(queue, { username })).length > 0) {
            errors.push(`The requested username is not available.`);
        }
        if (config_1.default.use_registration_keys) {
            try {
                let key = await atlas.stores.keys.lookup(queue, { key_id: (0, utils_1.binid)(key_id) });
                if (is.present(key.user_id)) {
                    errors.push(`The registration key has already been used.`);
                }
            }
            catch (error) {
                errors.push(`The registration key is not valid.`);
            }
        }
        if (Buffer.from(username).length >= 256) {
            errors.push(`The username is too long!`);
        }
        if (Buffer.from(name).length >= 256) {
            errors.push(`The name is too long!`);
        }
        if (errors.length > 0) {
            return {
                errors
            };
        }
        let user_id = Uint8Array.from(libcrypto.randomBytes(8));
        await atlas.stores.users.insert(queue, {
            user_id,
            username,
            name,
            password: passwords.generate(password)
        });
        if (config_1.default.use_registration_keys) {
            let key = await atlas.stores.keys.lookup(queue, { key_id: (0, utils_1.binid)(key_id) });
            await atlas.stores.keys.update(queue, {
                ...key,
                user_id
            });
        }
        let token = await auth.createToken(queue, username, password);
        return {
            token
        };
    }
    exports.createUser = createUser;
    ;
    async function lookupAlbumBase(queue, album_id, api_user_id) {
        let album = await atlas.stores.albums.lookup(queue, { album_id: (0, utils_1.binid)(album_id) });
        let image_files = [];
        let album_files = await atlas.links.album_album_files.filter(queue, album);
        for (let album_file of album_files) {
            try {
                image_files.push(await atlas.stores.image_files.lookup(queue, album_file));
            }
            catch (error) { }
        }
        return {
            album_id: (0, utils_1.hexid)(album.album_id),
            title: config_1.default.use_demo_mode ? "Album title" : album.title,
            artwork: image_files.map((image_file) => ({
                ...image_file,
                file_id: (0, utils_1.hexid)(image_file.file_id)
            }))
        };
    }
    exports.lookupAlbumBase = lookupAlbumBase;
    ;
    async function lookupAlbum(queue, album_id, api_user_id) {
        let album_base = await lookupAlbumBase(queue, album_id, api_user_id);
        let album = await atlas.stores.albums.lookup(queue, { album_id: (0, utils_1.binid)(album_id) });
        return {
            ...album_base,
            artists: await Promise.all((await atlas.links.album_album_artists.filter(queue, album))
                .map((record) => lookupArtistBase(queue, (0, utils_1.hexid)(record.artist_id), api_user_id))),
            year: album.year_id != null ? await lookupYearBase(queue, (0, utils_1.hexid)(album.year_id), api_user_id) : undefined,
            discs: await Promise.all((await atlas.links.album_discs.filter(queue, album))
                .map((record) => lookupDisc(queue, (0, utils_1.hexid)(record.disc_id), api_user_id, album_base))),
            affinity: atlas.adjustAffinity(album.affinity)
        };
    }
    exports.lookupAlbum = lookupAlbum;
    ;
    async function lookupArtistBase(queue, artist_id, api_user_id) {
        let artist = await atlas.stores.artists.lookup(queue, { artist_id: (0, utils_1.binid)(artist_id) });
        return {
            artist_id: (0, utils_1.hexid)(artist.artist_id),
            title: config_1.default.use_demo_mode ? "Artist name" : artist.name
        };
    }
    exports.lookupArtistBase = lookupArtistBase;
    ;
    async function lookupArtist(queue, artist_id, api_user_id) {
        let artist_base = await lookupArtistBase(queue, artist_id, api_user_id);
        let artist = await atlas.stores.artists.lookup(queue, { artist_id: (0, utils_1.binid)(artist_id) });
        return {
            ...artist_base,
            albums: await Promise.all((await atlas.links.artist_album_artists.filter(queue, artist))
                .map((album_artist) => lookupAlbum(queue, (0, utils_1.hexid)(album_artist.album_id), api_user_id))),
            affinity: atlas.adjustAffinity(artist.affinity)
        };
    }
    exports.lookupArtist = lookupArtist;
    ;
    async function lookupCueBase(queue, cue_id, api_user_id, subtitle) {
        let cue = await atlas.stores.cues.lookup(queue, { cue_id: (0, utils_1.binid)(cue_id) });
        return {
            cue_id: (0, utils_1.hexid)(cue.cue_id),
            subtitle: is.present(subtitle) ? subtitle : await lookupSubtitleBase(queue, (0, utils_1.hexid)(cue.subtitle_id), api_user_id),
            start_ms: cue.start_ms,
            duration_ms: cue.duration_ms,
            lines: cue.lines.split("\n")
        };
    }
    exports.lookupCueBase = lookupCueBase;
    ;
    async function lookupCue(queue, cue_id, api_user_id, subtitle) {
        let cue_base = await lookupCueBase(queue, cue_id, api_user_id, subtitle);
        let video_subtitles = await atlas.links.subtitle_file_video_subtitles.filter(queue, { file_id: (0, utils_1.binid)(cue_base.subtitle.subtitle.file_id) });
        let entities = [];
        for (let video_subtitle of video_subtitles) {
            let episode_files = await atlas.links.file_episode_files.filter(queue, { file_id: video_subtitle.video_file_id });
            for (let episode_file of episode_files) {
                try {
                    entities.push(await lookupEpisode(queue, (0, utils_1.hexid)(episode_file.episode_id), api_user_id));
                }
                catch (error) { }
            }
            let movie_files = await atlas.links.file_movie_files.filter(queue, { file_id: video_subtitle.video_file_id });
            for (let movie_file of movie_files) {
                try {
                    entities.push(await lookupMovie(queue, (0, utils_1.hexid)(movie_file.movie_id), api_user_id));
                }
                catch (error) { }
            }
        }
        let entity = entities.pop();
        if (is.absent(entity)) {
            throw `Expected a valid video file!`;
        }
        return {
            ...cue_base,
            media: entity
        };
    }
    exports.lookupCue = lookupCue;
    ;
    async function lookupDiscBase(queue, disc_id, api_user_id, album) {
        let disc = await atlas.stores.discs.lookup(queue, { disc_id: (0, utils_1.binid)(disc_id) });
        return {
            disc_id: (0, utils_1.hexid)(disc.disc_id),
            album: is.present(album) ? album : await lookupAlbumBase(queue, (0, utils_1.hexid)(disc.album_id), api_user_id),
            number: disc.number
        };
    }
    exports.lookupDiscBase = lookupDiscBase;
    ;
    async function lookupDisc(queue, disc_id, api_user_id, album) {
        let disc_base = await lookupDiscBase(queue, disc_id, api_user_id, album);
        let disc = await atlas.stores.discs.lookup(queue, { disc_id: (0, utils_1.binid)(disc_id) });
        return {
            ...disc_base,
            tracks: await Promise.all((await atlas.links.disc_tracks.filter(queue, disc))
                .map((record) => lookupTrack(queue, (0, utils_1.hexid)(record.track_id), api_user_id, disc_base))),
            affinity: atlas.adjustAffinity(disc.affinity)
        };
    }
    exports.lookupDisc = lookupDisc;
    ;
    async function lookupEpisodeBase(queue, episode_id, api_user_id, season) {
        let episode = await atlas.stores.episodes.lookup(queue, { episode_id: (0, utils_1.binid)(episode_id) });
        return {
            episode_id: (0, utils_1.hexid)(episode.episode_id),
            title: config_1.default.use_demo_mode ? "Episode title" : episode.title,
            number: episode.number,
            season: is.present(season) ? season : await lookupSeasonBase(queue, (0, utils_1.hexid)(episode.season_id), api_user_id)
        };
    }
    exports.lookupEpisodeBase = lookupEpisodeBase;
    ;
    async function lookupEpisode(queue, episode_id, api_user_id, season) {
        let episode_base = await lookupEpisodeBase(queue, episode_id, api_user_id, season);
        let episode = await atlas.stores.episodes.lookup(queue, { episode_id: (0, utils_1.binid)(episode_id) });
        let video_files = [];
        let episode_files = await atlas.links.episode_episode_files.filter(queue, episode);
        for (let episode_file of episode_files) {
            try {
                video_files.push(await atlas.stores.video_files.lookup(queue, episode_file));
            }
            catch (error) { }
        }
        video_files.sort(jsondb.NumericSort.increasing((record) => record.height));
        let video_file = video_files.pop();
        if (is.absent(video_file)) {
            throw `Expected a valid video file!`;
        }
        let subtitle_files = [];
        let video_file_video_subtitles = (await atlas.links.video_file_video_subtitles.filter(queue, video_file));
        for (let video_file_video_subtitle of video_file_video_subtitles) {
            subtitle_files.push(await atlas.stores.subtitle_files.lookup(queue, { file_id: video_file_video_subtitle.subtitle_file_id }));
        }
        let streams = await atlas.queries.getStreamsFromUserIdAndFileId.filter(queue, {
            user_id: (0, utils_1.binid)(api_user_id),
            file_id: video_file.file_id
        }, undefined, 1);
        return {
            ...episode_base,
            year: episode.year_id != null ? await lookupYearBase(queue, (0, utils_1.hexid)(episode.year_id), api_user_id) : undefined,
            summary: config_1.default.use_demo_mode ? "Episode summary." : episode.summary ?? undefined,
            last_stream_date: streams.pop()?.timestamp_ms,
            media: {
                ...video_file,
                file_id: (0, utils_1.hexid)(video_file.file_id)
            },
            subtitles: subtitle_files.map((subtitle_file) => ({
                ...subtitle_file,
                file_id: (0, utils_1.hexid)(subtitle_file.file_id),
                language: subtitle_file.language ?? undefined
            })),
            copyright: episode.copyright ?? undefined,
            imdb: episode.imdb ?? undefined,
            affinity: atlas.adjustAffinity(episode.affinity)
        };
    }
    exports.lookupEpisode = lookupEpisode;
    ;
    async function lookupGenreBase(queue, genre_id, api_user_id) {
        let genre = await atlas.stores.genres.lookup(queue, { genre_id: (0, utils_1.binid)(genre_id) });
        return {
            genre_id: (0, utils_1.hexid)(genre.genre_id),
            title: genre.name
        };
    }
    exports.lookupGenreBase = lookupGenreBase;
    ;
    async function lookupGenre(queue, genre_id, api_user_id) {
        let genre_base = await lookupGenreBase(queue, genre_id, api_user_id);
        let genre = await atlas.stores.genres.lookup(queue, { genre_id: (0, utils_1.binid)(genre_id) });
        return {
            ...genre_base,
            affinity: atlas.adjustAffinity(genre.affinity)
        };
    }
    exports.lookupGenre = lookupGenre;
    ;
    async function lookupMovieBase(queue, movie_id, api_user_id) {
        let movie = await atlas.stores.movies.lookup(queue, { movie_id: (0, utils_1.binid)(movie_id) });
        let movie_files = await atlas.links.movie_movie_files.filter(queue, movie);
        let artwork = [];
        for (let movie_file of movie_files) {
            try {
                let image_file = await atlas.stores.image_files.lookup(queue, movie_file);
                artwork.push({
                    ...image_file,
                    file_id: (0, utils_1.hexid)(image_file.file_id)
                });
            }
            catch (error) { }
        }
        return {
            movie_id: (0, utils_1.hexid)(movie.movie_id),
            title: config_1.default.use_demo_mode ? "Movie title" : movie.title,
            artwork: artwork
        };
    }
    exports.lookupMovieBase = lookupMovieBase;
    ;
    async function lookupMovie(queue, movie_id, api_user_id) {
        let movie_base = await lookupMovieBase(queue, movie_id, api_user_id);
        let movie = await atlas.stores.movies.lookup(queue, { movie_id: (0, utils_1.binid)(movie_id) });
        let video_files = [];
        let movie_files = await atlas.links.movie_movie_files.filter(queue, movie);
        for (let movie_file of movie_files) {
            try {
                video_files.push(await atlas.stores.video_files.lookup(queue, movie_file));
            }
            catch (error) { }
        }
        video_files.sort(jsondb.NumericSort.increasing((record) => record.height));
        let video_file = video_files.pop();
        if (is.absent(video_file)) {
            throw `Expected a valid video file!`;
        }
        let subtitle_files = [];
        let video_file_video_subtitles = (await atlas.links.video_file_video_subtitles.filter(queue, video_file));
        for (let video_file_video_subtitle of video_file_video_subtitles) {
            subtitle_files.push(await atlas.stores.subtitle_files.lookup(queue, { file_id: video_file_video_subtitle.subtitle_file_id }));
        }
        let streams = await atlas.queries.getStreamsFromUserIdAndFileId.filter(queue, {
            user_id: (0, utils_1.binid)(api_user_id),
            file_id: video_file.file_id
        }, undefined, 1);
        return {
            ...movie_base,
            year: movie.year_id != null ? await lookupYearBase(queue, (0, utils_1.hexid)(movie.year_id), api_user_id) : undefined,
            summary: config_1.default.use_demo_mode ? "Movie summary." : movie.summary ?? undefined,
            genres: await Promise.all((await atlas.links.movie_movie_genres.filter(queue, movie))
                .map((record) => lookupGenreBase(queue, (0, utils_1.hexid)(record.genre_id), api_user_id))),
            actors: await Promise.all((await atlas.links.movie_movie_actors.filter(queue, movie))
                .map((record) => lookupActorBase(queue, (0, utils_1.hexid)(record.actor_id), api_user_id))),
            last_stream_date: streams.pop()?.timestamp_ms,
            media: {
                ...video_file,
                file_id: (0, utils_1.hexid)(video_file.file_id)
            },
            subtitles: subtitle_files.map((subtitle_file) => ({
                ...subtitle_file,
                file_id: (0, utils_1.hexid)(subtitle_file.file_id),
                language: subtitle_file.language ?? undefined
            })),
            copyright: movie.copyright ?? undefined,
            imdb: movie.imdb ?? undefined,
            affinity: atlas.adjustAffinity(movie.affinity)
        };
    }
    exports.lookupMovie = lookupMovie;
    ;
    async function lookupActorBase(queue, actor_id, api_user_id) {
        let actor = await atlas.stores.actors.lookup(queue, { actor_id: (0, utils_1.binid)(actor_id) });
        return {
            actor_id: (0, utils_1.hexid)(actor.actor_id),
            name: config_1.default.use_demo_mode ? "Actor name" : actor.name
        };
    }
    exports.lookupActorBase = lookupActorBase;
    ;
    async function lookupActor(queue, actor_id, api_user_id) {
        let actor_base = await lookupActorBase(queue, actor_id, api_user_id);
        let actor = await atlas.stores.actors.lookup(queue, { actor_id: (0, utils_1.binid)(actor_id) });
        return {
            ...actor_base,
            affinity: atlas.adjustAffinity(actor.affinity)
        };
    }
    exports.lookupActor = lookupActor;
    ;
    async function lookupPlaylistBase(queue, playlist_id, api_user_id, user) {
        let playlist = await atlas.stores.playlists.lookup(queue, { playlist_id: (0, utils_1.binid)(playlist_id) });
        return {
            playlist_id: (0, utils_1.hexid)(playlist.playlist_id),
            title: playlist.title,
            description: playlist.description,
            user: is.present(user) ? user : await lookupUserBase(queue, (0, utils_1.hexid)(playlist.user_id), api_user_id)
        };
    }
    exports.lookupPlaylistBase = lookupPlaylistBase;
    ;
    async function lookupPlaylist(queue, playlist_id, api_user_id, user) {
        let playlist_base = await lookupPlaylistBase(queue, playlist_id, api_user_id, user);
        let playlist = await atlas.stores.playlists.lookup(queue, { playlist_id: (0, utils_1.binid)(playlist_id) });
        return {
            ...playlist_base,
            items: await Promise.all((await atlas.links.playlist_playlist_items.filter(queue, { playlist_id: (0, utils_1.binid)(playlist_base.playlist_id) }))
                .map((record) => lookupPlaylistItem(queue, (0, utils_1.hexid)(record.playlist_item_id), api_user_id, playlist_base))),
            affinity: atlas.adjustAffinity(playlist.affinity)
        };
    }
    exports.lookupPlaylist = lookupPlaylist;
    ;
    async function lookupPlaylistItemBase(queue, playlist_item_id, api_user_id, playlist) {
        let playlist_item = await atlas.stores.playlist_items.lookup(queue, { playlist_item_id: (0, utils_1.binid)(playlist_item_id) });
        return {
            playlist_item_id: (0, utils_1.hexid)(playlist_item.playlist_item_id),
            number: playlist_item.number,
            playlist: is.present(playlist) ? playlist : await lookupPlaylistBase(queue, (0, utils_1.hexid)(playlist_item.playlist_id), api_user_id),
            track: await lookupTrack(queue, (0, utils_1.hexid)(playlist_item.track_id), api_user_id)
        };
    }
    exports.lookupPlaylistItemBase = lookupPlaylistItemBase;
    ;
    async function lookupPlaylistItem(queue, playlist_item_id, api_user_id, playlist) {
        let playlist_item = await lookupPlaylistItemBase(queue, playlist_item_id, api_user_id, playlist);
        return {
            ...playlist_item
        };
    }
    exports.lookupPlaylistItem = lookupPlaylistItem;
    ;
    async function lookupSeasonBase(queue, season_id, api_user_id, show) {
        let season = await atlas.stores.seasons.lookup(queue, { season_id: (0, utils_1.binid)(season_id) });
        return {
            season_id: (0, utils_1.hexid)(season.season_id),
            number: season.number,
            show: is.present(show) ? show : await lookupShowBase(queue, (0, utils_1.hexid)(season.show_id), api_user_id)
        };
    }
    exports.lookupSeasonBase = lookupSeasonBase;
    ;
    async function lookupSeason(queue, season_id, api_user_id, show) {
        let season_base = await lookupSeasonBase(queue, season_id, api_user_id, show);
        let season = await atlas.stores.seasons.lookup(queue, { season_id: (0, utils_1.binid)(season_id) });
        return {
            ...season_base,
            episodes: await Promise.all((await atlas.links.season_episodes.filter(queue, season))
                .map((record) => lookupEpisode(queue, (0, utils_1.hexid)(record.episode_id), api_user_id, season_base))),
            affinity: atlas.adjustAffinity(season.affinity)
        };
    }
    exports.lookupSeason = lookupSeason;
    ;
    async function lookupShowBase(queue, show_id, api_user_id) {
        let show = await atlas.stores.shows.lookup(queue, { show_id: (0, utils_1.binid)(show_id) });
        let show_files = await atlas.links.show_show_files.filter(queue, show);
        let artwork;
        for (let show_file of show_files) {
            try {
                artwork = await atlas.stores.image_files.lookup(queue, show_file);
                break;
            }
            catch (error) { }
        }
        return {
            show_id: (0, utils_1.hexid)(show.show_id),
            title: config_1.default.use_demo_mode ? "Show title" : show.name,
            artwork: artwork != null ? [
                {
                    ...artwork,
                    file_id: (0, utils_1.hexid)(artwork.file_id)
                }
            ] : []
        };
    }
    exports.lookupShowBase = lookupShowBase;
    ;
    async function lookupShow(queue, show_id, api_user_id) {
        let show_base = await lookupShowBase(queue, show_id, api_user_id);
        let show = await atlas.stores.shows.lookup(queue, { show_id: (0, utils_1.binid)(show_id) });
        return {
            ...show_base,
            summary: config_1.default.use_demo_mode ? "Show summary." : show.summary ?? undefined,
            genres: await Promise.all((await atlas.links.show_show_genres.filter(queue, show))
                .map((show_genre) => lookupGenreBase(queue, (0, utils_1.hexid)(show_genre.genre_id), api_user_id))),
            actors: await Promise.all((await atlas.links.show_show_actors.filter(queue, show))
                .map((show_actor) => lookupActorBase(queue, (0, utils_1.hexid)(show_actor.actor_id), api_user_id))),
            seasons: await Promise.all((await atlas.links.show_seasons.filter(queue, show))
                .map((season) => lookupSeason(queue, (0, utils_1.hexid)(season.season_id), api_user_id, show_base))),
            imdb: show.imdb ?? undefined,
            affinity: atlas.adjustAffinity(show.affinity)
        };
    }
    exports.lookupShow = lookupShow;
    ;
    async function lookupSubtitleBase(queue, subtitle_id, user_id) {
        let subtitle = await atlas.stores.subtitles.lookup(queue, { subtitle_id: (0, utils_1.binid)(subtitle_id) });
        let subtitle_file = await atlas.stores.subtitle_files.lookup(queue, subtitle);
        return {
            subtitle_id: (0, utils_1.hexid)(subtitle.subtitle_id),
            subtitle: {
                ...subtitle_file,
                file_id: (0, utils_1.hexid)(subtitle_file.file_id),
                language: subtitle_file.language ?? undefined
            }
        };
    }
    exports.lookupSubtitleBase = lookupSubtitleBase;
    ;
    async function lookupSubtitle(queue, subtitle_id, user_id) {
        let subtitle = await lookupSubtitleBase(queue, subtitle_id, user_id);
        let subtitle_cues = await atlas.links.subtitle_cues.filter(queue, { subtitle_id: (0, utils_1.binid)(subtitle.subtitle_id) });
        let cues = [];
        for (let subtitle_cue of subtitle_cues) {
            cues.push(await lookupCue(queue, (0, utils_1.hexid)(subtitle_cue.cue_id), user_id));
        }
        return {
            ...subtitle,
            cues: cues
        };
    }
    exports.lookupSubtitle = lookupSubtitle;
    ;
    async function lookupTrackBase(queue, track_id, user_id, disc) {
        let record = await atlas.stores.tracks.lookup(queue, { track_id: (0, utils_1.binid)(track_id) });
        return {
            track_id: (0, utils_1.hexid)(record.track_id),
            title: config_1.default.use_demo_mode ? "Track title" : record.title,
            disc: is.present(disc) ? disc : await lookupDiscBase(queue, (0, utils_1.hexid)(record.disc_id), user_id),
            number: record.number
        };
    }
    exports.lookupTrackBase = lookupTrackBase;
    ;
    async function lookupTrack(queue, track_id, user_id, disc) {
        let track = await lookupTrackBase(queue, track_id, user_id, disc);
        let record = await atlas.stores.tracks.lookup(queue, { track_id: (0, utils_1.binid)(track_id) });
        let track_files = await atlas.links.track_track_files.filter(queue, record);
        let media;
        for (let track_file of track_files) {
            try {
                media = await atlas.stores.audio_files.lookup(queue, track_file);
                break;
            }
            catch (error) { }
        }
        if (media == null) {
            throw `Expected a valid audio file!`;
        }
        let artists = [];
        let track_artists = await atlas.links.track_track_artists.filter(queue, record);
        for (let track_artist of track_artists) {
            artists.push(await lookupArtistBase(queue, (0, utils_1.hexid)(track_artist.artist_id), user_id));
        }
        let streams = await atlas.queries.getStreamsFromUserIdAndFileId.filter(queue, {
            user_id: (0, utils_1.binid)(user_id),
            file_id: media.file_id
        }, undefined, 1);
        return {
            ...track,
            artists: artists,
            last_stream_date: streams.pop()?.timestamp_ms,
            media: {
                ...media,
                file_id: (0, utils_1.hexid)(media.file_id)
            },
            copyright: record.copyright ?? undefined,
            affinity: atlas.adjustAffinity(record.affinity)
        };
    }
    exports.lookupTrack = lookupTrack;
    ;
    async function lookupUserBase(queue, user_id, api_user_id) {
        let record = await atlas.stores.users.lookup(queue, { user_id: (0, utils_1.binid)(user_id) });
        return {
            user_id: (0, utils_1.hexid)(record.user_id),
            name: record.name,
            username: record.username
        };
    }
    exports.lookupUserBase = lookupUserBase;
    ;
    async function lookupUser(queue, user_id, api_user_id) {
        let user = await lookupUserBase(queue, user_id, api_user_id);
        return {
            ...user
        };
    }
    exports.lookupUser = lookupUser;
    ;
    async function lookupYearBase(queue, year_id, user_id) {
        let record = await atlas.stores.years.lookup(queue, { year_id: (0, utils_1.binid)(year_id) });
        return {
            year_id: (0, utils_1.hexid)(record.year_id),
            year: record.year
        };
    }
    exports.lookupYearBase = lookupYearBase;
    ;
    async function lookupYear(queue, year_id, user_id) {
        let year = await lookupYearBase(queue, year_id, user_id);
        let record = await atlas.stores.years.lookup(queue, { year_id: (0, utils_1.binid)(year_id) });
        return {
            ...year,
            affinity: atlas.adjustAffinity(record.affinity)
        };
    }
    exports.lookupYear = lookupYear;
    ;
    async function getNewAlbums(queue, user_id, anchor, offset, length) {
        let albums = [];
        for (let entry of await atlas.queries.getRecentlyUpdatedAlbums.filter(queue, {}, anchor != null ? { album_id: (0, utils_1.binid)(anchor) } : undefined, length)) {
            albums.push(await lookupAlbum(queue, (0, utils_1.hexid)(entry.album_id), user_id));
        }
        return albums;
    }
    exports.getNewAlbums = getNewAlbums;
    ;
    async function getNewMovies(queue, user_id, anchor, offset, length) {
        let movies = [];
        for (let entry of await atlas.queries.getRecentlyUpdatedMovies.filter(queue, {}, anchor != null ? { movie_id: (0, utils_1.binid)(anchor) } : undefined, length)) {
            movies.push(await lookupMovie(queue, (0, utils_1.hexid)(entry.movie_id), user_id));
        }
        return movies;
    }
    exports.getNewMovies = getNewMovies;
    ;
    async function searchForAlbums(queue, query, anchor, offset, length, user_id) {
        if (query === "") {
            return await Promise.all((await atlas.stores.albums.filter(queue, undefined, undefined, anchor != null ? { album_id: (0, utils_1.binid)(anchor) } : undefined, length))
                .map((record) => lookupAlbum(queue, (0, utils_1.hexid)(record.album_id), user_id)));
        }
        else {
            return [];
            /* 		return await Promise.all(database.album_search.search(query)
                        .slice(offset, offset + length)
                        .map((record) => record.lookup().album_id)
                        .map((id) => lookupAlbum(queue, id, user_id))
                        .collect()); */
        }
    }
    exports.searchForAlbums = searchForAlbums;
    ;
    async function searchForArtists(queue, query, anchor, offset, length, user_id) {
        if (query === "") {
            return await Promise.all((await atlas.stores.artists.filter(queue, undefined, undefined, anchor != null ? { artist_id: (0, utils_1.binid)(anchor) } : undefined, length))
                .map((record) => lookupArtist(queue, (0, utils_1.hexid)(record.artist_id), user_id)));
        }
        else {
            return [];
            /* 		return await Promise.all(database.artist_search.search(query)
                        .slice(offset, offset + length)
                        .map((record) => record.lookup().artist_id)
                        .map((id) => lookupArtist(queue, id, user_id))
                        .collect()); */
        }
    }
    exports.searchForArtists = searchForArtists;
    ;
    async function searchForCues(queue, query, offset, limit, user_id) {
        return []; /* await Promise.all(database.cue_search.search(query)
            .slice(offset, offset + limit)
            .map((record) => lookupCue(queue, record.lookup().cue_id, user_id))
            .include(is.present)
            .collect()); */
    }
    exports.searchForCues = searchForCues;
    ;
    async function searchForDiscs(queue, query, anchor, offset, length, user_id) {
        return await Promise.all((await atlas.stores.discs.filter(queue, undefined, undefined, anchor != null ? { disc_id: (0, utils_1.binid)(anchor) } : undefined, length))
            .map((record) => lookupDisc(queue, (0, utils_1.hexid)(record.disc_id), user_id)));
    }
    exports.searchForDiscs = searchForDiscs;
    ;
    async function searchForEpisodes(queue, query, anchor, offset, length, user_id) {
        if (query === "") {
            return await Promise.all((await atlas.stores.episodes.filter(queue, undefined, undefined, anchor != null ? { episode_id: (0, utils_1.binid)(anchor) } : undefined, length))
                .map((record) => lookupEpisode(queue, (0, utils_1.hexid)(record.episode_id), user_id)));
        }
        else {
            return [];
            /* 		return await Promise.all(database.episode_search.search(query)
                        .slice(offset, offset + length)
                        .map((record) => record.lookup().episode_id)
                        .map((id) => lookupEpisode(queue, id, user_id))
                        .collect()); */
        }
    }
    exports.searchForEpisodes = searchForEpisodes;
    ;
    async function searchForGenres(queue, query, anchor, offset, length, user_id) {
        if (query === "") {
            return await Promise.all((await atlas.stores.genres.filter(queue, undefined, undefined, anchor != null ? { genre_id: (0, utils_1.binid)(anchor) } : undefined, length))
                .map((record) => lookupGenre(queue, (0, utils_1.hexid)(record.genre_id), user_id)));
        }
        else {
            return [];
            /* 		return await Promise.all(database.genre_search.search(query)
                        .slice(offset, offset + length)
                        .map((record) => record.lookup().genre_id)
                        .map((id) => lookupGenre(queue, id, user_id))
                        .collect()); */
        }
    }
    exports.searchForGenres = searchForGenres;
    ;
    async function searchForMovies(queue, query, anchor, offset, length, user_id) {
        if (query === "") {
            return await Promise.all((await atlas.stores.movies.filter(queue, undefined, undefined, anchor != null ? { movie_id: (0, utils_1.binid)(anchor) } : undefined, length))
                .map((record) => lookupMovie(queue, (0, utils_1.hexid)(record.movie_id), user_id)));
        }
        else {
            return [];
            /* 		return await Promise.all(database.movie_search.search(query)
                        .slice(offset, offset + length)
                        .map((record) => record.lookup().movie_id)
                        .map((id) => lookupMovie(queue, id, user_id))
                        .collect()); */
        }
    }
    exports.searchForMovies = searchForMovies;
    ;
    async function searchForActors(queue, query, anchor, offset, length, user_id) {
        if (query === "") {
            return await Promise.all((await atlas.stores.actors.filter(queue, undefined, undefined, anchor != null ? { actor_id: (0, utils_1.binid)(anchor) } : undefined, length))
                .map((record) => lookupActor(queue, (0, utils_1.hexid)(record.actor_id), user_id)));
        }
        else {
            return [];
            /* 		return await Promise.all(database.actor_search.search(query)
                        .slice(offset, offset + length)
                        .map((record) => record.lookup().actor_id)
                        .map((id) => lookupActor(queue, id, user_id))
                        .collect()); */
        }
    }
    exports.searchForActors = searchForActors;
    ;
    async function searchForPlaylists(queue, query, anchor, offset, length, user_id) {
        if (query === "") {
            return await Promise.all((await atlas.stores.playlists.filter(queue, undefined, undefined, anchor != null ? { playlist_id: (0, utils_1.binid)(anchor) } : undefined, length))
                .map((record) => lookupPlaylist(queue, (0, utils_1.hexid)(record.playlist_id), user_id)));
        }
        else {
            return [];
            /* 		return await Promise.all(database.playlist_search.search(query)
                        .slice(offset, offset + length)
                        .map((record) => record.lookup().playlist_id)
                        .map((id) => lookupPlaylist(queue, id, user_id))
                        .collect()); */
        }
    }
    exports.searchForPlaylists = searchForPlaylists;
    ;
    async function searchForSeasons(queue, query, anchor, offset, length, user_id) {
        return await Promise.all((await atlas.stores.seasons.filter(queue, undefined, undefined, anchor != null ? { season_id: (0, utils_1.binid)(anchor) } : undefined, length))
            .map((record) => lookupSeason(queue, (0, utils_1.hexid)(record.season_id), user_id)));
    }
    exports.searchForSeasons = searchForSeasons;
    ;
    async function searchForShows(queue, query, anchor, offset, length, user_id) {
        if (query === "") {
            return await Promise.all((await atlas.stores.shows.filter(queue, undefined, undefined, anchor != null ? { show_id: (0, utils_1.binid)(anchor) } : undefined, length))
                .map((record) => lookupShow(queue, (0, utils_1.hexid)(record.show_id), user_id)));
        }
        else {
            return [];
            /* 		return await Promise.all(database.shows_search.search(query)
                        .slice(offset, offset + length)
                        .map((record) => record.lookup().show_id)
                        .map((id) => lookupShow(queue, id, user_id))
                        .collect()); */
        }
    }
    exports.searchForShows = searchForShows;
    ;
    async function searchForTracks(queue, query, anchor, offset, length, user_id) {
        if (query === "") {
            return await Promise.all((await atlas.stores.tracks.filter(queue, undefined, undefined, anchor != null ? { track_id: (0, utils_1.binid)(anchor) } : undefined, length))
                .map((record) => lookupTrack(queue, (0, utils_1.hexid)(record.track_id), user_id)));
        }
        else {
            return [];
            /* 		return await Promise.all(database.track_search.search(query)
                        .slice(offset, offset + length)
                        .map((record) => record.lookup().track_id)
                        .map((id) => lookupTrack(queue, id, user_id))
                        .collect()); */
        }
    }
    exports.searchForTracks = searchForTracks;
    ;
    async function searchForUsers(queue, query, anchor, offset, length, user_id) {
        if (query === "") {
            return await Promise.all((await atlas.stores.users.filter(queue, undefined, undefined, anchor != null ? { user_id: (0, utils_1.binid)(anchor) } : undefined, length))
                .map((record) => lookupUser(queue, (0, utils_1.hexid)(record.user_id), user_id)));
        }
        else {
            return [];
            /* 		return await Promise.all(database.user_search.search(query)
                        .slice(offset, offset + length)
                        .map((record) => record.lookup().user_id)
                        .map((id) => lookupUser(queue, id, user_id))
                        .collect()); */
        }
    }
    exports.searchForUsers = searchForUsers;
    ;
    async function searchForYears(queue, query, anchor, offset, length, user_id) {
        if (query === "") {
            return await Promise.all((await atlas.stores.years.filter(queue, undefined, { year: (0, atlas_1.createDecreasingOrder)() }, anchor != null ? { year_id: (0, utils_1.binid)(anchor) } : undefined, length))
                .map((record) => lookupYear(queue, (0, utils_1.hexid)(record.year_id), user_id)));
        }
        else {
            return [];
            /* 		return await Promise.all(database.year_search.search(query)
                        .slice(offset, offset + length)
                        .map((record) => record.lookup().year_id)
                        .map((id) => lookupYear(queue, id, user_id))
                        .collect()); */
        }
    }
    exports.searchForYears = searchForYears;
    ;
    async function searchForEntities(queue, query, user_id, offset, limit, options) {
        return [];
        /* 	let results = [
                ...database.actor_search.search(query).map((result) => ({ ...result, type: "ACTOR", type_rank: 1 })),
                ...database.album_search.search(query).map((result) => ({ ...result, type: "ALBUM", type_rank: 9 })),
                ...database.artist_search.search(query).map((result) => ({ ...result, type: "ARTIST", type_rank: 6 })),
                ...database.episode_search.search(query).map((result) => ({ ...result, type: "EPISODE", type_rank: 4 })),
                ...database.genre_search.search(query).map((result) => ({ ...result, type: "GENRE", type_rank: 2 })),
                ...database.movie_search.search(query).map((result) => ({ ...result, type: "MOVIE", type_rank: 8 })),
                ...database.playlist_search.search(query).map((result) => ({ ...result, type: "PLAYLIST", type_rank: 3 })),
                ...database.shows_search.search(query).map((result) => ({ ...result, type: "SHOW", type_rank: 7 })),
                ...database.track_search.search(query).map((result) => ({ ...result, type: "TRACK", type_rank: 5 })),
                ...database.user_search.search(query).map((result) => ({ ...result, type: "USER", type_rank: 0 })),
                ...database.year_search.search(query).map((result) => ({ ...result, type: "YEAR", type_rank: 10 })),
                ...new Array<SearchResult<Cue> & { type: "CUE", type_rank: number }>()
            ].sort(jsondb.CombinedSort.of(
                jsondb.NumericSort.decreasing((value) => value.rank),
                jsondb.NumericSort.decreasing((value) => value.type_rank)
            ));
            if (options?.cues) {
                let cue = database.cue_search.search(query).shift();
                if (is.present(cue)) {
                    let result = results[0];
                    if (is.absent(result) || cue.rank > result.rank) {
                        results.unshift({ ...cue, type: "CUE", type_rank: 11 });
                    }
                }
            }
            let entities = await Promise.all(results.slice(offset, offset + limit).map((result) => {
                let type = result.type;
                if (false) {
                } else if (type === "ACTOR") {
                    return lookupActor(queue, (result.lookup() as Actor).actor_id, user_id);
                } else if (type === "ALBUM") {
                    return lookupAlbum(queue, (result.lookup() as Album).album_id, user_id);
                } else if (type === "ARTIST") {
                    return lookupArtist(queue, (result.lookup() as Artist).artist_id, user_id);
                } else if (type === "CUE") {
                    return lookupCue(queue, (result.lookup() as Cue).cue_id, user_id);
                } else if (type === "EPISODE") {
                    return lookupEpisode(queue, (result.lookup() as Episode).episode_id, user_id);
                } else if (type === "GENRE") {
                    return lookupGenre(queue, (result.lookup() as Genre).genre_id, user_id);
                } else if (type === "MOVIE") {
                    return lookupMovie(queue, (result.lookup() as Movie).movie_id, user_id);
                } else if (type === "PLAYLIST") {
                    return lookupPlaylist(queue, (result.lookup() as Playlist).playlist_id, user_id);
                } else if (type === "SHOW") {
                    return lookupShow(queue, (result.lookup() as Show).show_id, user_id);
                } else if (type === "TRACK") {
                    return lookupTrack(queue, (result.lookup() as Track).track_id, user_id);
                } else if (type === "USER") {
                    return lookupUser(queue, (result.lookup() as User).user_id, user_id);
                } else if (type === "YEAR") {
                    return lookupYear(queue, (result.lookup() as Year).year_id, user_id);
                }
                throw `Expected code to be unreachable!`;
            }));
            return entities; */
    }
    exports.searchForEntities = searchForEntities;
    ;
    // TODO: Optimize.
    async function getArtistAppearances(queue, artist_id, offset, length, user_id) {
        let artist = await atlas.stores.artists.lookup(queue, { artist_id: (0, utils_1.binid)(artist_id) });
        let map = new Map();
        let track_artists = await atlas.links.artist_track_artists.filter(queue, artist);
        for (let track_artist of track_artists) {
            let track = await atlas.stores.tracks.lookup(queue, track_artist);
            let disc = await atlas.stores.discs.lookup(queue, track);
            let key = (0, utils_1.hexid)(disc.album_id);
            let value = map.get(key) ?? 0;
            value += 1;
            map.set(key, value);
        }
        for (let entry of map.entries()) {
            let album = await atlas.stores.albums.lookup(queue, { album_id: (0, utils_1.binid)(entry[0]) });
            let album_artists = await atlas.links.album_album_artists.filter(queue, album);
            for (let album_artist of album_artists) {
                if ((0, utils_1.hexid)(album_artist.artist_id) === artist_id) {
                    map.delete(entry[0]);
                }
            }
        }
        return await Promise.all(Array.from(map.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => entry[0])
            .map((album_id) => lookupAlbum(queue, album_id, user_id)));
    }
    exports.getArtistAppearances = getArtistAppearances;
    ;
    async function getArtistTracks(queue, artist_id, offset, length, user_id) {
        let artist = await atlas.stores.artists.lookup(queue, { artist_id: (0, utils_1.binid)(artist_id) });
        let map = new Map();
        let track_artists = await atlas.links.artist_track_artists.filter(queue, artist);
        for (let track_artist of track_artists) {
            let track = await atlas.stores.tracks.lookup(queue, track_artist);
            if (track.affinity > 0) {
                map.set((0, utils_1.hexid)(track_artist.track_id), track.affinity);
            }
        }
        return await Promise.all(Array.from(map.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => entry[0])
            .map((track_id) => lookupTrack(queue, track_id, user_id)));
    }
    exports.getArtistTracks = getArtistTracks;
    // TODO: Optimize.
    async function getPlaylistAppearances(queue, track_id, offset, length, user_id) {
        let track = await atlas.stores.tracks.lookup(queue, { track_id: (0, utils_1.binid)(track_id) });
        let map = new Map();
        let playlist_items = await atlas.links.track_playlist_items.filter(queue, track);
        for (let playlist_item of playlist_items) {
            let key = (0, utils_1.hexid)(playlist_item.playlist_id);
            let value = map.get(key) ?? 0;
            map.set(key, value + 2);
        }
        return await Promise.all(Array.from(map.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => entry[0])
            .map((playlist_id) => lookupPlaylist(queue, playlist_id, user_id)));
    }
    exports.getPlaylistAppearances = getPlaylistAppearances;
    ;
    async function getMovieSuggestions(queue, movie_id, anchor, offset, length, user_id) {
        let movies = [];
        for (let entry of await atlas.links.movie_movie_suggestions.filter(queue, { movie_id: (0, utils_1.binid)(movie_id) }, anchor != null ? { movie_id: (0, utils_1.binid)(movie_id), suggested_movie_id: (0, utils_1.binid)(anchor) } : undefined, length)) {
            movies.push(await lookupMovie(queue, (0, utils_1.hexid)(entry.suggested_movie_id), user_id));
        }
        return movies;
    }
    exports.getMovieSuggestions = getMovieSuggestions;
    ;
    async function getMoviesFromGenre(queue, genre_id, user_id, anchor, offset, length) {
        let movies = [];
        for (let entry of await atlas.links.genre_movie_genres.filter(queue, { genre_id: (0, utils_1.binid)(genre_id) }, anchor != null ? { genre_id: (0, utils_1.binid)(genre_id), movie_id: (0, utils_1.binid)(anchor) } : undefined, length)) {
            movies.push(await lookupMovie(queue, (0, utils_1.hexid)(entry.movie_id), user_id));
        }
        return movies;
    }
    exports.getMoviesFromGenre = getMoviesFromGenre;
    ;
    async function getMoviesFromActor(queue, actor_id, user_id, anchor, offset, length) {
        let movies = [];
        for (let entry of await atlas.links.actor_movie_actors.filter(queue, { actor_id: (0, utils_1.binid)(actor_id) }, anchor != null ? { actor_id: (0, utils_1.binid)(actor_id), movie_id: (0, utils_1.binid)(anchor) } : undefined, length)) {
            movies.push(await lookupMovie(queue, (0, utils_1.hexid)(entry.movie_id), user_id));
        }
        return movies;
    }
    exports.getMoviesFromActor = getMoviesFromActor;
    ;
    async function getShowsFromGenre(queue, genre_id, user_id, anchor, offset, length) {
        let shows = [];
        for (let entry of await atlas.links.genre_show_genres.filter(queue, { genre_id: (0, utils_1.binid)(genre_id) }, anchor != null ? { genre_id: (0, utils_1.binid)(genre_id), show_id: (0, utils_1.binid)(anchor) } : undefined, length)) {
            shows.push(await lookupShow(queue, (0, utils_1.hexid)(entry.show_id), user_id));
        }
        return shows;
    }
    exports.getShowsFromGenre = getShowsFromGenre;
    ;
    async function getShowsFromActor(queue, actor_id, user_id, anchor, offset, length) {
        let shows = [];
        for (let entry of await atlas.links.actor_show_actors.filter(queue, { actor_id: (0, utils_1.binid)(actor_id) }, anchor != null ? { actor_id: (0, utils_1.binid)(actor_id), show_id: (0, utils_1.binid)(anchor) } : undefined, length)) {
            shows.push(await lookupShow(queue, (0, utils_1.hexid)(entry.show_id), user_id));
        }
        return shows;
    }
    exports.getShowsFromActor = getShowsFromActor;
    ;
    async function getUserPlaylists(queue, subject_user_id, user_id, anchor, offset, length) {
        let playlists = [];
        for (let entry of await atlas.links.user_playlists.filter(queue, { user_id: (0, utils_1.binid)(subject_user_id) }, anchor != null ? { playlist_id: (0, utils_1.binid)(anchor) } : undefined, length)) {
            playlists.push(await lookupPlaylist(queue, (0, utils_1.hexid)(entry.playlist_id), user_id));
        }
        return playlists;
    }
    exports.getUserPlaylists = getUserPlaylists;
    ;
    async function getUserAlbums(queue, subject_user_id, anchor, offset, length, user_id) {
        let albums = [];
        for (let album_affinity of await atlas.links.user_album_affinities.filter(queue, { user_id: (0, utils_1.binid)(subject_user_id) }, anchor != null ? { album_id: (0, utils_1.binid)(anchor), user_id: (0, utils_1.binid)(subject_user_id) } : undefined, length)) {
            albums.push(await lookupAlbum(queue, (0, utils_1.hexid)(album_affinity.album_id), user_id));
        }
        return albums;
    }
    exports.getUserAlbums = getUserAlbums;
    ;
    async function getUserShows(queue, subject_user_id, anchor, offset, length, user_id) {
        let shows = [];
        for (let show_affinity of await atlas.links.user_show_affinities.filter(queue, { user_id: (0, utils_1.binid)(subject_user_id) }, anchor != null ? { show_id: (0, utils_1.binid)(anchor), user_id: (0, utils_1.binid)(subject_user_id) } : undefined, length)) {
            shows.push(await lookupShow(queue, (0, utils_1.hexid)(show_affinity.show_id), user_id));
        }
        return shows;
    }
    exports.getUserShows = getUserShows;
    ;
    async function getMoviesFromYear(queue, year_id, user_id, anchor, offset, length) {
        let movies = [];
        for (let movie of await atlas.links.year_movies.filter(queue, { year_id: (0, utils_1.binid)(year_id) }, anchor != null ? { movie_id: (0, utils_1.binid)(anchor) } : undefined, length)) {
            movies.push(await lookupMovie(queue, (0, utils_1.hexid)(movie.movie_id), user_id));
        }
        return movies;
    }
    exports.getMoviesFromYear = getMoviesFromYear;
    ;
    async function getAlbumsFromYear(queue, year_id, user_id, anchor, offset, length) {
        let albums = [];
        for (let album of await atlas.links.year_albums.filter(queue, { year_id: (0, utils_1.binid)(year_id) }, anchor != null ? { album_id: (0, utils_1.binid)(anchor) } : undefined, length)) {
            albums.push(await lookupAlbum(queue, (0, utils_1.hexid)(album.album_id), user_id));
        }
        return albums;
    }
    exports.getAlbumsFromYear = getAlbumsFromYear;
    ;
});
define("build/api/schema/objects/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/database/schema/index", "build/database/schema/index", "build/database/schema/index", "build/database/schema/index"], function (require, exports, autoguard, schema_1, schema_2, schema_3, schema_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Entity = exports.EntityBase = exports.Year = exports.YearBase = exports.Cue = exports.CueBase = exports.Subtitle = exports.SubtitleBase = exports.Episode = exports.EpisodeBase = exports.Season = exports.SeasonBase = exports.Show = exports.ShowBase = exports.Movie = exports.MovieBase = exports.Genre = exports.GenreBase = exports.PlaylistItem = exports.PlaylistItemBase = exports.Playlist = exports.PlaylistBase = exports.User = exports.UserBase = exports.Track = exports.TrackBase = exports.Disc = exports.DiscBase = exports.Album = exports.AlbumBase = exports.Artist = exports.ArtistBase = exports.Actor = exports.ActorBase = void 0;
    exports.ActorBase = autoguard.guards.Object.of({
        "actor_id": autoguard.guards.String,
        "name": autoguard.guards.String
    }, {});
    exports.Actor = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ActorBase), autoguard.guards.Object.of({
        "affinity": autoguard.guards.Number
    }, {}));
    exports.ArtistBase = autoguard.guards.Object.of({
        "artist_id": autoguard.guards.String,
        "title": autoguard.guards.String
    }, {});
    exports.Artist = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ArtistBase), autoguard.guards.Object.of({
        "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Album)),
        "affinity": autoguard.guards.Number
    }, {}));
    exports.AlbumBase = autoguard.guards.Object.of({
        "album_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    }, {});
    exports.Album = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.AlbumBase), autoguard.guards.Object.of({
        "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ArtistBase)),
        "discs": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Disc)),
        "affinity": autoguard.guards.Number
    }, {
        "year": autoguard.guards.Reference.of(() => exports.YearBase)
    }));
    exports.DiscBase = autoguard.guards.Object.of({
        "disc_id": autoguard.guards.String,
        "album": autoguard.guards.Reference.of(() => exports.AlbumBase),
        "number": autoguard.guards.Number
    }, {});
    exports.Disc = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.DiscBase), autoguard.guards.Object.of({
        "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Track)),
        "affinity": autoguard.guards.Number
    }, {}));
    exports.TrackBase = autoguard.guards.Object.of({
        "track_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "disc": autoguard.guards.Reference.of(() => exports.DiscBase),
        "number": autoguard.guards.Number
    }, {});
    exports.Track = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.TrackBase), autoguard.guards.Object.of({
        "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ArtistBase)),
        "media": autoguard.guards.Reference.of(() => schema_1.AudioFile),
        "affinity": autoguard.guards.Number
    }, {
        "last_stream_date": autoguard.guards.Number,
        "copyright": autoguard.guards.String
    }));
    exports.UserBase = autoguard.guards.Object.of({
        "user_id": autoguard.guards.String,
        "name": autoguard.guards.String,
        "username": autoguard.guards.String
    }, {});
    exports.User = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.UserBase), autoguard.guards.Object.of({}, {}));
    exports.PlaylistBase = autoguard.guards.Object.of({
        "playlist_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "description": autoguard.guards.String,
        "user": autoguard.guards.Reference.of(() => exports.UserBase)
    }, {});
    exports.Playlist = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.PlaylistBase), autoguard.guards.Object.of({
        "items": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.PlaylistItem)),
        "affinity": autoguard.guards.Number
    }, {}));
    exports.PlaylistItemBase = autoguard.guards.Object.of({
        "playlist_item_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "playlist": autoguard.guards.Reference.of(() => exports.PlaylistBase),
        "track": autoguard.guards.Reference.of(() => exports.Track)
    }, {});
    exports.PlaylistItem = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.PlaylistItemBase), autoguard.guards.Object.of({}, {}));
    exports.GenreBase = autoguard.guards.Object.of({
        "genre_id": autoguard.guards.String,
        "title": autoguard.guards.String
    }, {});
    exports.Genre = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.GenreBase), autoguard.guards.Object.of({
        "affinity": autoguard.guards.Number
    }, {}));
    exports.MovieBase = autoguard.guards.Object.of({
        "movie_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    }, {});
    exports.Movie = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.MovieBase), autoguard.guards.Object.of({
        "genres": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.GenreBase)),
        "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ActorBase)),
        "media": autoguard.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_3.SubtitleFile)),
        "affinity": autoguard.guards.Number
    }, {
        "year": autoguard.guards.Reference.of(() => exports.YearBase),
        "summary": autoguard.guards.String,
        "last_stream_date": autoguard.guards.Number,
        "copyright": autoguard.guards.String,
        "imdb": autoguard.guards.String
    }));
    exports.ShowBase = autoguard.guards.Object.of({
        "show_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "artwork": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_2.ImageFile))
    }, {});
    exports.Show = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ShowBase), autoguard.guards.Object.of({
        "genres": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.GenreBase)),
        "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.ActorBase)),
        "seasons": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Season)),
        "affinity": autoguard.guards.Number
    }, {
        "summary": autoguard.guards.String,
        "imdb": autoguard.guards.String
    }));
    exports.SeasonBase = autoguard.guards.Object.of({
        "season_id": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "show": autoguard.guards.Reference.of(() => exports.ShowBase)
    }, {});
    exports.Season = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.SeasonBase), autoguard.guards.Object.of({
        "episodes": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Episode)),
        "affinity": autoguard.guards.Number
    }, {}));
    exports.EpisodeBase = autoguard.guards.Object.of({
        "episode_id": autoguard.guards.String,
        "title": autoguard.guards.String,
        "number": autoguard.guards.Number,
        "season": autoguard.guards.Reference.of(() => exports.SeasonBase)
    }, {});
    exports.Episode = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.EpisodeBase), autoguard.guards.Object.of({
        "media": autoguard.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => schema_3.SubtitleFile)),
        "affinity": autoguard.guards.Number
    }, {
        "year": autoguard.guards.Reference.of(() => exports.YearBase),
        "summary": autoguard.guards.String,
        "last_stream_date": autoguard.guards.Number,
        "copyright": autoguard.guards.String,
        "imdb": autoguard.guards.String
    }));
    exports.SubtitleBase = autoguard.guards.Object.of({
        "subtitle_id": autoguard.guards.String,
        "subtitle": autoguard.guards.Reference.of(() => schema_3.SubtitleFile)
    }, {});
    exports.Subtitle = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.SubtitleBase), autoguard.guards.Object.of({
        "cues": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Cue))
    }, {}));
    exports.CueBase = autoguard.guards.Object.of({
        "cue_id": autoguard.guards.String,
        "subtitle": autoguard.guards.Reference.of(() => exports.SubtitleBase),
        "start_ms": autoguard.guards.Number,
        "duration_ms": autoguard.guards.Number,
        "lines": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.Cue = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.CueBase), autoguard.guards.Object.of({
        "media": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Episode), autoguard.guards.Reference.of(() => exports.Movie))
    }, {}));
    exports.YearBase = autoguard.guards.Object.of({
        "year_id": autoguard.guards.String,
        "year": autoguard.guards.Number
    }, {});
    exports.Year = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.YearBase), autoguard.guards.Object.of({
        "affinity": autoguard.guards.Number
    }, {}));
    exports.EntityBase = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ActorBase), autoguard.guards.Reference.of(() => exports.AlbumBase), autoguard.guards.Reference.of(() => exports.ArtistBase), autoguard.guards.Reference.of(() => exports.CueBase), autoguard.guards.Reference.of(() => exports.DiscBase), autoguard.guards.Reference.of(() => exports.EpisodeBase), autoguard.guards.Reference.of(() => exports.GenreBase), autoguard.guards.Reference.of(() => exports.MovieBase), autoguard.guards.Reference.of(() => exports.PlaylistBase), autoguard.guards.Reference.of(() => exports.SeasonBase), autoguard.guards.Reference.of(() => exports.ShowBase), autoguard.guards.Reference.of(() => exports.TrackBase), autoguard.guards.Reference.of(() => exports.UserBase), autoguard.guards.Reference.of(() => exports.YearBase));
    exports.Entity = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.Actor), autoguard.guards.Reference.of(() => exports.Album), autoguard.guards.Reference.of(() => exports.Artist), autoguard.guards.Reference.of(() => exports.Cue), autoguard.guards.Reference.of(() => exports.Disc), autoguard.guards.Reference.of(() => exports.Episode), autoguard.guards.Reference.of(() => exports.Genre), autoguard.guards.Reference.of(() => exports.Movie), autoguard.guards.Reference.of(() => exports.Playlist), autoguard.guards.Reference.of(() => exports.Season), autoguard.guards.Reference.of(() => exports.Show), autoguard.guards.Reference.of(() => exports.Track), autoguard.guards.Reference.of(() => exports.User), autoguard.guards.Reference.of(() => exports.Year));
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ActorBase": autoguard.guards.Reference.of(() => exports.ActorBase),
            "Actor": autoguard.guards.Reference.of(() => exports.Actor),
            "ArtistBase": autoguard.guards.Reference.of(() => exports.ArtistBase),
            "Artist": autoguard.guards.Reference.of(() => exports.Artist),
            "AlbumBase": autoguard.guards.Reference.of(() => exports.AlbumBase),
            "Album": autoguard.guards.Reference.of(() => exports.Album),
            "DiscBase": autoguard.guards.Reference.of(() => exports.DiscBase),
            "Disc": autoguard.guards.Reference.of(() => exports.Disc),
            "TrackBase": autoguard.guards.Reference.of(() => exports.TrackBase),
            "Track": autoguard.guards.Reference.of(() => exports.Track),
            "UserBase": autoguard.guards.Reference.of(() => exports.UserBase),
            "User": autoguard.guards.Reference.of(() => exports.User),
            "PlaylistBase": autoguard.guards.Reference.of(() => exports.PlaylistBase),
            "Playlist": autoguard.guards.Reference.of(() => exports.Playlist),
            "PlaylistItemBase": autoguard.guards.Reference.of(() => exports.PlaylistItemBase),
            "PlaylistItem": autoguard.guards.Reference.of(() => exports.PlaylistItem),
            "GenreBase": autoguard.guards.Reference.of(() => exports.GenreBase),
            "Genre": autoguard.guards.Reference.of(() => exports.Genre),
            "MovieBase": autoguard.guards.Reference.of(() => exports.MovieBase),
            "Movie": autoguard.guards.Reference.of(() => exports.Movie),
            "ShowBase": autoguard.guards.Reference.of(() => exports.ShowBase),
            "Show": autoguard.guards.Reference.of(() => exports.Show),
            "SeasonBase": autoguard.guards.Reference.of(() => exports.SeasonBase),
            "Season": autoguard.guards.Reference.of(() => exports.Season),
            "EpisodeBase": autoguard.guards.Reference.of(() => exports.EpisodeBase),
            "Episode": autoguard.guards.Reference.of(() => exports.Episode),
            "SubtitleBase": autoguard.guards.Reference.of(() => exports.SubtitleBase),
            "Subtitle": autoguard.guards.Reference.of(() => exports.Subtitle),
            "CueBase": autoguard.guards.Reference.of(() => exports.CueBase),
            "Cue": autoguard.guards.Reference.of(() => exports.Cue),
            "YearBase": autoguard.guards.Reference.of(() => exports.YearBase),
            "Year": autoguard.guards.Reference.of(() => exports.Year),
            "EntityBase": autoguard.guards.Reference.of(() => exports.EntityBase),
            "Entity": autoguard.guards.Reference.of(() => exports.Entity)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.RegisterResponse = exports.RegisterRequest = exports.ErrorMessage = void 0;
    exports.ErrorMessage = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.RegisterRequest = autoguard.guards.Object.of({
        "username": autoguard.guards.String,
        "password": autoguard.guards.String,
        "name": autoguard.guards.String,
        "key_id": autoguard.guards.String
    }, {});
    exports.RegisterResponse = autoguard.guards.Object.of({
        "token": autoguard.guards.String
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ErrorMessage": autoguard.guards.Reference.of(() => exports.ErrorMessage),
            "RegisterRequest": autoguard.guards.Reference.of(() => exports.RegisterRequest),
            "RegisterResponse": autoguard.guards.Reference.of(() => exports.RegisterResponse)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/api/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/messages/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/messages/index", "build/api/schema/messages/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2, objects_3, objects_4, objects_5, objects_6, messages_1, objects_7, objects_8, objects_9, messages_2, messages_3, objects_10, objects_11, objects_12, objects_13, objects_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = void 0;
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {};
        Autoguard.Requests = {
            "POST:/auth/": autoguard.guards.Object.of({
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "x-circus-username": autoguard.guards.String,
                    "x-circus-password": autoguard.guards.String
                }, {}), autoguard.api.Headers)
            }, {
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Options),
                "payload": autoguard.api.Binary
            }),
            "POST:/users/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Reference.of(() => messages_2.RegisterRequest)
            }, {
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Options),
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number,
                    "cues": autoguard.guards.Boolean
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/actors/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/actors/<actor_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/actors/<actor_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/actors/<actor_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "actor_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/albums/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getNewAlbums": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/albums/<album_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "album_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/artists/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/artists/<artist_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "artist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/discs/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/discs/<disc_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "disc_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/episodes/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/episodes/<episode_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "episode_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/genres/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/genres/<genre_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/genres/<genre_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/genres/<genre_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "genre_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/movies/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "getNewMovies": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/movies/<movie_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "movie_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/movies/<movie_id>/suggestions/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "movie_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/playlists/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/playlists/<playlist_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "playlist_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/seasons/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/seasons/<season_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "season_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/shows/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/shows/<show_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "show_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/tracks/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/tracks/<track_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "track_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/tracks/<track_id>/playlists/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "track_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/users/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/users/<user_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/users/<user_id>/albums/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/users/<user_id>/playlists/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/users/<user_id>/shows/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "user_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/years/<query>": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "query": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/years/<year_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/years/<year_id>/albums/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/years/<year_id>/movies/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "year_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {
                    "anchor": autoguard.guards.String,
                    "offset": autoguard.guards.Number,
                    "limit": autoguard.guards.Number
                }), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/files/<file_id>/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "file_id": autoguard.guards.String,
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/statistics/": autoguard.guards.Object.of({
                "options": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "token": autoguard.guards.String
                }, {}), autoguard.api.Options)
            }, {
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            })
        };
        Autoguard.Responses = {
            "POST:/auth/": autoguard.guards.Object.of({
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({
                    "x-circus-token": autoguard.guards.String
                }, {}), autoguard.api.Headers)
            }, {
                "status": autoguard.guards.Number,
                "payload": autoguard.api.Binary
            }),
            "POST:/users/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => messages_3.RegisterResponse), autoguard.guards.Reference.of(() => messages_1.ErrorMessage))
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "entities": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_5.Entity))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/actors/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "actors": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_1.Actor))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/actors/<actor_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "actor": autoguard.guards.Reference.of(() => objects_1.Actor)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/actors/<actor_id>/movies/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/actors/<actor_id>/shows/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/albums/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getNewAlbums": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/albums/<album_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "album": autoguard.guards.Reference.of(() => objects_2.Album)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/artists/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "artists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_3.Artist))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/artists/<artist_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "artist": autoguard.guards.Reference.of(() => objects_3.Artist),
                    "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_12.Track)),
                    "appearances": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/discs/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "discs": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_4.Disc))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/discs/<disc_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "disc": autoguard.guards.Reference.of(() => objects_4.Disc)
                }, {
                    "last": autoguard.guards.Reference.of(() => objects_4.Disc),
                    "next": autoguard.guards.Reference.of(() => objects_4.Disc)
                })
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/episodes/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "episodes": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_6.Episode))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/episodes/<episode_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "episode": autoguard.guards.Reference.of(() => objects_6.Episode)
                }, {
                    "last": autoguard.guards.Reference.of(() => objects_6.Episode),
                    "next": autoguard.guards.Reference.of(() => objects_6.Episode)
                })
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/genres/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "genres": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_7.Genre))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/genres/<genre_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "genre": autoguard.guards.Reference.of(() => objects_7.Genre)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/genres/<genre_id>/movies/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/genres/<genre_id>/shows/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/movies/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "getNewMovies": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/movies/<movie_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movie": autoguard.guards.Reference.of(() => objects_8.Movie)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/movies/<movie_id>/suggestions/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/playlists/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "playlists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_9.Playlist))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/playlists/<playlist_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "playlist": autoguard.guards.Reference.of(() => objects_9.Playlist)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/seasons/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "seasons": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_10.Season))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/seasons/<season_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "season": autoguard.guards.Reference.of(() => objects_10.Season)
                }, {
                    "last": autoguard.guards.Reference.of(() => objects_10.Season),
                    "next": autoguard.guards.Reference.of(() => objects_10.Season)
                })
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/shows/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/shows/<show_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "show": autoguard.guards.Reference.of(() => objects_11.Show)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/tracks/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_12.Track))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/tracks/<track_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "track": autoguard.guards.Reference.of(() => objects_12.Track)
                }, {
                    "last": autoguard.guards.Reference.of(() => objects_12.Track),
                    "next": autoguard.guards.Reference.of(() => objects_12.Track)
                })
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/tracks/<track_id>/playlists/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "playlists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_9.Playlist))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/users/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "users": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_13.User))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/users/<user_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "user": autoguard.guards.Reference.of(() => objects_13.User)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/users/<user_id>/albums/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/users/<user_id>/playlists/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "playlists": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_9.Playlist))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/users/<user_id>/shows/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "shows": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_11.Show))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/years/<query>": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "years": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_14.Year))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/years/<year_id>/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "year": autoguard.guards.Reference.of(() => objects_14.Year)
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/years/<year_id>/albums/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "albums": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Album))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/years/<year_id>/movies/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "movies": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_8.Movie))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            }),
            "GET:/files/<file_id>/": autoguard.guards.Object.of({}, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers),
                "payload": autoguard.api.Binary
            }),
            "GET:/statistics/": autoguard.guards.Object.of({
                "payload": autoguard.guards.Object.of({
                    "statistics": autoguard.guards.Array.of(autoguard.guards.Object.of({
                        "title": autoguard.guards.String,
                        "value": autoguard.guards.Number
                    }, {
                        "unit": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("BYTES"), autoguard.guards.StringLiteral.of("MILLISECONDS"))
                    }))
                }, {})
            }, {
                "status": autoguard.guards.Number,
                "headers": autoguard.guards.Intersection.of(autoguard.guards.Object.of({}, {}), autoguard.api.Headers)
            })
        };
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/api/schema/api/server", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-server/index", "build/api/schema/api/index"], function (require, exports, autoguard, shared) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeServer = void 0;
    const makeServer = (routes, serverOptions) => {
        let endpoints = new Array();
        endpoints.push((raw, auxillary) => {
            let method = "POST";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("auth")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers["x-circus-username"] = autoguard.api.decodeHeaderValue(raw.headers, "x-circus-username", true);
                    headers["x-circus-password"] = autoguard.api.decodeHeaderValue(raw.headers, "x-circus-password", true);
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["POST:/auth/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["POST:/auth/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["POST:/auth/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeHeaderPairs("x-circus-token", [response.headers?.["x-circus-token"]], true));
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = response.payload ?? [];
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/octet-stream"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "POST";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = await autoguard.api.deserializePayload(raw.payload);
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["POST:/users/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["POST:/users/"](new autoguard.api.ClientRequest(request, false, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["POST:/users/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[0].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options["cues"] = autoguard.api.decodeParameterValue(raw.parameters, "cues", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/actors/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["actor_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<actor_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/actors/<actor_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<actor_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["actor_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<actor_id>/movies/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/actors/<actor_id>/movies/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<actor_id>/movies/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("actors")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["actor_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/actors/<actor_id>/shows/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/actors/<actor_id>/shows/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/actors/<actor_id>/shows/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/albums/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/albums/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/albums/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("new")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getNewAlbums"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["getNewAlbums"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getNewAlbums"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["album_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/albums/<album_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/albums/<album_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/albums/<album_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("artists")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/artists/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/artists/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/artists/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("artists")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["artist_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/artists/<artist_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/artists/<artist_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/artists/<artist_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("discs")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/discs/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/discs/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/discs/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("discs")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["disc_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/discs/<disc_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/discs/<disc_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/discs/<disc_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("episodes")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/episodes/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/episodes/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/episodes/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("episodes")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["episode_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/episodes/<episode_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/episodes/<episode_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/episodes/<episode_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/genres/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["genre_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<genre_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/genres/<genre_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<genre_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["genre_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<genre_id>/movies/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/genres/<genre_id>/movies/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<genre_id>/movies/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("genres")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["genre_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/genres/<genre_id>/shows/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/genres/<genre_id>/shows/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/genres/<genre_id>/shows/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/movies/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/movies/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/movies/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("new")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["getNewMovies"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["getNewMovies"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["getNewMovies"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["movie_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/movies/<movie_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/movies/<movie_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/movies/<movie_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("suggestions")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["movie_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/movies/<movie_id>/suggestions/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/movies/<movie_id>/suggestions/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/movies/<movie_id>/suggestions/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/playlists/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/playlists/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/playlists/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["playlist_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/playlists/<playlist_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/playlists/<playlist_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/playlists/<playlist_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("seasons")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/seasons/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/seasons/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/seasons/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("seasons")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["season_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/seasons/<season_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/seasons/<season_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/seasons/<season_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/shows/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/shows/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/shows/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["show_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/shows/<show_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/shows/<show_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/shows/<show_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("tracks")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/tracks/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/tracks/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/tracks/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("tracks")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["track_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/tracks/<track_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/tracks/<track_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/tracks/<track_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("tracks")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["track_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/tracks/<track_id>/playlists/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/tracks/<track_id>/playlists/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/tracks/<track_id>/playlists/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/users/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["user_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/users/<user_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["user_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/albums/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/users/<user_id>/albums/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/albums/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("playlists")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["user_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/playlists/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/users/<user_id>/playlists/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/playlists/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("users")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("shows")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["user_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/users/<user_id>/shows/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/users/<user_id>/shows/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/users/<user_id>/shows/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["query"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<query>"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/years/<query>"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<query>"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["year_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<year_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/years/<year_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<year_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("albums")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["year_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<year_id>/albums/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/years/<year_id>/albums/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<year_id>/albums/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("years")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("movies")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["year_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options["anchor"] = autoguard.api.decodeParameterValue(raw.parameters, "anchor", true);
                    options["offset"] = autoguard.api.decodeParameterValue(raw.parameters, "offset", false);
                    options["limit"] = autoguard.api.decodeParameterValue(raw.parameters, "limit", false);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/years/<year_id>/movies/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/years/<year_id>/movies/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/years/<year_id>/movies/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("files")));
            matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["file_id"] = matchers[1].getValue();
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/files/<file_id>/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/files/<file_id>/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/files/<file_id>/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = response.payload ?? [];
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/octet-stream"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        endpoints.push((raw, auxillary) => {
            let method = "GET";
            let matchers = new Array();
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("statistics")));
            matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
            return {
                acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
                acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
                validateRequest: async () => {
                    let options = {};
                    options["token"] = autoguard.api.decodeParameterValue(raw.parameters, "token", true);
                    options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
                    let headers = {};
                    headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
                    let payload = raw.payload;
                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/statistics/"], serverOptions?.debugMode);
                    let request = guard.as({ options, headers, payload }, "request");
                    return {
                        handleRequest: async () => {
                            let response = await routes["GET:/statistics/"](new autoguard.api.ClientRequest(request, true, auxillary));
                            return {
                                validateResponse: async () => {
                                    let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/statistics/"], serverOptions?.debugMode);
                                    guard.as(response, "response");
                                    let status = response.status ?? 200;
                                    let headers = new Array();
                                    headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
                                    let payload = autoguard.api.serializePayload(response.payload);
                                    let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
                                    defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
                                    return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
                                }
                            };
                        }
                    };
                }
            };
        });
        return (request, response) => autoguard.api.route(endpoints, request, response, serverOptions);
    };
    exports.makeServer = makeServer;
});
define("build/api/api", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-server/index", "crypto", "fs", "build/server/auth", "build/server/auth", "build/api/handler", "build/api/schema/api/server", "build/database/atlas", "build/utils"], function (require, exports, autoguard, libcrypto, libfs, libauth, auth, handler, apiv2, atlas, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.server = void 0;
    function getVersion() {
        try {
            let pack = libfs.readFileSync("./package.json", "utf8");
            let json = JSON.parse(pack);
            let parts = /^([0-9]+)[.]([0-9]+)[.]([0-9]+)$/.exec(String(json?.version));
            if (parts != null) {
                let major = Number.parseInt(parts[1], 10);
                let minor = Number.parseInt(parts[2], 10);
                let patch = Number.parseInt(parts[3], 10);
                return {
                    major,
                    minor,
                    patch
                };
            }
        }
        catch (error) { }
    }
    exports.server = apiv2.makeServer({
        "POST:/auth/": (request) => atlas.transactionManager.enqueueWritableTransaction(async (queue) => {
            let headers = request.headers();
            let token = await libauth.createToken(queue, headers["x-circus-username"], headers["x-circus-password"]);
            return {
                headers: {
                    "x-circus-token": token
                }
            };
        }),
        "POST:/users/": (request) => atlas.transactionManager.enqueueWritableTransaction(async (queue) => {
            let payload = await handler.createUser(queue, await request.payload());
            return {
                payload
            };
        }),
        "GET:/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let entities = options.cues
                ? await handler.searchForCues(queue, options.query, options.offset ?? 0, options.limit ?? 24, user_id)
                : await handler.searchForEntities(queue, options.query, user_id, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    entities
                }
            };
        }),
        "GET:/actors/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let actors = await handler.searchForActors(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    actors
                }
            };
        }),
        "GET:/actors/<actor_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let actor = await handler.lookupActor(queue, options.actor_id, user_id);
            return {
                payload: {
                    actor
                }
            };
        }),
        "GET:/actors/<actor_id>/movies/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let movies = await handler.getMoviesFromActor(queue, options.actor_id, user_id, options.anchor, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    movies
                }
            };
        }),
        "GET:/actors/<actor_id>/shows/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let shows = await handler.getShowsFromActor(queue, options.actor_id, user_id, options.anchor, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    shows
                }
            };
        }),
        "GET:/albums/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let albums = await handler.searchForAlbums(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    albums
                }
            };
        }),
        getNewAlbums: (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let albums = await handler.getNewAlbums(queue, user_id, options.anchor, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    albums
                }
            };
        }),
        "GET:/albums/<album_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let album = await handler.lookupAlbum(queue, options.album_id, user_id);
            return {
                payload: {
                    album
                }
            };
        }),
        "GET:/artists/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let artists = await handler.searchForArtists(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    artists
                }
            };
        }),
        "GET:/artists/<artist_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let artist = await handler.lookupArtist(queue, options.artist_id, user_id);
            let tracks = await handler.getArtistTracks(queue, options.artist_id, 0, 3, user_id);
            let appearances = await handler.getArtistAppearances(queue, options.artist_id, 0, 24, user_id);
            return {
                payload: {
                    artist,
                    tracks,
                    appearances
                }
            };
        }),
        "GET:/discs/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let discs = await handler.searchForDiscs(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    discs
                }
            };
        }),
        "GET:/discs/<disc_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let disc = await handler.lookupDisc(queue, options.disc_id, user_id);
            let discs = (await handler.lookupAlbum(queue, disc.album.album_id, user_id)).discs;
            let index = discs.findIndex((other) => other.disc_id === disc.disc_id);
            let last = discs[index - 1];
            let next = discs[index + 1];
            return {
                payload: {
                    disc,
                    last,
                    next
                }
            };
        }),
        "GET:/episodes/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let episodes = await handler.searchForEpisodes(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    episodes
                }
            };
        }),
        "GET:/episodes/<episode_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let episode = await handler.lookupEpisode(queue, options.episode_id, user_id);
            let episodes = (await handler.lookupSeason(queue, episode.season.season_id, user_id)).episodes;
            let index = episodes.findIndex((other) => other.episode_id === episode.episode_id);
            let last = episodes[index - 1];
            let next = episodes[index + 1];
            return {
                payload: {
                    episode,
                    last,
                    next
                }
            };
        }),
        "GET:/genres/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let genres = await handler.searchForGenres(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    genres
                }
            };
        }),
        "GET:/genres/<genre_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let genre = await handler.lookupGenre(queue, options.genre_id, user_id);
            return {
                payload: {
                    genre
                }
            };
        }),
        "GET:/genres/<genre_id>/movies/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let movies = await handler.getMoviesFromGenre(queue, options.genre_id, user_id, options.anchor, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    movies
                }
            };
        }),
        "GET:/genres/<genre_id>/shows/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let shows = await handler.getShowsFromGenre(queue, options.genre_id, user_id, options.anchor, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    shows
                }
            };
        }),
        "GET:/movies/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let movies = await handler.searchForMovies(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    movies
                }
            };
        }),
        getNewMovies: (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let movies = await handler.getNewMovies(queue, user_id, options.anchor, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    movies
                }
            };
        }),
        "GET:/movies/<movie_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let movie = await handler.lookupMovie(queue, options.movie_id, user_id);
            return {
                payload: {
                    movie
                }
            };
        }),
        "GET:/movies/<movie_id>/suggestions/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let movies = await handler.getMovieSuggestions(queue, options.movie_id, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    movies
                }
            };
        }),
        "GET:/playlists/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let playlists = await handler.searchForPlaylists(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    playlists
                }
            };
        }),
        "GET:/playlists/<playlist_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let playlist = await handler.lookupPlaylist(queue, options.playlist_id, user_id);
            return {
                payload: {
                    playlist
                }
            };
        }),
        "GET:/seasons/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let seasons = await handler.searchForSeasons(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    seasons
                }
            };
        }),
        "GET:/seasons/<season_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let season = await handler.lookupSeason(queue, options.season_id, user_id);
            let seasons = (await handler.lookupShow(queue, season.show.show_id, user_id)).seasons;
            let index = seasons.findIndex((other) => other.season_id === season.season_id);
            let last = seasons[index - 1];
            let next = seasons[index + 1];
            return {
                payload: {
                    season,
                    last,
                    next
                }
            };
        }),
        "GET:/shows/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let shows = await handler.searchForShows(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    shows
                }
            };
        }),
        "GET:/shows/<show_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let show = await handler.lookupShow(queue, options.show_id, user_id);
            return {
                payload: {
                    show
                }
            };
        }),
        "GET:/tracks/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let tracks = await handler.searchForTracks(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    tracks
                }
            };
        }),
        "GET:/tracks/<track_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let track = await handler.lookupTrack(queue, options.track_id, user_id);
            let tracks = (await handler.lookupDisc(queue, track.disc.disc_id, user_id)).tracks;
            let index = tracks.findIndex((other) => other.track_id === track.track_id);
            let last = tracks[index - 1];
            let next = tracks[index + 1];
            return {
                payload: {
                    track,
                    last,
                    next
                }
            };
        }),
        "GET:/tracks/<track_id>/playlists/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let playlists = await handler.getPlaylistAppearances(queue, options.track_id, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    playlists
                }
            };
        }),
        "GET:/users/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let users = await handler.searchForUsers(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    users
                }
            };
        }),
        "GET:/users/<user_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            if (options.user_id === user_id) {
                atlas.transactionManager.enqueueWritableTransaction(async (queue) => {
                    // TODO: Refresh token expiry.
                });
            }
            let user = await handler.lookupUser(queue, options.user_id || user_id, user_id);
            return {
                payload: {
                    user
                }
            };
        }),
        "GET:/users/<user_id>/albums/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let albums = await handler.getUserAlbums(queue, options.user_id || user_id, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    albums
                }
            };
        }),
        "GET:/users/<user_id>/playlists/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let playlists = await handler.getUserPlaylists(queue, options.user_id || user_id, user_id, options.anchor, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    playlists
                }
            };
        }),
        "GET:/users/<user_id>/shows/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let shows = await handler.getUserShows(queue, options.user_id || user_id, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    shows
                }
            };
        }),
        "GET:/years/<query>": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let years = await handler.searchForYears(queue, options.query, options.anchor, options.offset ?? 0, options.limit ?? 24, user_id);
            return {
                payload: {
                    years
                }
            };
        }),
        "GET:/years/<year_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let year = await handler.lookupYear(queue, options.year_id, user_id);
            return {
                payload: {
                    year
                }
            };
        }),
        "GET:/years/<year_id>/albums/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let albums = await handler.getAlbumsFromYear(queue, options.year_id, user_id, options.anchor, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    albums
                }
            };
        }),
        "GET:/years/<year_id>/movies/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let movies = await handler.getMoviesFromYear(queue, options.year_id, user_id, options.anchor, options.offset ?? 0, options.limit ?? 24);
            return {
                payload: {
                    movies
                }
            };
        }),
        "GET:/files/<file_id>/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let file = await handler.lookupFile(queue, options.file_id, user_id);
            let range = autoguard.api.parseRangeHeader(request.headers().range, libfs.statSync(file.path).size);
            let stream = libfs.createReadStream(file.path, {
                start: range.offset,
                end: range.offset + range.length
            });
            if (file.mime.startsWith("audio/") || file.mime.startsWith("video/")) {
                stream.addListener("close", () => {
                    if (range.offset + stream.bytesRead === range.size) {
                        atlas.transactionManager.enqueueWritableTransaction(async (queue) => {
                            await atlas.createStream(queue, {
                                stream_id: Uint8Array.from(libcrypto.randomBytes(8)),
                                user_id: (0, utils_1.binid)(user_id),
                                file_id: (0, utils_1.binid)(options.file_id),
                                timestamp_ms: Date.now()
                            });
                        });
                    }
                });
            }
            return {
                status: range.status,
                headers: {
                    "Access-Control-Allow-Origin": "*",
                    "Accept-Ranges": "bytes",
                    "Cache-Control": "private,max-age=86400",
                    "Content-Length": `${range.length}`,
                    "Content-Range": range.length > 0 ? `bytes ${range.offset}-${range.offset + range.length - 1}/${range.size}` : `bytes */${range.size}`,
                    "Content-Type": file.mime
                },
                payload: stream
            };
        }),
        "GET:/statistics/": (request) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            // TODO: Create statistics table.
            let options = request.options();
            let user_id = await auth.getUserId(queue, options.token);
            let files = await atlas.stores.files.filter(queue);
            let audio_files = await atlas.stores.audio_files.filter(queue);
            let image_files = await atlas.stores.image_files.filter(queue);
            let metadata_files = await atlas.stores.metadata_files.filter(queue);
            let subtitle_files = await atlas.stores.subtitle_files.filter(queue);
            let video_files = await atlas.stores.video_files.filter(queue);
            let version = getVersion();
            return {
                payload: {
                    statistics: [
                        {
                            title: "Major version",
                            value: version?.major ?? 0
                        },
                        {
                            title: "Minor version",
                            value: version?.minor ?? 0
                        },
                        {
                            title: "Patch version",
                            value: version?.patch ?? 0
                        },
                        {
                            title: "Library Size",
                            value: files.reduce((sum, item) => sum + (item?.size ?? 0), 0),
                            unit: "BYTES"
                        },
                        {
                            title: "Audio Content",
                            value: audio_files.reduce((sum, item) => sum + item.duration_ms, 0),
                            unit: "MILLISECONDS"
                        },
                        {
                            title: "Video Content",
                            value: video_files.reduce((sum, item) => sum + item.duration_ms, 0),
                            unit: "MILLISECONDS"
                        },
                        {
                            title: "Files",
                            value: files.length
                        },
                        {
                            title: "Audio Files",
                            value: audio_files.length
                        },
                        {
                            title: "Image Files",
                            value: image_files.length
                        },
                        {
                            title: "Metadata Files",
                            value: metadata_files.length
                        },
                        {
                            title: "Subtitle Files",
                            value: subtitle_files.length
                        },
                        {
                            title: "Video Files",
                            value: video_files.length
                        }
                    ]
                }
            };
        })
    }, { urlPrefix: "/api" });
});
define("build/server/ffprobe/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.FormatResult = exports.Format = exports.StreamsResult = exports.Stream = exports.VideoStream = exports.SubtitleStream = exports.ImageStream = exports.AudioStream = exports.StreamCommon = exports.FramesResult = exports.VideoFrame = void 0;
    exports.VideoFrame = autoguard.guards.Object.of({
        "pkt_pts_time": autoguard.guards.String
    }, {});
    exports.FramesResult = autoguard.guards.Object.of({
        "frames": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.VideoFrame))
    }, {});
    exports.StreamCommon = autoguard.guards.Object.of({
        "codec_name": autoguard.guards.String
    }, {});
    exports.AudioStream = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.StreamCommon), autoguard.guards.Object.of({
        "codec_type": autoguard.guards.StringLiteral.of("audio"),
        "start_time": autoguard.guards.String,
        "duration": autoguard.guards.String
    }, {}));
    exports.ImageStream = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.StreamCommon), autoguard.guards.Object.of({
        "codec_type": autoguard.guards.StringLiteral.of("video"),
        "codec_time_base": autoguard.guards.StringLiteral.of("0/1"),
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    }, {}));
    exports.SubtitleStream = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.StreamCommon), autoguard.guards.Object.of({
        "codec_type": autoguard.guards.StringLiteral.of("subtitle")
    }, {}));
    exports.VideoStream = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.StreamCommon), autoguard.guards.Object.of({
        "codec_type": autoguard.guards.StringLiteral.of("video"),
        "start_time": autoguard.guards.String,
        "duration": autoguard.guards.String,
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number
    }, {}));
    exports.Stream = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.AudioStream), autoguard.guards.Reference.of(() => exports.ImageStream), autoguard.guards.Reference.of(() => exports.SubtitleStream), autoguard.guards.Reference.of(() => exports.VideoStream));
    exports.StreamsResult = autoguard.guards.Object.of({
        "streams": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Stream))
    }, {});
    exports.Format = autoguard.guards.Object.of({
        "format_name": autoguard.guards.String
    }, {
        "tags": autoguard.guards.Object.of({}, {
            "title": autoguard.guards.String,
            "date": autoguard.guards.String,
            "comment": autoguard.guards.String,
            "show": autoguard.guards.String,
            "episode_id": autoguard.guards.String,
            "episode_sort": autoguard.guards.String,
            "season_number": autoguard.guards.String,
            "track": autoguard.guards.String,
            "artist": autoguard.guards.String,
            "album_artist": autoguard.guards.String,
            "album": autoguard.guards.String,
            "disc": autoguard.guards.String
        })
    });
    exports.FormatResult = autoguard.guards.Object.of({
        "format": autoguard.guards.Reference.of(() => exports.Format)
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "VideoFrame": autoguard.guards.Reference.of(() => exports.VideoFrame),
            "FramesResult": autoguard.guards.Reference.of(() => exports.FramesResult),
            "StreamCommon": autoguard.guards.Reference.of(() => exports.StreamCommon),
            "AudioStream": autoguard.guards.Reference.of(() => exports.AudioStream),
            "ImageStream": autoguard.guards.Reference.of(() => exports.ImageStream),
            "SubtitleStream": autoguard.guards.Reference.of(() => exports.SubtitleStream),
            "VideoStream": autoguard.guards.Reference.of(() => exports.VideoStream),
            "Stream": autoguard.guards.Reference.of(() => exports.Stream),
            "StreamsResult": autoguard.guards.Reference.of(() => exports.StreamsResult),
            "Format": autoguard.guards.Reference.of(() => exports.Format),
            "FormatResult": autoguard.guards.Reference.of(() => exports.FormatResult)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/server/keyframes", ["require", "exports", "child_process", "build/server/ffprobe/index"], function (require, exports, libcp, libffprobe) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getKeyframeSegments = exports.getKeyframeOffsets = exports.getStreams = exports.combineOffsets = exports.makeSegments = void 0;
    function makeSegments(offsets_ms) {
        let segments = new Array();
        for (let i = 0; i + 1 < offsets_ms.length; i++) {
            segments.push({
                offset_ms: offsets_ms[i],
                duration_ms: offsets_ms[i + 1] - offsets_ms[i]
            });
        }
        return segments;
    }
    exports.makeSegments = makeSegments;
    function combineOffsets(offsets_ms, target_duration_ms) {
        let last_offset_ms = 0 - Infinity;
        let combined_offsets_ms = new Array();
        for (let i = 1; i < offsets_ms.length; i++) {
            if (offsets_ms[i] - last_offset_ms > target_duration_ms) {
                last_offset_ms = offsets_ms[i - 1];
                combined_offsets_ms.push(last_offset_ms);
            }
        }
        return combined_offsets_ms;
    }
    exports.combineOffsets = combineOffsets;
    async function getStreams(paths) {
        return new Promise((resolve, reject) => {
            let ffprobe = libcp.spawn("ffprobe", [
                "-hide_banner",
                "-i", paths.join("/"),
                "-show_streams",
                "-show_entries", "stream=start_time,duration",
                "-of", "json"
            ]);
            let chunks = new Array();
            ffprobe.stdout.on("data", (chunk) => {
                chunks.push(chunk);
            });
            ffprobe.on("exit", () => {
                let string = Buffer.concat(chunks).toString();
                let json = libffprobe.StreamsResult.as(JSON.parse(string));
                let streams = json.streams.filter((stream) => libffprobe.VideoStream.is(stream)).map((stream) => {
                    let offset_ms = Math.round(Number.parseFloat(stream.start_time) * 1000);
                    let duration_ms = Math.round(Number.parseFloat(stream.duration) * 1000);
                    return {
                        offset_ms,
                        duration_ms
                    };
                });
                resolve(streams);
            });
        });
    }
    exports.getStreams = getStreams;
    async function getKeyframeOffsets(paths, streamIndex) {
        return new Promise((resolve, reject) => {
            let ffprobe = libcp.spawn("ffprobe", [
                "-hide_banner",
                "-i", paths.join("/"),
                "-select_streams", `${streamIndex}`,
                "-skip_frame", "nokey",
                "-show_frames",
                "-show_entries", "frame=pkt_pts_time",
                "-of", "json"
            ]);
            let chunks = new Array();
            ffprobe.stdout.on("data", (chunk) => {
                chunks.push(chunk);
            });
            ffprobe.on("error", (error) => {
                reject(error);
            });
            ffprobe.on("exit", () => {
                let string = Buffer.concat(chunks).toString();
                try {
                    let json = libffprobe.FramesResult.as(JSON.parse(string));
                    let frames = json.frames.map((frame) => {
                        return Math.round(Number.parseFloat(frame.pkt_pts_time) * 1000);
                    });
                    resolve(frames);
                }
                catch (error) {
                    //console.log(`Keyframes failed for ${paths.join("/")}!`);
                    reject(error);
                }
            });
        });
    }
    exports.getKeyframeOffsets = getKeyframeOffsets;
    async function getKeyframeSegments(paths, streamIndex, targetDurationMs) {
        let streams = await getStreams(paths);
        let keyframeOffsets = await getKeyframeOffsets(paths, streamIndex);
        let stream = streams[streamIndex];
        let combinedOffsets = combineOffsets([...keyframeOffsets, stream.duration_ms], targetDurationMs);
        let segments = makeSegments([...combinedOffsets, stream.duration_ms]);
        return segments;
    }
    exports.getKeyframeSegments = getKeyframeSegments;
});
define("build/server/subsearch", ["require", "exports", "fs", "child_process", "crypto", "build/database/indexer", "build/is", "build/utils", "build/server/keyframes", "build/database/atlas"], function (require, exports, libfs, libcp, libcrypto, indexer, is, utils, keyframes, dbschema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateMeme = exports.generateStill = void 0;
    function createWorkingDirectory(cb) {
        let id = libcrypto.randomBytes(8).toString("hex");
        let wd = [".", "private", "jobs", id];
        libfs.mkdirSync(wd.join("/"), { recursive: true });
        return cb(wd, id);
    }
    function renameFile(source, target) {
        libfs.mkdirSync(target.slice(0, -1).join("/"), { recursive: true });
        libfs.renameSync(source.join("/"), target.join("/"));
    }
    function deleteTree(root) {
        let stats = libfs.statSync(root);
        if (stats.isDirectory()) {
            let nodes = libfs.readdirSync(root).map((node) => {
                return root + "/" + node;
            });
            nodes.forEach(deleteTree);
            libfs.rmdirSync(root);
        }
        else if (stats.isFile()) {
            libfs.unlinkSync(root);
        }
    }
    async function generateStill(target, source) {
        let offsets = await keyframes.getKeyframeOffsets(source, 0);
        let offset = offsets[Math.floor(offsets.length / 2)];
        return new Promise((resolve, reject) => {
            createWorkingDirectory((wd, id) => {
                let still = [...wd, "still.jpeg"];
                let cp = libcp.spawn("ffmpeg", [
                    "-ss", utils.formatTimestamp(offset),
                    "-i", source.join("/"),
                    "-q:v", "1",
                    "-frames:v", "1",
                    "-f", "singlejpeg",
                    "-fflags", "+bitexact",
                    "-map_metadata", "-1",
                    still.join("/"),
                    "-y"
                ]);
                cp.on("error", () => {
                    deleteTree(wd.join("/"));
                    return reject();
                });
                cp.on("exit", () => {
                    renameFile(still, target);
                    deleteTree(wd.join("/"));
                    return resolve();
                });
            });
        });
    }
    exports.generateStill = generateStill;
    function generateMeme(target, video_path, subtitle_path, cue, cb) {
        createWorkingDirectory((wd, id) => {
            let subtitle = [...wd, "subtitle.vtt"];
            let palette = [...wd, "palette.png"];
            let meme = [...wd, "meme.gif"];
            let cp = libcp.spawn("ffmpeg", [
                "-ss", utils.formatTimestamp(cue.start_ms),
                "-t", utils.formatTimestamp(Math.min(cue.duration_ms, 5000)),
                "-i", subtitle_path.join("/"),
                subtitle.join("/"),
                "-y"
            ]);
            cp.on("error", () => {
                console.log("ffmpeg command failed!");
                deleteTree(wd.join("/"));
                return cb();
            });
            cp.on("exit", () => {
                let cp = libcp.spawn("ffmpeg", [
                    "-ss", utils.formatTimestamp(cue.start_ms),
                    "-t", utils.formatTimestamp(Math.min(cue.duration_ms, 5000)),
                    "-i", video_path.join("/"),
                    "-vf", "fps=15,scale=w=384:h=216:force_original_aspect_ratio=decrease,pad=384:216:-1:-1,subtitles=" + subtitle.join("/") + ":force_style='Bold=1,Fontsize=24,Outline=2',palettegen",
                    palette.join("/"),
                    "-y"
                ]);
                cp.on("exit", () => {
                    let cp = libcp.spawn("ffmpeg", [
                        "-ss", utils.formatTimestamp(cue.start_ms),
                        "-t", utils.formatTimestamp(Math.min(cue.duration_ms, 5000)),
                        "-i", video_path.join("/"),
                        "-i", palette.join("/"),
                        "-filter_complex", "fps=15,scale=w=384:h=216:force_original_aspect_ratio=decrease,pad=384:216:-1:-1,subtitles=" + subtitle.join("/") + ":force_style='Bold=1,Fontsize=24,Outline=2'[x];[x][1:v]paletteuse",
                        "-map_metadata", "-1",
                        meme.join("/"),
                        "-y"
                    ]);
                    cp.on("exit", () => {
                        renameFile(meme, target);
                        deleteTree(wd.join("/"));
                        return cb();
                    });
                });
            });
        });
    }
    exports.generateMeme = generateMeme;
    const stillsTranscodingQueue = [];
    async function processQueue() {
        let job = stillsTranscodingQueue.pop();
        if (is.absent(job)) {
            return;
        }
        try {
            await generateStill(job.target, job.source);
        }
        catch (error) { }
        setTimeout(processQueue, 10 * 1000);
    }
    dbschema.transactionManager.enqueueReadableTransaction(async (queue) => {
        for (let video_file of await dbschema.stores.video_files.filter(queue)) {
            let target = [".", "private", "stills", utils.hexid(video_file.file_id)];
            if (!libfs.existsSync(target.join("/"))) {
                let file = await dbschema.stores.files.lookup(queue, video_file);
                let source = await indexer.getPath(queue, file);
                stillsTranscodingQueue.push({
                    source,
                    target
                });
            }
        }
        setTimeout(processQueue);
    });
});
define("build/observers/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayObservable = exports.computed = exports.ObservableClass = void 0;
    class ObservableClass {
        state;
        observers;
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer, alwaysNotify) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push({
                observer: (state) => {
                    observable.updateState(observer(state));
                },
                alwaysNotify
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return this.state;
        }
        updateState(state) {
            let didChange = state !== this.state;
            this.state = state;
            for (let observer of this.observers) {
                if (didChange || observer.alwaysNotify) {
                    observer.observer(this.state);
                }
            }
        }
    }
    exports.ObservableClass = ObservableClass;
    function computed(computer, ...observables) {
        let observable = new ObservableClass(computer(...observables.map((observable) => observable.getState())));
        let updater = () => {
            observable.updateState(computer(...observables.map((observable) => observable.getState())));
        };
        for (let observable of observables) {
            observable.addObserver(updater);
        }
        return observable;
    }
    exports.computed = computed;
    class ArrayObservable {
        state;
        observers;
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer) {
            this.observers.push(observer);
            for (let value of this.state) {
                observer.onappend?.(value);
            }
        }
        compute(observer) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push({
                onappend: (state) => {
                    observable.updateState(observer(this.state));
                },
                onsplice: (state, index) => {
                    observable.updateState(observer(this.state));
                }
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return this.state;
        }
        append(state) {
            this.state.push(state);
            for (let observer of this.observers) {
                observer.onappend?.(state);
            }
        }
        splice(index) {
            if (index < 0 || index >= this.state.length) {
                throw `Expected an index of at most ${this.state.length}, got ${index}!`;
            }
            let state = this.state[index];
            this.state.splice(index, 1);
            for (let observer of this.observers) {
                observer.onsplice?.(state, index);
            }
        }
        update(state) {
            for (let i = this.state.length - 1; i >= 0; i--) {
                this.splice(i);
            }
            for (let v of state) {
                this.append(v);
            }
        }
    }
    exports.ArrayObservable = ArrayObservable;
});
define("build/player/schema/objects/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2, objects_3, objects_4, objects_5, objects_6, objects_7, objects_8, objects_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Session = exports.Device = exports.ContextItem = exports.Context = exports.ContextEpisode = exports.ContextSeason = exports.ContextShow = exports.ContextMovie = exports.ContextPlaylist = exports.ContextTrack = exports.ContextDisc = exports.ContextArtist = exports.ContextAlbum = void 0;
    exports.ContextAlbum = autoguard.guards.Reference.of(() => objects_1.Album);
    exports.ContextArtist = autoguard.guards.Reference.of(() => objects_2.Artist);
    exports.ContextDisc = autoguard.guards.Reference.of(() => objects_3.Disc);
    exports.ContextTrack = autoguard.guards.Reference.of(() => objects_9.Track);
    exports.ContextPlaylist = autoguard.guards.Reference.of(() => objects_6.Playlist);
    exports.ContextMovie = autoguard.guards.Reference.of(() => objects_5.Movie);
    exports.ContextShow = autoguard.guards.Reference.of(() => objects_8.Show);
    exports.ContextSeason = autoguard.guards.Reference.of(() => objects_7.Season);
    exports.ContextEpisode = autoguard.guards.Reference.of(() => objects_4.Episode);
    exports.Context = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ContextAlbum), autoguard.guards.Reference.of(() => exports.ContextArtist), autoguard.guards.Reference.of(() => exports.ContextDisc), autoguard.guards.Reference.of(() => exports.ContextTrack), autoguard.guards.Reference.of(() => exports.ContextPlaylist), autoguard.guards.Reference.of(() => exports.ContextMovie), autoguard.guards.Reference.of(() => exports.ContextShow), autoguard.guards.Reference.of(() => exports.ContextSeason), autoguard.guards.Reference.of(() => exports.ContextEpisode));
    exports.ContextItem = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ContextTrack), autoguard.guards.Reference.of(() => exports.ContextMovie), autoguard.guards.Reference.of(() => exports.ContextEpisode));
    exports.Device = autoguard.guards.Object.of({
        "id": autoguard.guards.String,
        "protocol": autoguard.guards.String,
        "name": autoguard.guards.String,
        "type": autoguard.guards.String
    }, {});
    exports.Session = autoguard.guards.Object.of({
        "playback": autoguard.guards.Boolean
    }, {
        "context": autoguard.guards.Reference.of(() => exports.Context),
        "device": autoguard.guards.Reference.of(() => exports.Device),
        "index": autoguard.guards.Number,
        "progress": autoguard.guards.Number
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "ContextAlbum": autoguard.guards.Reference.of(() => exports.ContextAlbum),
            "ContextArtist": autoguard.guards.Reference.of(() => exports.ContextArtist),
            "ContextDisc": autoguard.guards.Reference.of(() => exports.ContextDisc),
            "ContextTrack": autoguard.guards.Reference.of(() => exports.ContextTrack),
            "ContextPlaylist": autoguard.guards.Reference.of(() => exports.ContextPlaylist),
            "ContextMovie": autoguard.guards.Reference.of(() => exports.ContextMovie),
            "ContextShow": autoguard.guards.Reference.of(() => exports.ContextShow),
            "ContextSeason": autoguard.guards.Reference.of(() => exports.ContextSeason),
            "ContextEpisode": autoguard.guards.Reference.of(() => exports.ContextEpisode),
            "Context": autoguard.guards.Reference.of(() => exports.Context),
            "ContextItem": autoguard.guards.Reference.of(() => exports.ContextItem),
            "Device": autoguard.guards.Reference.of(() => exports.Device),
            "Session": autoguard.guards.Reference.of(() => exports.Session)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/player/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/player/schema/objects/index", "build/player/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.SetToken = exports.SetProgress = exports.SetPlayback = exports.SetLocalDevice = exports.SetIndex = exports.SetDevices = exports.SetDevice = exports.SetContext = void 0;
    exports.SetContext = autoguard.guards.Object.of({}, {
        "context": autoguard.guards.Reference.of(() => objects_1.Context)
    });
    exports.SetDevice = autoguard.guards.Object.of({}, {
        "device": autoguard.guards.Reference.of(() => objects_2.Device)
    });
    exports.SetDevices = autoguard.guards.Object.of({
        "devices": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.Device))
    }, {});
    exports.SetIndex = autoguard.guards.Object.of({}, {
        "index": autoguard.guards.Number
    });
    exports.SetLocalDevice = autoguard.guards.Object.of({
        "device": autoguard.guards.Reference.of(() => objects_2.Device)
    }, {});
    exports.SetPlayback = autoguard.guards.Object.of({
        "playback": autoguard.guards.Boolean
    }, {});
    exports.SetProgress = autoguard.guards.Object.of({}, {
        "progress": autoguard.guards.Number
    });
    exports.SetToken = autoguard.guards.Object.of({}, {
        "token": autoguard.guards.String
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "SetContext": autoguard.guards.Reference.of(() => exports.SetContext),
            "SetDevice": autoguard.guards.Reference.of(() => exports.SetDevice),
            "SetDevices": autoguard.guards.Reference.of(() => exports.SetDevices),
            "SetIndex": autoguard.guards.Reference.of(() => exports.SetIndex),
            "SetLocalDevice": autoguard.guards.Reference.of(() => exports.SetLocalDevice),
            "SetPlayback": autoguard.guards.Reference.of(() => exports.SetPlayback),
            "SetProgress": autoguard.guards.Reference.of(() => exports.SetProgress),
            "SetToken": autoguard.guards.Reference.of(() => exports.SetToken)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/player/schema/index", ["require", "exports", "build/player/schema/messages/index", "build/player/schema/objects/index"], function (require, exports, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    exports.messages = messages;
    exports.objects = objects;
});
define("node_modules/@joelek/ts-sockets/dist/lib/shared", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusCode = exports.ReadyState = void 0;
    var ReadyState;
    (function (ReadyState) {
        ReadyState[ReadyState["CONNECTING"] = 0] = "CONNECTING";
        ReadyState[ReadyState["OPEN"] = 1] = "OPEN";
        ReadyState[ReadyState["CLOSING"] = 2] = "CLOSING";
        ReadyState[ReadyState["CLOSED"] = 3] = "CLOSED";
    })(ReadyState = exports.ReadyState || (exports.ReadyState = {}));
    ;
    var StatusCode;
    (function (StatusCode) {
        StatusCode[StatusCode["NORMAL"] = 1000] = "NORMAL";
        StatusCode[StatusCode["GOING_AWAY"] = 1001] = "GOING_AWAY";
        StatusCode[StatusCode["PROTOCOL_ERROR"] = 1002] = "PROTOCOL_ERROR";
        StatusCode[StatusCode["DATA_TYPE_NOT_ACCEPTED"] = 1003] = "DATA_TYPE_NOT_ACCEPTED";
        StatusCode[StatusCode["RESERVED_1004"] = 1004] = "RESERVED_1004";
        StatusCode[StatusCode["RESERVED_1005"] = 1005] = "RESERVED_1005";
        StatusCode[StatusCode["RESERVED_1006"] = 1006] = "RESERVED_1006";
        StatusCode[StatusCode["BAD_DATA_TYPE"] = 1007] = "BAD_DATA_TYPE";
        StatusCode[StatusCode["POLICY_VIOLATION"] = 1008] = "POLICY_VIOLATION";
        StatusCode[StatusCode["MESSAGE_TOO_BIG"] = 1009] = "MESSAGE_TOO_BIG";
        StatusCode[StatusCode["CLIENT_EXPECTED_EXTENSION"] = 1010] = "CLIENT_EXPECTED_EXTENSION";
        StatusCode[StatusCode["SERVER_UNEXPECTED_CONDITION"] = 1011] = "SERVER_UNEXPECTED_CONDITION";
        StatusCode[StatusCode["RESERVED_1015"] = 1015] = "RESERVED_1015";
    })(StatusCode = exports.StatusCode || (exports.StatusCode = {}));
    ;
    ;
});
define("build/typesockets/schema/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Envelope = void 0;
    exports.Envelope = autoguard.guards.Object.of({
        "type": autoguard.guards.String,
        "data": autoguard.guards.Any
    }, {
        "id": autoguard.guards.String
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Envelope": autoguard.guards.Reference.of(() => exports.Envelope)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/typesockets/shared", ["require", "exports", "build/typesockets/schema/index", "build/is"], function (require, exports, schema, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Serializer = void 0;
    class Serializer {
        guards;
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let envelope = schema.Envelope.as(JSON.parse(string));
            let id = envelope.id;
            let type = envelope.type;
            let data = envelope.data;
            let guard = this.guards[type];
            if (is.absent(guard)) {
                throw `Unknown message type "${type}"!`;
            }
            cb(type, guard.as(data), id);
        }
        serialize(type, data, id) {
            return JSON.stringify({
                type,
                data,
                id
            });
        }
    }
    exports.Serializer = Serializer;
    ;
});
define("build/typesockets/client", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/index", "node_modules/@joelek/ts-sockets/dist/lib/shared", "build/typesockets/shared", "build/is"], function (require, exports, stdlib, sockets, shared, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketClient = void 0;
    class TypeSocketClient {
        nextConnectionAttemptDelayFactor;
        nextConnectionAttemptDelay;
        router;
        serializer;
        url;
        factory;
        socket;
        requests;
        makeId() {
            let string = "";
            for (let i = 0; i < 32; i++) {
                let number = Math.floor(Math.random() * 16);
                string += number.toString(16);
            }
            return string;
        }
        makeSocket() {
            let socket = this.factory(this.url);
            socket.addEventListener("close", this.onClose.bind(this));
            socket.addEventListener("error", this.onError.bind(this));
            socket.addEventListener("message", this.onMessage.bind(this));
            socket.addEventListener("open", this.onOpen.bind(this));
            return socket;
        }
        onClose(event) {
            this.router.route("sys", "disconnect", {});
        }
        onError(event) {
            setTimeout(() => {
                this.socket = this.makeSocket();
            }, this.nextConnectionAttemptDelay);
            this.nextConnectionAttemptDelay = Math.round(this.nextConnectionAttemptDelay * this.nextConnectionAttemptDelayFactor);
        }
        onMessage(event) {
            try {
                this.serializer.deserialize(event.data, (type, data, id) => {
                    this.router.route("sys", "message", {
                        type,
                        data
                    });
                    if (is.present(id)) {
                        let callback = this.requests.get(id);
                        if (is.present(callback)) {
                            this.requests.delete(id);
                            callback(type, data);
                        }
                    }
                    this.router.route("app", type, data);
                });
            }
            catch (error) {
                this.socket.close();
            }
        }
        onOpen(event) {
            this.nextConnectionAttemptDelay = 2000;
            this.router.route("sys", "connect", {});
        }
        queue(payload) {
            if (this.socket.readyState === sockets.ReadyState.OPEN) {
                this.socket.send(payload);
            }
            else {
                let onopen = () => {
                    this.socket.removeEventListener("open", onopen);
                    this.socket.send(payload);
                };
                this.socket.addEventListener("open", onopen);
            }
        }
        constructor(url, factory, guards) {
            this.nextConnectionAttemptDelayFactor = 2.0 + Math.random();
            this.nextConnectionAttemptDelay = 2000;
            this.router = new stdlib.routing.NamespacedMessageRouter();
            this.serializer = new shared.Serializer(guards);
            this.url = url;
            this.factory = factory;
            this.socket = this.makeSocket();
            this.requests = new Map();
        }
        addEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        close() {
            this.socket.close();
        }
        reconnect() {
            if (this.socket.readyState === sockets.ReadyState.CLOSED) {
                this.socket = this.makeSocket();
            }
        }
        removeEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        request(type, response_type, data) {
            return new Promise((resolve, reject) => {
                let id = this.makeId();
                let payload = this.serializer.serialize(type, data, id);
                this.requests.set(id, (type, data) => {
                    if (type !== response_type) {
                        reject(`Received response with type "${type}" when expecting "${response_type}"!`);
                    }
                    else {
                        resolve(data);
                    }
                });
                this.queue(payload);
            });
        }
        send(type, data) {
            let payload = this.serializer.serialize(type, data);
            this.queue(payload);
        }
    }
    exports.TypeSocketClient = TypeSocketClient;
    ;
});
define("build/player/client", ["require", "exports", "build/is", "build/observers/index", "build/player/schema/index", "build/typesockets/client"], function (require, exports, is, observers, schema, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextClient = void 0;
    class ContextClient {
        tsc;
        estimatedProgress = new observers.ObservableClass(undefined);
        estimatedProgressTimestamp = new observers.ObservableClass(undefined);
        token = new observers.ObservableClass(undefined);
        localDevice = new observers.ObservableClass(undefined);
        devices = new observers.ArrayObservable(new Array());
        device = new observers.ObservableClass(undefined);
        isDeviceLocal = new observers.ObservableClass(false);
        isDeviceRemote = new observers.ObservableClass(false);
        context = new observers.ObservableClass(undefined);
        contextPath = new observers.ObservableClass(undefined);
        flattenedContext = new observers.ObservableClass(undefined);
        lastIndex = new observers.ObservableClass(undefined);
        lastEntry = new observers.ObservableClass(undefined);
        lastLocalEntry = new observers.ObservableClass(undefined);
        currentIndex = new observers.ObservableClass(undefined);
        currentEntry = new observers.ObservableClass(undefined);
        currentLocalEntry = new observers.ObservableClass(undefined);
        nextIndex = new observers.ObservableClass(undefined);
        nextEntry = new observers.ObservableClass(undefined);
        nextLocalEntry = new observers.ObservableClass(undefined);
        playback = new observers.ObservableClass(false);
        progress = new observers.ObservableClass(undefined);
        localPlayback = new observers.ObservableClass(false);
        canPlayLast = new observers.ObservableClass(false);
        canPlayCurrent = new observers.ObservableClass(false);
        canPlayNext = new observers.ObservableClass(false);
        isCurrentEntryVideo = new observers.ObservableClass(false);
        isOnline = new observers.ObservableClass(false);
        sendPlay(context, index) {
            this.isCurrentEntryVideo.updateState(false);
            this.tsc.send("SetContext", {
                context
            });
            this.tsc.send("SetIndex", {
                index
            });
            this.tsc.send("SetPlayback", {
                playback: true
            });
        }
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.tsc = new typesockets.TypeSocketClient(url, factory, schema.messages.Autoguard.Guards);
            this.tsc.addEventListener("sys", "connect", () => {
                this.isOnline.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.isOnline.updateState(false);
            });
            this.context.addObserver((context) => {
                if (is.present(context)) {
                    if (schema.objects.ContextAlbum.is(context)) {
                        let files = [];
                        let album = context;
                        for (let disc of album.discs) {
                            files.push(...disc.tracks);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextArtist.is(context)) {
                        let files = [];
                        let artist = context;
                        for (let album of artist.albums) {
                            for (let disc of album.discs) {
                                files.push(...disc.tracks);
                            }
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextEpisode.is(context)) {
                        let files = [];
                        let episode = context;
                        files.push(episode);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextMovie.is(context)) {
                        let files = [];
                        let movie = context;
                        files.push(movie);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextPlaylist.is(context)) {
                        let files = [];
                        let playlist = context;
                        for (let item of playlist.items) {
                            files.push(item.track);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextSeason.is(context)) {
                        let files = [];
                        let season = context;
                        files.push(...season.episodes);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextShow.is(context)) {
                        let files = [];
                        let show = context;
                        for (let season of show.seasons) {
                            files.push(...season.episodes);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextTrack.is(context)) {
                        let files = [];
                        let track = context;
                        files.push(track);
                        this.flattenedContext.updateState(files);
                    }
                    else {
                        throw `Expected code to be unreachable!`;
                    }
                }
            });
            {
                let computer = () => {
                    let context = this.context.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(context) && is.present(currentIndex)) {
                        if (schema.objects.ContextAlbum.is(context)) {
                            let discIndex = 0;
                            let trackIndex = currentIndex;
                            let album = context;
                            let discs = album.discs;
                            for (let d = 0; d < discs.length; d++) {
                                let length = discs[d].tracks.length;
                                if (trackIndex >= length) {
                                    discIndex += 1;
                                    trackIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.album_id,
                                context.discs[discIndex]?.disc_id,
                                context.discs[discIndex]?.tracks[trackIndex]?.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextArtist.is(context)) {
                            let albumIndex = 0;
                            let discIndex = 0;
                            let trackIndex = currentIndex;
                            let artist = context;
                            let albums = artist.albums;
                            outer: for (let a = 0; a < albums.length; a++) {
                                let discs = albums[a].discs;
                                for (let d = 0; d < discs.length; d++) {
                                    let length = discs[d].tracks.length;
                                    if (trackIndex >= length) {
                                        discIndex += 1;
                                        trackIndex -= length;
                                    }
                                    else {
                                        break outer;
                                    }
                                }
                                albumIndex += 1;
                                discIndex = 0;
                            }
                            return this.contextPath.updateState([
                                context.artist_id,
                                context.albums[albumIndex]?.album_id,
                                context.albums[albumIndex]?.discs[discIndex]?.disc_id,
                                context.albums[albumIndex]?.discs[discIndex]?.tracks[trackIndex]?.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextEpisode.is(context)) {
                            return this.contextPath.updateState([
                                context.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextMovie.is(context)) {
                            return this.contextPath.updateState([
                                context.movie_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextPlaylist.is(context)) {
                            let itemIndex = currentIndex;
                            return this.contextPath.updateState([
                                context.playlist_id,
                                context.items[itemIndex]?.track.track_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextShow.is(context)) {
                            let seasonIndex = 0;
                            let episodeIndex = currentIndex;
                            let show = context;
                            let seasons = show.seasons;
                            for (let d = 0; d < seasons.length; d++) {
                                let length = seasons[d].episodes.length;
                                if (episodeIndex >= length) {
                                    seasonIndex += 1;
                                    episodeIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.show_id,
                                context.seasons[seasonIndex]?.season_id,
                                context.seasons[seasonIndex]?.episodes[episodeIndex]?.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextSeason.is(context)) {
                            let episodeIndex = currentIndex;
                            return this.contextPath.updateState([
                                context.season_id,
                                context.episodes[episodeIndex]?.episode_id
                            ].filter(is.present));
                        }
                        else if (schema.objects.ContextTrack.is(context)) {
                            return this.contextPath.updateState([
                                context.track_id
                            ].filter(is.present));
                        }
                        else {
                            throw `Expected code to be unreachable!`;
                        }
                    }
                    this.contextPath.updateState(undefined);
                };
                this.context.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            this.lastEntry.addObserver((lastEntry) => {
                this.canPlayLast.updateState(is.present(lastEntry));
            });
            this.currentEntry.addObserver((currentEntry) => {
                this.canPlayCurrent.updateState(is.present(currentEntry));
            });
            this.nextEntry.addObserver((nextEntry) => {
                this.canPlayNext.updateState(is.present(nextEntry));
            });
            this.progress.addObserver((progress) => {
                this.estimatedProgress.updateState(progress);
                this.estimatedProgressTimestamp.updateState(Date.now());
            }, true);
            this.playback.addObserver((playback) => {
                let estimatedProgress = this.estimatedProgress.getState();
                let estimatedProgressTimestamp = this.estimatedProgressTimestamp.getState();
                let now = Date.now();
                if (!playback) {
                    if (is.present(estimatedProgress) && is.present(estimatedProgressTimestamp)) {
                        this.estimatedProgress.updateState(estimatedProgress + (now - estimatedProgressTimestamp) / 1000);
                    }
                }
                this.estimatedProgressTimestamp.updateState(now);
            });
            this.progress.addObserver((progress) => {
                console.log(`Progress: ${progress}`);
            });
            this.estimatedProgress.addObserver((estimatedProgress) => {
                console.log(`Estimated progress: ${estimatedProgress}`);
            });
            {
                let computer = () => {
                    let playback = this.playback.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.localPlayback.updateState(isDeviceLocal && playback);
                };
                this.playback.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let lastEntry = this.lastEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.lastLocalEntry.updateState(isDeviceLocal ? lastEntry : undefined);
                };
                this.lastEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let currentEntry = this.currentEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.currentLocalEntry.updateState(isDeviceLocal ? currentEntry : undefined);
                };
                this.currentEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let nextEntry = this.nextEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.nextLocalEntry.updateState(isDeviceLocal ? nextEntry : undefined);
                };
                this.nextEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id === device.id) {
                            return this.isDeviceLocal.updateState(true);
                        }
                    }
                    return this.isDeviceLocal.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id !== device.id) {
                            return this.isDeviceRemote.updateState(true);
                        }
                    }
                    return this.isDeviceRemote.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(currentIndex)) {
                        let index = currentIndex - 1;
                        if (index >= 0 && index < flattenedContext.length) {
                            return this.lastIndex.updateState(index);
                        }
                    }
                    return this.lastIndex.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(currentIndex)) {
                        let index = currentIndex + 1;
                        if (index >= 0 && index < flattenedContext.length) {
                            return this.nextIndex.updateState(index);
                        }
                    }
                    return this.nextIndex.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let lastIndex = this.lastIndex.getState();
                    if (is.present(flattenedContext) && is.present(lastIndex)) {
                        return this.lastEntry.updateState(flattenedContext[lastIndex]);
                    }
                    return this.lastEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.lastIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let contextIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(contextIndex)) {
                        if (contextIndex >= 0 && contextIndex + 0 < flattenedContext.length) {
                            return this.currentEntry.updateState(flattenedContext[contextIndex + 0]);
                        }
                    }
                    return this.currentEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let nextIndex = this.nextIndex.getState();
                    if (is.present(flattenedContext) && is.present(nextIndex)) {
                        return this.nextEntry.updateState(flattenedContext[nextIndex]);
                    }
                    return this.nextEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.nextIndex.addObserver(computer);
            }
            this.tsc.addEventListener("app", "SetLocalDevice", (message) => {
                this.localDevice.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetDevices", (message) => {
                this.devices.update(message.devices);
            });
            this.tsc.addEventListener("app", "SetContext", (message) => {
                this.context.updateState(message.context);
            });
            this.tsc.addEventListener("app", "SetDevice", (message) => {
                this.device.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetIndex", (message) => {
                this.currentIndex.updateState(message.index);
            });
            this.tsc.addEventListener("app", "SetPlayback", (message) => {
                this.playback.updateState(message.playback);
            });
            this.tsc.addEventListener("app", "SetProgress", (message) => {
                this.progress.updateState(message.progress);
            });
            this.tsc.addEventListener("app", "SetToken", (message) => {
                this.token.updateState(message.token);
            });
            this.isOnline.addObserver((isOnline) => {
                if (!isOnline) {
                    this.context.updateState(undefined);
                    this.currentIndex.updateState(undefined);
                    this.playback.updateState(false);
                    this.progress.updateState(undefined);
                }
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.isOnline, this.token);
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        close() {
            this.tsc.close();
        }
        last() {
            let lastIndex = this.lastIndex.getState();
            if (is.present(lastIndex)) {
                this.currentIndex.updateState(lastIndex);
                this.tsc.send("SetIndex", {
                    index: lastIndex
                });
            }
            else {
                this.pause();
            }
        }
        next() {
            let nextIndex = this.nextIndex.getState();
            if (is.present(nextIndex)) {
                this.currentIndex.updateState(nextIndex);
                this.tsc.send("SetIndex", {
                    index: nextIndex
                });
            }
            else {
                this.pause();
            }
        }
        pause() {
            this.playback.updateState(false);
            this.tsc.send("SetPlayback", {
                playback: false
            });
        }
        play() {
            this.resume();
        }
        playAlbum(album, discIndex, trackIndex) {
            let index = 0;
            if (is.present(discIndex)) {
                let discs = album.discs;
                if (discIndex < 0 || discIndex >= discs.length) {
                    throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                }
                index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                if (is.present(trackIndex)) {
                    let tracks = discs[discIndex].tracks;
                    if (trackIndex < 0 || trackIndex >= tracks.length) {
                        throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                    }
                    index += trackIndex;
                }
            }
            return this.sendPlay(album, index);
        }
        playArtist(artist, albumIndex, discIndex, trackIndex) {
            let index = 0;
            if (is.present(albumIndex)) {
                let albums = artist.albums;
                if (albumIndex < 0 || albumIndex >= albums.length) {
                    throw `Expected ${albumIndex} to be a number between 0 and ${albums.length}!`;
                }
                index += albums.slice(0, albumIndex).reduce((sum, album) => sum + album.discs.reduce((sum, disc) => sum + disc.tracks.length, 0), 0);
                if (is.present(discIndex)) {
                    let discs = albums[albumIndex].discs;
                    if (discIndex < 0 || discIndex >= discs.length) {
                        throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                    }
                    index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                    if (is.present(trackIndex)) {
                        let tracks = discs[discIndex].tracks;
                        if (trackIndex < 0 || trackIndex >= tracks.length) {
                            throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                        }
                        index += trackIndex;
                    }
                }
            }
            return this.sendPlay(artist, index);
        }
        playDisc(disc, trackIndex) {
            let index = 0;
            if (is.present(trackIndex)) {
                let tracks = disc.tracks;
                if (trackIndex < 0 || trackIndex >= tracks.length) {
                    throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                }
                index += trackIndex;
            }
            return this.sendPlay(disc, index);
        }
        playEpisode(episode) {
            this.sendPlay(episode, 0);
        }
        playMovie(movie) {
            this.sendPlay(movie, 0);
        }
        playPlaylist(playlist, itemIndex) {
            let index = 0;
            if (is.present(itemIndex)) {
                let items = playlist.items;
                if (itemIndex < 0 || itemIndex >= items.length) {
                    throw `Expected ${itemIndex} to be a number between 0 and ${items.length}!`;
                }
                index += itemIndex;
            }
            return this.sendPlay(playlist, index);
        }
        playSeason(season, episodeIndex) {
            let index = 0;
            if (is.present(episodeIndex)) {
                let episodes = season.episodes;
                if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                    throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                }
                index += episodeIndex;
            }
            return this.sendPlay(season, index);
        }
        playShow(show, seasonIndex, episodeIndex) {
            let index = 0;
            if (is.present(seasonIndex)) {
                let seasons = show.seasons;
                if (seasonIndex < 0 || seasonIndex >= seasons.length) {
                    throw `Expected ${seasonIndex} to be a number between 0 and ${seasons.length}!`;
                }
                index += seasons.slice(0, seasonIndex).reduce((sum, season) => sum + season.episodes.length, 0);
                if (is.present(episodeIndex)) {
                    let episodes = seasons[seasonIndex].episodes;
                    if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                        throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                    }
                    index += episodeIndex;
                }
            }
            return this.sendPlay(show, index);
        }
        playTrack(track) {
            this.sendPlay(track, 0);
        }
        reconnect() {
            this.tsc.reconnect();
        }
        resume() {
            if (this.canPlayCurrent.getState()) {
                this.playback.updateState(true);
                this.tsc.send("SetPlayback", {
                    playback: true
                });
            }
        }
        seek(progress) {
            this.progress.updateState(progress);
            this.tsc.send("SetProgress", {
                progress: progress
            });
        }
        toggle() {
            if (this.playback.getState()) {
                this.pause();
            }
            else {
                this.resume();
            }
        }
        transfer(device) {
            this.tsc.send("SetDevice", {
                device: device
            });
        }
    }
    exports.ContextClient = ContextClient;
});
define("node_modules/@joelek/ts-sockets/dist/lib/frames", ["require", "exports", "crypto"], function (require, exports, libcrypto) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeFrame = exports.decodeFrame = exports.WebSocketFrameType = void 0;
    var WebSocketFrameType;
    (function (WebSocketFrameType) {
        WebSocketFrameType[WebSocketFrameType["CONTINUATION"] = 0] = "CONTINUATION";
        WebSocketFrameType[WebSocketFrameType["TEXT"] = 1] = "TEXT";
        WebSocketFrameType[WebSocketFrameType["BINARY"] = 2] = "BINARY";
        WebSocketFrameType[WebSocketFrameType["UNUSED_3"] = 3] = "UNUSED_3";
        WebSocketFrameType[WebSocketFrameType["UNUSED_4"] = 4] = "UNUSED_4";
        WebSocketFrameType[WebSocketFrameType["UNUSED_5"] = 5] = "UNUSED_5";
        WebSocketFrameType[WebSocketFrameType["UNUSED_6"] = 6] = "UNUSED_6";
        WebSocketFrameType[WebSocketFrameType["UNUSED_7"] = 7] = "UNUSED_7";
        WebSocketFrameType[WebSocketFrameType["CLOSE"] = 8] = "CLOSE";
        WebSocketFrameType[WebSocketFrameType["PING"] = 9] = "PING";
        WebSocketFrameType[WebSocketFrameType["PONG"] = 10] = "PONG";
        WebSocketFrameType[WebSocketFrameType["UNUSED_B"] = 11] = "UNUSED_B";
        WebSocketFrameType[WebSocketFrameType["UNUSED_C"] = 12] = "UNUSED_C";
        WebSocketFrameType[WebSocketFrameType["UNUSED_D"] = 13] = "UNUSED_D";
        WebSocketFrameType[WebSocketFrameType["UNUSED_E"] = 14] = "UNUSED_E";
        WebSocketFrameType[WebSocketFrameType["UNUSED_F"] = 15] = "UNUSED_F";
    })(WebSocketFrameType = exports.WebSocketFrameType || (exports.WebSocketFrameType = {}));
    ;
    function decodeFrame(state) {
        let final = ((state.buffer.readUInt8(state.offset) >> 7) & 0x01);
        let reserved1 = ((state.buffer.readUInt8(state.offset) >> 6) & 0x01);
        let reserved2 = ((state.buffer.readUInt8(state.offset) >> 5) & 0x01);
        let reserved3 = ((state.buffer.readUInt8(state.offset) >> 4) & 0x01);
        let opcode = ((state.buffer.readUInt8(state.offset) >> 0) & 0x0F);
        state.offset += 1;
        let masked = ((state.buffer.readUInt8(state.offset) >> 7) & 0x01);
        let payload_length = ((state.buffer.readUInt8(state.offset) >> 0) & 0x7F);
        state.offset += 1;
        if (payload_length === 126) {
            payload_length = state.buffer.readUInt16BE(state.offset);
            state.offset += 2;
            if (payload_length <= 125) {
                throw "Invalid frame encoding!";
            }
        }
        else if (payload_length === 127) {
            if (state.buffer.readUInt32BE(state.offset) !== 0) {
                throw "Invalid frame encoding!";
            }
            state.offset += 4;
            payload_length = state.buffer.readUInt32BE(state.offset);
            state.offset += 4;
            if (payload_length <= 65535) {
                throw "Invalid frame encoding!";
            }
        }
        let key = Buffer.alloc(4);
        if (masked === 1) {
            key = state.buffer.slice(state.offset, state.offset + 4);
            state.offset += 4;
        }
        if (state.offset + payload_length > state.buffer.length) {
            throw "Invalid frame encoding!";
        }
        let payload = state.buffer.slice(state.offset, state.offset + payload_length);
        state.offset += payload_length;
        if (masked === 1) {
            for (let i = 0; i < payload.length; i++) {
                payload[i] = payload[i] ^ key[i & 0x03];
            }
        }
        return {
            final,
            reserved1,
            reserved2,
            reserved3,
            opcode,
            masked,
            payload
        };
    }
    exports.decodeFrame = decodeFrame;
    ;
    function encodeFrame(frame) {
        let chunks = new Array();
        let payload_length = frame.payload.length;
        let header = Buffer.alloc(2);
        chunks.push(header);
        let byte0 = 0;
        byte0 |= ((frame.final & 0x01) << 7);
        byte0 |= ((frame.reserved1 & 0x01) << 6);
        byte0 |= ((frame.reserved2 & 0x01) << 5);
        byte0 |= ((frame.reserved3 & 0x01) << 4);
        byte0 |= ((frame.opcode & 0x0F) << 0);
        header.writeUInt8(byte0, 0);
        if (payload_length <= 125) {
            let byte1 = 0;
            byte1 |= ((frame.masked & 0x01) << 7);
            byte1 |= ((payload_length & 0x7F) << 0);
            header.writeUInt8(byte1, 1);
        }
        else if (payload_length <= 65535) {
            let byte1 = 0;
            byte1 |= ((frame.masked & 0x01) << 7);
            byte1 |= ((126 & 0x7F) << 0);
            header.writeUInt8(byte1, 1);
            let length = Buffer.alloc(2);
            length.writeUInt16BE(payload_length, 0);
            chunks.push(length);
        }
        else if (payload_length <= 4294967295) {
            let byte1 = 0;
            byte1 |= ((frame.masked & 0x01) << 7);
            byte1 |= ((127 & 0x7F) << 0);
            header.writeUInt8(byte1, 1);
            let length = Buffer.alloc(8);
            length.writeUInt32BE(payload_length, 4);
            chunks.push(length);
        }
        else {
            throw "Invalid frame size!";
        }
        if (frame.masked === 1) {
            let key = libcrypto.randomBytes(4);
            let payload = Buffer.concat([frame.payload]);
            for (let i = 0; i < payload.length; i++) {
                payload[i] = payload[i] ^ key[i & 0x03];
            }
            chunks.push(key, payload);
        }
        else {
            chunks.push(frame.payload);
        }
        return Buffer.concat(chunks);
    }
    exports.encodeFrame = encodeFrame;
    ;
});
define("node_modules/@joelek/ts-sockets/dist/lib/is", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.present = exports.absent = void 0;
    function absent(subject) {
        return subject == null;
    }
    exports.absent = absent;
    ;
    function present(subject) {
        return subject != null;
    }
    exports.present = present;
    ;
});
define("node_modules/@joelek/ts-sockets/dist/lib/utils", ["require", "exports", "node_modules/@joelek/ts-sockets/dist/lib/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BiMap = exports.getHeader = void 0;
    function getHeader(request, key) {
        let values = request.headers[key.toLowerCase()];
        if (is.present(values)) {
            if (values.constructor === String) {
                return values;
            }
            if (values.constructor === Array && values.length === 1) {
                return values[0];
            }
        }
        return null;
    }
    exports.getHeader = getHeader;
    ;
    class BiMap {
        constructor() {
            this.value_to_key = new Map();
            this.key_to_value = new Map();
        }
        [Symbol.iterator]() {
            return this.key_to_value[Symbol.iterator]();
        }
        add(key, value) {
            this.value_to_key.set(value, key);
            this.key_to_value.set(key, value);
        }
        key(value) {
            return this.value_to_key.get(value) || null;
        }
        remove(key) {
            let value = this.key_to_value.get(key);
            if (is.present(value)) {
                this.value_to_key.delete(value);
            }
            this.key_to_value.delete(key);
        }
        value(key) {
            return this.key_to_value.get(key) || null;
        }
    }
    exports.BiMap = BiMap;
    ;
});
define("node_modules/@joelek/ts-sockets/dist/lib/client", ["require", "exports", "crypto", "http", "https", "url", "node_modules/@joelek/ts-stdlib/dist/lib/index", "node_modules/@joelek/ts-sockets/dist/lib/frames", "node_modules/@joelek/ts-sockets/dist/lib/is", "node_modules/@joelek/ts-sockets/dist/lib/shared", "node_modules/@joelek/ts-sockets/dist/lib/utils"], function (require, exports, libcrypto, libhttp, libhttps, liburl, stdlib, frames, is, shared, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketClient = void 0;
    function makeHttpPromise(url, options) {
        return new Promise((resolve, reject) => {
            libhttp.get(url, options)
                .on("upgrade", (response, socket, buffer) => {
                resolve({ response, socket, buffer });
            })
                .on("error", reject);
        });
    }
    function makeHttpsPromise(url, options) {
        return new Promise((resolve, reject) => {
            libhttps.get(url, options)
                .on("upgrade", (response, socket, buffer) => {
                resolve({ response, socket, buffer });
            })
                .on("error", reject);
        });
    }
    class WebSocketClient {
        constructor(url) {
            var _a;
            this.state = shared.ReadyState.CONNECTING;
            this.listeners = new stdlib.routing.MessageRouter();
            this.pending = new Array();
            this.socket = undefined;
            let key = libcrypto.randomBytes(16).toString("base64");
            let headers = {
                "Connection": "upgrade",
                "Host": (_a = liburl.parse(url).host) !== null && _a !== void 0 ? _a : "",
                "Sec-WebSocket-Key": key,
                "Sec-WebSocket-Version": "13",
                "Upgrade": "websocket"
            };
            (() => {
                if (url.startsWith("wss:")) {
                    return makeHttpsPromise("https:" + url.substring(4), { headers, rejectUnauthorized: false });
                }
                else if (url.startsWith("ws:")) {
                    return makeHttpPromise("http:" + url.substring(3), { headers });
                }
                else {
                    throw `Expected ${url} to be a WebSocket URL!`;
                }
            })().then((upgraded) => {
                var _a, _b;
                let response = upgraded.response;
                let socket = upgraded.socket;
                let buffer = upgraded.buffer;
                socket.on("close", () => {
                    this.state = shared.ReadyState.CLOSED;
                    this.listeners.route("close", {});
                });
                socket.on("error", () => {
                    this.state = shared.ReadyState.CLOSING;
                    this.listeners.route("error", {});
                    socket.end();
                });
                if (response.statusCode !== 101) {
                    return socket.emit("error");
                }
                if (((_a = utils.getHeader(response, "Connection")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== "upgrade") {
                    return socket.emit("error");
                }
                if (((_b = utils.getHeader(response, "Upgrade")) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== "websocket") {
                    return socket.emit("error");
                }
                let accept = libcrypto.createHash("sha1")
                    .update(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")
                    .digest("base64");
                if (utils.getHeader(response, "Sec-WebSocket-Accept") !== accept) {
                    return socket.emit("error");
                }
                this.socket = socket;
                let processBuffer = () => {
                    while (true) {
                        try {
                            let state = {
                                buffer,
                                offset: 0
                            };
                            let frame = frames.decodeFrame(state);
                            this.onFrame(socket, frame);
                            buffer = buffer.slice(state.offset);
                        }
                        catch (error) {
                            break;
                        }
                    }
                };
                this.socket.on("data", (chunk) => {
                    buffer = Buffer.concat([buffer, chunk]);
                    processBuffer();
                });
                this.state = shared.ReadyState.OPEN;
                this.listeners.route("open", {});
                processBuffer();
            });
        }
        onFrame(socket, frame) {
            if (frame.reserved1 !== 0 || frame.reserved2 !== 0 || frame.reserved3 !== 0) {
                return this.close(shared.StatusCode.PROTOCOL_ERROR);
            }
            if (frame.opcode < 8) {
                if (frame.opcode === frames.WebSocketFrameType.CONTINUATION || frame.opcode === frames.WebSocketFrameType.TEXT || frame.opcode == frames.WebSocketFrameType.BINARY) {
                    if (this.pending.length === 0) {
                        if (frame.opcode === frames.WebSocketFrameType.CONTINUATION) {
                            return this.close(shared.StatusCode.PROTOCOL_ERROR);
                        }
                    }
                    else {
                        if (frame.opcode !== frames.WebSocketFrameType.CONTINUATION) {
                            return this.close(shared.StatusCode.PROTOCOL_ERROR);
                        }
                    }
                    this.pending.push(frame.payload);
                    if (frame.final === 1) {
                        let buffer = Buffer.concat(this.pending);
                        this.pending.splice(0);
                        this.listeners.route("message", {
                            data: buffer.toString()
                        });
                    }
                }
                else {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
            }
            else {
                if (frame.final !== 1) {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.payload.length > 125) {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.opcode === frames.WebSocketFrameType.CLOSE) {
                    if (this.readyState === shared.ReadyState.CLOSING) {
                        return socket.end();
                    }
                    else {
                        socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { masked: 1 })), () => {
                            return socket.end();
                        });
                    }
                }
                else if (frame.opcode === frames.WebSocketFrameType.PING) {
                    socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { opcode: 0x0A, masked: 1 })));
                }
                else if (frame.opcode === frames.WebSocketFrameType.PONG) {
                }
                else {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
            }
        }
        addEventListener(type, listener) {
            this.listeners.addObserver(type, listener);
        }
        close(status) {
            if (this.state !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            const socket = this.socket;
            if (is.absent(socket)) {
                throw `Expected socket to be open!`;
            }
            let payload = Buffer.alloc(0);
            if (is.present(status)) {
                payload = Buffer.concat([Buffer.alloc(2), Buffer.from("Connection closed by client.")]);
                payload.writeUInt16BE(status, 0);
            }
            let frame = frames.encodeFrame({
                final: 1,
                reserved1: 0,
                reserved2: 0,
                reserved3: 0,
                opcode: frames.WebSocketFrameType.CLOSE,
                masked: 1,
                payload: payload
            });
            socket.write(frame);
            this.state = shared.ReadyState.CLOSING;
        }
        removeEventListener(type, listener) {
            this.listeners.removeObserver(type, listener);
        }
        send(payload) {
            if (this.state !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            let socket = this.socket;
            if (is.absent(socket)) {
                throw `Expected socket to be open!`;
            }
            let final = 1;
            let reserved1 = 0;
            let reserved2 = 0;
            let reserved3 = 0;
            let opcode = frames.WebSocketFrameType.BINARY;
            let masked = 1;
            if (!(payload instanceof Buffer)) {
                payload = Buffer.from(payload, "utf8");
                opcode = frames.WebSocketFrameType.TEXT;
            }
            let frame = frames.encodeFrame({
                final,
                reserved1,
                reserved2,
                reserved3,
                opcode,
                masked,
                payload
            });
            socket.write(frame);
        }
        get readyState() {
            return this.state;
        }
    }
    exports.WebSocketClient = WebSocketClient;
    ;
});
define("node_modules/@joelek/ts-sockets/dist/lib/server", ["require", "exports", "crypto", "tls", "node_modules/@joelek/ts-stdlib/dist/lib/index", "node_modules/@joelek/ts-sockets/dist/lib/frames", "node_modules/@joelek/ts-sockets/dist/lib/is", "node_modules/@joelek/ts-sockets/dist/lib/shared", "node_modules/@joelek/ts-sockets/dist/lib/utils"], function (require, exports, libcrypto, libtls, stdlib, frames, is, shared, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketServer = void 0;
    function makeConnectionUrl(request) {
        let host = request.headers.host || "";
        let path = request.url || "/";
        let protocol = request.socket instanceof libtls.TLSSocket ? "wss:" : "ws:";
        return `${protocol}//${host}${path}`;
    }
    class WebSocketServer {
        constructor() {
            this.pending_chunks = new Map();
            this.states = new Map();
            this.connections = new utils.BiMap();
            this.router = new stdlib.routing.MessageRouter();
        }
        onFrame(connection_id, connection_url, socket, frame) {
            if (frame.reserved1 !== 0 || frame.reserved2 !== 0 || frame.reserved3 !== 0) {
                return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
            }
            if (frame.masked !== 1) {
                return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
            }
            if (frame.opcode < 8) {
                if (frame.opcode === frames.WebSocketFrameType.CONTINUATION || frame.opcode === frames.WebSocketFrameType.TEXT || frame.opcode == frames.WebSocketFrameType.BINARY) {
                    let pending_chunks = this.pending_chunks.get(connection_id);
                    if (is.absent(pending_chunks)) {
                        pending_chunks = new Array();
                        this.pending_chunks.set(connection_id, pending_chunks);
                    }
                    else {
                        if (frame.opcode !== frames.WebSocketFrameType.CONTINUATION) {
                            return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                        }
                    }
                    pending_chunks.push(frame.payload);
                    if (frame.final === 1) {
                        let buffer = Buffer.concat(pending_chunks);
                        this.pending_chunks.delete(connection_id);
                        this.router.route("message", {
                            connection_id,
                            connection_url,
                            buffer
                        });
                    }
                }
                else {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
            }
            else {
                if (frame.final !== 1) {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.payload.length > 125) {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.opcode === frames.WebSocketFrameType.CLOSE) {
                    if (this.states.get(connection_id) === shared.ReadyState.CLOSING) {
                        socket.end();
                        return;
                    }
                    else {
                        socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { masked: 0 })), () => {
                            return socket.end();
                        });
                    }
                }
                else if (frame.opcode === frames.WebSocketFrameType.PING) {
                    socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { opcode: 0x0A, masked: 0 })));
                }
                else if (frame.opcode === frames.WebSocketFrameType.PONG) {
                }
                else {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
            }
        }
        addEventListener(type, listener) {
            return this.router.addObserver(type, listener);
        }
        broadcast(payload) {
            for (let [connection_id, socket] of this.connections) {
                if (this.states.get(connection_id) === shared.ReadyState.OPEN) {
                    this.send(connection_id, payload);
                }
            }
        }
        close(connection_id, status) {
            if (this.states.get(connection_id) !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            const socket = this.connections.value(connection_id);
            if (is.absent(socket)) {
                throw "Connection with id \"" + connection_id + "\" has no socket!";
            }
            let payload = Buffer.alloc(0);
            if (is.present(status)) {
                payload = Buffer.concat([Buffer.alloc(2), Buffer.from("Connection closed by server.")]);
                payload.writeUInt16BE(status, 0);
            }
            let frame = frames.encodeFrame({
                final: 1,
                reserved1: 0,
                reserved2: 0,
                reserved3: 0,
                opcode: frames.WebSocketFrameType.CLOSE,
                masked: 0,
                payload: payload
            });
            socket.write(frame);
            this.states.set(connection_id, shared.ReadyState.CLOSING);
        }
        getRequestHandler() {
            return (request, response) => {
                let socket = request.socket;
                let connection_id = this.connections.key(socket);
                if (is.present(connection_id)) {
                    response.writeHead(400);
                    return response.end();
                }
                let major = request.httpVersionMajor;
                let minor = request.httpVersionMinor;
                if (major < 1 || (major === 1 && minor < 1)) {
                    response.writeHead(400);
                    return response.end();
                }
                let method = request.method;
                if (method !== "GET") {
                    response.writeHead(400);
                    return response.end();
                }
                let host = utils.getHeader(request, "Host");
                if (is.absent(host)) {
                    response.writeHead(400);
                    return response.end();
                }
                let upgrade = utils.getHeader(request, "Upgrade");
                if (is.absent(upgrade) || upgrade.toLowerCase() !== "websocket") {
                    response.writeHead(400);
                    return response.end();
                }
                let connection = utils.getHeader(request, "Connection");
                if (is.absent(connection) || connection.toLowerCase() !== "upgrade") {
                    response.writeHead(400);
                    return response.end();
                }
                let key = utils.getHeader(request, "Sec-WebSocket-Key");
                if (is.absent(key) || Buffer.from(key, "base64").length !== 16) {
                    response.writeHead(400);
                    return response.end();
                }
                let version = utils.getHeader(request, "Sec-WebSocket-Version");
                if (version !== "13") {
                    response.writeHead(426, {
                        "Sec-WebSocket-Version": "13"
                    });
                    return response.end();
                }
                let accept = libcrypto.createHash("sha1")
                    .update(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")
                    .digest("base64");
                response.writeHead(101, {
                    "Upgrade": "websocket",
                    "Connection": "Upgrade",
                    "Sec-WebSocket-Accept": accept
                });
                return response.end(() => {
                    let connection_id = libcrypto.randomBytes(16).toString("hex");
                    let connection_url = makeConnectionUrl(request);
                    let buffer = Buffer.alloc(0);
                    socket.on("data", (chunk) => {
                        buffer = Buffer.concat([buffer, chunk]);
                        while (true) {
                            try {
                                let state = {
                                    buffer,
                                    offset: 0
                                };
                                let frame = frames.decodeFrame(state);
                                this.onFrame(connection_id, connection_url, socket, frame);
                                buffer = buffer.slice(state.offset);
                            }
                            catch (error) {
                                break;
                            }
                        }
                    });
                    socket.on("close", () => {
                        this.connections.remove(connection_id);
                        this.states.delete(connection_id);
                        this.router.route("disconnect", {
                            connection_id,
                            connection_url
                        });
                    });
                    socket.setTimeout(0);
                    this.connections.add(connection_id, socket);
                    this.states.set(connection_id, shared.ReadyState.OPEN);
                    this.router.route("connect", {
                        connection_id,
                        connection_url
                    });
                });
            };
        }
        removeEventListener(type, listener) {
            return this.router.removeObserver(type, listener);
        }
        send(connection_id, payload) {
            if (this.states.get(connection_id) !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            let socket = this.connections.value(connection_id);
            if (is.absent(socket)) {
                throw "Connection with id \"" + connection_id + "\" has no socket!";
            }
            let final = 1;
            let reserved1 = 0;
            let reserved2 = 0;
            let reserved3 = 0;
            let opcode = frames.WebSocketFrameType.BINARY;
            let masked = 0;
            if (!(payload instanceof Buffer)) {
                payload = Buffer.from(payload, "utf8");
                opcode = frames.WebSocketFrameType.TEXT;
            }
            let frame = frames.encodeFrame({
                final,
                reserved1,
                reserved2,
                reserved3,
                opcode,
                masked,
                payload
            });
            socket.write(frame);
        }
    }
    exports.WebSocketServer = WebSocketServer;
});
define("node_modules/@joelek/ts-sockets/dist/lib/index", ["require", "exports", "node_modules/@joelek/ts-sockets/dist/lib/client", "node_modules/@joelek/ts-sockets/dist/lib/frames", "node_modules/@joelek/ts-sockets/dist/lib/server", "node_modules/@joelek/ts-sockets/dist/lib/shared", "node_modules/@joelek/ts-sockets/dist/lib/client", "node_modules/@joelek/ts-sockets/dist/lib/server"], function (require, exports, client, frames, server, shared, client_1, server_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shared = exports.server = exports.frames = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketServer = exports.WebSocketClient = exports.shared = exports.server = exports.frames = exports.client = void 0;
    exports.client = client;
    exports.frames = frames;
    exports.server = server;
    exports.shared = shared;
    Object.defineProperty(exports, "WebSocketClient", { enumerable: true, get: function () { return client_1.WebSocketClient; } });
    Object.defineProperty(exports, "WebSocketServer", { enumerable: true, get: function () { return server_1.WebSocketServer; } });
});
define("build/typesockets/server", ["require", "exports", "node_modules/@joelek/ts-stdlib/dist/lib/index", "node_modules/@joelek/ts-sockets/dist/lib/index", "build/typesockets/shared"], function (require, exports, stdlib, sockets, shared) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketServer = void 0;
    class TypeSocketServer {
        router;
        serializer;
        socket;
        debug;
        constructor(guards, debug = false) {
            this.router = new stdlib.routing.NamespacedMessageRouter();
            this.serializer = new shared.Serializer(guards);
            this.socket = new sockets.WebSocketServer();
            this.debug = debug;
            this.socket.addEventListener("connect", (message) => {
                let connection_id = message.connection_id;
                let connection_url = message.connection_url;
                this.router.route("sys", "connect", {
                    connection_id,
                    connection_url
                });
            });
            this.socket.addEventListener("disconnect", (message) => {
                let connection_id = message.connection_id;
                let connection_url = message.connection_url;
                this.router.route("sys", "disconnect", {
                    connection_id,
                    connection_url
                });
            });
            this.socket.addEventListener("message", (message) => {
                let connection_id = message.connection_id;
                let connection_url = message.connection_url;
                let payload = message.buffer.toString();
                try {
                    this.serializer.deserialize(payload, (type, data, id) => {
                        if (this.debug) {
                            console.log(`${connection_id} -> ${type}`);
                        }
                        this.router.route("sys", "message", {
                            connection_id,
                            connection_url,
                            id,
                            type,
                            data
                        });
                        this.router.route("app", type, {
                            connection_id,
                            connection_url,
                            id,
                            data
                        });
                    });
                }
                catch (error) {
                    if (this.debug) {
                        console.log(error);
                    }
                }
            });
        }
        addEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        broadcast(type, data) {
            let payload = this.serializer.serialize(type, data);
            this.socket.broadcast(payload);
        }
        close(connection_id) {
            this.socket.close(connection_id);
        }
        getRequestHandler() {
            return this.socket.getRequestHandler();
        }
        removeEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        respond(message, type, data) {
            let payload = this.serializer.serialize(type, data, message.id);
            if (this.debug) {
                console.log(`${message.connection_id} <- ${type}`);
            }
            try {
                this.socket.send(message.connection_id, payload);
            }
            catch (error) {
                if (this.debug) {
                    console.log(error);
                }
            }
        }
        send(type, connection_ids, data) {
            let payload = this.serializer.serialize(type, data);
            for (let connection_id of Array.isArray(connection_ids) ? connection_ids : [connection_ids]) {
                if (this.debug) {
                    console.log(`${connection_id} <- ${type}`);
                }
                try {
                    this.socket.send(connection_id, payload);
                }
                catch (error) {
                    if (this.debug) {
                        console.log(error);
                    }
                }
            }
        }
    }
    exports.TypeSocketServer = TypeSocketServer;
    ;
});
define("build/typesockets/index", ["require", "exports", "build/typesockets/client", "build/typesockets/server", "build/typesockets/shared", "build/typesockets/client", "build/typesockets/server"], function (require, exports, client, server, shared, client_1, server_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shared = exports.server = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketServer = exports.TypeSocketClient = exports.shared = exports.server = exports.client = void 0;
    exports.client = client;
    exports.server = server;
    exports.shared = shared;
    Object.defineProperty(exports, "TypeSocketClient", { enumerable: true, get: function () { return client_1.TypeSocketClient; } });
    Object.defineProperty(exports, "TypeSocketServer", { enumerable: true, get: function () { return server_1.TypeSocketServer; } });
});
define("build/player/server", ["require", "exports", "url", "build/server/auth", "build/is", "build/observers/index", "build/player/schema/index", "build/typesockets/index", "build/database/atlas"], function (require, exports, liburl, auth, is, observers, schema, typesockets, atlas) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextServer = void 0;
    function getQuery(url, key) {
        let values = url.query[key] ?? [];
        if (Array.isArray(values)) {
            return values;
        }
        else {
            return [values];
        }
    }
    function makeDevice(connection_id, connection_url) {
        let url = liburl.parse(connection_url, true);
        let protocol = getQuery(url, "protocol").pop() ?? "";
        let name = getQuery(url, "name").pop() ?? "";
        let type = getQuery(url, "type").pop() ?? "";
        return {
            id: connection_id,
            protocol: protocol,
            name: name,
            type: type
        };
    }
    class ContextServer {
        chromecasts;
        tss;
        tokens = new Map();
        sessions = new Map();
        async getExistingSession(queue, connection_id, callback) {
            let token = this.tokens.get(connection_id);
            if (is.present(token)) {
                let user_id = await auth.getUserId(queue, token);
                let session = this.sessions.get(user_id);
                if (is.present(session)) {
                    callback(session);
                }
            }
        }
        getSession(user_id) {
            let existingSession = this.sessions.get(user_id);
            if (is.present(existingSession)) {
                return existingSession;
            }
            const session = {
                playback: false,
                devices: new observers.ObservableClass(new Array())
            };
            let allDevices = new observers.ObservableClass([]);
            {
                let computer = () => {
                    let devices = session.devices.getState();
                    let chromecasts = this.chromecasts.getState().filter((chromecast) => {
                        return is.absent(devices.find((device) => {
                            return device.id === chromecast.id;
                        }));
                    });
                    allDevices.updateState([...devices, ...chromecasts]);
                };
                session.devices.addObserver(computer);
                this.chromecasts.addObserver(computer);
            }
            allDevices.addObserver((allDevices) => {
                this.tss.send("SetDevices", session.devices.getState().map((device) => {
                    return device.id;
                }), {
                    devices: allDevices
                });
            });
            session.devices.addObserver((devices) => {
                this.updateProgress(session);
            });
            session.devices.addObserver((devices) => {
                let deviceWasLost = is.absent(devices.find((device) => {
                    return device.id === session.device?.id;
                }));
                if (deviceWasLost) {
                    this.updateProgress(session);
                    session.playback = false;
                    this.tss.send("SetPlayback", devices.map((device) => {
                        return device.id;
                    }), {
                        playback: session.playback
                    });
                    session.device = undefined;
                    this.tss.send("SetDevice", devices.map((device) => {
                        return device.id;
                    }), {
                        device: session.device
                    });
                }
            });
            this.sessions.set(user_id, session);
            return session;
        }
        async revokeAuthentication(queue, connection_id) {
            let token = this.tokens.get(connection_id);
            this.tokens.delete(connection_id);
            if (is.present(token)) {
                let user_id = await auth.getUserId(queue, token);
                let session = this.sessions.get(user_id);
                if (is.present(session)) {
                    let devices = session.devices;
                    devices.updateState(devices.getState().filter((device) => {
                        return device.id !== connection_id;
                    }));
                }
            }
        }
        updateProgress(session) {
            let now = Date.now();
            if (session.playback) {
                if (is.present(session.progress) && is.present(session.progressTimestamp)) {
                    session.progress += (now - session.progressTimestamp) / 1000;
                }
            }
            session.progressTimestamp = now;
        }
        constructor() {
            this.chromecasts = new observers.ObservableClass([]);
            this.tss = new typesockets.TypeSocketServer(schema.messages.Autoguard.Guards);
            this.tss.addEventListener("sys", "connect", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
                console.log("connect: " + message.connection_url);
                let device = makeDevice(message.connection_id, message.connection_url);
                this.tss.send("SetLocalDevice", message.connection_id, {
                    device
                });
                if (device.protocol === "cast" || device.protocol === "airplay") {
                    this.chromecasts.updateState([...this.chromecasts.getState(), device]);
                }
            }));
            this.tss.addEventListener("sys", "disconnect", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
                console.log("disconnect: " + message.connection_url);
                let device = makeDevice(message.connection_id, message.connection_url);
                await this.revokeAuthentication(queue, message.connection_id);
                if (device.protocol === "cast" || device.protocol === "airplay") {
                    this.chromecasts.updateState(this.chromecasts.getState().filter((chromecast) => {
                        return chromecast.id !== device.id;
                    }));
                }
            }));
            this.tss.addEventListener("app", "SetToken", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
                await this.revokeAuthentication(queue, message.connection_id);
                let token = message.data.token;
                if (is.present(token)) {
                    let user_id = await auth.getUserId(queue, token);
                    this.tokens.set(message.connection_id, token);
                    let session = this.getSession(user_id);
                    let device = makeDevice(message.connection_id, message.connection_url);
                    session.devices.updateState([...session.devices.getState(), device]);
                    this.tss.send("SetContext", message.connection_id, {
                        context: session.context
                    });
                    this.tss.send("SetDevice", message.connection_id, {
                        device: session.device
                    });
                    this.tss.send("SetIndex", message.connection_id, {
                        index: session.index
                    });
                    this.tss.send("SetPlayback", message.connection_id, {
                        playback: session.playback
                    });
                    this.tss.send("SetProgress", message.connection_id, {
                        progress: session.progress
                    });
                    this.tss.send("SetToken", message.connection_id, {
                        token: token
                    });
                }
            }));
            this.tss.addEventListener("app", "SetContext", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
                await this.getExistingSession(queue, message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    session.index = undefined;
                    this.tss.send("SetIndex", session.devices.getState().map((device) => {
                        return device.id;
                    }), {
                        index: session.index
                    });
                    session.context = message.data.context;
                    this.tss.send("SetContext", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            }));
            this.tss.addEventListener("app", "SetDevice", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
                await this.getExistingSession(queue, message.connection_id, (session) => {
                    this.updateProgress(session);
                    this.tss.send("SetProgress", session.devices.getState().map((device) => {
                        return device.id;
                    }), {
                        progress: session.progress
                    });
                    session.device = message.data.device;
                    this.tss.send("SetDevice", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                    if (is.present(session.device)) {
                        this.tss.send("SetToken", session.device.id, {
                            token: this.tokens.get(message.connection_id)
                        });
                    }
                });
            }));
            this.tss.addEventListener("app", "SetIndex", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
                await this.getExistingSession(queue, message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    session.progress = is.present(message.data.index) ? 0 : undefined;
                    session.progressTimestamp = Date.now();
                    this.tss.send("SetProgress", session.devices.getState().map((device) => {
                        return device.id;
                    }), {
                        progress: session.progress
                    });
                    session.index = message.data.index;
                    this.tss.send("SetIndex", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            }));
            this.tss.addEventListener("app", "SetPlayback", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
                await this.getExistingSession(queue, message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    this.updateProgress(session);
                    session.playback = message.data.playback;
                    this.tss.send("SetPlayback", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            }));
            this.tss.addEventListener("app", "SetProgress", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
                await this.getExistingSession(queue, message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    session.progress = message.data.progress;
                    session.progressTimestamp = Date.now();
                    this.tss.send("SetProgress", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            }));
        }
        getRequestHandler() {
            return this.tss.getRequestHandler();
        }
    }
    exports.ContextServer = ContextServer;
});
define("build/player/index", ["require", "exports", "build/player/client", "build/player/server", "build/player/schema/index"], function (require, exports, client, server, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    exports.client = client;
    exports.server = server;
    exports.schema = schema;
});
define("build/playlists/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/api/schema/objects/index", "build/api/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.UpdatePlaylistItem = exports.UpdatePlaylistItemResponse = exports.UpdatePlaylistItemRequest = exports.DeletePlaylistItem = exports.DeletePlaylistItemResponse = exports.DeletePlaylistItemRequest = exports.CreatePlaylistItem = exports.CreatePlaylistItemResponse = exports.CreatePlaylistItemRequest = exports.UpdatePlaylist = exports.UpdatePlaylistResponse = exports.UpdatePlaylistRequest = exports.DeletePlaylist = exports.DeletePlaylistResponse = exports.DeletePlaylistRequest = exports.CreatePlaylist = exports.CreatePlaylistResponse = exports.CreatePlaylistRequest = exports.PermissionsResponse = exports.PermissionsRequest = exports.SetToken = void 0;
    exports.SetToken = autoguard.guards.Object.of({}, {
        "token": autoguard.guards.String
    });
    exports.PermissionsRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String
        }, {})
    }, {});
    exports.PermissionsResponse = autoguard.guards.Object.of({
        "permissions": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("read"), autoguard.guards.StringLiteral.of("write"))
    }, {});
    exports.CreatePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "title": autoguard.guards.String,
            "description": autoguard.guards.String
        }, {})
    }, {});
    exports.CreatePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String),
        "playlist_id": autoguard.guards.String
    }, {});
    exports.CreatePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    }, {});
    exports.DeletePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String
        }, {})
    }, {});
    exports.DeletePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.DeletePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    }, {});
    exports.UpdatePlaylistRequest = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String,
            "title": autoguard.guards.String,
            "description": autoguard.guards.String
        }, {})
    }, {});
    exports.UpdatePlaylistResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.UpdatePlaylist = autoguard.guards.Object.of({
        "playlist": autoguard.guards.Reference.of(() => objects_1.PlaylistBase)
    }, {});
    exports.CreatePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_id": autoguard.guards.String,
            "track_id": autoguard.guards.String
        }, {})
    }, {});
    exports.CreatePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String),
        "playlist_item_id": autoguard.guards.String
    }, {});
    exports.CreatePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    }, {});
    exports.DeletePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_item_id": autoguard.guards.String
        }, {})
    }, {});
    exports.DeletePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.DeletePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    }, {});
    exports.UpdatePlaylistItemRequest = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Object.of({
            "playlist_item_id": autoguard.guards.String,
            "number": autoguard.guards.Number
        }, {})
    }, {});
    exports.UpdatePlaylistItemResponse = autoguard.guards.Object.of({
        "errors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.UpdatePlaylistItem = autoguard.guards.Object.of({
        "playlist_item": autoguard.guards.Reference.of(() => objects_2.PlaylistItemBase)
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "SetToken": autoguard.guards.Reference.of(() => exports.SetToken),
            "PermissionsRequest": autoguard.guards.Reference.of(() => exports.PermissionsRequest),
            "PermissionsResponse": autoguard.guards.Reference.of(() => exports.PermissionsResponse),
            "CreatePlaylistRequest": autoguard.guards.Reference.of(() => exports.CreatePlaylistRequest),
            "CreatePlaylistResponse": autoguard.guards.Reference.of(() => exports.CreatePlaylistResponse),
            "CreatePlaylist": autoguard.guards.Reference.of(() => exports.CreatePlaylist),
            "DeletePlaylistRequest": autoguard.guards.Reference.of(() => exports.DeletePlaylistRequest),
            "DeletePlaylistResponse": autoguard.guards.Reference.of(() => exports.DeletePlaylistResponse),
            "DeletePlaylist": autoguard.guards.Reference.of(() => exports.DeletePlaylist),
            "UpdatePlaylistRequest": autoguard.guards.Reference.of(() => exports.UpdatePlaylistRequest),
            "UpdatePlaylistResponse": autoguard.guards.Reference.of(() => exports.UpdatePlaylistResponse),
            "UpdatePlaylist": autoguard.guards.Reference.of(() => exports.UpdatePlaylist),
            "CreatePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.CreatePlaylistItemRequest),
            "CreatePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.CreatePlaylistItemResponse),
            "CreatePlaylistItem": autoguard.guards.Reference.of(() => exports.CreatePlaylistItem),
            "DeletePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.DeletePlaylistItemRequest),
            "DeletePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.DeletePlaylistItemResponse),
            "DeletePlaylistItem": autoguard.guards.Reference.of(() => exports.DeletePlaylistItem),
            "UpdatePlaylistItemRequest": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItemRequest),
            "UpdatePlaylistItemResponse": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItemResponse),
            "UpdatePlaylistItem": autoguard.guards.Reference.of(() => exports.UpdatePlaylistItem)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/playlists/client", ["require", "exports", "build/observers/index", "build/jsondb/index", "build/playlists/schema/messages/index", "build/typesockets/client"], function (require, exports, observers, jsondb, messages, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaylistsClient = void 0;
    class PlaylistsClient {
        tsc;
        token = new observers.ObservableClass(undefined);
        online = new observers.ObservableClass(false);
        playlists = new observers.ArrayObservable(new Array());
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.tsc = new typesockets.TypeSocketClient(url, factory, messages.Autoguard.Guards);
            this.tsc.addEventListener("sys", "connect", () => {
                this.online.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.online.updateState(false);
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.online, this.token);
            this.tsc.addEventListener("app", "CreatePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
                let playlist = {
                    ...message.playlist,
                    items: new Array(),
                    affinity: 0
                };
                this.playlists.append(new observers.ObservableClass(playlist));
            });
            this.tsc.addEventListener("app", "DeletePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylist", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        playlist.updateState({
                            ...state,
                            ...message.playlist
                        });
                    }
                }
            });
            this.tsc.addEventListener("app", "CreatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        items.push(message.playlist_item);
                        let additions = 1;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "DeletePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        let additions = 0;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let old_index = state.items.findIndex((item) => item.playlist_item_id === message.playlist_item.playlist_item_id);
                        if (old_index >= 0) {
                            let new_index = message.playlist_item.number - 1;
                            if (new_index > old_index) {
                                for (let i = old_index + 1; i < new_index; i++) {
                                    state.items[i].number -= 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            else if (new_index < old_index) {
                                for (let i = new_index; i < old_index; i++) {
                                    state.items[i].number += 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            state.items[new_index] = {
                                ...state.items[new_index],
                                ...message.playlist_item
                            };
                            playlist.updateState({
                                ...state
                            });
                        }
                    }
                }
            });
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        isOnline() {
            return this.online.getState();
        }
        getPermissions(request) {
            return this.tsc.request("PermissionsRequest", "PermissionsResponse", request);
        }
        createPlaylist(request) {
            return this.tsc.request("CreatePlaylistRequest", "CreatePlaylistResponse", request);
        }
        deletePlaylist(request) {
            return this.tsc.request("DeletePlaylistRequest", "DeletePlaylistResponse", request);
        }
        updatePlaylist(request) {
            return this.tsc.request("UpdatePlaylistRequest", "UpdatePlaylistResponse", request);
        }
        createPlaylistItem(request) {
            return this.tsc.request("CreatePlaylistItemRequest", "CreatePlaylistItemResponse", request);
        }
        deletePlaylistItem(request) {
            return this.tsc.request("DeletePlaylistItemRequest", "DeletePlaylistItemResponse", request);
        }
        updatePlaylistItem(request) {
            return this.tsc.request("UpdatePlaylistItemRequest", "UpdatePlaylistItemResponse", request);
        }
        close() {
            this.tsc.close();
        }
        reconnect() {
            this.tsc.reconnect();
        }
    }
    exports.PlaylistsClient = PlaylistsClient;
    ;
});
define("build/playlists/schema/objects/index", ["require", "exports"], function (require, exports) {
    "use strict";
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = void 0;
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {};
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/playlists/schema/index", ["require", "exports", "build/playlists/schema/messages/index", "build/playlists/schema/objects/index"], function (require, exports, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    exports.messages = messages;
    exports.objects = objects;
});
define("build/api/schema/index", ["require", "exports", "build/api/schema/api/index", "build/api/schema/messages/index", "build/api/schema/objects/index"], function (require, exports, api, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = exports.api = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = exports.api = void 0;
    exports.api = api;
    exports.messages = messages;
    exports.objects = objects;
});
define("build/api/index", ["require", "exports", "build/api/handler", "build/api/schema/index"], function (require, exports, handler, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.handler = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.handler = void 0;
    exports.handler = handler;
    exports.schema = schema;
});
define("build/playlists/server", ["require", "exports", "crypto", "build/server/auth", "build/is", "build/playlists/schema/index", "build/typesockets/index", "build/api/index", "build/database/atlas", "build/utils"], function (require, exports, libcrypto, auth, is, schema, typesockets, api, atlas, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaylistsServer = void 0;
    class PlaylistsServer {
        tss;
        tokens = new Map();
        sessions = new Map();
        getOrCreateSession(user_id) {
            let session = this.sessions.get(user_id);
            if (is.present(session)) {
                return session;
            }
            session = {
                connections: new Set()
            };
            this.sessions.set(user_id, session);
            return session;
        }
        async revokeAuthentication(queue, connection_id) {
            let token = this.tokens.get(connection_id);
            this.tokens.delete(connection_id);
            if (is.present(token)) {
                let user_id = await auth.getUserId(queue, token);
                let session = this.sessions.get(user_id);
                if (is.present(session)) {
                    let connections = session.connections;
                    connections.delete(connection_id);
                }
            }
        }
        constructor() {
            this.tss = new typesockets.TypeSocketServer(schema.messages.Autoguard.Guards);
            this.tss.addEventListener("sys", "connect", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
            }));
            this.tss.addEventListener("sys", "disconnect", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
                await this.revokeAuthentication(queue, message.connection_id);
            }));
            this.tss.addEventListener("app", "SetToken", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
                await this.revokeAuthentication(queue, message.connection_id);
                let token = message.data.token;
                if (is.present(token)) {
                    let user_id = await auth.getUserId(queue, token);
                    this.tokens.set(message.connection_id, token);
                    let session = this.getOrCreateSession(user_id);
                    session.connections.add(message.connection_id);
                    for (let playlist of await atlas.links.user_playlists.filter(queue, { user_id: (0, utils_1.binid)(user_id) })) {
                        this.tss.send("CreatePlaylist", message.connection_id, {
                            playlist: await api.handler.lookupPlaylistBase(queue, (0, utils_1.hexid)(playlist.playlist_id), user_id)
                        });
                        for (let playlist_item of await atlas.links.playlist_playlist_items.filter(queue, playlist)) {
                            this.tss.send("CreatePlaylistItem", message.connection_id, {
                                playlist_item: await api.handler.lookupPlaylistItemBase(queue, (0, utils_1.hexid)(playlist_item.playlist_item_id), user_id)
                            });
                        }
                    }
                }
            }));
            this.tss.addEventListener("app", "PermissionsRequest", (message) => atlas.transactionManager.enqueueReadableTransaction(async (queue) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = await auth.getUserId(queue, token);
                    let playlist = await atlas.stores.playlists.lookup(queue, { playlist_id: (0, utils_1.binid)(message.data.playlist.playlist_id) });
                    if ((0, utils_1.hexid)(playlist.user_id) === user_id) {
                        this.tss.respond(message, "PermissionsResponse", {
                            permissions: "write"
                        });
                    }
                    else {
                        this.tss.respond(message, "PermissionsResponse", {
                            permissions: "read"
                        });
                    }
                }
            }));
            this.tss.addEventListener("app", "CreatePlaylistRequest", (message) => atlas.transactionManager.enqueueWritableTransaction(async (queue) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = await auth.getUserId(queue, token);
                    let errors = new Array();
                    let title = message.data.playlist.title;
                    if (Buffer.from(title).length >= 256) {
                        errors.push(`The playlist title is too long!`);
                    }
                    let description = message.data.playlist.description;
                    if (Buffer.from(description).length >= 256) {
                        errors.push(`The playlist description is too long!`);
                    }
                    let playlist_id = libcrypto.randomBytes(8).toString("hex");
                    this.tss.respond(message, "CreatePlaylistResponse", {
                        errors,
                        playlist_id
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let playlist = {
                        playlist_id: (0, utils_1.binid)(playlist_id),
                        title: title,
                        description: description,
                        user_id: (0, utils_1.binid)(user_id),
                        affinity: 0
                    };
                    await atlas.stores.playlists.insert(queue, playlist);
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("CreatePlaylist", Array.from(session.connections), {
                        playlist: await api.handler.lookupPlaylistBase(queue, (0, utils_1.hexid)(playlist.playlist_id), user_id)
                    });
                }
            }));
            this.tss.addEventListener("app", "DeletePlaylistRequest", (message) => atlas.transactionManager.enqueueWritableTransaction(async (queue) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = await auth.getUserId(queue, token);
                    let errors = new Array();
                    let playlist_id = message.data.playlist.playlist_id;
                    let playlist = await atlas.stores.playlists.lookup(queue, { playlist_id: (0, utils_1.binid)(message.data.playlist.playlist_id) });
                    if ((0, utils_1.hexid)(playlist.user_id) !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    this.tss.respond(message, "DeletePlaylistResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("DeletePlaylist", Array.from(session.connections), {
                        playlist: await api.handler.lookupPlaylistBase(queue, (0, utils_1.hexid)(playlist.playlist_id), user_id)
                    });
                    await atlas.stores.playlists.remove(queue, playlist);
                }
            }));
            this.tss.addEventListener("app", "UpdatePlaylistRequest", (message) => atlas.transactionManager.enqueueWritableTransaction(async (queue) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = await auth.getUserId(queue, token);
                    let errors = new Array();
                    let playlist_id = message.data.playlist.playlist_id;
                    let playlist = await atlas.stores.playlists.lookup(queue, { playlist_id: (0, utils_1.binid)(message.data.playlist.playlist_id) });
                    if ((0, utils_1.hexid)(playlist.user_id) !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    let title = message.data.playlist.title;
                    if (Buffer.from(title).length >= 256) {
                        errors.push(`The playlist title is too long!`);
                    }
                    let description = message.data.playlist.description;
                    if (Buffer.from(description).length >= 256) {
                        errors.push(`The playlist description is too long!`);
                    }
                    this.tss.respond(message, "UpdatePlaylistResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    await atlas.stores.playlists.update(queue, {
                        ...playlist,
                        ...message.data.playlist,
                        playlist_id: (0, utils_1.binid)(playlist_id)
                    });
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("UpdatePlaylist", Array.from(session.connections), {
                        playlist: await api.handler.lookupPlaylistBase(queue, (0, utils_1.hexid)(playlist.playlist_id), user_id)
                    });
                }
            }));
            this.tss.addEventListener("app", "CreatePlaylistItemRequest", (message) => atlas.transactionManager.enqueueWritableTransaction(async (queue) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = await auth.getUserId(queue, token);
                    let errors = new Array();
                    let playlist_id = message.data.playlist_item.playlist_id;
                    let playlist = await atlas.stores.playlists.lookup(queue, { playlist_id: (0, utils_1.binid)(message.data.playlist_item.playlist_id) });
                    if ((0, utils_1.hexid)(playlist.user_id) !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    let track_id = message.data.playlist_item.track_id;
                    let track = await atlas.stores.tracks.lookup(queue, { track_id: (0, utils_1.binid)(track_id) });
                    let playlist_item_id = libcrypto.randomBytes(8).toString("hex");
                    this.tss.respond(message, "CreatePlaylistItemResponse", {
                        errors,
                        playlist_item_id
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let playlist_items = await atlas.links.playlist_playlist_items.filter(queue, playlist);
                    let playlist_item = {
                        playlist_item_id: (0, utils_1.binid)(playlist_item_id),
                        playlist_id: (0, utils_1.binid)(playlist_id),
                        track_id: (0, utils_1.binid)(track_id),
                        number: (playlist_items.pop()?.number ?? 0) + 1,
                        added_ms: Date.now()
                    };
                    await atlas.stores.playlist_items.insert(queue, playlist_item);
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("CreatePlaylistItem", Array.from(session.connections), {
                        playlist_item: await api.handler.lookupPlaylistItemBase(queue, (0, utils_1.hexid)(playlist_item.playlist_item_id), user_id)
                    });
                }
            }));
            this.tss.addEventListener("app", "DeletePlaylistItemRequest", (message) => atlas.transactionManager.enqueueWritableTransaction(async (queue) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = await auth.getUserId(queue, token);
                    let errors = new Array();
                    let playlist_item_id = message.data.playlist_item.playlist_item_id;
                    let playlist_item = await atlas.stores.playlist_items.lookup(queue, { playlist_item_id: (0, utils_1.binid)(playlist_item_id) });
                    let playlist = await atlas.stores.playlists.lookup(queue, playlist_item);
                    if ((0, utils_1.hexid)(playlist.user_id) !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    this.tss.respond(message, "DeletePlaylistItemResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let number = playlist_item.number;
                    let playlist_items = await atlas.links.playlist_playlist_items.filter(queue, playlist);
                    for (let playlist_item of playlist_items) {
                        if (playlist_item.number > number) {
                            playlist_item.number -= 1;
                            await atlas.stores.playlist_items.update(queue, playlist_item);
                        }
                    }
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("DeletePlaylistItem", Array.from(session.connections), {
                        playlist_item: await api.handler.lookupPlaylistItemBase(queue, (0, utils_1.hexid)(playlist_item.playlist_item_id), user_id)
                    });
                    await atlas.stores.playlist_items.remove(queue, playlist_item);
                }
            }));
            this.tss.addEventListener("app", "UpdatePlaylistItemRequest", (message) => atlas.transactionManager.enqueueWritableTransaction(async (queue) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = await auth.getUserId(queue, token);
                    let errors = new Array();
                    let playlist_item_id = message.data.playlist_item.playlist_item_id;
                    let playlist_item = await atlas.stores.playlist_items.lookup(queue, { playlist_item_id: (0, utils_1.binid)(playlist_item_id) });
                    let playlist = await atlas.stores.playlists.lookup(queue, playlist_item);
                    if ((0, utils_1.hexid)(playlist.user_id) !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    let number = message.data.playlist_item.number;
                    let playlist_items = await atlas.links.playlist_playlist_items.filter(queue, playlist);
                    if (number < 1 || number > playlist_items.length) {
                        errors.push(`Expected a position between ${1} and ${playlist_items.length} (${number})!`);
                    }
                    this.tss.respond(message, "UpdatePlaylistItemResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let old_index = number - 1;
                    let new_index = message.data.playlist_item.number - 1;
                    if (new_index > old_index) {
                        for (let i = old_index + 1; i < new_index; i++) {
                            let playlist_item = playlist_items[i];
                            playlist_item.number -= 1;
                            await atlas.stores.playlist_items.update(queue, playlist_item);
                        }
                    }
                    else if (new_index < old_index) {
                        for (let i = new_index; i < old_index; i++) {
                            let playlist_item = playlist_items[i];
                            playlist_item.number += 1;
                            await atlas.stores.playlist_items.update(queue, playlist_item);
                        }
                    }
                    playlist_item.number = number;
                    await atlas.stores.playlist_items.update(queue, {
                        ...playlist_item,
                        ...message.data.playlist_item,
                        playlist_item_id: (0, utils_1.binid)(message.data.playlist_item.playlist_item_id)
                    });
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("UpdatePlaylistItem", Array.from(session.connections), {
                        playlist_item: await api.handler.lookupPlaylistItemBase(queue, (0, utils_1.hexid)(playlist_item.playlist_item_id), user_id)
                    });
                }
            }));
        }
        getRequestHandler() {
            return this.tss.getRequestHandler();
        }
    }
    exports.PlaylistsServer = PlaylistsServer;
    ;
});
define("build/playlists/index", ["require", "exports", "build/playlists/client", "build/playlists/server", "build/playlists/schema/index"], function (require, exports, client, server, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    exports.client = client;
    exports.server = server;
    exports.schema = schema;
});
define("build/chromecast/protobuf", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeOptionalBuffer = exports.parseOptionalBuffer = exports.serializeRequiredBuffer = exports.parseRequiredBuffer = exports.serializeOptionalString = exports.parseOptionalString = exports.serializeRequiredString = exports.parseRequiredString = exports.serializeRequiredEnum = exports.parseRequiredEnum = exports.parseFields = exports.serializeField = exports.parseField = exports.serializeKey = exports.parseKey = exports.makeUInt64LE = exports.serializeVarint = exports.parseVarint = exports.WireType = exports.readBytes = exports.numberFromBigInt = void 0;
    function numberFromBigInt(bigint) {
        if (bigint > Number.MAX_SAFE_INTEGER || bigint < Number.MIN_SAFE_INTEGER) {
            throw `Expected a safe integer but got ${bigint}!`;
        }
        return Number(bigint);
    }
    exports.numberFromBigInt = numberFromBigInt;
    ;
    function readBytes(state, length) {
        let remaining = state.buffer.length - state.offset;
        if (length > remaining) {
            throw `Expected to read at most ${remaining} bytes but attempted to read ${length} bytes!`;
        }
        let buffer = state.buffer.slice(state.offset, state.offset + length);
        state.offset += length;
        return buffer;
    }
    exports.readBytes = readBytes;
    ;
    var WireType;
    (function (WireType) {
        WireType[WireType["VARINT"] = 0] = "VARINT";
        WireType[WireType["FIXED_64_BIT"] = 1] = "FIXED_64_BIT";
        WireType[WireType["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
        WireType[WireType["START_GROUP"] = 3] = "START_GROUP";
        WireType[WireType["END_GROUP"] = 4] = "END_GROUP";
        WireType[WireType["FIXED_32_BIT"] = 5] = "FIXED_32_BIT";
    })(WireType = exports.WireType || (exports.WireType = {}));
    ;
    function parseVarint(state) {
        let bytes = Buffer.alloc(10);
        for (let i = 0; i < 10; i++) {
            let byte = state.buffer.readUInt8(state.offset);
            state.offset += 1;
            bytes[i] = byte;
            if ((byte & 0x80) === 0) {
                if (i + 1 === 10) {
                    if ((byte & 0x7E) !== 0) {
                        throw "Expected a varint of at most 64 bits!";
                    }
                }
                let value = BigInt(0);
                for (let j = i; j >= 0; j--) {
                    value = (value << BigInt(7)) | BigInt(bytes[j] & 0x7F);
                }
                let buffer = Buffer.alloc(8);
                buffer.writeBigUInt64LE(value, 0);
                return buffer;
            }
        }
        throw "Expected a varint of at most 10 bytes!";
    }
    exports.parseVarint = parseVarint;
    ;
    function serializeVarint(buffer) {
        let bigint = buffer.readBigUInt64LE(0);
        let result = Buffer.alloc(10);
        for (let i = 0; i < 10; i++) {
            let byte = (bigint & BigInt(0x7F));
            bigint = (bigint >> BigInt(7));
            if (bigint > 0) {
                result.writeUInt8(numberFromBigInt(byte) | 0x80, i);
            }
            else {
                result.writeUInt8(numberFromBigInt(byte) | 0x00, i);
                return result.slice(0, i + 1);
            }
        }
        throw "Expected to serialize at most 10 bytes!";
    }
    exports.serializeVarint = serializeVarint;
    ;
    function makeUInt64LE(number) {
        let buffer = Buffer.alloc(8);
        buffer.writeBigUInt64LE(BigInt(number));
        return buffer;
    }
    exports.makeUInt64LE = makeUInt64LE;
    ;
    function parseKey(state) {
        let bigint = parseVarint(state).readBigUInt64LE(0);
        let field_number = numberFromBigInt(bigint >> BigInt(3));
        let wire_type = numberFromBigInt(bigint & BigInt(0x07));
        return {
            field_number,
            wire_type
        };
    }
    exports.parseKey = parseKey;
    ;
    function serializeKey(key) {
        let bigint = (BigInt(key.field_number) << BigInt(3)) | (BigInt(key.wire_type) & BigInt(0x07));
        let buffer = Buffer.alloc(8);
        buffer.writeBigUInt64LE(bigint, 0);
        return serializeVarint(buffer);
    }
    exports.serializeKey = serializeKey;
    ;
    function parseField(state) {
        let key = parseKey(state);
        if (key.wire_type === WireType.VARINT) {
            let data = parseVarint(state);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.FIXED_64_BIT) {
            let data = readBytes(state, 8);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.LENGTH_DELIMITED) {
            let bigint = parseVarint(state).readBigUInt64LE(0);
            let length = numberFromBigInt(bigint);
            let data = readBytes(state, length);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.START_GROUP) {
            let data = Buffer.alloc(0);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.END_GROUP) {
            let data = Buffer.alloc(0);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.FIXED_32_BIT) {
            let data = readBytes(state, 4);
            return {
                key,
                data
            };
        }
        throw "Expected a recognized wire type!";
    }
    exports.parseField = parseField;
    ;
    function serializeField(field) {
        if (field.key.wire_type === WireType.VARINT) {
            return Buffer.concat([
                serializeKey(field.key),
                serializeVarint(field.data)
            ]);
        }
        if (field.key.wire_type === WireType.FIXED_64_BIT) {
            if (field.data.length !== 8) {
                throw `Expected to serialize exactly 8 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.LENGTH_DELIMITED) {
            let length = Buffer.alloc(8);
            length.writeBigUInt64LE(BigInt(field.data.length));
            return Buffer.concat([
                serializeKey(field.key),
                serializeVarint(length),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.START_GROUP) {
            if (field.data.length !== 0) {
                throw `Expected to serialize exactly 0 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.END_GROUP) {
            if (field.data.length !== 0) {
                throw `Expected to serialize exactly 0 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.FIXED_32_BIT) {
            if (field.data.length !== 4) {
                throw `Expected to serialize exactly 4 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        throw "Expected a recognized wire type!";
    }
    exports.serializeField = serializeField;
    ;
    function parseFields(state) {
        let fields = new Array();
        while (state.offset < state.buffer.length) {
            let field = parseField(state);
            fields.push(field);
        }
        return fields;
    }
    exports.parseFields = parseFields;
    ;
    function parseRequiredEnum(field_number, fields) {
        let candidates = fields.filter((field) => field.key.field_number === field_number);
        if (candidates.length === 0) {
            throw `Expected required field to be present!`;
        }
        let field = candidates[candidates.length - 1];
        let value = numberFromBigInt(field.data.readBigUInt64LE(0));
        return value;
    }
    exports.parseRequiredEnum = parseRequiredEnum;
    ;
    function serializeRequiredEnum(field_number, value) {
        let key = {
            field_number,
            wire_type: WireType.VARINT
        };
        let data = makeUInt64LE(value);
        return serializeField({
            key,
            data
        });
    }
    exports.serializeRequiredEnum = serializeRequiredEnum;
    ;
    function parseRequiredString(field_number, fields) {
        let candidates = fields.filter((field) => field.key.field_number === field_number);
        if (candidates.length === 0) {
            throw `Expected required field to be present!`;
        }
        let field = candidates[candidates.length - 1];
        let value = field.data.toString();
        return value;
    }
    exports.parseRequiredString = parseRequiredString;
    ;
    function serializeRequiredString(field_number, value) {
        let key = {
            field_number,
            wire_type: WireType.LENGTH_DELIMITED
        };
        let data = Buffer.from(value);
        return serializeField({
            key,
            data
        });
    }
    exports.serializeRequiredString = serializeRequiredString;
    ;
    function parseOptionalString(field_number, fields) {
        try {
            return parseRequiredString(field_number, fields);
        }
        catch (error) {
            return undefined;
        }
    }
    exports.parseOptionalString = parseOptionalString;
    ;
    function serializeOptionalString(field_number, value) {
        if (value == null) {
            return Buffer.alloc(0);
        }
        return serializeRequiredString(field_number, value);
    }
    exports.serializeOptionalString = serializeOptionalString;
    ;
    function parseRequiredBuffer(field_number, fields) {
        let candidates = fields.filter((field) => field.key.field_number === field_number);
        if (candidates.length === 0) {
            throw `Expected required field to be present!`;
        }
        let field = candidates[candidates.length - 1];
        let value = field.data;
        return value;
    }
    exports.parseRequiredBuffer = parseRequiredBuffer;
    ;
    function serializeRequiredBuffer(field_number, value) {
        let key = {
            field_number,
            wire_type: WireType.LENGTH_DELIMITED
        };
        let data = value;
        return serializeField({
            key,
            data
        });
    }
    exports.serializeRequiredBuffer = serializeRequiredBuffer;
    ;
    function parseOptionalBuffer(field_number, fields) {
        try {
            return parseRequiredBuffer(field_number, fields);
        }
        catch (error) {
            return undefined;
        }
    }
    exports.parseOptionalBuffer = parseOptionalBuffer;
    ;
    function serializeOptionalBuffer(field_number, value) {
        if (value == null) {
            return Buffer.alloc(0);
        }
        return serializeRequiredBuffer(field_number, value);
    }
    exports.serializeOptionalBuffer = serializeOptionalBuffer;
    ;
});
define("build/chromecast/cast_message", ["require", "exports", "build/chromecast/protobuf"], function (require, exports, protobuf) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeCastMessage = exports.parseCastMessage = exports.PayloadType = exports.ProtocolVersion = void 0;
    var ProtocolVersion;
    (function (ProtocolVersion) {
        ProtocolVersion[ProtocolVersion["CASTV2_1_0"] = 0] = "CASTV2_1_0";
    })(ProtocolVersion = exports.ProtocolVersion || (exports.ProtocolVersion = {}));
    ;
    var PayloadType;
    (function (PayloadType) {
        PayloadType[PayloadType["STRING"] = 0] = "STRING";
        PayloadType[PayloadType["BINARY"] = 1] = "BINARY";
    })(PayloadType = exports.PayloadType || (exports.PayloadType = {}));
    ;
    function parseCastMessage(buffer) {
        let fields = protobuf.parseFields({
            buffer: buffer,
            offset: 0
        });
        let protocol_version = protobuf.parseRequiredEnum(1, fields);
        let source_id = protobuf.parseRequiredString(2, fields);
        let destination_id = protobuf.parseRequiredString(3, fields);
        let namespace = protobuf.parseRequiredString(4, fields);
        let payload_type = protobuf.parseRequiredEnum(5, fields);
        let payload_utf8 = protobuf.parseOptionalString(6, fields);
        let payload_binary = protobuf.parseOptionalBuffer(7, fields);
        return {
            protocol_version,
            source_id,
            destination_id,
            namespace,
            payload_type,
            payload_utf8,
            payload_binary
        };
    }
    exports.parseCastMessage = parseCastMessage;
    ;
    function serializeCastMessage(message) {
        return Buffer.concat([
            protobuf.serializeRequiredEnum(1, message.protocol_version),
            protobuf.serializeRequiredString(2, message.source_id),
            protobuf.serializeRequiredString(3, message.destination_id),
            protobuf.serializeRequiredString(4, message.namespace),
            protobuf.serializeRequiredEnum(5, message.payload_type),
            protobuf.serializeOptionalString(6, message.payload_utf8),
            protobuf.serializeOptionalBuffer(7, message.payload_binary),
        ]);
    }
    exports.serializeCastMessage = serializeCastMessage;
    ;
});
define("build/mdns/index", ["require", "exports", "dgram", "os", "build/is"], function (require, exports, libdgram, libos, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observe = exports.sendDiscoveryPacket = void 0;
    const MDNS_ADDRESS = "224.0.0.251";
    const MDNS_PORT = 5353;
    let map = new Map();
    function parseName(buffer, offset) {
        let labels = new Array();
        while (true) {
            let length = buffer.readUInt8(offset);
            if (length === 0) {
                offset += 1;
                break;
            }
            if (length < 192) {
                offset += 1;
                let label = buffer.slice(offset, offset + length);
                offset += length;
                labels.push(label.toString());
                continue;
            }
            let name = parseName(buffer, buffer.readUInt16BE(offset) & 0x3FFF);
            labels.push(name.labels.join("."));
            offset += 2;
            break;
        }
        return {
            labels: labels,
            offset: offset
        };
    }
    ;
    var Type;
    (function (Type) {
        Type[Type["A"] = 1] = "A";
        Type[Type["PTR"] = 12] = "PTR";
        Type[Type["TXT"] = 16] = "TXT";
        Type[Type["SRV"] = 33] = "SRV";
    })(Type || (Type = {}));
    ;
    function parseQuestion(packet, offset) {
        let name = parseName(packet, offset);
        offset = name.offset;
        let type = packet.readUInt16BE(offset);
        offset += 2;
        let kind = packet.readUInt16BE(offset);
        offset += 2;
        return {
            value: name.labels.join("."),
            type,
            kind,
            offset
        };
    }
    ;
    function parseA(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let a = buffer.readUInt8(data_offset);
        data_offset += 1;
        let b = buffer.readUInt8(data_offset);
        data_offset += 1;
        let c = buffer.readUInt8(data_offset);
        data_offset += 1;
        let d = buffer.readUInt8(data_offset);
        data_offset += 1;
        let ipv4 = `${a}.${b}.${c}.${d}`;
        return {
            ipv4
        };
    }
    function parsePTR(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let to = parseName(buffer, data_offset);
        data_offset = to.offset;
        return {
            to: to.labels.join(".")
        };
    }
    function parseTXT(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let content = parseName(buffer, data_offset);
        return {
            content: content.labels
        };
    }
    function parseSRV(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let priority = buffer.readUInt16BE(data_offset);
        data_offset += 2;
        let weight = buffer.readUInt16BE(data_offset);
        data_offset += 2;
        let port = buffer.readUInt16BE(data_offset);
        data_offset += 2;
        let to = parseName(buffer, data_offset);
        data_offset = to.offset;
        return {
            priority,
            weight,
            port,
            to: to.labels.join(".")
        };
    }
    function parseAnswer(packet, offset) {
        let name = parseName(packet, offset);
        offset = name.offset;
        let type = packet.readUInt16BE(offset);
        offset += 2;
        let kind = packet.readUInt16BE(offset);
        offset += 2;
        let ttl = packet.readUInt32BE(offset);
        offset += 4;
        let data_length = packet.readUInt16BE(offset);
        offset += 2;
        let data_offset = offset;
        if (data_offset + data_length > packet.length) {
            throw `Invalid buffer length!`;
        }
        offset += data_length;
        return {
            name: name.labels.join("."),
            type,
            kind,
            ttl,
            packet,
            data_offset,
            data_length
        };
    }
    ;
    function parsePacket(buffer) {
        let offset = 0;
        let header = buffer.slice(offset, offset + 12);
        offset += 12;
        let id = header.readUInt16BE(0);
        let flags = header.readUInt16BE(2);
        let qdcount = header.readUInt16BE(4);
        let ancount = header.readUInt16BE(6);
        let nscount = header.readUInt16BE(8);
        let arcount = header.readUInt16BE(10);
        let questions = new Array();
        for (let i = 0; i < qdcount; i++) {
            let result = parseQuestion(buffer, offset);
            questions.push(result);
            offset = result.offset;
        }
        let answers = new Array();
        for (let i = 0; i < ancount; i++) {
            let result = parseAnswer(buffer, offset);
            answers.push(result);
            offset = result.data_offset + result.data_length;
        }
        let authorities = new Array();
        for (let i = 0; i < nscount; i++) {
            let result = parseAnswer(buffer, offset);
            authorities.push(result);
            offset = result.data_offset + result.data_length;
        }
        let additionals = new Array();
        for (let i = 0; i < arcount; i++) {
            let result = parseAnswer(buffer, offset);
            additionals.push(result);
            offset = result.data_offset + result.data_length;
        }
        return {
            buffer,
            questions,
            answers,
            authorities,
            additionals
        };
    }
    ;
    function lookupDevice(device, packet) {
        for (let answer of [...packet.answers, ...packet.authorities, ...packet.additionals]) {
            if (answer.name === device.hostname) {
                if (answer.type === Type.TXT) {
                    try {
                        let record = parseTXT(answer);
                        device = {
                            ...device,
                            service_info: record.content
                        };
                    }
                    catch (error) { }
                }
            }
        }
        for (let answer of [...packet.answers, ...packet.authorities, ...packet.additionals]) {
            if (answer.name === device.hostname) {
                if (answer.type === Type.A) {
                    let record = parseA(answer);
                    device = {
                        ...device,
                        hostname: record.ipv4
                    };
                    return device;
                }
                else if (answer.type === Type.PTR) {
                    let record = parsePTR(answer);
                    device = {
                        ...device,
                        hostname: record.to
                    };
                    return lookupDevice(device, packet);
                }
                else if (answer.type === Type.SRV) {
                    let record = parseSRV(answer);
                    device = {
                        ...device,
                        hostname: record.to
                    };
                    return lookupDevice(device, packet);
                }
            }
        }
    }
    function notifyObservers(packet) {
        for (let answer of packet.answers) {
            let hostname = answer.name;
            let observers = map.get(hostname);
            if (is.present(observers)) {
                let device = lookupDevice({ hostname }, packet);
                if (is.present(device)) {
                    for (let observer of observers) {
                        observer(device);
                    }
                }
            }
        }
    }
    ;
    function getNetworkInterfaces() {
        let networkInterfaces = libos.networkInterfaces();
        return Object.values(networkInterfaces)
            .filter(is.present)
            .flat()
            .filter((networkInterface) => {
            return !networkInterface.internal;
        });
    }
    const socket = libdgram.createSocket({ type: "udp4", reuseAddr: true });
    const networkInterfaces = getNetworkInterfaces()
        .filter((networkInterface) => {
        return networkInterface.family === "IPv4";
    });
    socket.on("listening", () => {
        socket.setMulticastLoopback(false);
        for (let networkInterface of networkInterfaces) {
            socket.addMembership(MDNS_ADDRESS, networkInterface.address);
        }
    });
    function isAddressLocal(string) {
        let remotes = string.split(".")
            .map((part) => {
            return Number.parseInt(part, 10);
        });
        outer: for (let networkInterface of networkInterfaces) {
            let locals = networkInterface.address.split(".")
                .map((part) => {
                return Number.parseInt(part, 10);
            });
            let masks = networkInterface.netmask.split(".")
                .map((part) => {
                return Number.parseInt(part, 10);
            });
            inner: for (let [index, mask] of masks.entries()) {
                if ((remotes[index] & mask) !== (locals[index] & mask)) {
                    continue outer;
                }
                return true;
            }
        }
        return false;
    }
    socket.on("message", (buffer, rinfo) => {
        let address = rinfo.address;
        if (!isAddressLocal(address)) {
            console.log(`Unexpected DNS packet from ${address}!`);
            return;
        }
        try {
            let packet = parsePacket(buffer);
            notifyObservers(packet);
        }
        catch (error) {
            console.log(`Expected a valid DNS packet!`);
        }
    });
    socket.bind(MDNS_PORT);
    // TODO: Encode labels properly.
    function sendDiscoveryPacket(host) {
        let buffers = Array();
        let head = Buffer.alloc(12);
        head.writeUInt16BE(1, 4);
        buffers.push(head);
        for (let label of host.split(".")) {
            if (label.length >= 64) {
                throw `Expected a label with a length less than 64!`;
            }
            let buffer = Buffer.alloc(1 + label.length);
            buffer.writeUInt8(label.length, 0);
            buffer.write(label, 1);
            buffers.push(buffer);
        }
        let tail = Buffer.alloc(5);
        tail.writeUInt8(0, 0);
        tail.writeUInt16BE(12, 1);
        tail.writeUInt16BE(1, 3);
        buffers.push(tail);
        socket.send(Buffer.concat(buffers), MDNS_PORT, MDNS_ADDRESS);
    }
    exports.sendDiscoveryPacket = sendDiscoveryPacket;
    ;
    ;
    function observe(host, observer) {
        let observers = map.get(host);
        if (is.absent(observers)) {
            observers = new Set();
            map.set(host, observers);
        }
        observers.add(observer);
        sendDiscoveryPacket(host);
        return {
            cancel() {
                let observers = map.get(host);
                if (is.present(observers)) {
                    observers.delete(observer);
                    if (observers.size === 0) {
                        map.delete(host);
                    }
                }
            }
        };
    }
    exports.observe = observe;
    ;
});
define("build/chromecast/schema/connection/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.CLOSE = exports.CONNECT = void 0;
    exports.CONNECT = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("CONNECT")
    }, {});
    exports.CLOSE = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("CLOSE")
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "CONNECT": autoguard.guards.Reference.of(() => exports.CONNECT),
            "CLOSE": autoguard.guards.Reference.of(() => exports.CLOSE)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/chromecast/schema/heartbeat/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.PONG = exports.PING = void 0;
    exports.PING = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("PING")
    }, {});
    exports.PONG = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("PONG")
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "PING": autoguard.guards.Reference.of(() => exports.PING),
            "PONG": autoguard.guards.Reference.of(() => exports.PONG)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/chromecast/schema/objects/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.MediaStatus = exports.PhotoMediaMetadata = exports.MusicTrackMediaMetadata = exports.TvShowMediaMetadata = exports.MovieMediaMetadata = exports.GenericMediaMetadata = exports.MediaInformation = exports.Volume = exports.Image = void 0;
    exports.Image = autoguard.guards.Object.of({
        "url": autoguard.guards.String
    }, {
        "height": autoguard.guards.Number,
        "width": autoguard.guards.Number
    });
    exports.Volume = autoguard.guards.Object.of({}, {
        "level": autoguard.guards.Number,
        "muted": autoguard.guards.Boolean
    });
    exports.MediaInformation = autoguard.guards.Object.of({
        "contentId": autoguard.guards.String,
        "streamType": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("NONE"), autoguard.guards.StringLiteral.of("BUFFERED"), autoguard.guards.StringLiteral.of("LIVE")),
        "contentType": autoguard.guards.String
    }, {
        "metadata": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.GenericMediaMetadata), autoguard.guards.Reference.of(() => exports.MovieMediaMetadata), autoguard.guards.Reference.of(() => exports.TvShowMediaMetadata), autoguard.guards.Reference.of(() => exports.MusicTrackMediaMetadata), autoguard.guards.Reference.of(() => exports.PhotoMediaMetadata)),
        "duration": autoguard.guards.Number,
        "customData": autoguard.guards.Record.of(autoguard.guards.Any),
        "tracks": autoguard.guards.Array.of(autoguard.guards.Group.of(autoguard.guards.Union.of(autoguard.guards.Object.of({
            "trackId": autoguard.guards.Number,
            "type": autoguard.guards.String
        }, {}), autoguard.guards.Object.of({
            "trackId": autoguard.guards.Number,
            "type": autoguard.guards.StringLiteral.of("TEXT"),
            "trackType": autoguard.guards.StringLiteral.of("TEXT"),
            "trackContentId": autoguard.guards.String,
            "trackContentType": autoguard.guards.String,
            "subtype": autoguard.guards.StringLiteral.of("SUBTITLES"),
            "language": autoguard.guards.String
        }, {
            "name": autoguard.guards.String,
            "customData": autoguard.guards.Record.of(autoguard.guards.Any)
        }))))
    });
    exports.GenericMediaMetadata = autoguard.guards.Object.of({
        "metadataType": autoguard.guards.NumberLiteral.of(0)
    }, {
        "title": autoguard.guards.String,
        "subtitle": autoguard.guards.String,
        "images": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Image)),
        "releaseDate": autoguard.guards.String
    });
    exports.MovieMediaMetadata = autoguard.guards.Object.of({
        "metadataType": autoguard.guards.NumberLiteral.of(1)
    }, {
        "title": autoguard.guards.String,
        "subtitle": autoguard.guards.String,
        "studio": autoguard.guards.String,
        "images": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Image)),
        "releaseDate": autoguard.guards.String
    });
    exports.TvShowMediaMetadata = autoguard.guards.Object.of({
        "metadataType": autoguard.guards.NumberLiteral.of(2)
    }, {
        "seriesTitle": autoguard.guards.String,
        "subtitle": autoguard.guards.String,
        "season": autoguard.guards.Number,
        "episode": autoguard.guards.Number,
        "images": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Image)),
        "originalAirDate": autoguard.guards.String
    });
    exports.MusicTrackMediaMetadata = autoguard.guards.Object.of({
        "metadataType": autoguard.guards.NumberLiteral.of(3)
    }, {
        "albumName": autoguard.guards.String,
        "title": autoguard.guards.String,
        "albumArtist": autoguard.guards.String,
        "artist": autoguard.guards.String,
        "composer": autoguard.guards.String,
        "trackNumber": autoguard.guards.Number,
        "discNumber": autoguard.guards.Number,
        "images": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Image)),
        "releaseDate": autoguard.guards.String
    });
    exports.PhotoMediaMetadata = autoguard.guards.Object.of({
        "metadataType": autoguard.guards.NumberLiteral.of(4)
    }, {
        "title": autoguard.guards.String,
        "artist": autoguard.guards.String,
        "location": autoguard.guards.String,
        "latitude": autoguard.guards.Number,
        "longitude": autoguard.guards.Number,
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number,
        "creationDateTime": autoguard.guards.String
    });
    exports.MediaStatus = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "playbackRate": autoguard.guards.Number,
        "playerState": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("IDLE"), autoguard.guards.StringLiteral.of("PLAYING"), autoguard.guards.StringLiteral.of("BUFFERING"), autoguard.guards.StringLiteral.of("PAUSED")),
        "currentTime": autoguard.guards.Number,
        "supportedMediaCommands": autoguard.guards.Number,
        "volume": autoguard.guards.Reference.of(() => exports.Volume)
    }, {
        "media": autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.MediaInformation), autoguard.guards.Object.of({}, {})),
        "idleReason": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("CANCELLED"), autoguard.guards.StringLiteral.of("INTERRUPTED"), autoguard.guards.StringLiteral.of("FINISHED"), autoguard.guards.StringLiteral.of("ERROR")),
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Image": autoguard.guards.Reference.of(() => exports.Image),
            "Volume": autoguard.guards.Reference.of(() => exports.Volume),
            "MediaInformation": autoguard.guards.Reference.of(() => exports.MediaInformation),
            "GenericMediaMetadata": autoguard.guards.Reference.of(() => exports.GenericMediaMetadata),
            "MovieMediaMetadata": autoguard.guards.Reference.of(() => exports.MovieMediaMetadata),
            "TvShowMediaMetadata": autoguard.guards.Reference.of(() => exports.TvShowMediaMetadata),
            "MusicTrackMediaMetadata": autoguard.guards.Reference.of(() => exports.MusicTrackMediaMetadata),
            "PhotoMediaMetadata": autoguard.guards.Reference.of(() => exports.PhotoMediaMetadata),
            "MediaStatus": autoguard.guards.Reference.of(() => exports.MediaStatus)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/chromecast/schema/media/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "build/chromecast/schema/objects/index", "build/chromecast/schema/objects/index", "build/chromecast/schema/objects/index"], function (require, exports, autoguard, objects_1, objects_2, objects_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.MEDIA_STATUS = exports.INVALID_REQUEST = exports.LOAD_CANCELLED = exports.LOAD_FAILED = exports.INVALID_PLAYER_STATE = exports.VOLUME = exports.GET_STATUS = exports.PLAY = exports.STOP = exports.SEEK = exports.PAUSE = exports.LOAD = void 0;
    exports.LOAD = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("LOAD"),
        "media": autoguard.guards.Reference.of(() => objects_1.MediaInformation)
    }, {
        "autoplay": autoguard.guards.Boolean,
        "currentTime": autoguard.guards.Number,
        "customData": autoguard.guards.Record.of(autoguard.guards.Any),
        "activeTrackIds": autoguard.guards.Array.of(autoguard.guards.Number)
    });
    exports.PAUSE = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("PAUSE")
    }, {
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    exports.SEEK = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("SEEK")
    }, {
        "resumeState": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("PLAYBACK_START"), autoguard.guards.StringLiteral.of("PLAYBACK_PAUSE")),
        "currentTime": autoguard.guards.Number,
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    exports.STOP = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("STOP")
    }, {
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    exports.PLAY = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("PLAY")
    }, {
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    exports.GET_STATUS = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("GET_STATUS")
    }, {
        "mediaSessionId": autoguard.guards.Number,
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    exports.VOLUME = autoguard.guards.Object.of({
        "mediaSessionId": autoguard.guards.Number,
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("VOLUME"),
        "volume": autoguard.guards.Reference.of(() => objects_3.Volume)
    }, {
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    exports.INVALID_PLAYER_STATE = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("INVALID_PLAYER_STATE")
    }, {
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    exports.LOAD_FAILED = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("LOAD_FAILED")
    }, {
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    exports.LOAD_CANCELLED = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("LOAD_CANCELLED")
    }, {
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    exports.INVALID_REQUEST = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("INVALID_REQUEST"),
        "reason": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("INVALID_COMMAND"), autoguard.guards.StringLiteral.of("DUPLICATE_REQUESTID"))
    }, {
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    exports.MEDIA_STATUS = autoguard.guards.Object.of({
        "requestId": autoguard.guards.Number,
        "type": autoguard.guards.StringLiteral.of("MEDIA_STATUS"),
        "status": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => objects_2.MediaStatus))
    }, {
        "customData": autoguard.guards.Record.of(autoguard.guards.Any)
    });
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "LOAD": autoguard.guards.Reference.of(() => exports.LOAD),
            "PAUSE": autoguard.guards.Reference.of(() => exports.PAUSE),
            "SEEK": autoguard.guards.Reference.of(() => exports.SEEK),
            "STOP": autoguard.guards.Reference.of(() => exports.STOP),
            "PLAY": autoguard.guards.Reference.of(() => exports.PLAY),
            "GET_STATUS": autoguard.guards.Reference.of(() => exports.GET_STATUS),
            "VOLUME": autoguard.guards.Reference.of(() => exports.VOLUME),
            "INVALID_PLAYER_STATE": autoguard.guards.Reference.of(() => exports.INVALID_PLAYER_STATE),
            "LOAD_FAILED": autoguard.guards.Reference.of(() => exports.LOAD_FAILED),
            "LOAD_CANCELLED": autoguard.guards.Reference.of(() => exports.LOAD_CANCELLED),
            "INVALID_REQUEST": autoguard.guards.Reference.of(() => exports.INVALID_REQUEST),
            "MEDIA_STATUS": autoguard.guards.Reference.of(() => exports.MEDIA_STATUS)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/chromecast/schema/receiver/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.RECEIVER_STATUS = exports.SET_VOLUME = exports.GET_APP_AVAILABILITY = exports.GET_STATUS = exports.STOP = exports.LAUNCH = void 0;
    exports.LAUNCH = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("LAUNCH"),
        "requestId": autoguard.guards.Number,
        "appId": autoguard.guards.String
    }, {});
    exports.STOP = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("STOP"),
        "requestId": autoguard.guards.Number,
        "sessionId": autoguard.guards.String
    }, {});
    exports.GET_STATUS = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("GET_STATUS"),
        "requestId": autoguard.guards.Number
    }, {});
    exports.GET_APP_AVAILABILITY = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("GET_APP_AVAILABILITY"),
        "requestId": autoguard.guards.Number,
        "appId": autoguard.guards.Array.of(autoguard.guards.String)
    }, {});
    exports.SET_VOLUME = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("SET_VOLUME"),
        "requestId": autoguard.guards.Number,
        "volume": autoguard.guards.Group.of(autoguard.guards.Union.of(autoguard.guards.Object.of({
            "level": autoguard.guards.Number
        }, {}), autoguard.guards.Object.of({
            "muted": autoguard.guards.Boolean
        }, {})))
    }, {});
    exports.RECEIVER_STATUS = autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("RECEIVER_STATUS"),
        "requestId": autoguard.guards.Number,
        "status": autoguard.guards.Object.of({
            "userEq": autoguard.guards.Object.of({}, {}),
            "volume": autoguard.guards.Object.of({
                "controlType": autoguard.guards.String,
                "level": autoguard.guards.Number,
                "muted": autoguard.guards.Boolean,
                "stepInterval": autoguard.guards.Number
            }, {})
        }, {
            "applications": autoguard.guards.Array.of(autoguard.guards.Object.of({
                "appId": autoguard.guards.String,
                "displayName": autoguard.guards.String,
                "iconUrl": autoguard.guards.String,
                "isIdleScreen": autoguard.guards.Boolean,
                "launchedFromCloud": autoguard.guards.Boolean,
                "namespaces": autoguard.guards.Array.of(autoguard.guards.Object.of({
                    "name": autoguard.guards.String
                }, {})),
                "sessionId": autoguard.guards.String,
                "statusText": autoguard.guards.String,
                "transportId": autoguard.guards.String
            }, {}))
        })
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "LAUNCH": autoguard.guards.Reference.of(() => exports.LAUNCH),
            "STOP": autoguard.guards.Reference.of(() => exports.STOP),
            "GET_STATUS": autoguard.guards.Reference.of(() => exports.GET_STATUS),
            "GET_APP_AVAILABILITY": autoguard.guards.Reference.of(() => exports.GET_APP_AVAILABILITY),
            "SET_VOLUME": autoguard.guards.Reference.of(() => exports.SET_VOLUME),
            "RECEIVER_STATUS": autoguard.guards.Reference.of(() => exports.RECEIVER_STATUS)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/chromecast/schema/index", ["require", "exports", "build/chromecast/schema/connection/index", "build/chromecast/schema/heartbeat/index", "build/chromecast/schema/media/index", "build/chromecast/schema/objects/index", "build/chromecast/schema/receiver/index"], function (require, exports, connection, heartbeat, media, objects, receiver) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.receiver = exports.objects = exports.media = exports.heartbeat = exports.connection = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.receiver = exports.objects = exports.media = exports.heartbeat = exports.connection = void 0;
    exports.connection = connection;
    exports.heartbeat = heartbeat;
    exports.media = media;
    exports.objects = objects;
    exports.receiver = receiver;
});
define("build/languages", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pref = exports.db = void 0;
    const db = {
        eng: {
            title: "English",
            iso639_1: "en",
            iso3166_1: "US"
        },
        swe: {
            title: "Swedish",
            iso639_1: "sv",
            iso3166_1: "SE"
        },
        jpn: {
            title: "Japanese",
            iso639_1: "ja",
            iso3166_1: "JP"
        }
    };
    exports.db = db;
    const pref = [
        "swe",
        "eng",
        "jpn"
    ];
    exports.pref = pref;
});
define("build/chromecast/chromecasts", ["require", "exports", "tls", "build/chromecast/cast_message", "build/mdns/index", "build/chromecast/schema/index", "build/is", "build/languages", "build/observers/index", "build/player/client", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index", "node_modules/@joelek/ts-sockets/dist/lib/index", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/api/schema/objects/index"], function (require, exports, libtls, cast_message, mdns, schema, is, languages, observers, libcontext, autoguard, sockets, stdlib, objects_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.discover = exports.observe = void 0;
    const DEBUG = false;
    function getLanguage(language) {
        let entry = languages.db[language ?? "eng"] ?? languages.db["eng"];
        return {
            language: [
                entry.iso639_1,
                entry.iso3166_1
            ].join("-"),
            name: entry.title
        };
    }
    function makeMediaInformation(item, media_server_host, token) {
        if (objects_1.Episode.is(item)) {
            let episode = item;
            let season = episode.season;
            let show = season.show;
            return {
                contentId: `${media_server_host}/api/files/${item.media.file_id}/?token=${token}`,
                contentType: episode.media.mime,
                streamType: "BUFFERED",
                metadata: {
                    metadataType: 0,
                    title: episode.title,
                    subtitle: show.title
                },
                tracks: episode.subtitles.map((subtitle, subtitleIndex) => ({
                    ...getLanguage(subtitle.language),
                    trackId: subtitleIndex,
                    type: "TEXT",
                    trackType: "TEXT",
                    trackContentId: `${media_server_host}/api/files/${subtitle.file_id}/?token=${token}`,
                    trackContentType: subtitle.mime,
                    subtype: "SUBTITLES"
                }))
            };
        }
        else if (objects_1.Movie.is(item)) {
            let movie = item;
            return {
                contentId: `${media_server_host}/api/files/${item.media.file_id}/?token=${token}`,
                contentType: movie.media.mime,
                streamType: "BUFFERED",
                metadata: {
                    metadataType: 0,
                    title: movie.title,
                    images: movie.artwork.map((image) => ({
                        url: `${media_server_host}/api/files/${image.file_id}/?token=${token}`
                    }))
                },
                tracks: movie.subtitles.map((subtitle, subtitleIndex) => ({
                    ...getLanguage(subtitle.language),
                    trackId: subtitleIndex,
                    type: "TEXT",
                    trackType: "TEXT",
                    trackContentId: `${media_server_host}/api/files/${subtitle.file_id}/?token=${token}`,
                    trackContentType: subtitle.mime,
                    subtype: "SUBTITLES"
                }))
            };
        }
        else if (objects_1.Track.is(item)) {
            let track = item;
            let disc = track.disc;
            let album = disc.album;
            return {
                contentId: `${media_server_host}/api/files/${item.media.file_id}/?token=${token}`,
                contentType: item.media.mime,
                streamType: "BUFFERED",
                metadata: {
                    metadataType: 0,
                    title: track.title,
                    subtitle: track.artists.map((artist) => artist.title).join(" \u00b7 "),
                    images: album.artwork.map((image) => ({
                        url: `${media_server_host}/api/files/${image.file_id}/?token=${token}`
                    }))
                }
            };
        }
        else {
            throw `Expected code to be unreachable!`;
        }
    }
    function getDeviceName(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "fn") {
                    return parts.slice(1).join("=");
                }
            }
        }
        return "Chromecast";
    }
    function getDeviceType(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "md") {
                    return parts.slice(1).join("=");
                }
            }
        }
        return "Generic Cast Device";
    }
    const connections = new Map();
    function observe(websocket_host, media_server_host) {
        mdns.observe("_googlecast._tcp.local", async (service_device) => {
            try {
                let { hostname, service_info } = { ...service_device };
                let connection = connections.get(hostname);
                if (is.absent(connection)) {
                    let socket = libtls.connect({
                        host: hostname,
                        port: 8009,
                        rejectUnauthorized: false
                    });
                    connections.set(hostname, socket);
                    socket.on("secureConnect", () => {
                        console.log(`Connected to Cast device at ${hostname}.`);
                        let deviceName = getDeviceName(service_info ?? []);
                        let deviceType = getDeviceType(service_info ?? []);
                        new ChromecastPlayer(socket, websocket_host, media_server_host, deviceName, deviceType);
                    });
                    socket.on("close", () => {
                        console.log(`Disconnected from Cast device at ${hostname}.`);
                        connections.delete(hostname);
                    });
                    socket.on("error", (error) => {
                        socket.destroy();
                    });
                }
            }
            catch (error) {
                console.log(error);
            }
        });
    }
    exports.observe = observe;
    ;
    function discover() {
        mdns.sendDiscoveryPacket("_googlecast._tcp.local");
    }
    exports.discover = discover;
    ;
    function unwrapPacketPayload(socket, onpayload) {
        let buffered = Buffer.alloc(0);
        let waiting_header = true;
        let bytes_required = 4;
        socket.on("data", (chunk) => {
            buffered = Buffer.concat([buffered, chunk]);
            while (buffered.length >= bytes_required) {
                let buffer = buffered.slice(0, bytes_required);
                buffered = buffered.slice(bytes_required);
                if (waiting_header) {
                    waiting_header = false;
                    bytes_required = buffer.readUInt32BE(0);
                }
                else {
                    waiting_header = true;
                    bytes_required = 4;
                    onpayload(buffer);
                }
            }
        });
    }
    class MessageHandler {
        socket;
        constructor(socket, onmessage) {
            this.socket = socket;
            unwrapPacketPayload(socket, (payload) => {
                try {
                    let message = cast_message.parseCastMessage(payload);
                    if (DEBUG && message.namespace !== HearbeatHandler.NAMESPACE) {
                        console.log("incoming", message);
                    }
                    onmessage(message);
                }
                catch (error) {
                    console.log(error);
                }
            });
        }
        getRequestId() {
            return Math.floor(Math.random() * 65536);
        }
        send(message) {
            if (DEBUG && message.namespace !== HearbeatHandler.NAMESPACE) {
                console.log("outgoing", message);
            }
            let buffer = cast_message.serializeCastMessage({
                protocol_version: message.protocol_version ?? cast_message.ProtocolVersion.CASTV2_1_0,
                source_id: message.source_id ?? "sender-0",
                destination_id: message.destination_id ?? "receiver-0",
                namespace: message.namespace,
                payload_type: message.payload_type ?? cast_message.PayloadType.STRING,
                payload_utf8: message.payload_utf8,
                payload_binary: message.payload_binary
            });
            let header = Buffer.alloc(4);
            header.writeUInt32BE(buffer.length, 0);
            this.socket.write(header);
            this.socket.write(buffer);
        }
    }
    class ConnectionHandler {
        static NAMESPACE = "urn:x-cast:com.google.cast.tp.connection";
        messageHandler;
        serializer;
        listeners;
        constructor(messageHandler) {
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.connection.Autoguard.Guards);
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                this.listeners.route(type, data);
            });
        }
        send(type, data, transportId) {
            this.messageHandler.send({
                namespace: ConnectionHandler.NAMESPACE,
                destination_id: transportId,
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    class HearbeatHandler {
        static NAMESPACE = "urn:x-cast:com.google.cast.tp.heartbeat";
        messageHandler;
        serializer;
        listeners;
        constructor(messageHandler) {
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.heartbeat.Autoguard.Guards);
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                this.listeners.route(type, data);
            });
        }
        send(type, data) {
            this.messageHandler.send({
                namespace: HearbeatHandler.NAMESPACE,
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    class MediaHandler {
        static NAMESPACE = "urn:x-cast:com.google.cast.media";
        messageHandler;
        serializer;
        callbacks;
        listeners;
        transportId = new observers.ObservableClass(undefined);
        mediaSessionId = new observers.ObservableClass(undefined);
        constructor(messageHandler) {
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.media.Autoguard.Guards);
            this.callbacks = new Map();
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            try {
                this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                    let callback = this.callbacks.get(data.requestId);
                    if (is.present(callback)) {
                        this.callbacks.delete(data.requestId);
                        callback(data);
                    }
                    this.listeners.route(type, data);
                });
            }
            catch (error) {
                console.log(JSON.stringify(data, null, 2));
            }
        }
        send(type, data, callback) {
            data.requestId = this.messageHandler.getRequestId();
            if (is.present(callback)) {
                this.callbacks.set(data.requestId, callback);
            }
            this.messageHandler.send({
                namespace: MediaHandler.NAMESPACE,
                destination_id: this.transportId.getState(),
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    class ReceiverHandler {
        static NAMESPACE = "urn:x-cast:com.google.cast.receiver";
        messageHandler;
        serializer;
        callbacks;
        listeners;
        constructor(messageHandler) {
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.receiver.Autoguard.Guards);
            this.callbacks = new Map();
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                let callback = this.callbacks.get(data.requestId);
                if (is.present(callback)) {
                    this.callbacks.delete(data.requestId);
                    callback(data);
                }
                this.listeners.route(type, data);
            });
        }
        send(type, data, callback) {
            data.requestId = this.messageHandler.getRequestId();
            if (is.present(callback)) {
                this.callbacks.set(data.requestId, callback);
            }
            this.messageHandler.send({
                namespace: ReceiverHandler.NAMESPACE,
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    const APPLICATION_ID = "CC1AD845";
    class ChromecastPlayer {
        socket;
        heartbeatHandler;
        connectionHandler;
        mediaHandler;
        receiverHandler;
        context;
        timer;
        setTimer() {
            if (is.present(this.timer)) {
                clearTimeout(this.timer);
                this.timer = undefined;
            }
            this.timer = setTimeout(() => {
                this.timer = undefined;
                this.heartbeatHandler.send("PING", {
                    type: "PING"
                });
                this.timer = setTimeout(() => {
                    this.socket.destroy();
                }, 5000);
            }, 5000);
        }
        constructor(socket, websocket_host, media_server_host, device_name, device_type) {
            let messageHandler = new MessageHandler(socket, (message) => {
                let namespace = message.namespace;
                if (namespace === ConnectionHandler.NAMESPACE) {
                    this.connectionHandler.handle(message);
                }
                else if (namespace === HearbeatHandler.NAMESPACE) {
                    this.heartbeatHandler.handle(message);
                }
                else if (namespace === MediaHandler.NAMESPACE) {
                    this.mediaHandler.handle(message);
                }
                else if (namespace === ReceiverHandler.NAMESPACE) {
                    this.receiverHandler.handle(message);
                }
            });
            this.socket = socket;
            this.heartbeatHandler = new HearbeatHandler(messageHandler);
            this.connectionHandler = new ConnectionHandler(messageHandler);
            this.mediaHandler = new MediaHandler(messageHandler);
            this.receiverHandler = new ReceiverHandler(messageHandler);
            let url = `${websocket_host}/sockets/context/?protocol=cast&name=${encodeURIComponent(device_name)}&type=${encodeURIComponent(device_type)}`;
            this.context = new libcontext.ContextClient(url, (url) => new sockets.WebSocketClient(url));
            this.timer = undefined;
            socket.on("close", () => {
                if (is.present(this.timer)) {
                    clearTimeout(this.timer);
                }
                this.context.close();
            });
            this.connectionHandler.send("CONNECT", {
                type: "CONNECT"
            });
            this.connectionHandler.listeners.addObserver("CLOSE", (message) => {
                this.mediaHandler.transportId.updateState(undefined);
            });
            this.heartbeatHandler.listeners.addObserver("PING", (message) => {
                this.heartbeatHandler.send("PONG", {
                    "type": "PONG"
                });
            });
            this.heartbeatHandler.listeners.addObserver("PONG", (message) => {
                this.setTimer();
            });
            this.receiverHandler.listeners.addObserver("RECEIVER_STATUS", (message) => {
                let applications = message.status.applications ?? [];
                let application = applications.find((application) => {
                    return application.appId === APPLICATION_ID;
                });
                if (is.present(application)) {
                    this.mediaHandler.transportId.updateState(application.transportId);
                }
                else {
                    this.mediaHandler.transportId.updateState(undefined);
                }
            });
            this.mediaHandler.listeners.addObserver("MEDIA_STATUS", (message) => {
                let status = message.status[message.status.length - 1];
                if (is.present(status)) {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        if (status.mediaSessionId === mediaSessionId) {
                            if (this.context.isDeviceLocal.getState()) {
                                if (status.playerState === "IDLE" && status.idleReason === "FINISHED") {
                                    this.context.next();
                                }
                            }
                        }
                        else {
                            this.mediaHandler.mediaSessionId.updateState(undefined);
                        }
                    }
                }
            });
            this.setTimer();
            this.mediaHandler.transportId.addObserver((transportId) => {
                if (is.present(transportId)) {
                    this.connectionHandler.send("CONNECT", {
                        type: "CONNECT"
                    }, transportId);
                }
            });
            this.context.isDeviceLocal.addObserver((isDeviceLocal) => {
                if (isDeviceLocal) {
                    let transportId = this.mediaHandler.transportId.getState();
                    if (is.absent(transportId)) {
                        this.receiverHandler.send("LAUNCH", {
                            type: "LAUNCH",
                            requestId: -1,
                            appId: APPLICATION_ID
                        });
                    }
                }
                else {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        this.mediaHandler.send("STOP", {
                            type: "STOP",
                            requestId: -1,
                            mediaSessionId: mediaSessionId
                        });
                    }
                }
            });
            {
                let computer = () => {
                    let transportId = this.mediaHandler.transportId.getState();
                    let currentLocalEntry = this.context.currentLocalEntry.getState();
                    let token = this.context.token.getState();
                    if (is.present(transportId) && is.present(currentLocalEntry) && is.present(token)) {
                        let media = makeMediaInformation(currentLocalEntry, media_server_host, token);
                        let activeTrackIds;
                        if (is.present(media.tracks)) {
                            let swe = media.tracks.find((track) => {
                                return track.language === "sv-SE";
                            });
                            if (is.present(swe)) {
                                activeTrackIds = [swe.trackId];
                            }
                            else {
                                let eng = media.tracks.find((track) => {
                                    return track.language === "en-US";
                                });
                                if (is.present(eng)) {
                                    activeTrackIds = [eng.trackId];
                                }
                                else {
                                    let jpn = media.tracks.find((track) => {
                                        return track.language === "ja-JP";
                                    });
                                    if (is.present(jpn)) {
                                        activeTrackIds = [jpn.trackId];
                                    }
                                    else {
                                        if (media.tracks.length > 0) {
                                            activeTrackIds = [0];
                                        }
                                    }
                                }
                            }
                        }
                        this.mediaHandler.send("LOAD", {
                            type: "LOAD",
                            requestId: -1,
                            media: media,
                            autoplay: false,
                            activeTrackIds: activeTrackIds
                        }, (message) => {
                            if (schema.media.MEDIA_STATUS.is(message)) {
                                let status = message.status[message.status.length - 1];
                                if (is.present(status)) {
                                    this.mediaHandler.mediaSessionId.updateState(status.mediaSessionId);
                                }
                            }
                        });
                    }
                };
                this.mediaHandler.transportId.addObserver(computer);
                this.context.currentLocalEntry.addObserver(computer);
                this.context.token.addObserver(computer);
            }
            {
                // Transfer context when application is lost and device is local.
                this.mediaHandler.transportId.addObserver((transportId) => {
                    if (is.absent(transportId) && this.context.isDeviceLocal.getState()) {
                        this.context.transfer(undefined);
                    }
                });
            }
            {
                // Reset media session when application is lost.
                this.mediaHandler.transportId.addObserver((transportId) => {
                    if (is.absent(transportId)) {
                        this.mediaHandler.mediaSessionId.updateState(undefined);
                    }
                });
            }
            {
                // Handle playback changes when there is an active media session.
                let computer = () => {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        let playback = this.context.playback.getState();
                        if (playback) {
                            this.mediaHandler.send("PLAY", {
                                type: "PLAY",
                                requestId: -1,
                                mediaSessionId: mediaSessionId
                            });
                        }
                        else {
                            this.mediaHandler.send("PAUSE", {
                                type: "PAUSE",
                                requestId: -1,
                                mediaSessionId: mediaSessionId
                            });
                        }
                    }
                };
                this.mediaHandler.mediaSessionId.addObserver(computer);
                this.context.playback.addObserver(computer);
            }
            {
                // Handle progress changes when there is an active media session.
                let computer = () => {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        let progress = this.context.progress.getState() ?? 0;
                        this.mediaHandler.send("SEEK", {
                            type: "SEEK",
                            requestId: -1,
                            mediaSessionId: mediaSessionId,
                            currentTime: progress
                        });
                    }
                };
                this.mediaHandler.mediaSessionId.addObserver(computer);
                this.context.progress.addObserver(computer);
            }
        }
    }
});
define("build/airplay/schema/messages/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.StoppedEvent = exports.PausedEvent = exports.PlayingEvent = exports.LoadingEvent = void 0;
    exports.LoadingEvent = autoguard.guards.Object.of({
        "sessionID": autoguard.guards.Number,
        "state": autoguard.guards.StringLiteral.of("loading")
    }, {});
    exports.PlayingEvent = autoguard.guards.Object.of({
        "sessionID": autoguard.guards.Number,
        "state": autoguard.guards.StringLiteral.of("playing")
    }, {});
    exports.PausedEvent = autoguard.guards.Object.of({
        "sessionID": autoguard.guards.Number,
        "state": autoguard.guards.StringLiteral.of("paused")
    }, {});
    exports.StoppedEvent = autoguard.guards.Object.of({
        "sessionID": autoguard.guards.Number,
        "state": autoguard.guards.StringLiteral.of("stopped"),
        "reason": autoguard.guards.String
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "LoadingEvent": autoguard.guards.Reference.of(() => exports.LoadingEvent),
            "PlayingEvent": autoguard.guards.Reference.of(() => exports.PlayingEvent),
            "PausedEvent": autoguard.guards.Reference.of(() => exports.PausedEvent),
            "StoppedEvent": autoguard.guards.Reference.of(() => exports.StoppedEvent)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/airplay/schema/index", ["require", "exports", "build/airplay/schema/messages/index"], function (require, exports, messages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.messages = void 0;
    exports.messages = messages;
});
define("build/airplay/api", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getServerInfo = exports.stop = exports.scrub = exports.rate = exports.play = void 0;
    function play(socket, session_id, url, progress_factor) {
        return socket.request({
            method: "POST",
            path: `/play`,
            headers: [
                { key: "Content-Type", value: "text/parameters" },
                { key: "X-Apple-Session-ID", value: session_id },
            ],
            body: Buffer.from([
                `Content-Location: ${url}`,
                `Start-Position: ${progress_factor}`,
                ``
            ].join("\n"))
        });
    }
    exports.play = play;
    ;
    function rate(socket, session_id, factor) {
        return socket.request({
            method: "POST",
            path: `/rate?value=${factor}`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.rate = rate;
    ;
    function scrub(socket, session_id, seconds) {
        return socket.request({
            method: "POST",
            path: `/scrub?position=${seconds}`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.scrub = scrub;
    ;
    function stop(socket, session_id) {
        return socket.request({
            method: "POST",
            path: `/stop`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.stop = stop;
    ;
    function getServerInfo(socket, session_id) {
        return socket.request({
            method: "GET",
            path: `/server-info`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.getServerInfo = getServerInfo;
    ;
});
define("build/airplay/http", ["require", "exports", "net", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/is"], function (require, exports, libnet, stdlib, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InboundSocket = exports.OutboundSocket = exports.serializeResponse = exports.parseResponse = exports.serializeRequest = exports.parseRequest = exports.serializeMessage = exports.parseMessage = void 0;
    function parseMessage(buffer) {
        let string = buffer.toString("binary");
        let lines = string.split("\r\n");
        let i = 0;
        let line = lines[i++];
        let headers = new Array();
        while (i < lines.length) {
            let line = lines[i++];
            if (line === "") {
                break;
            }
            let parts = line.split(": ");
            let key = parts[0];
            let value = parts.slice(1).join(": ");
            headers.push({
                key: Buffer.from(key, "binary").toString(),
                value: Buffer.from(value, "binary").toString()
            });
        }
        let body = Buffer.from(lines.slice(i).join("\r\n"), "binary");
        return {
            line: Buffer.from(line, "binary").toString(),
            headers,
            body
        };
    }
    exports.parseMessage = parseMessage;
    ;
    function serializeMessage(message) {
        let body = message.body ?? Buffer.alloc(0);
        let headers = [
            { key: "Content-Length", value: `${body.length}` },
            ...(message.headers ?? [])
        ];
        let head = Buffer.from([
            message.line,
            ...headers.map((header) => `${header.key}: ${header.value}`),
            ``,
            ``
        ].join("\r\n"));
        return Buffer.concat([head, body]);
    }
    exports.serializeMessage = serializeMessage;
    ;
    function parseRequest(buffer) {
        let message = parseMessage(buffer);
        let line = message.line;
        let parts = line.split(" ");
        if (parts.length !== 3) {
            throw `Expected three parts in request line!`;
        }
        return {
            method: parts[0],
            path: parts[1],
            version: parts[2],
            headers: message.headers,
            body: message.body
        };
    }
    exports.parseRequest = parseRequest;
    ;
    function serializeRequest(request) {
        return serializeMessage({
            line: `${request.method ?? "GET"} ${request.path ?? "/"} ${request.version ?? "HTTP/1.1"}`,
            headers: request.headers,
            body: request.body
        });
    }
    exports.serializeRequest = serializeRequest;
    ;
    function parseResponse(buffer) {
        let message = parseMessage(buffer);
        let line = message.line;
        let parts = line.split(" ");
        if (parts.length < 3) {
            throw `Expected at least three parts in response line!`;
        }
        if (!/^[1-9][0-9][0-9]$/.test(parts[1])) {
            throw `Expected a three-digit status!`;
        }
        return {
            version: parts[0],
            status: Number.parseInt(parts[1]),
            reason: parts.slice(2).join(" "),
            headers: message.headers,
            body: message.body
        };
    }
    exports.parseResponse = parseResponse;
    ;
    function serializeResponse(response) {
        return serializeMessage({
            line: `${response.version ?? "HTTP/1.1"} ${response.status ?? 200} ${response.reason ?? "OK"}`,
            headers: response.headers,
            body: response.body
        });
    }
    exports.serializeResponse = serializeResponse;
    ;
    class OutboundSocket extends stdlib.routing.MessageRouter {
        socket;
        constructor(options) {
            super();
            let socket = libnet.createConnection(options);
            socket.on("connect", () => {
            });
            socket.on("close", () => {
                this.route("close", {});
            });
            socket.on("error", () => {
                socket.destroy();
            });
            this.socket = socket;
        }
        close() {
            this.socket.destroy();
        }
        async request(request) {
            return new Promise((resolve, reject) => {
                this.socket.write(serializeRequest(request));
                let ondata = async (buffer) => {
                    this.socket.off("data", ondata);
                    let response = parseResponse(buffer);
                    resolve(response);
                };
                this.socket.on("data", ondata);
            });
        }
    }
    exports.OutboundSocket = OutboundSocket;
    ;
    class InboundSocket extends stdlib.routing.MessageRouter {
        socket;
        constructor(options, upgrade, handle) {
            super();
            let socket = libnet.createConnection(options);
            let ondata = (buffer) => {
                let response = parseResponse(buffer);
                if (response.status !== 101) {
                    return socket.emit("error", `Expected status 101!`);
                }
                let connection = response.headers.find((header) => header.key.toLowerCase() === "connection");
                if (is.absent(connection) || connection.value !== "Upgrade") {
                    return socket.emit("error", `Expected a valid connection header!`);
                }
                let upgrade = response.headers.find((header) => header.key.toLowerCase() === "upgrade");
                if (is.absent(upgrade) || upgrade.value !== "PTTH/1.0") {
                    return socket.emit("error", `Expected a valid upgrade header!`);
                }
                socket.off("data", ondata);
                socket.on("data", async (buffer) => {
                    try {
                        let request = parseRequest(buffer);
                        let response = await handle(request);
                        socket.write(serializeResponse(response));
                    }
                    catch (error) {
                        socket.emit("error", error);
                    }
                });
            };
            socket.on("data", ondata);
            socket.on("connect", () => {
                socket.write(serializeRequest({
                    ...upgrade,
                    headers: [
                        { key: "Connection", value: "Upgrade" },
                        { key: "Upgrade", value: "PTTH/1.0" },
                        ...(upgrade.headers ?? [])
                    ]
                }));
            });
            socket.on("close", () => {
                this.route("close", {});
            });
            socket.on("error", () => {
                socket.destroy();
            });
            this.socket = socket;
        }
        close() {
            this.socket.destroy();
        }
    }
    exports.InboundSocket = InboundSocket;
    ;
});
define("build/xml/index", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.XMLElement = exports.XMLAttribute = exports.XMLText = exports.XMLNode = exports.expect = exports.Tokenizer = void 0;
    const MATCHERS = {
        "WS": /^([\t\r\n ]+)/isu,
        "<": /^([<])/isu,
        ">": /^([>])/isu,
        "!": /^([!])/isu,
        "?": /^([?])/isu,
        "=": /^([=])/isu,
        "</": /^([<][/])/isu,
        "/>": /^([/][>])/isu,
        "IDENTIFIER": /^([a-z][a-z0-9_-]*)/isu,
        "STRING_LITERAL": /^("[^"]*")/isu,
        "TEXT_NODE": /^([^<>]+)[<]/isu
    };
    class Tokenizer {
        tokens;
        offset;
        peek() {
            return this.tokens[this.offset];
        }
        read() {
            if (this.offset >= this.tokens.length) {
                throw `Unexpectedly reached end of stream!`;
            }
            return this.tokens[this.offset++];
        }
        constructor(string) {
            let tokens = new Array();
            let row = 1;
            let col = 1;
            while (string.length > 0) {
                let token;
                for (let key in MATCHERS) {
                    let type = key;
                    let exec = MATCHERS[type].exec(string);
                    if (is.absent(exec)) {
                        continue;
                    }
                    if (is.absent(token) || (exec[1].length > token[1].length)) {
                        token = [type, exec[1]];
                    }
                }
                if (is.absent(token)) {
                    throw `Unrecognized token at row ${row}, col ${col}!`;
                }
                tokens.push({
                    type: token[0],
                    value: token[1],
                    row: row,
                    col: col
                });
                string = string.slice(token[1].length);
                let lines = token[1].split(/\r?\n/);
                if (lines.length > 1) {
                    row += lines.length - 1;
                    col = 1;
                }
                col += lines[lines.length - 1].length;
            }
            this.tokens = tokens.filter((token) => {
                return token.type !== "WS";
            });
            this.offset = 0;
        }
        newContext(producer) {
            let offset = this.offset;
            try {
                return producer(() => this.read(), () => this.peek());
            }
            catch (error) {
                this.offset = offset;
                throw error;
            }
        }
    }
    exports.Tokenizer = Tokenizer;
    ;
    function expect(token, family) {
        let families = Array.isArray(family) ? family : [family];
        if (!families.includes(token.type)) {
            throw `Unexpected ${token.type} at row ${token.row}, col ${token.col}!`;
        }
        return token;
    }
    exports.expect = expect;
    ;
    class XMLNode {
        asElement() {
            throw `Expected node to be an XMLElement!`;
        }
        isElement() {
            try {
                this.asElement();
                return true;
            }
            catch (error) { }
            return false;
        }
        asText() {
            throw `Expected node to be an XMLText!`;
        }
        isText() {
            try {
                this.asText();
                return true;
            }
            catch (error) { }
            return false;
        }
    }
    exports.XMLNode = XMLNode;
    ;
    function parseNode(tokenizer) {
        try {
            return parseElement(tokenizer);
        }
        catch (error) { }
        try {
            return parseText(tokenizer);
        }
        catch (error) { }
        return tokenizer.newContext((read, peek) => {
            let token = peek();
            if (is.present(token)) {
                throw `Unexpected ${token.type} at ${token.row}, ${token.col}!`;
            }
            else {
                throw `Unexpectedly reached end of stream!`;
            }
        });
    }
    class XMLText extends XMLNode {
        $value;
        constructor(value) {
            super();
            this.$value = value;
        }
        asText() {
            return this;
        }
        value() {
            return this.$value;
        }
    }
    exports.XMLText = XMLText;
    ;
    function parseText(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            let value = expect(read(), ["TEXT_NODE", "IDENTIFIER"]).value;
            return new XMLText(value);
        });
    }
    class XMLAttribute {
        $key;
        $value;
        constructor(key, value) {
            this.$key = key;
            this.$value = value;
        }
        key() {
            return this.$key;
        }
        value() {
            return this.$value;
        }
    }
    exports.XMLAttribute = XMLAttribute;
    ;
    function parseAttribute(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            let key = expect(read(), "IDENTIFIER").value;
            expect(read(), "=");
            let value = expect(read(), "STRING_LITERAL").value.slice(1, -1);
            return new XMLAttribute(key, value);
        });
    }
    class XMLArray {
        array;
        constructor(iterable) {
            this.array = Array.from(iterable);
        }
        get(index) {
            if (index < 0 || index >= this.array.length) {
                throw `Expected index ${index} to be between 0 and ${this.array.length}!`;
            }
            return this.array[index];
        }
        length() {
            return this.array.length;
        }
        [Symbol.iterator]() {
            return this.array[Symbol.iterator]();
        }
    }
    ;
    class XMLElement extends XMLNode {
        $tag;
        $attributes;
        $children;
        constructor(tag, attributes, children) {
            super();
            this.$tag = tag;
            this.$attributes = new XMLArray(attributes);
            this.$children = new XMLArray(children);
        }
        asElement() {
            return this;
        }
        tag(...expected) {
            let tag = this.$tag;
            if (!expected.includes(tag)) {
                throw `Expected tag to be one of [${expected.join(", ")}] but was ${tag}!`;
            }
            return tag;
        }
        attributes() {
            return this.$attributes;
        }
        children() {
            return this.$children;
        }
    }
    exports.XMLElement = XMLElement;
    ;
    function parseElement(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            expect(read(), "<");
            let tag = expect(read(), "IDENTIFIER").value;
            let attributes = new Array();
            while (peek()?.type !== ">" && peek()?.type !== "/>") {
                let attribute = parseAttribute(tokenizer);
                attributes.push(attribute);
            }
            let children = new Array();
            let token = expect(read(), [">", "/>"]);
            if (token.type === ">") {
                while (peek()?.type !== "</") {
                    let child = parseNode(tokenizer);
                    children.push(child);
                }
                expect(read(), "</");
                if (expect(read(), "IDENTIFIER").value !== tag) {
                    throw ``;
                }
                expect(read(), ">");
            }
            return new XMLElement(tag, attributes, children);
        });
    }
    function parseHeader(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            expect(read(), "<");
            expect(read(), "?");
            if (expect(read(), "IDENTIFIER").value !== "xml") {
                throw ``;
            }
            if (expect(read(), "IDENTIFIER").value !== "version") {
                throw ``;
            }
            expect(read(), "=");
            expect(read(), "STRING_LITERAL");
            if (expect(read(), "IDENTIFIER").value !== "encoding") {
                throw ``;
            }
            expect(read(), "=");
            expect(read(), "STRING_LITERAL");
            expect(read(), "?");
            expect(read(), ">");
        });
    }
    function parseDoctype(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            expect(read(), "<");
            expect(read(), "!");
            if (expect(read(), "IDENTIFIER").value !== "DOCTYPE") {
                throw ``;
            }
            let name = expect(read(), "IDENTIFIER").value;
            let access = expect(read(), "IDENTIFIER").value;
            let type = expect(read(), "STRING_LITERAL").value;
            let url = expect(read(), "STRING_LITERAL").value;
            expect(read(), ">");
        });
    }
    function parseDocument(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            let header = parseHeader(tokenizer);
            let doctype = parseDoctype(tokenizer);
            let root = parseElement(tokenizer);
            return {
                root
            };
        });
    }
    function parse(string) {
        let tokenizer = new Tokenizer(string.trim());
        return parseDocument(tokenizer);
    }
    exports.parse = parse;
});
define("build/airplay/plist", ["require", "exports", "build/xml/index"], function (require, exports, xml) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseFromString = void 0;
    function parseArray(element) {
        element.tag("array");
        let children = element.children();
        let array = [];
        for (let i = 0; i < children.length(); i += 1) {
            let value = children.get(i + 0).asElement();
            array.push(parseJSON(value));
        }
        return array;
    }
    function parseFalse(element) {
        element.tag("false");
        let children = element.children();
        if (children.length() !== 0) {
            throw `Expected exactly zero children!`;
        }
        return false;
    }
    function parseTrue(element) {
        element.tag("true");
        let children = element.children();
        if (children.length() !== 0) {
            throw `Expected exactly zero children!`;
        }
        return true;
    }
    function parseBoolean(element) {
        try {
            return parseFalse(element);
        }
        catch (error) { }
        try {
            return parseTrue(element);
        }
        catch (error) { }
        throw `Expected a boolean!`;
    }
    function parseInteger(element) {
        element.tag("integer");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        let number = Number.parseInt(text);
        if (Number.isNaN(number)) {
            throw `Expected an integer number!`;
        }
        return number;
    }
    function parseReal(element) {
        element.tag("real");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        let number = Number.parseFloat(text);
        if (Number.isNaN(number)) {
            throw `Expected a real-valued number!`;
        }
        return number;
    }
    function parseNumber(element) {
        try {
            return parseInteger(element);
        }
        catch (error) { }
        try {
            return parseReal(element);
        }
        catch (error) { }
        throw `Expected a number!`;
    }
    function parseKey(element) {
        element.tag("key");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        return text;
    }
    function parseObject(element) {
        element.tag("dict");
        let children = element.children();
        let object = {};
        for (let i = 0; i < children.length(); i += 2) {
            let key = children.get(i + 0).asElement();
            let value = children.get(i + 1).asElement();
            object[parseKey(key)] = parseJSON(value);
        }
        return object;
    }
    function parseString(element) {
        element.tag("string");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        return text;
    }
    function parseJSON(node) {
        try {
            return parseArray(node);
        }
        catch (error) { }
        try {
            return parseBoolean(node);
        }
        catch (error) { }
        try {
            return parseNumber(node);
        }
        catch (error) { }
        try {
            return parseObject(node);
        }
        catch (error) { }
        try {
            return parseString(node);
        }
        catch (error) { }
        throw `Expected a type!`;
    }
    function parseFromString(string) {
        let document = xml.parse(string);
        let root = document.root;
        root.tag("plist");
        let children = root.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        return parseJSON(children.get(0).asElement());
    }
    exports.parseFromString = parseFromString;
    ;
});
define("build/airplay/device", ["require", "exports", "crypto", "node_modules/@joelek/ts-sockets/dist/lib/index", "node_modules/@joelek/ts-stdlib/dist/lib/index", "build/player/client", "build/is", "build/observers/index", "build/airplay/schema/index", "build/airplay/api", "build/airplay/http", "build/airplay/plist"], function (require, exports, libcrypto, sockets, stdlib, player, is, observers, schema, api, http, plist) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Device = void 0;
    const PORT = 7000;
    function makeCorrelationID() {
        return [
            libcrypto.randomBytes(4).toString("hex"),
            libcrypto.randomBytes(2).toString("hex"),
            libcrypto.randomBytes(2).toString("hex"),
            libcrypto.randomBytes(2).toString("hex"),
            libcrypto.randomBytes(6).toString("hex")
        ].join("-");
    }
    class Device extends stdlib.routing.MessageRouter {
        constructor(host, websocket_host, media_server_host, device_name, device_type) {
            super();
            let correlation_id = makeCorrelationID();
            let outbound = new http.OutboundSocket({ host: host, port: PORT });
            outbound.addObserver("close", () => {
                this.route("close", {});
            });
            api.getServerInfo(outbound, correlation_id).then(() => {
                let inbound = new http.InboundSocket({ host: host, port: PORT }, {
                    method: "POST",
                    path: "/reverse",
                    headers: [
                        { key: "X-Apple-Purpose", value: "event" },
                        { key: "X-Apple-Session-ID", value: correlation_id }
                    ]
                }, async (request) => {
                    let string = request.body.toString();
                    let document = plist.parseFromString(string);
                    if (schema.messages.PlayingEvent.is(document)) {
                        context.resume();
                    }
                    else if (schema.messages.PausedEvent.is(document)) {
                        context.pause();
                    }
                    else if (schema.messages.StoppedEvent.is(document) && document.reason === "ended") {
                        context.next();
                    }
                    return {
                        status: 200,
                        reason: "OK"
                    };
                });
                inbound.addObserver("close", () => {
                    this.route("close", {});
                });
                let url = `${websocket_host}/sockets/context/?protocol=airplay&name=${encodeURIComponent(device_name)}&type=${encodeURIComponent(device_type)}`;
                let context = new player.ContextClient(url, (url) => new sockets.WebSocketClient(url));
                observers.computed(async (currentLocalEntry, token) => {
                    if (is.present(currentLocalEntry) && is.present(token)) {
                        let url = `${media_server_host}/api/files/${currentLocalEntry.media.file_id}/?token=${token}`;
                        await api.play(outbound, correlation_id, url, 0.0);
                    }
                    else {
                        await api.stop(outbound, correlation_id);
                    }
                }, context.currentLocalEntry, context.token);
                observers.computed(async (currentLocalEntry, progress) => {
                    if (is.present(currentLocalEntry) && is.present(progress)) {
                        await api.scrub(outbound, correlation_id, progress);
                    }
                }, context.currentLocalEntry, context.progress);
                observers.computed(async (playback) => {
                    await api.rate(outbound, correlation_id, playback ? 1.0 : 0.0);
                }, context.playback);
                this.addObserver("close", () => {
                    context.close();
                    outbound.close();
                    inbound.close();
                });
            });
        }
    }
    exports.Device = Device;
    ;
});
define("build/airplay/index", ["require", "exports", "build/mdns/index", "build/is", "build/airplay/device"], function (require, exports, mdns, is, device_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.discover = exports.observe = void 0;
    const devices = new Map();
    function getDeviceName(service_info) {
        let last = service_info[service_info.length - 1];
        if (is.present(last)) {
            let parts = /^([^.]+)[.]_airplay[.]_tcp[.]local$/.exec(last);
            if (is.present(parts)) {
                return parts[1];
            }
        }
        return "AirPlay";
    }
    function getDeviceType(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "model") {
                    return parts.slice(1).join("=");
                }
            }
        }
        return "Generic AirPlay Device";
    }
    function isProtocolSupported(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "protovers") {
                    return parts.slice(1).join("=") === "1.0";
                }
            }
        }
        return true;
    }
    function observe(websocket_host, media_server_host) {
        mdns.observe("_airplay._tcp.local", async (service_device) => {
            try {
                let { hostname, service_info } = { ...service_device };
                let device = devices.get(hostname);
                if (is.absent(device) && isProtocolSupported(service_info ?? [])) {
                    let device_name = getDeviceName(service_info ?? []);
                    let device_type = getDeviceType(service_info ?? []);
                    let device = new device_1.Device(hostname, websocket_host, media_server_host, device_name, device_type);
                    devices.set(hostname, device);
                    device.addObserver("close", function onclose() {
                        device.removeObserver("close", onclose);
                        devices.delete(hostname);
                    });
                }
            }
            catch (error) {
                console.log(error);
            }
        });
    }
    exports.observe = observe;
    ;
    function discover() {
        mdns.sendDiscoveryPacket("_airplay._tcp.local");
    }
    exports.discover = discover;
    ;
});
define("build/server/server", ["require", "exports", "fs", "http", "https", "os", "tls", "build/api/api", "build/database/indexer", "build/server/subsearch", "build/player/index", "build/playlists/index", "build/chromecast/chromecasts", "build/airplay/index", "build/is", "build/config/index", "build/database/atlas", "build/utils", "build/database/atlas"], function (require, exports, libfs, libhttp, libhttps, libos, libtls, api, indexer, subsearch, context, playlists, chromecasts, airplay, is, config_1, atlas_1, utils_1, atlas) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    const contextServer = new context.server.ContextServer();
    const playlistsServer = new playlists.server.PlaylistsServer();
    let indexTimer;
    function setupIndexTimer() {
        if (is.present(indexTimer)) {
            clearTimeout(indexTimer);
        }
        indexTimer = setTimeout(() => {
            indexTimer = undefined;
            indexer.runIndexer();
        }, 60 * 60 * 1000);
    }
    async function requestHandler(request, response) {
        let host = request.headers["host"] || "";
        let method = request.method || "";
        let path = request.url || "";
        if (/^[/]sockets[/]context[/]/.test(path)) {
            return contextServer.getRequestHandler()(request, response);
        }
        if (/^[/]sockets[/]playlists[/]/.test(path)) {
            return playlistsServer.getRequestHandler()(request, response);
        }
        let startMs = Date.now();
        response.on("finish", () => {
            let duration_ms = Date.now() - startMs;
            process.stderr.write(`${response.statusCode} ${method}:${path} (${duration_ms} ms)\n`);
            setupIndexTimer();
        });
        if (false && /^[0-9]+[.][0-9]+[.][0-9]+[.][0-9]+(:[0-9]+)?$/.test(host)) {
            response.writeHead(400);
            response.end();
            return;
        }
        let parts;
        if (method === 'GET' && path === '/favicon.ico') {
            response.writeHead(404);
            response.end();
            return;
        }
        if (method === "POST" && path === "/discover") {
            airplay.discover();
            chromecasts.discover();
            response.writeHead(200);
            response.end("{}");
            return;
        }
        if (/^[/]media[/]/.test(path)) {
            if ((parts = /^[/]media[/]stills[/]([0-9a-f]{16})[/]/.exec(path)) != null) {
                let file_id = parts[1];
                let filename = [".", "private", "stills", file_id];
                if (libfs.existsSync(filename.join("/"))) {
                    let stream = libfs.createReadStream(filename.join("/"));
                    stream.on("open", () => {
                        response.writeHead(200, {
                            "Access-Control-Allow-Origin": "*",
                            "Cache-Control": "public, max-age=86400",
                            "Content-Type": "image/jpeg"
                        });
                        stream.pipe(response);
                    });
                }
                else {
                    response.writeHead(404);
                    response.end();
                    return;
                }
                return;
            }
            if ((parts = /^[/]media[/]gifs[/]([0-9a-f]{16})[/]/.exec(path)) != null) {
                let cue_id = parts[1];
                let filename = [".", "private", "gifs", cue_id];
                if (libfs.existsSync(filename.join("/"))) {
                    let stream = libfs.createReadStream(filename.join("/"));
                    stream.on("open", () => {
                        response.writeHead(200, {
                            "Access-Control-Allow-Origin": "*",
                            "Cache-Control": "public, max-age=86400",
                            "Content-Type": "image/gif"
                        });
                        stream.pipe(response);
                    });
                }
                else {
                    atlas_1.transactionManager.enqueueReadableTransaction(async (queue) => {
                        let cue = await atlas.stores.cues.lookup(queue, { cue_id: (0, utils_1.binid)(cue_id) });
                        let subtitle = await atlas.stores.subtitles.lookup(queue, cue);
                        let file_subtitle = await atlas.stores.files.lookup(queue, subtitle);
                        let video_subtitles = await atlas.links.subtitle_file_video_subtitles.filter(queue, subtitle);
                        let file_video = await atlas.stores.files.lookup(queue, { file_id: video_subtitles[0].video_file_id });
                        let video_path = await indexer.getPath(queue, file_video);
                        let subtitle_path = await indexer.getPath(queue, file_subtitle);
                        subsearch.generateMeme(filename, video_path, subtitle_path, cue, () => {
                            if (!libfs.existsSync(filename.join("/"))) {
                                response.writeHead(500);
                                return response.end();
                            }
                            let stream = libfs.createReadStream(filename.join("/"));
                            stream.on("open", () => {
                                response.writeHead(200, {
                                    "Access-Control-Allow-Origin": "*",
                                    "Cache-Control": "public, max-age=86400",
                                    "Content-Type": "image/gif"
                                });
                                stream.pipe(response);
                            });
                        });
                    });
                }
                return;
            }
        }
        if (/^[/]api[/]/.test(path)) {
            return api.server(request, response);
        }
        if (path === "/manifest.json") {
            response.writeHead(200, {
                "Content-Type": "application/json"
            });
            response.end(JSON.stringify({
                "name": "Circus",
                "start_url": "/",
                "display": "standalone",
                "theme_color": "#df4f7f",
                "background_color": "#1f1f1f",
                "icons": []
            }));
            return;
        }
        if (path === "/logo.png") {
            response.writeHead(200, {
                "Content-Type": "image/png"
            });
            libfs.createReadStream("./public/logo.png").pipe(response);
            return;
        }
        if (path === "/backdrop.png") {
            response.writeHead(200, {
                "Content-Type": "image/png"
            });
            libfs.createReadStream("./public/backdrop.png").pipe(response);
            return;
        }
        if (method === 'GET') {
            response.writeHead(200);
            response.end(`<!doctype html><html><head><base href="/"/><meta charset="utf-8"/><meta content="https://circus.joelek.se/backdrop.png" property="og:image"/><meta content="Transform your media library into your personal streaming service." name="description"/><meta content="width=device-width,initial-scale=1.0" name="viewport"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /><link rel="apple-touch-icon" href="logo.png" /><link rel="manifest" href="/manifest.json"/><link href="https://fonts.googleapis.com/css2?family=Nunito&family=Pacifico&display=swap" rel="stylesheet"/><title>Circus</title></head><body><script>${libfs.readFileSync('./dist/client.min.js')}</script></body></html>`);
            return;
        }
        console.log('unhandled', JSON.stringify(request.headers, null, "\t"));
        response.writeHead(400);
        response.end();
        return;
    }
    if (!libfs.existsSync("./private/certs/")) {
        libfs.mkdirSync("./private/certs/", { recursive: true });
    }
    function getLocalIp(family = "ipv4") {
        let networkInterfaces = libos.networkInterfaces();
        for (let interfaceInfos of Object.values(networkInterfaces)) {
            if (is.present(interfaceInfos)) {
                for (let interfaceInfo of interfaceInfos) {
                    if (interfaceInfo.internal === true) {
                        continue;
                    }
                    if (interfaceInfo.family.toLowerCase() === family.toLowerCase()) {
                        return interfaceInfo.address;
                    }
                }
            }
        }
        throw `Expected a local interface!`;
    }
    // TODO: Use hostname from certificate.
    let hostname = getLocalIp();
    let media_server_host = `http://${hostname}:${config_1.default.http_port}`;
    let http_server = libhttp.createServer({}, requestHandler);
    http_server.listen(config_1.default.http_port, () => {
        console.log(`http://${hostname}:${config_1.default.http_port}`);
    });
    http_server.keepAliveTimeout = 60 * 1000;
    if (libfs.existsSync(config_1.default.certificate_path.join("/")) && libfs.existsSync(config_1.default.certificate_key_path.join("/"))) {
        let https_server = libhttps.createServer({
            SNICallback: (servername, callback) => {
                let secureContext = libtls.createSecureContext({
                    key: libfs.readFileSync(config_1.default.certificate_key_path.join("/")),
                    cert: libfs.readFileSync(config_1.default.certificate_path.join("/")),
                    dhparam: libfs.existsSync("./private/certs/dhparam.pem") ? libfs.readFileSync("./private/certs/dhparam.pem") : undefined
                });
                callback(null, secureContext);
            },
            key: libfs.readFileSync(config_1.default.certificate_key_path.join("/")),
            cert: libfs.readFileSync(config_1.default.certificate_path.join("/")),
            dhparam: libfs.existsSync("./private/certs/dhparam.pem") ? libfs.readFileSync("./private/certs/dhparam.pem") : undefined
        }, requestHandler);
        https_server.listen(config_1.default.https_port, () => {
            console.log(`https://${hostname}:${config_1.default.https_port}`);
        });
        https_server.keepAliveTimeout = 60 * 1000;
        let websocket_host = `wss://${hostname}:${config_1.default.https_port}`;
        airplay.observe(websocket_host, media_server_host);
        chromecasts.observe(websocket_host, media_server_host);
    }
    else {
        let websocket_host = `ws://${hostname}:${config_1.default.http_port}`;
        airplay.observe(websocket_host, media_server_host);
        chromecasts.observe(websocket_host, media_server_host);
    }
});
function define(e,t,l){let n=define;function u(e){return require(e)}null==n.moduleStates&&(n.moduleStates=new Map),null==n.dependentsMap&&(n.dependentsMap=new Map);let d=n.moduleStates.get(e);if(null!=d)throw"Duplicate module found with name "+e+"!";d={callback:l,dependencies:t,module:null},n.moduleStates.set(e,d);for(let l of t){let t=n.dependentsMap.get(l);null==t&&(t=new Set,n.dependentsMap.set(l,t)),t.add(e)}!function e(t){let l=n.moduleStates.get(t);if(null==l||null!=l.module)return;let d=Array(),o={exports:{}};for(let e of l.dependencies){if("require"===e){d.push(u);continue}if("module"===e){d.push(o);continue}if("exports"===e){d.push(o.exports);continue}try{d.push(u(e));continue}catch(e){}let t=n.moduleStates.get(e);if(null==t||null==t.module)return;d.push(t.module.exports)}l.callback(...d),l.module=o;let p=n.dependentsMap.get(t);if(null!=p)for(let t of p)e(t)}(e)}